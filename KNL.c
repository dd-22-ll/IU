                        /*!
	The information contained herein is the exclusive property of SONiX and
	shall not be distributed, or disclosed in whole or in part without prior
	permission of SONiX.
	SONiX reserves the right to make changes without further notice to the
	product to improve reliability, function or design. SONiX does not assume
	any liability arising out of the application or use of any product or
	circuits described herein. All application information is advisor and does
	not from part of the specification.

	\file		KNL.c
	\brief		Kernel Control function
	\author		Justin Chen
	\version	2.20
	\date		2024/03/25
	\copyright	Copyright(C) 2022 SONiX Technology Co.,Ltd. All rights reserved.
*/
//------------------------------------------------------------------------------
#include <string.h>
#include "KNL.h"
#include "BUF.h"
#include "EN_API.h"
#include "ISP_API.h"
#include "CIPHER_API.h"
#include "CRC_API.h"
#include "CHECKSUM_API.h"
#include "DMAC_API.h"
#include "MMU_API.h"
#include "USBD_API.h"
#include "USBH_API.h"
#include "RTC_API.h"
#include "FWU_API.h"
#include "LCD.h"
#include "SEN.h"
#include "TIMER.h"
#include "RC.h"
#include "BSP.h"
#include "SD_API.h"
#include "PLY_API.h"
#include "MEDIA.h"
#include "DDR_API.h"
#include "VDO.h"
#include "WDT.h"
#include "snx_pcm_alaw.h"
#include "snx_audio_aud32.h"
#include "AAC_ENC.h"
#include "AAC_DEC.h"
#include "ADO.h"
#include "ADO_API.h"
#include "APP_HS.h"
#include "IQ_PARSER_API.h"
#include "MD_API.h"

#ifdef OP_STA
#if APP_RTC676X_FOTA_ENABLE
#include "FWU_API.h"
#endif
#endif
#if APP_RTC676X_BRIDGE_COEXISTENCE_ENABLE
#include "RTC676x_CTRL.h"
#include "rwrf.h"

uint8_t ubKNL_FreqTableInSf = 0xFF;
uint8_t ubKNL_FreqTableSel = 0xF0;
uint8_t ubKNL_FreqKeepCnt = 0;

//0xFF -> Full Band or No-WiFi Bridge Function
//0x00 -> Full Band or No-WiFi Bridge Function
//0xF0 -> Select Freq-Table[0]
//0xF1 -> Select Freq-Table[1]
//0xF2 -> Select Freq-Table[2]
void KNL_SetFreqTableInSf(uint8_t ubFreqSelect)
{
	ubKNL_FreqTableInSf = ubFreqSelect;	
	ubKNL_FreqTableSel = ubFreqSelect;	//0xF0 For Table0, 0xF1 For Table1, 0xF2 For Table2
}

uint8_t ubKNL_GetFreqTableInSf(void)
{
	return ubKNL_FreqTableInSf; 
}

#if (FREQ_TABLE_NUM == 2)	//Using Table[0]/Table[2] Only 
unsigned char frequency_table_Ch0[80] =	//Low Band
{	
	44,48,52,56,60,56,52,48,44,40,
	36,40,44,48,52,56,60,56,52,48,
	44,40,36,40,44,48,52,56,60,56,
	52,48,44,40,36,40,44,48,52,56,
	60,56,52,48,44,40,36,40,44,48,
	52,56,60,56,52,48,44,40,36,40,
	44,48,52,56,60,56,52,48,44,40,
	36,40,44,48,52,56,60,56,52,48	
};

unsigned char frequency_table_Ch1[80] = //Mid Band
{	
	69,73,77,81,77,73,69,65,61,65,
	69,73,77,81,77,73,69,65,61,65,
	69,73,77,81,77,73,69,65,61,65,
	69,73,77,81,77,73,69,65,61,65,
	69,73,77,81,77,73,69,65,61,65,
	69,73,77,81,77,73,69,65,61,65,	
	69,73,77,81,77,73,69,65,61,65,
	69,73,77,81,77,73,69,65,61,65	
};

unsigned char frequency_table_Ch2[80] = //High Band
{	
	94,98,102,106,102,98,94,90,86,90,
	94,98,102,106,102,98,94,90,86,90,
	94,98,102,106,102,98,94,90,86,90,
	94,98,102,106,102,98,94,90,86,90,
	94,98,102,106,102,98,94,90,86,90,
	94,98,102,106,102,98,94,90,86,90,
	94,98,102,106,102,98,94,90,86,90,
	94,98,102,106,102,98,94,90,86,90
};
#endif

#if (FREQ_TABLE_NUM == 3)	//Using Table[0]/Table[1]/Table[2] 
unsigned char frequency_table_Ch0[80] =	//Skip Low-Band
{	
	 81, 85, 89, 93, 97,101,105,101, 97, 93,	
	 89, 85, 81, 77, 73, 69, 65, 61, 65, 69, 	
	 73, 77, 81, 85, 89, 93, 97,101,105,101, 	
	 97, 93, 89, 85, 81, 77, 73, 69, 65, 61,	 
	 65, 69, 73, 77, 81, 85, 89, 93, 97,101,	
	105,101, 97, 93, 89, 85, 81, 77, 73, 69, 	 
	 65, 61, 65, 69, 73, 77, 81, 85, 89, 93,
	 97,101,105,101, 97, 93, 89, 85, 81, 77 
};

unsigned char frequency_table_Ch1[80] = //Skip Mid-Band	
{
	58, 86, 90, 94, 98,102,106,102, 98, 94,
	90, 86, 58, 54, 50, 46, 42, 38,	42, 46,
	50, 54, 58, 86, 90, 94, 98,102,106,102,
	98, 94, 90, 86, 58, 54, 50, 46, 42, 38,
	42, 46, 50, 54, 58, 86, 90, 94, 98,102,
   106,102, 98, 94, 90, 86, 58, 54, 50, 46,
	42, 38, 42, 46, 50, 54, 58, 86, 90, 94,
	98,102,106,102, 98, 94, 90, 86, 58, 54	
};

unsigned char frequency_table_Ch2[80] =	//Skip High-Band	
{	
	59, 63, 67, 71, 75, 79, 83, 79, 75, 71,	
	67, 63, 59, 55, 51, 47, 43, 39,	43, 47,	
	51, 55, 59, 63, 67, 71, 75, 79, 83, 79,	
	75, 71, 67, 63, 59, 55, 51, 47, 43, 39,	
	43, 47, 51, 55, 59, 63, 67, 71, 75, 79,	
	83, 79, 75, 71, 67, 63, 59, 55, 51, 47, 
	43, 39, 43, 47, 51, 55, 59, 63, 67, 71,	
	75, 79, 83, 79, 75, 71, 67, 63, 59, 55
};
#endif

unsigned char frequency_table_Full[80] = //Full Band
{		
	 88, 95, 98,102,105,108,105,102, 98, 95, 
	 88, 85, 82, 78, 75, 72, 62, 58, 55, 52, 
	 48, 45, 41, 38, 41, 45, 48, 52, 55, 58, 
	 62, 72, 75, 78, 82, 85, 88, 95, 98,102, 
	105,108,105,102, 98, 95, 88, 85, 82, 78, 
	 75, 72, 62, 58, 55, 52, 48, 45, 41, 38, 
	 41, 45, 48, 52, 55, 58, 62, 72, 75, 78,
	 82, 85, 88, 95, 98,102,105,108,105,102 
};

void KNL_SetFreqTable(uint8_t ubFreqTable)
{
	if((ubFreqTable == 0xFF) || (ubFreqTable == 0x00))
	{
		rf_setopt(RF_OPT_FREQTABLE, frequency_table_Full,80);
	}
	else if(ubFreqTable == 0xF0)
	{
		rf_setopt(RF_OPT_FREQTABLE, frequency_table_Ch0,80);
	}
	else if(ubFreqTable == 0xF1)
	{
		rf_setopt(RF_OPT_FREQTABLE, frequency_table_Ch1,80);
	}
	else if(ubFreqTable == 0xF2)
	{
		rf_setopt(RF_OPT_FREQTABLE, frequency_table_Ch2,80);
	}
}
#endif

#if (APP_DUAL_HOST_ENABLE == 1)
#include "USBH_API.h"
#include "cmd_uvc.h"
#endif

#if defined(BUC_CAM) || defined(BUC_CU)
#if ((APP_DUAL_HOST_ENABLE == 1) || (APP_UVC_CAM_ENABLE == 1))
#include "APP_XUCMD.h"
#endif

#if (APP_USBD_COMPOSITE_MODE & USBD_MULTI_UAC)
#include "UI_BUCCU.h"
#endif

#if (APP_USBD_COMPOSITE_MODE & USBD_MULTI_UVC)
#include "APP_UVCUACCMD.h"
#endif

#endif
#include "USBD_API.h"
#if defined(BSP_DVR_SDK)
uint8_t ubKNL_PlaybackIngFlg = 0;
#endif

#if defined(BSP_DVR_SDK)
#if (defined(BSP_CARCAM_CU_HD_LCDPORTRAIT_EVB)||defined(BSP_CARCAM_CU_HD_LCDPORTRAIT_DEMO))
#include "UI_BUCCU[HD].h"
#endif
#endif
#include "TRX_IF.h"
#ifdef RTC676x
#include "RTC676x_SPI.h"
#include "RTC676x_CTRL.h"
#include "rwerror.h"
#include "rwrf.h"
#include "RTC676x_SPI.h"
#endif

#if (BSP_RTC_TIMER_SEL == RTC_TIMER_EXTERNAL)
#include "RTC_PCF85063A.h"
#endif
#ifdef BIO_BU
#include "QR_API.h"
#include "FD_API.h"
#include "FDOSD.h"
#endif

#if APP_MAC_FUNC_ENABLE
#include "ETH_API.h"
#endif

#if ((defined(S2019A) && defined(RVCS_APP)) || (defined(OP_AP) && defined(sWIFIBDG)))
#include "WiFiDtApp.h"
#endif
#if (defined(S2019A) && defined(RVCS_APP))
#if (APP_BLE_SN9380_FUNC_ENABLE == 1) 
#include "UI_CMD.h"
#endif
#define READ_PLYBK_FILE_SZ_ONE_TIME		0x20000
#if (E_RVCS_ALL_I_FRM == 1)
uint8_t ubKNL_UpdVdoGopFlag = FALSE;
#endif
uint8_t ubRES_SWITCH = 0;
#endif

SNX_AUD32_CONTEXT_t KNL_Ado32_EncInfo[ADO_AUDIO32_MAX_NUM] = {0};
SNX_AUD32_CONTEXT_t KNL_Ado32_DecInfo[ADO_AUDIO32_MAX_NUM] = {0};

//------------------------------------------------------------------------------
/*!	\file KNL.c	
KNL Initial Flow Chart:	
	\dot
		digraph G {
	node [shape=record,fontsize=10];
	"Start" -> "Set System Information";	
	node [shape=record,fontsize=10];
	"Set System Information" -> "Set Data Path";
	node [shape=record,fontsize=10];
	"Set Data Path" -> "KNL_Init";
	node [shape=record,fontsize=10];
	"KNL_Init" -> "KNL_BufInit";
	node [shape=record,fontsize=10];
	"KNL_BufInit" -> "KNL_BlockInit";	
	}
	\enddot
*/
//------------------------------------------------------------------------------

#if defined(RTC676x)
#if APP_RTC676X_FOTA_ENABLE

uint8_t ubKNL_FotaStartRcvFlg = 0;
uint16_t uwKNL_FotaNumOfFrm = 0;
uint16_t uwKNL_FotaCurFrmIdx = 0;
uint16_t uwKNL_FotaPreFrmIdx = 0;
uint32_t ulKNL_FotaRealFwSz = 0;
uint32_t ulKNL_FotaPadFwSz = 0;

uint8_t ubKNL_FotaForceStopFlg = 0;
uint8_t ubKNL_GetFotaTwcFlg[4];
uint8_t ubKNL_FotaTrxFlg = 0;
uint32_t ulKNL_FotaDataSize = 0;
uint32_t ulKNL_FotaDataAddr = 0;
uint8_t ubKNL_FotaStatusRptInPercent = 0;											
										
#ifdef OP_AP
uint8_t ubKNL_GetFotaStatusRpt(void)
{
	return ubKNL_FotaStatusRptInPercent;
}

//pvFotaEventCbFunc pKNL_FotaCbFuncAtRx = NULL;	//RX Side(Display)
//void KNL_RegisterFotaEventAtRx(pvFotaEventCbFunc pvCB)
//{
//	pKNL_FotaCbFuncAtRx = pvCB;
//}
#endif

#ifdef OP_STA
pvFotaEventCbFunc pKNL_FotaCbFuncAtTx = NULL;	//Tx Side(Camera)
void KNL_RegisterFotaEventAtTx(pvFotaEventCbFunc pvCB)
{
	pKNL_FotaCbFuncAtTx = pvCB;
}
#endif

#ifdef OP_STA
void KNL_FotaEventAtTx(void)
{
	E_FW_OTA_UPDT_RSLT tStatus;
	//KNL_PROCESS tKNLInfo;
	uint8_t ubRetryCnt = 10; 
	uint8_t ubTwcOkFlg = 0;
	uint8_t ubData;	
	
	if(ubKNL_TwcSend(KNL_MASTER_AP, TWC_FOTA_RPT, &ubData, 1, 16) != TWC_SUCCESS)
	{		
		while(ubRetryCnt--)
		{
			if(ubKNL_TwcSend(KNL_MASTER_AP, TWC_FOTA_RPT, &ubData, 1, 16) == TWC_SUCCESS)
			{
				printf("TWC(FOTA_RPT)-> Ok:%d\r\n",ubRetryCnt);
				ubTwcOkFlg = 1;
				break;
			}
			else
			{
				printf("TWC(FOTA_RPT)-> Fail:%d\r\n",ubRetryCnt);
			}
			osDelay(100);
		}
	}
	else
	{
		printf("TWC(FOTA_RPT)-> Ok\r\n");
		ubTwcOkFlg = 1;
	}	
	
	if(ubTwcOkFlg)
	{
		osDelay(500);	//Dummy Delay
		
		ulKNL_FotaDataAddr = ulBUF_GetBlkBufAddr(0,BUF_FOTA);
		printf("FOTA Event:Addr:0x%x,Size:0x%x\r\n",ulKNL_FotaDataAddr,ulKNL_FotaDataSize);		

		tStatus = tFOTA_UpdateFW2SF(FW_OTA_TYPE_MASK,(uint8_t *)ulKNL_FotaDataAddr);
		if(tStatus == FW_OTA_UPDT_SUCCESS)
		{
			printf("FWU From FOTA -> Ok\r\n");
			SYS_Reboot();
		}
		else
		{
			printf("FWU From FOTA -> Fail\r\n");
		}
	}
	else
	{
		printf("Fota Event + TWC(Fail)\r\n");
	}	
}
#endif
#endif

#endif
osSemaphoreId tKNL_AccExtraDataSem;

//osSemaphoreId tKNL_AccSendApiSem;

uint8_t ubKNL_ExtraWrDataIdx = KNL_EXT_BUF_NUM-1;
uint8_t ubKNL_ExtraRdDataIdx = KNL_EXT_BUF_NUM-1;
uint8_t ubKNL_ExtraDataFlg[KNL_EXT_BUF_NUM];
uint8_t ubKNL_ExtraData[KNL_EXT_BUF_NUM][KNL_EXT_DATA_INTERNAL_LEN+KNL_EXT_DATA_EXTERNAL_LEN];

pvKNL_GetDataFromDevice1CbFunc pKNL_GetDataFromDevice1 = NULL;
pvKNL_GetDataFromDevice2CbFunc pKNL_GetDataFromDevice2 = NULL;

void KNL_SetDataFromDevice1CbFunc(pvKNL_GetDataFromDevice1CbFunc pCbFunc)
{
	pKNL_GetDataFromDevice1 = pCbFunc;
}

void KNL_SetDataFromDevice2CbFunc(pvKNL_GetDataFromDevice2CbFunc pCbFunc)
{
	pKNL_GetDataFromDevice2 = pCbFunc;
}

//void KNL_Test1(uint32_t ulAddr,uint16_t uwLen)
//{	
//	uint8_t ubFirst,ubFinal;
//	
//	ubFirst	= *(uint8_t *)(ulAddr+0);	
//	ubFinal	= *(uint8_t *)(ulAddr+uwLen-1);	
//	printf("D1[%d][%d,%d]\r\n",uwLen,ubFirst,ubFinal);		
//}

//void KNL_Test2(uint32_t ulAddr,uint16_t uwLen)
//{	
//	uint8_t ubFirst,ubFinal;
//	
//	ubFirst	= *(uint8_t *)(ulAddr+0);	
//	ubFinal	= *(uint8_t *)(ulAddr+uwLen-1);	
//	
//	printf("D2[%d][%d,%d]\r\n",uwLen,ubFirst,ubFinal);
//}

void KNL_ExtraDataInit(void)
{
	uint8_t i;
	
	for(i=0;i<KNL_EXT_BUF_NUM;i++)
		ubKNL_ExtraDataFlg[i] = 0;
	
	osSemaphoreDef(tKNL_AccExtraDataSem);
	tKNL_AccExtraDataSem	= osSemaphoreCreate(osSemaphore(tKNL_AccExtraDataSem), 1);	
	
//	KNL_SetDataFromDevice1CbFunc(KNL_Test1);
//	KNL_SetDataFromDevice2CbFunc(KNL_Test2);	
}

uint8_t ubKNL_SendExtraData(uint32_t ulAddr,uint16_t uwLen)
{	
	osSemaphoreWait(tKNL_AccExtraDataSem, osWaitForever);
	
	if(uwLen > KNL_EXT_DATA_EXTERNAL_LEN)
	{			
		osSemaphoreRelease(tKNL_AccExtraDataSem);
		return 0;	
	}	
	ubKNL_ExtraWrDataIdx++;
	if(ubKNL_ExtraWrDataIdx >= KNL_EXT_BUF_NUM)
		ubKNL_ExtraWrDataIdx = 0;
	
	if(ubKNL_ExtraDataFlg[ubKNL_ExtraWrDataIdx] == 0)
	{		
		ubKNL_ExtraDataFlg[ubKNL_ExtraWrDataIdx] = 1;		
		ubKNL_ExtraData[ubKNL_ExtraWrDataIdx][0] = 0;					//Source, Don't care
		ubKNL_ExtraData[ubKNL_ExtraWrDataIdx][1] = uwLen & 0x00FFL;		//Len[0]
		ubKNL_ExtraData[ubKNL_ExtraWrDataIdx][2] = (uwLen & 0xFF00L)>>8;//Len[1]
		ubKNL_ExtraData[ubKNL_ExtraWrDataIdx][3] = 0;					//Reserved
		memcpy((uint8_t*)&ubKNL_ExtraData[ubKNL_ExtraWrDataIdx][4],(uint8_t*)ulAddr,uwLen);
	}
	else
	{		
		//Restore
		if(ubKNL_ExtraWrDataIdx)
			ubKNL_ExtraWrDataIdx--;
		else
			ubKNL_ExtraWrDataIdx = KNL_EXT_BUF_NUM-1;
		
		osSemaphoreRelease(tKNL_AccExtraDataSem);
		return 0;		
	}	
	osSemaphoreRelease(tKNL_AccExtraDataSem);	
	return 1;
}

uint32_t ulKNL_ChkExtraData(uint32_t ulAddr,uint32_t ulLen)
{		
	uint32_t i;
	uint32_t ulExtraLen;
	uint8_t ubTemp[2];	
	
	osSemaphoreWait(tKNL_AccExtraDataSem, osWaitForever);	
	
	ubKNL_ExtraRdDataIdx++;
	if(ubKNL_ExtraRdDataIdx >= KNL_EXT_BUF_NUM)
		ubKNL_ExtraRdDataIdx = 0;
	
	if(ubKNL_ExtraDataFlg[ubKNL_ExtraRdDataIdx] == 1)
	{		
		ubKNL_ExtraDataFlg[ubKNL_ExtraRdDataIdx] = 0;
		
		//Get Length
		ubTemp[0] = ubKNL_ExtraData[ubKNL_ExtraRdDataIdx][1];	//Len[0]
		ubTemp[1] = ubKNL_ExtraData[ubKNL_ExtraRdDataIdx][2];	//Len[1]
		ulExtraLen = ((uint32_t)ubTemp[0]) + (((uint32_t)ubTemp[1])<<8);
		
		//Alignment to 4 Bytes
		if((ulLen % KNL_ALIGN_UNIT))
			ulLen = ((ulLen/KNL_ALIGN_UNIT)*KNL_ALIGN_UNIT)+KNL_ALIGN_UNIT;		
	
		//Add Extra Data
		//Length
		*((uint8_t *)(ulAddr+ulLen+0)) = 0;			//Source, Don't care
		*((uint8_t *)(ulAddr+ulLen+1)) = ubTemp[0];	//Len[0]
		*((uint8_t *)(ulAddr+ulLen+2)) = ubTemp[1];	//Len[1]
		*((uint8_t *)(ulAddr+ulLen+3)) = 0;			//Reserved
		//Data
		for(i=0;i<ulExtraLen;i++)
			*((uint8_t *)(ulAddr+KNL_EXT_DATA_INTERNAL_LEN+ulLen+i)) = ubKNL_ExtraData[ubKNL_ExtraRdDataIdx][4+i];		
		
		ulLen = ulLen+KNL_EXT_DATA_INTERNAL_LEN+KNL_EXT_DATA_EXTERNAL_LEN;
	}
	else
	{
		//Restore
		if(ubKNL_ExtraRdDataIdx)
			ubKNL_ExtraRdDataIdx--;
		else
			ubKNL_ExtraRdDataIdx = KNL_EXT_BUF_NUM-1;		
		
		//Alignment to 4 Bytes
		if((ulLen % KNL_ALIGN_UNIT))
			ulLen = ((ulLen/KNL_ALIGN_UNIT)*KNL_ALIGN_UNIT)+KNL_ALIGN_UNIT;				
		
		//Add Extra Data
		//Length
		*((uint8_t *)(ulAddr+ulLen+0)) = 0;	//Source, Don't care
		*((uint8_t *)(ulAddr+ulLen+1)) = 0;	//Len[0]
		*((uint8_t *)(ulAddr+ulLen+2)) = 0;	//Len[1]
		*((uint8_t *)(ulAddr+ulLen+3)) = 0;	//Reserved
		//Data
		//None	
		
		ulLen = ulLen+KNL_EXT_DATA_INTERNAL_LEN+KNL_EXT_DATA_EXTERNAL_LEN;
		
		osSemaphoreRelease(tKNL_AccExtraDataSem);
		return ulLen;
	}
	
	osSemaphoreRelease(tKNL_AccExtraDataSem);	
	return ulLen;
}

#if defined(RTC676x)
/*
int iKNL_SendPacket(COMM_DATA_TYPE tType,const void *buf, size_t len, int flags, int dest_id, uint64_t *ack)
{
	int Result;
	
	osSemaphoreWait(tKNL_AccSendApiSem, osWaitForever);
	
	KNL_StartChkVCTimeOut();
	
	if(tType == COMM_DATA_TYPE_VDO)
	{
		Result = rf_send_video_packet(buf,len,flags,dest_id,ack);
	}
	else if(tType == COMM_DATA_TYPE_ADO)
	{
		Result = rf_send_audio_packet(buf,len,flags,dest_id,ack);
	}	
	else if(tType == COMM_DATA_TYPE_CMD)
	{
		Result = rf_send_smsg_packet(buf,len,flags,dest_id,ack);
	}
	
	KNL_StopChkVCTimeOut();
	
	osSemaphoreRelease(tKNL_AccSendApiSem);
	return Result;
}
*/

RW_MODULATION_MODE tKNL_RfModulationMode = MODE_QPSK;
KNL_RF_MODE_SW tKNL_RfModeSwInfo;
uint8_t ubKNL_StopTrxFlg[3] = {0,0,0};
uint8_t ubKNL_GetStopTrxFlg(void)
{
	return ubKNL_StopTrxFlg[2];
}
void KNL_ClearStopTrxFlg(void)
{
	ubKNL_StopTrxFlg[2] = 0;
}
#endif
uint8_t ubKNL_FixDisplayLocateEnable	= 0;	
uint8_t ubKNL_SenThenEncEnable			= 0;
uint8_t ubKNL_AdjBufEnable				= 0;

void KNL_SetFixDisplayLocateEnable(uint8_t ubFlg)
{
	ubKNL_FixDisplayLocateEnable = ubFlg;
}
uint8_t ubKNL_GetFixDisplayLocateEnable(void)
{
	return ubKNL_FixDisplayLocateEnable;
}

void KNL_SetSenThenEncEnable(uint8_t ubFlg)
{
	ubKNL_SenThenEncEnable = ubFlg;
}
uint8_t ubKNL_GetSenThenEncEnable(void)
{
	return ubKNL_SenThenEncEnable;
}

uint8_t ubKNL_GetIspEnable(void)
{
#if (defined(OP_STA) || (defined(OP_AP) && defined(BSP_DVR_SDK)))
	return ubSEN_GetByPassIqState();
#else
    return 0;
#endif
}

void KNL_SetAdjBufEnable(uint8_t ubFlg)
{
	ubKNL_AdjBufEnable = ubFlg;
}
uint8_t ubKNL_GetAdjBufEnable(void)
{
	return ubKNL_AdjBufEnable;
}

KNL_ADO_SRC_SEL KNL_AdoSrcSel = LOCAL_REMOTE;

#if defined(BSP_DVR_SDK)
uint8_t ubKNL_ModifyDPCnt=0;
#endif
// Richwave RTC676x
//=============================================================================================
RW_RF_STATE tKNL_RwRfState = INIT_STATE;
uint8_t ubKNL_RwResetCnt = 0;
float fKNL_PreRatio = 1;

#if defined(BUC_CAM)
uint8_t ubKNL_SysMaxFps = VGA_RES_FPS;
#else
uint8_t ubKNL_SysMaxFps = VDO_FRAME_RATE(HD_WIDTH, HD_HEIGHT);
#endif

uint8_t ubKNL_FrmLossFlag[4] = {0,0,0,0};
uint8_t ubKNL_LinkActiveTime = KNL_LINK_ACTIVE_TIME;

#ifndef S2019A
uint8_t ubKNL_ErrFlg[KNL_ERR_STATIC] = {0,0};
uint8_t ubKNL_ErrCnt = 0;
uint8_t ubKNL_StaticCnt = 0;
#endif

uint8_t ubKNL_TmrErrFlg = 0;
KNL_SLOT_SWITCH tKNL_SlotSwitchMode = KNL_SLOT_MANUAL_SET;

#ifdef RTC676x
typedef struct
{
	KNL_ROLE	tKNL_Role;
	TWC_TAG		tTWC_StaNum;
}KNL_StaMap_t;
KNL_StaMap_t tKNL_StaMapTab[] =
{
	[0] = {KNL_STA1, TWC_STA1},
	[1] = {KNL_STA2, TWC_STA2},
	[2] = {KNL_STA3, TWC_STA3},
	[3] = {KNL_STA4, TWC_STA4},
};
#if (APP_MODULATION_MODE == MODULATION_FIXED_QPSK)
int KNL_EvenSlot = 1200;
int KNL_CurRwBbRateMode = PREF_BBR_QPSK;
int KNL_NewRwBbRateMode = PREF_BBR_QPSK;
#endif
#if (APP_MODULATION_MODE == MODULATION_FIXED_16QAM)
int KNL_EvenSlot = 1667;
int KNL_CurRwBbRateMode = PREF_BBR_16QAM;
int KNL_NewRwBbRateMode = PREF_BBR_16QAM;
#endif
#if (APP_MODULATION_MODE == MODULATION_AUTO)
int KNL_EvenSlot = 1667;
int KNL_CurRwBbRateMode = PREF_BBR_QPSK;
int KNL_NewRwBbRateMode = PREF_BBR_QPSK;
#endif
int KNL_PreBwType = BW_QUARTER_BANDWIDTH;
int KNL_CurBwType = BW_QUARTER_BANDWIDTH;
int KNL_RwBwRpt = BW_QUARTER_BANDWIDTH;
#endif
#if (APP_DOORPHONE_ENABLE==1)
uint8_t ubKNK_VideoOnOffFg[4] = {0,0,0,0}; // 1 on , 0 off
#endif
uint8_t ubKNL_GetSensorBufNumber(void)
{
#if (defined(OP_STA) || (defined(OP_AP) && defined(BSP_DVR_SDK)))
	return ubSEN_GetSensorBufNumber();
#else
    return 0;
#endif
}

#if defined(BSP_DVR_SDK)
void KNL_SetPlayBackIngFlg(uint8_t ubFlg)
{
	ubKNL_PlaybackIngFlg = ubFlg;
}

uint8_t ubKNL_GetPlayBackIngFlg(void)
{
	return ubKNL_PlaybackIngFlg;
}
#endif

void KNL_SetSlotSwitchMode(KNL_SLOT_SWITCH tMode)
{
	tKNL_SlotSwitchMode = tMode;
}

KNL_SLOT_SWITCH tKNL_GetSlotSwitchMode(void)
{
	return tKNL_SlotSwitchMode;
}

void KNL_SetSysMaxFps(uint8_t ubFps)
{
	ubKNL_SysMaxFps = ubFps;
}

uint8_t ubKNL_GetSysMaxFps(void)
{
	return ubKNL_SysMaxFps;
}

#ifdef RTC676x
int KNL_GetCurRwBbRateMode(void)
{
	return KNL_CurRwBbRateMode;
}

void KNL_SetEvenSlot(int EvenSlot)
{	
	KNL_EvenSlot = EvenSlot;
    rf_setopt(RF_OPT_EVEN_SECTION, &KNL_EvenSlot, sizeof(KNL_EvenSlot));
}

int KNL_GetEvenSlot(void)
{
	return KNL_EvenSlot;
}

int KNL_SetRwRemoteId(int *idv, int idvcnt)	//Set Richwave RTC676x Remote ID
{	
	int result1 = 0,result2 = 0;
	int bwv[4];
    bwv[0] = BW_QUARTER_BANDWIDTH;
    bwv[1] = BW_QUARTER_BANDWIDTH;
    bwv[2] = BW_QUARTER_BANDWIDTH;
    bwv[3] = BW_QUARTER_BANDWIDTH;

	int *ptr;
	uint8_t i;
	int ulSlaveId[4];	
	
	ptr = idv;
	
	if(idvcnt == 1)
		KNL_RwBwRpt = BW_FULL_BANDWIDTH;
	else if(idvcnt == 2)
		KNL_RwBwRpt = BW_HALF_BANDWIDTH;
	else if(idvcnt == 4)
		KNL_RwBwRpt = BW_QUARTER_BANDWIDTH;
	
	for(i=0;i<4;i++)		//Force to '0'
		ulSlaveId[i] = 0;
	
	for(i=0;i<idvcnt;i++)
	{
		ulSlaveId[i] = *ptr++;
	}
	
//	for(i=0;i<4;i++)
//		printf("ID[%d]:0x%x\r\n",i,ulSlaveId[i]);	
	result1 = rf_set_remote_id(ulSlaveId,4);
	
	if(tKNL_GetSlotSwitchMode() == KNL_SLOT_MANUAL_SET)
	{
		if(idvcnt == 1)
		{
			bwv[0] = BW_FULL_BANDWIDTH;
			bwv[1] = BW_NONE;
			bwv[2] = BW_NONE;
			bwv[3] = BW_NONE;
		}
		else if(idvcnt == 2)
		{
			bwv[0] = BW_HALF_BANDWIDTH;
			bwv[1] = BW_HALF_BANDWIDTH;
			bwv[2] = BW_NONE;
			bwv[3] = BW_NONE;
		}
		else if(idvcnt == 4)
		{
			bwv[0] = BW_QUARTER_BANDWIDTH;
			bwv[1] = BW_QUARTER_BANDWIDTH;
			bwv[2] = BW_QUARTER_BANDWIDTH;
			bwv[3] = BW_QUARTER_BANDWIDTH;
		}	
		result2 = rf_set_slave_bandwidth(bwv, 4);
	}
		
	if(result1 || result2)
	{
		printf("Fail(%d,%d) @%s\r\n",result1,result2,__func__);
	}	
	return result1;
}

int KNL_GetRwBwRpt(void)	//Used for AP
{
	return KNL_RwBwRpt;
}

int KNL_SocketFd = 0;

osMessageQId KNL_VdoPacketizeQue = NULL;		//Transmit(Video)
osMessageQId KNL_AdoPacketizeQue = NULL;		//Transmit(Audio)
KNL_MSG_Q_INFO_t KNL_PacketQue[4] = {NULL};		//Receive(VDO/ADO/CMD Pkt for Cam1~Cam4)
KNL_SEMAPHORE_INFO_t tKNL_PacketThRdySem[4];

#endif

osSemaphoreId tKNL_GetFramSzSem;

osSemaphoreId tKNL_AuxAccSem;
osSemaphoreId tKNL_UvcFlgAccSem;

osSemaphoreId tKNL_CrcAccSem;

uint8_t ubKNL_StaOnLineMap = 0;
uint8_t ubKNL_CodecFailFlg[4] = {0,0,0,0};

uint8_t ubKNL_OutFps[4] = {0,0,0,0};
uint8_t ubKNL_OutFpsTemp[4] = {0,0,0,0};

uint8_t ubPkt_AckStatus[KNL_ACK_STATIC_NUM];
uint32_t ulPkt_MonitIdx = 0;

osSemaphoreId tKNL_LinkActiveTimeSem;
osSemaphoreId tKNL_ErrCntSem;
//=============================================================================================

osMutexId tKNL_LinkSem;
uint8_t ubKNL_BbRtyFlg = 0;
uint8_t ubKNL_ResetIFlg[KNL_SRC_NUM]={0};
uint8_t ubKNL_SenStartFlg = 0;
uint8_t ubKNL_ChgResFlg = 0;
uint8_t ubKNL_SysStopFlag;
uint8_t ubKNL_BbPathAct;
KNL_SrcLocateMap_t KNL_SwDispInfo;

//For Process
KNL_INFO tKNL_Info;

osMessageQId KNL_VdoInProcQueue;

#if (APP_DUAL_HOST_ENABLE == 1)
osMessageQId KNL_UsbMonitQueue;
osMessageQId KNL_UsbResetQueue;
uint8_t ubKNL_UvcStreamMap[2] = {0xFF,0xFF};
#endif
#if (defined(OP_STA) || defined(BSP_DVR_SDK))
osMessageQId KNL_ResSwProcQueue;

#endif
osMessageQId KNL_VdoCodecProcQueue;
osMessageQId KNL_AdoCodecProcQueue;
osMessageQId KNL_CommTxProcQueue;

//For AVG
osMessageQId KNL_TwcMonitQueue;
KNL_MSG_Q_INFO_t KNL_AvgPlyQ[4];
KNL_THRD_INFO_t KNL_AvgThrd[4];
uint8_t ubKNL_AvgPlyStartFlg[4] = {0,0,0,0};
uint8_t ubKNL_AvgPlyCnt[4] = {0,0,0,0};
uint8_t ubKNL_AvgPlyStartNum = 4;

//For Block Init
uint8_t ubKNL_InitBBFlg = 0;
uint8_t ubKNL_InitImgFlg = 0;
uint8_t ubKNL_InitAdoFlg = 0;
uint8_t ubKNL_InitJpegFlg = 0;

uint8_t ubKNL_InitLcdFlg = 0;
uint8_t ubKNL_InitH264DecFlg[4] = {0,0,0,0};
uint8_t ubKNL_InitH264EncFlg[4] = {0,0,0,0};
//For Jpeg
uint8_t ubKNL_JpegPreNode;	//For BUC JPEG IP
uint8_t ubKNL_JpegSrc;			//For BUC JPEG IP
#if (defined(BSP_DVR_SDK) || (defined(BSP_RVCS_SDK)&&defined(OP_STA)&& APP_PHOTOGRAPH_FUNC_ENABLE))
uint32_t ulKNL_JPGAddr;
#else
uint32_t ulKNL_JPGAddr[4] = {0,0,0,0};
#endif
osMessageQId KNL_QueueJpegMonit;
osSemaphoreId JPEG_CodecSem;

typedef struct
{
	uint8_t ubProcFlag;
	osSemaphoreId osWaitSem;
}KNL_JpgSingleProc_t;
KNL_JpgSingleProc_t tKNL_JpegSigProc;
#ifdef BSP_DVR_SDK
#if ((defined(OP_AP) || (defined(OP_STA) && defined(VDO_SUBPATH_ENABLE) && (VDO_SUBPATH_ENABLE!=0))))
typedef struct
{
	uint8_t  ubSrcNum;
	uint32_t ulSrcAddr;
	uint32_t ulSrcSize;
}KNL_LocProcInfo_t;
osMessageQId osKNL_LocProcQue;
static void KNL_LocalDpProc(void const *argument);
#endif
#endif

#if (defined(BSP_DVR_SDK) || (defined(BSP_RVCS_SDK)&&defined(OP_STA)&& APP_PHOTOGRAPH_FUNC_ENABLE))
//For Snapshot @Local
//========================================================================
uint32_t ulKNL_LocalSnapshotSz = 0;
KNL_STATUS tKNL_LocalSnapshotStatus = KNL_READY;
uint8_t ubKNL_LocalSnapshotProcFg = 0;
uint32_t ulKNL_LocalSnapshotYuvAddr;
uint32_t ulKNL_LocalSnapshotBsAddr;
#endif
//For Capture
uint32_t ulKNL_CapSignal = 1;
#define osKNL_CapFinSignal			0x33
#define osKNL_PhotoPlyFinSignal		0x35
osThreadId osKNL_RecordThreadId;
osMessageQId osKNL_RecordMsgQue;
osMutexId osKNL_RecordFuncMutex;
KNL_RecordAct_t tKNL_RecordAct;
LCD_BUF_TYP *pKNL_LcdPlayBuf;
char cKNL_LatestFileName[FS_FILE_NAME_MAX_LENGTH];
uint32_t ulKNL_LatestFileNameLen;
uint8_t ubKNL_CaptureBurstCnt[KNL_SRC_NUM]={0};
#if (APP_PHOTOGRAPH_FUNC_ENABLE || APP_REC_FUNC_ENABLE)
static void KNL_RecordThread(void const *argument);
uint32_t ulKNL_PreAdoTimeStamp[KNL_SRC_NUM]={0};
uint32_t ulPreVdoTimeStamp[KNL_SRC_NUM];
uint8_t ubKNL_DownloadMode_Stop = 0;
#endif

// For Scaling Up Capture
#if (defined(OP_AP)&&APP_PHOTOGRAPH_FUNC_ENABLE)
#if (ISP_RES == ISP_1296P)  // Scaling Up 12M
#define KNL_SCALE_CAP_WIDTH     4592
#define KNL_SCALE_CAP_HEIGHT    2560
#elif (ISP_RES == ISP_FHD)
#define KNL_SCALE_CAP_WIDTH     (3840)//(ISP_WIDTH*2)
#define KNL_SCALE_CAP_HEIGHT    (2160)//(ISP_HEIGHT*2)
#else
#define KNL_SCALE_CAP_WIDTH     (ISP_WIDTH)
#define KNL_SCALE_CAP_HEIGHT    (ISP_HEIGHT)
#endif
#endif

//For Img/H264
uint8_t ubKNL_ImgSrc;			//For IMG/H264 IP
uint32_t ulKNL_ImgSize;			//For IMG/H264 IP
uint32_t ulKNL_ImgTime;
uint8_t ubKNL_ImgTrigSrc;		//For IMG Merge
uint8_t ubKNL_ImgTrigType;		//For IMG Merge
osSemaphoreId tKNL_ImgSem;
osSemaphoreId osKNL_H264CdcWaitSem;
osSemaphoreId tKNL_BsBufCtrlSem;
uint32_t ulKNL_CurFrmIdx[4];
uint8_t ubKNL_Qp[4] = {42,42,42,42};
uint8_t ubKNL_VdoChkSrcNumFlg[4] = {0,0,0,0};
uint8_t ubKNL_ImgBusyFlg;
pvRoleMap2Src ptKNL_VdoRoleMap2SrcNum;
KNL_HQImgSte_t tKNL_CapHQImgSte;
#ifdef OP_STA
KNL_HQImgCap_t tKNL_CapHQImg;
osMessageQId osKNL_CapHQImgQue;
osMessageQId osKNL_HQImgUvcQue;
#endif

//For Node
KNL_NODE_STATE tKNL_NodeState[KNL_SRC_NUM][256];
KNL_NODE_INFO tKNL_VdoNodeInfo[KNL_SRC_NUM][KNL_MAX_NODE_NUM];		//For Video
KNL_NODE_INFO tKNL_AdoNodeInfo[KNL_SRC_NUM][KNL_MAX_NODE_NUM];		//For Audio

//For Communication
osSemaphoreId tKNL_TwcSem;
osMessageQId KNL_LinkQ;
osMessageQId KNL_QueBbFrmOk;
osMessageQId KNL_QueTxVdo;
osMessageQId KNL_QueTxAdo;
osMessageQId KNL_QueRxVdo;
osMessageQId KNL_QueRxAdo;
#if (defined(OP_AP) && defined(BSP_DVR_SDK))
uint8_t ubKNL_LinkStatus[6] = {BB_LOST_LINK,BB_LINK,BB_LOST_LINK,BB_LOST_LINK,BB_LOST_LINK,BB_LOST_LINK};
uint8_t ubKNL_RtLinkStatus[6] = {BB_LOST_LINK,BB_LINK,BB_LOST_LINK,BB_LOST_LINK,BB_LOST_LINK,BB_LOST_LINK};
#else

#if (APP_DUAL_HOST_ENABLE == 1)
uint8_t ubKNL_LinkStatus[6] = {BB_LOST_LINK,BB_LINK,BB_LINK,BB_LOST_LINK,BB_LINK,BB_LINK};
uint8_t ubKNL_RtLinkStatus[6] = {BB_LOST_LINK,BB_LINK,BB_LINK,BB_LOST_LINK,BB_LINK,BB_LINK};
#else
uint8_t ubKNL_LinkStatus[6] = {BB_LOST_LINK,BB_LOST_LINK,BB_LOST_LINK,BB_LOST_LINK,BB_LOST_LINK,BB_LOST_LINK};
uint8_t ubKNL_RtLinkStatus[6] = {BB_LOST_LINK,BB_LOST_LINK,BB_LOST_LINK,BB_LOST_LINK,BB_LOST_LINK,BB_LOST_LINK};
#endif
#endif
KNL_COMM_STATE tKNL_CommState = KNL_COMM_STATE_STOP;
static uint8_t ubKNL_WakeUpFlag[KNL_MAX_ROLE] = {0,0,0,0,0,0,0};
uint8_t ubKNL_StbLinkStsRrefFlag = FALSE;

//For Audio
ADO_KNL_PARA_t tKNL_AdoInfo;
uint32_t ulKNL_DacStartToPlayCnt = 0;
uint8_t ubKNL_DacStartToPlayFlg = 0;
uint8_t ubKNL_AdcFlowActiveFlg = 0;
uint8_t ubKNL_DacFlowActiveFlg[KNL_SRC_NUM];
uint8_t ubKNL_UsbdAdoEncAct    = 0;
uint8_t ubKNL_UsbdAdoEncStFlag = TRUE;
pvRoleMap2Src ptKNL_AdoRoleMap2SrcNum;
osMessageQId tKNL_EncEventQue;		
osMessageQId tKNL_DecEventQue;

//For Video
uint8_t ubKNL_ImgRdy = 1;
uint8_t ubKNL_VdoFlowActiveFlg[KNL_SRC_NUM];
uint8_t ubKNL_RcvFirstIFrame[KNL_SRC_NUM];
uint8_t ubKNL_VdoGroupIdx[4] = {0,0,0,0};
uint8_t ubKNL_VdoBsBusyCnt[4] = {0,0,0,0};
uint8_t ubKNL_VdoResendITwcFlg[4] = {FALSE, FALSE, FALSE, FALSE};
uint8_t ubKNL_VdoResChgTwcFlg[4] = {FALSE, FALSE, FALSE, FALSE};
uint8_t ubKNL_AppResendIFrmFlg[4] = {FALSE, FALSE, FALSE, FALSE};
uint8_t ubKNL_UsbdVdoViewType;

//For Display
LCD_BUF_TYP *pLcdCh0Buf,*pLcdCh1Buf,*pLcdCh2Buf,*pLcdCh3Buf;
uint8_t ubKNL_DispCh0ActiveFlg=1,ubKNL_DispCh1ActiveFlg=1,ubKNL_DispCh2ActiveFlg=1,ubKNL_DispCh3ActiveFlg=1;
LCD_INFOR_TYP *pLcdCropScaleParam;
uint8_t ubKNL_LcdDispParamActiveFlg=1;
osSemaphoreId osKNL_LcdDispInfoSem;
KNL_SRC	tKNL_delMergeHSrc;

//For JPEG LCD Display
KNL_JpgLcdChCtrl_t tKNL_JpgLcdChCtrl;
osMutexId osKNL_JpgLcdChMutex;

//For TWC
uint8_t ubKNL_TwcEndFlg = 1;
uint8_t ubKNL_TwcResult = 0;

//For Status Report
uint32_t ulKNL_VdoOutAccCnt[4] = {0,0,0,0};		//Bit-Rate
uint32_t ulKNL_VdoOutAccCntTemp[4] = {0,0,0,0};	//Bit-Rate
uint32_t ulKNL_AdoOutAccCnt = 0;				//Bit-Rate
uint32_t ulKNL_AdoOutAccCntTemp = 0;			//Bit-Rate
#if defined(BSP_DVR_SDK)
uint32_t ulKNL_H264EncCnt[KNL_SRC_NUM];
uint32_t ulKNL_H264EncCntTemp[KNL_SRC_NUM];

uint32_t ulKNL_H264DecCnt[KNL_SRC_NUM];
uint32_t ulKNL_H264DecCntTemp[KNL_SRC_NUM];

uint32_t ulKNL_JpegEncCnt[KNL_SRC_NUM];
uint32_t ulKNL_JpegEncCntTemp[KNL_SRC_NUM];

uint32_t ulKNL_JpegDecCnt[KNL_SRC_NUM];
uint32_t ulKNL_JpegDecCntTemp[KNL_SRC_NUM];
pvRecordNtyFunc pRecStsRpt;
#endif
uint32_t ulKNL_OutVdoFpsCnt[KNL_SRC_NUM];		//For Output
uint32_t ulKNL_OutVdoFpsCntTemp[KNL_SRC_NUM];	//For Output

uint32_t ulKNL_InVdoFpsCnt[KNL_SRC_NUM];		//For Input
uint32_t ulKNL_InVdoFpsCntTemp[KNL_SRC_NUM];	//For Input

uint32_t ulKNL_FrmTRxNum[KNL_MAX_ROLE];			//For Output
uint32_t ulKNL_FrmTRxNumTemp[KNL_MAX_ROLE];		//For Output

pvKNL_BbFrmOkCbFunc ptKNL_BbFrmMonitCbFunc;

//WOR
uint8_t ubKNL_WorSts;
SET_WOR_MODE tKNL_WorMode;

//For FS
KNL_FS_MEDIA_INFO_t tKNL_FsMediaInfo;
#if (APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
KNL_TX_FSSORT KNL_TxFsSort;
uint32_t ulTxPlyAdo32EncFirstFlg;
uint32_t ulTxPlyAdo32EncRemainDataSz;
uint8_t ubTxPlyAdo32EncRemainDataBuf[AUDIO32_ENCODE_SIZE];
#if OP_AP
pvKNL_TxFsCbFunc ptKNL_TxFsCbFunc;
uint32_t *pKNL_TXFldInfo;
uint32_t *pKNL_TXFilInfo;
uint32_t KNL_TXFldInfoSz;
uint32_t KNL_TXFileInfoSz;
FS_FILE_HIDDEN_INFO_t tKNL_TXFSHiddenInfo;
KNL_RemotePlaySync_t KNL_RP_SyncHdlr = {0};
uint8_t ubKNL_PlayRtCfged;
KNL_ROLE ubKNL_PlayRtSTA;
#endif
#if OP_STA
KNL_TX_FLDLAYER KNL_TxFsFldLayer = KNL_TX_FLDROOT;
pvKNL_RemotePlayCbFunc ptKNL_RP_FsCbFunc;
pvKNL_RemotePlayCbFunc ptKNL_RP_CbFunc;
uint16_t uwKNL_BackResH;
uint16_t uwKNL_BackResV;
#endif
#endif

//for Play/Rec
KNL_DISP_TYPE  KNL_BackDispType = KNL_DISP_NONSUP;
KNL_SrcLocateMap_t KNL_BackSwDispInfo;
#if defined(BSP_DVR_SDK)
uint8_t ubKNL_BackSrcLocate[4];
uint8_t ubKNL_VdoPlayActCh[4];
#else
uint8_t ubKNL_BackSrcLocate[4];
uint8_t ubKNL_VdoPlayActCh[4];
#endif
uint8_t ubKNL_VdoPlayActNum = 0;
osMessageQId KNL_QueEmergency;
osMessageQId KNL_QueDwnldMode;
uint32_t ulKNL_EMG_fileNum = 0;
char chKNL_RecLatestFileName[FS_FILE_NAME_MAX_LENGTH];
uint32_t ulKNL_RecLatestFileNameLen;

//thumbnail showing
#if APP_FS_FILE_LIST_STYLE
#define osKNL_ShowingThmSignal      0x51
KNL_THM_SHOW_INFO_t KNL_ThmShowInfo = {0};
#endif

#if APP_PC_CONNECT_EN
uint8_t ubKNL_LeavePcConnectFirstFlg = 0;
KNL_PcConn_PcConnHook KNL_EnterPcConnCbFunc;
KNL_PcConn_PcConnHook KNL_LeavePcConnCbFunc;
KNL_PcConn_PcConnHook KNL_PcConnCbFunc_OtherAction;
KNL_PcConn_PcConnHook KNL_PcConnCbFunc_SdCardPlugout;
KNL_PCCONN_FW_UPDATE_MODE KNL_PcConn_SdFwuMode = KNL_PCCONN_WAIT;
FS_FILE_NAME_INFO_t KNL_PcConn_EngModeFileName;
FS_FILE_NAME_INFO_t KNL_PcConn_SdFwuFileName;
osMutexId osKNL_Mutex_PcConnect;
uint8_t ubKNL_PcConnEnterFlg = 0;
uint8_t ubKNL_PcConnSdFwuFlg = 0;
osThreadId KNL_PcConn_SdFwUpdateThreadId;
#endif

//for TimeStamp
uint16_t uwRtcPosX = 75;    //Display Start X Unit 4
uint16_t uwRtcPosY = 15;    //Display Start Y Unit 4
#if ((OP_STA && APP_TIMESTAMP_FUNC_ENABLE) || (OP_AP && defined(BSP_DVR_SDK) && APP_TIMESTAMP_FUNC_ENABLE))
static uint8_t ubRtcSync = FALSE;
#endif
#if ( OP_STA )
#define KNL_GOPSYNC_INIT    0x00
#define KNL_GOPSYNC_SEND    0x10
#define KNL_GOPSYNC_RECV    0x20
static uint8_t ubGopSync = KNL_GOPSYNC_INIT;
#endif

//For USB Tuning tool
KNL_TuningMode_t tKNL_TuningMode;

//
uint8_t ubKNL_GetRxFrameNumber = 0;

static void KNL_VdoInProcThread(void const *argument);

#if (defined(OP_STA) || defined(BSP_DVR_SDK))
static void KNL_ResSwProcThread(void const *argument);

#endif
static void KNL_VdoCodecProcThread(void const *argument);
static void KNL_AdoCodecProcThread(void const *argument);
#if APP_ADO_FUNC_ENABLE
static void KNL_AdoEncMonitThread(void const *argument);
static void KNL_AdoDecMonitThread(void const *argument);
#endif
static void KNL_CommLinkMonitThread(void const *argument);
static void KNL_CommLinkUpdateThread(void const *argument);
static void KNL_CommAdoRxMonitThread(void const *argument);
static void KNL_TwcMonitThread(void const *argument);
#if OP_AP
static void KNL_CommVdoRxMonitThread(void const *argument);
#endif
static void KNL_CommTxProcThread(void const *argument);
#if (APP_PLYBK_ENABLE == 1) && defined(RVCS_APP)
static void KNL_PlyBk_DownloadThread(void const *argument);
void KNL_DownloadFile(KNL_FldType_t tSimFld,uint16_t uwRecFileIndex);
#endif

#ifdef OP_AP
#if (APP_USBD_COMPOSITE_MODE & USBD_MULTI_UAC)
osMessageQId osKNL_UsbdUacQue;
static void KNL_UsbdIsoInProcThread(void const *argument);
static void KNL_UsbdIsoOutProcThread(void const *argument);
#endif
#endif
#ifdef RTC676x
static void KNL_VdoPacketizeProcThread(void const *argument);	//(VDO)Transmit
static void KNL_AdoPacketizeProcThread(void const *argument);	//(ADO)Transmit
static void KNL_Packet0ProcThread(void const *argument);	//Receive(Cam1)
#endif
#if (defined(OP_AP) && defined(RTC676x))
static void KNL_Packet1ProcThread(void const *argument);	//Receive(Cam2)
static void KNL_Packet2ProcThread(void const *argument);	//Receive(Cam3)
static void KNL_Packet3ProcThread(void const *argument);	//Receive(Cam4)	
#endif

#ifdef A7130
static void KNL_BbFrmMonitThread(void const *argument);
#endif

#if (defined(S2019A) || (defined(OP_AP) && defined(sWIFIBDG)))
sPRF_DrvMode_t tKNL_sPRFDrvMd = sPRF_TRX_MODE;
#if (defined(OP_AP) && (defined(RVCS_APP) || defined(sWIFIBDG)))
osThreadId osKNL_ApBgdThdId;
osMessageQId osKNL_ApBdgQue;
typedef struct
{
	uint32_t ulBsAddr;
	uint32_t ulBsSize;
	uint32_t ulFrmIdx;
	uint8_t  ubVdoGop;
}KNL_ApBdgQue_t;
typedef struct
{
	KNL_SRC tBgdSrcNum;
	uint8_t ubIfrmFlag;
	uint8_t ubResChgFlag;
	uint8_t ubErrFlag;
}KNL_ApBdgInof_t;
KNL_ApBdgInof_t tKNL_ApBdgInfo;
#endif	//! End of #if (defined(OP_AP) && (defined(RVCS_APP) || defined(sWIFIBDG)))
typedef struct
{
	uint32_t ulBsBufSize;
	uint32_t ulBsOvfAddr[4];
}KNL_VdoBsOvf_t;
KNL_VdoBsOvf_t tKNL_VdoBsOvfInfo;
#endif	//! End of #if (defined(S2019A) || (defined(OP_AP) && defined(sWIFIBDG)))
#ifdef S2019A
static void KNL_sPRFMonitorThread(void const *argument);
osMessageQId osKNL_sPrfFrmQue;
osSemaphoreId osKNL_EncIfrmSem;
uint8_t ubKNL_EncIfrmFlag = FALSE;
typedef struct
{
	uint8_t  ubEn;
	uint8_t  ubFrames;
	uint32_t ulBps;
	uint8_t  ubFps;
}KNL_EncInfo_t;
#ifdef OP_STA
KNL_EncInfo_t tKNL_H264EncInfo[4];
#endif
#if sPRF_LTYMEAS_EN
SPRF_VdoLatency_t tKNL_VdoLatency = {FALSE, FALSE, {{KNL_STA1,0,0,0,0,0,{0},0,0,0,{0},FALSE,FALSE,FALSE},
												    {KNL_STA2,0,0,0,0,0,{0},0,0,0,{0},FALSE,FALSE,FALSE},
												    {KNL_STA3,0,0,0,0,0,{0},0,0,0,{0},FALSE,FALSE,FALSE},
												    {KNL_STA4,0,0,0,0,0,{0},0,0,0,{0},FALSE,FALSE,FALSE}}};
#ifdef OP_AP
static void KNL_CalcLatencyThread(void const *argument);
osMessageQId osKNL_LatyDataQue;
#endif	//! End of #ifdef OP_AP
#endif	//! End of #if sPRF_LTYMEAS_EN
#endif	//! End of #ifdef S2019A
uint8_t ubKNL_RstVdoGrpFlag = FALSE;

//static void KNL_ImgMonitThread(void const *argument);

#if ((defined(OP_AP) && defined(BSP_DVR_SDK)) || (!defined(BSP_DVR_SDK)))
static void KNL_JpegMonitThread(void const *argument);
#endif

static void KNL_AvgPlyThread(void const *argument);

static void KNL_SysMonitThread(void const *argument);
static void KNL_SecMonitThread(void const *argument);

#if (APP_DUAL_HOST_ENABLE == 1)
static void KNL_UsbMonitThread(void const *argument);
static void KNL_UsbResetThread(void const *argument);
#endif
#if APP_TIMESTAMP_FUNC_ENABLE
static void KNL_TimeStampThread(void const *argument);
#endif

#if (APP_REC_FUNC_ENABLE && OP_STA)
static void KNL_TxRecThread(void const *argument);
osThreadId KNL_TxRecThreadId;
#endif
#if (defined(OP_STA) && !defined(S2019A))
static void KNL_GOPSyncThread(void const *argument);
#endif

#if APP_REC_FUNC_ENABLE
static void KNL_RecSdMonitorThread(void const *argument);
static void KNL_RecEmergencyThread(void const *argument);
osThreadId KNL_RecSdMonitorThreadId;
typedef struct
{
	REC_INFO tRecInfo;
	uint8_t ubSrcNum;
	uint8_t ubNode;
	uint8_t ubRelease;
}KNL_StrgRecInfo_t;
osMessageQId osKNL_StrgRecQue;
static void KNL_StorageRecFilesProc(void const *argument);
#endif

#if APP_TIMESTAMP_FUNC_ENABLE
static void KNL_RtcMonitorThread(void const *argument);
#if (BSP_RTC_TIMER_SEL == RTC_TIMER_INTERNAL)
	RTC_Calendar_t tKNL_SysCalendar;
#elif (BSP_RTC_TIMER_SEL == RTC_TIMER_EXTERNAL)
	RTC_PCF85063A_Calendar_t tKNL_SysCalendar;
#endif
#endif

//! RTC Wrapper function
#if (BSP_RTC_TIMER_SEL == RTC_TIMER_INTERNAL)
	#define wRTC_SETBASECALENDAR(...)		iRTC_SetBaseCalendar(__VA_ARGS__)
	#define wRTC_SETCALENDAR(...)			RTC_SetCalendar(__VA_ARGS__)
	#define wRTC_GETCALENDAR(...)			RTC_GetCalendar(__VA_ARGS__)
#elif (BSP_RTC_TIMER_SEL == RTC_TIMER_EXTERNAL)
	#define wRTC_SETBASECALENDAR(...)		(void(0))
	#define wRTC_SETCALENDAR(...)			RTC_PCF85063A_SetCalendar(__VA_ARGS__)
	#define wRTC_GETCALENDAR(...)			RTC_PCF85063A_GetCalendar(__VA_ARGS__)
#else
	#define wRTC_SETBASECALENDAR(...)		((void)0)
	#define wRTC_SETCALENDAR(...)			((void)0)
	#define wRTC_GETCALENDAR(...)			((void)0)	
#endif	//! End of #if (BSP_RTC_TIMER_SEL == RTC_TIMER_INTERNAL)

//! Performance debug mode
uint8_t ubKNL_PerDbgEn;
pvPerDbgRptCbFunc pKNL_PerDbgFunc[2];	//!0: PER, 1:Lantency
static uint8_t ubKNL_TargetFps = 0;
#if (defined(RTC676x) && defined(OP_AP) && TRXBW_RPT_EN)
osMutexId osKNL_TrxBwMutex;
uint32_t ulKNL_TrxBwRpt[4];
#endif
//! For H View
typedef struct
{
	uint8_t ubY;
	uint8_t ubCb;
	uint8_t ubCr;
}KNL_DmyPatColor_t;
KNL_DmyPatColor_t tKNL_DmyPatColor = {0x10, 0x80, 0x80};	

#if (APP_REC_FUNC_ENABLE && OP_STA)
void KNL_TXRecordProcess(void);
#endif

uint8_t ubKNL_CamIsCvbs = 0;
//------------------------------------------------------------------------------

uint8_t ubKNL_ChkBbInitEnd(void)
{
	return ubKNL_InitBBFlg;
}

uint8_t ubKNL_ChkImgInitEnd(void)
{
	return ubKNL_InitImgFlg;
}

uint8_t ubKNL_ChkCodecInitEnd(uint8_t ubCodecIdx)
{
	return ubKNL_InitH264EncFlg[ubCodecIdx];
}

#if (APP_DUAL_HOST_ENABLE == 1)
uint8_t ubKNL_ChkUvcIFrame[2] = {1,1};

void KNL_SetUvcChkFlg(uint8_t ubIdx,uint8_t ubFlg)
{
	osSemaphoreWait(tKNL_UvcFlgAccSem, osWaitForever);
	
	ubKNL_ChkUvcIFrame[ubIdx] = ubFlg;	
	
	osSemaphoreRelease(tKNL_UvcFlgAccSem);
}

uint8_t ubKNL_GetUvcChkFlg(uint8_t ubIdx)
{
	uint8_t ubFlg;
	
	osSemaphoreWait(tKNL_UvcFlgAccSem, osWaitForever);	
	
	ubFlg = ubKNL_ChkUvcIFrame[ubIdx];
	
	osSemaphoreRelease(tKNL_UvcFlgAccSem);	
	
	return ubFlg;
}
void KNL_GetFramFromUsbHost(uint8_t ubDeviceId,uint8_t ubFrameType,uint32_t ulAddr,uint32_t ulSize)
{
	KNL_PROCESS tKNLInfo;
	uint32_t ulVdoBsAddr;	
	uint8_t ubIdxMap;
	
	uint32_t ulExtDataOfs;
	uint16_t uwExtLen;
	uint32_t ulTemp;
	uint8_t ubTemp[2];	
	
	//printf("%d\r\n",ulSize);
	
	//Check Extra Data From UVC Device1 or 2
	ulTemp = ulSize;	
	ulTemp = ulTemp - USBD_UVC_HEADER_LEN;
	ulExtDataOfs = ulTemp - (KNL_EXT_DATA_INTERNAL_LEN+KNL_EXT_DATA_EXTERNAL_LEN);	
	ubTemp[0] = *((uint8_t *)(ulAddr+USBD_UVC_HEADER_LEN+ulExtDataOfs+1));
	ubTemp[1] = *((uint8_t *)(ulAddr+USBD_UVC_HEADER_LEN+ulExtDataOfs+2));
	uwExtLen = ((uint16_t)ubTemp[0]) + (((uint16_t)ubTemp[1])<<8);

#if 0	
	if(uwExtLen)
	{
		if(ubDeviceId == USBH_UVC1_DEVICE_ID)
		{
			printf("UVC1(%d):%d\r\n",uwExtLen,*((uint8_t *)(ulAddr+USBD_UVC_HEADER_LEN+ulExtDataOfs+4)));
			if(pKNL_GetDataFromDevice1 != NULL)				
				pKNL_GetDataFromDevice1(ulAddr+USBD_UVC_HEADER_LEN+ulExtDataOfs+KNL_EXT_DATA_INTERNAL_LEN,uwExtLen);
		}
		else if(ubDeviceId == USBH_UVC2_DEVICE_ID)
		{
			printf("UVC2(%d):%d\r\n",uwExtLen,*((uint8_t *)(ulAddr+USBD_UVC_HEADER_LEN+ulExtDataOfs+4)));
			if(pKNL_GetDataFromDevice2 != NULL)				
				pKNL_GetDataFromDevice2(ulAddr+USBD_UVC_HEADER_LEN+ulExtDataOfs+KNL_EXT_DATA_INTERNAL_LEN,uwExtLen);
		}
	}
#endif
	
	if(ubDeviceId == USBH_UVC1_DEVICE_ID)
		ubIdxMap = 0;
	else if(ubDeviceId == USBH_UVC2_DEVICE_ID)
		ubIdxMap = 1;	
	
	if(ubFrameType == 0)	//I-Frame
	{		
		if(ubKNL_GetUvcChkFlg(ubIdxMap) == 1)
			printf("UVC First-I[%d]\r\n",ubDeviceId);							
		KNL_SetUvcChkFlg(ubIdxMap,0);
	}
	else
	{
		//printf("P[%d]\r\n",ubDeviceId);
	}

	//if(ubKNL_GetUvcChkFlg(ubIdxMap) == 0)
	if((ubKNL_GetUvcChkFlg(ubIdxMap) == 0) && ubKNL_VdoFlowActiveFlg[KNL_SRC_2_MAIN+ubIdxMap])	
	{		
		ulVdoBsAddr = ulKNL_GetBsBufAddr(KNL_SRC_2_MAIN+(ubIdxMap));
		
		if(ulVdoBsAddr != BUF_FAIL)
		{				
			tDMAC_MemCopy(((uint32_t)ulAddr)+12, ulVdoBsAddr,ulSize, NULL);			

			tKNLInfo.ubSrcNum		= KNL_SRC_2_MAIN+ubIdxMap;			
			tKNLInfo.ulDramAddr2    = ulVdoBsAddr;
			tKNLInfo.ubCurNode      = KNL_NODE_COMM_RX_VDO;
			tKNLInfo.ubNextNode     = ubKNL_GetNextNode(KNL_SRC_2_MAIN+ubIdxMap,KNL_NODE_COMM_RX_VDO);			
			tKNLInfo.ulIdx			= 0;									
			tKNLInfo.ubHqCapFlag  	= 0;
			tKNLInfo.ulSize			= ulSize;
			
			//For Extra Data
			tKNLInfo.ubDeviceId		= ubDeviceId;
			tKNLInfo.uwExtLen		= uwExtLen;
			//tKNLInfo.ulExtDataOfs	= ulAddr+USBD_UVC_HEADER_LEN+ulExtDataOfs+KNL_EXT_DATA_INTERNAL_LEN;
			tKNLInfo.ulExtDataOfs	= ulVdoBsAddr+ulExtDataOfs+KNL_EXT_DATA_INTERNAL_LEN;
			
			if(osMessagePut(KNL_VdoCodecProcQueue, &tKNLInfo, 0) == osErrorResource)
			{				
				ubKNL_ReleaseBsBufAddr(KNL_NODE_COMM_RX_VDO, KNL_SRC_2_MAIN+ubIdxMap, tKNLInfo.ulDramAddr2);				
				printd(DBG_ErrorLvl, "KNL_Q->Full !!!\r\n");
			}
		}
		else
		{			
			KNL_SetUvcChkFlg(ubIdxMap,1);
		}		
	}
	
	UVC_CleanBkBuf();
}
#endif

#if APP_PC_CONNECT_EN
uint8_t ubKNL_PcConnectAccFlg = 0;
void KNL_MscSectorWrite(uint8_t *pBf, uint32_t ulLBA, uint32_t ulLBA_Cnt)
{
	if(ubKNL_PcConnSdFwuFlg==0)
	{
		while(ubKNL_PcConnectAccFlg==1)
			osDelay(10);
		//printd(DBG_ErrorLvl, "Mw\n");
		if(FS_ChkMediaExist(tKNL_FsMediaInfo.MediaSel) == FS_MEDIA_IN)
		{
			uint8_t ubStatus;
#if KNL_FS_SD_POLLING_EN
			ubStatus = ubSD_Write(tSD_GetDevIF(), (uint32_t )pBf, ulLBA, ulLBA_Cnt*512, 1);
#else
			ubStatus = ubSD_Write(tSD_GetDevIF(), (uint32_t )pBf, ulLBA, ulLBA_Cnt*512, 0);
#endif
			if(ubStatus==0)
			{
				printd(DBG_ErrorLvl, "KNL MSC SecWrt fail->Lba=0x%X, Sz=0x%X\n",ulLBA,ulLBA_Cnt*512);
			}
		}
	}
}
void KNL_MscSectorRead(uint8_t *pBf, uint32_t ulLBA, uint32_t ulLBA_Cnt)
{
	if(ubKNL_PcConnSdFwuFlg==0)
	{
		while(ubKNL_PcConnectAccFlg==1)
			osDelay(10);
		//printd(DBG_ErrorLvl, "Mr\n");
		if(FS_ChkMediaExist(tKNL_FsMediaInfo.MediaSel) == FS_MEDIA_IN)
		{
			uint8_t ubStatus;
#if KNL_FS_SD_POLLING_EN
			ubStatus = ubSD_Read(tSD_GetDevIF(), (uint32_t )pBf, ulLBA, ulLBA_Cnt*512, 1);
#else
			ubStatus = ubSD_Read(tSD_GetDevIF(), (uint32_t )pBf, ulLBA, ulLBA_Cnt*512, 0);
	#endif
			if(ubStatus==0)
			{
				printd(DBG_ErrorLvl, "KNL MSC SecRd fail->Lba=0x%X, Sz=0x%X\n",ulLBA,ulLBA_Cnt*512);
			}
		}
	}
}
#endif

#if (OP_STA&&!defined(BSP_DVR_SDK))
void KNL_SenHwEndProcess(uint8_t ubSenPath, uint32_t ulYuvAddr, uint32_t ulPathSize);
void KNL_SenHwEndProcess(uint8_t ubSenPath, uint32_t ulYuvAddr, uint32_t ulPathSize)
{	
#if (A7130 || RTC676x)
	uint8_t ubTotalBufNum = 0;
	uint8_t ubUsedBufNum = 0;	
#endif
	
    uint8_t ubUvcFlg = 0;
	uint8_t ubBsBufFlg = 0;
	uint8_t ubBbBufFlg = 0;
	
	KNL_NODE_INFO tNodeInfo;
	uint32_t ulTemp;
    uint8_t ubTemp;
	uint8_t ubIsp1SrcNum;	
	//uint8_t ubSrcNum;		
	
	//Path1	
	//if(!ubSEN_GetResChgFlg(SENSOR_PATH1) && ubSEN_FrameDropState(SENSOR_PATH1) && ubSEN_GetDetectVideoState() && (ubSEN_GetResChgDropCnt() >= SEN_RES_DROP_FRAME))               
	if(!ubSEN_GetResChgFlg(SENSOR_PATH1) && ubSEN_FrameDropState(SENSOR_PATH1) && ubSEN_GetDetectVideoState() && (ubSEN_GetResChgDropCnt() >= SEN_RES_DROP_FRAME) && ubKNL_ChkVdoFlowAct(ubSEN_GetPathSrc(SENSOR_PATH1)))               
	{
        if((USBD_UVC_MODE == tUSBD_GetClassMode())&&(16 == (ulDDR_GetCapacity() >> 20)))
        {
            #ifdef RTC676x
            ubUvcFlg = 1;
            #else
            ubUvcFlg = 0;
            #endif
        }

        if((ubKNL_ChkImgRdy() && ubKNL_ChkImgInitEnd() && ubKNL_ChkCodecInitEnd(0) && ubKNL_ChkBbInitEnd()) || ubUvcFlg)
		{			
			ubIsp1SrcNum = ubSEN_GetPathSrc(SENSOR_PATH1);
			
			//FPS Information												
			ulKNL_OutVdoFpsCntTemp[ubIsp1SrcNum]++;			
			
            if(/*(sensor_state.ubInputType == SENSOR_CVBS_NTSC)||(sensor_state.ubInputType == SENSOR_CVBS_PAL)*/0)
            {
//				//printf("2 \r\n");
//				if(VDO_ENC_METHOD == ENC_I_WHEN_BUSY)
//				{					
//					ulTemp = ulKNL_GetBsBufAddr(ubIsp1SrcNum);
//					if(ulTemp == BUF_FAIL)
//					{
//						printd(DBG_ErrorLvl, "(Path1)BUF_VDO_BS Err !!!\r\n");					
//						ubBUF_ReleaseSenYuvBuf(sensor_cfg.xtSENAddr.ulPath1_Addr);	
//					}else{
//						//(2)Get the Resource First				
//						ubKNL_ImgRdy = 0;
//						KNL_SetNodeState(ubIsp1SrcNum,KNL_NODE_H264_ENC,KNL_NODE_START);

//						//(3)Video Encode					
//						// H264 Encode
//						tNodeInfo = tKNL_GetNodeInfo(ubIsp1SrcNum,KNL_NODE_H264_ENC);									
//						ubKNL_ImgSrc = ubIsp1SrcNum;				
//						ubKNL_ImgEnc((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,sensor_cfg.xtSENAddr.ulPath1_Addr,ulTemp);            
//					}
//				}
//				else if(VDO_ENC_METHOD == DROP_FRM_WHEN_BUSY)
//				{
//					//Check BS-Buffer
//					//==========================================================					
//					if(ubKNL_SrcNumMap(ubIsp1SrcNum) == 0)
//					{
//					#ifdef S2019A
//						if(ubBUF_GetVdoMainBsFreeBufNum(BUF_VDO_MAIN_BS0))
//					#else
//						if(uwBUF_GetVdoMainBs0FreeNum())
//					#endif
//							ubBsBufFlg = 1;
//						else
//							ubBsBufFlg = 0;
//					}
//					else if(ubKNL_SrcNumMap(ubIsp1SrcNum) == 1)
//					{
//					#ifdef S2019A
//						if(ubBUF_GetVdoMainBsFreeBufNum(BUF_VDO_MAIN_BS1))
//					#else
//						if(uwBUF_GetVdoMainBs1FreeNum())
//					#endif
//							ubBsBufFlg = 1;
//						else
//							ubBsBufFlg = 0;
//					}
//					else if(ubKNL_SrcNumMap(ubIsp1SrcNum) == 2)
//					{
//					#ifdef S2019A
//						if(ubBUF_GetVdoMainBsFreeBufNum(BUF_VDO_MAIN_BS2))
//					#else
//						if(uwBUF_GetVdoMainBs2FreeNum())
//					#endif
//							ubBsBufFlg = 1;
//						else
//							ubBsBufFlg = 0;
//					}
//					else if(ubKNL_SrcNumMap(ubIsp1SrcNum) == 3)
//					{
//					#ifdef S2019A
//						if(ubBUF_GetVdoMainBsFreeBufNum(BUF_VDO_MAIN_BS3))
//					#else
//						if(uwBUF_GetVdoMainBs3FreeNum())
//					#endif
//							ubBsBufFlg = 1;
//						else
//							ubBsBufFlg = 0;
//					}					
//					
//					//Check BB-Buffer
//					//==========================================================
//				#if RTC676x
//					tNodeInfo = tKNL_GetNodeInfo(ubIsp1SrcNum,KNL_NODE_H264_ENC);
//					
//					if(H264_GetPeriod((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx) == 0)
//					{
//						ubTotalBufNum	= uwBUF_GetVdoPacketizeBigTotalNum();
//						ubUsedBufNum 	= ubTotalBufNum-uwBUF_GetVdoPacketizeBigFreeNum();
//					}
//					else
//					{						
//						ubTotalBufNum	= uwBUF_GetVdoPacketizeSmallTotalNum();
//						ubUsedBufNum 	= ubTotalBufNum-uwBUF_GetVdoPacketizeSmallFreeNum();
//					}
//					if((ubTotalBufNum - ubUsedBufNum) >= 1)
//						ubBbBufFlg = 1;
//					else
//						ubBbBufFlg = 0;
//					
//				#elif A7130						
//					//Check Next Output Frame is I or P -Frame
//					//---------------------------------------------------------------------------------
//					tNodeInfo = tKNL_GetNodeInfo(ubIsp1SrcNum,KNL_NODE_H264_ENC);
//					
//					if(H264_GetPeriod((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx) == 0)
//					{
//						ubTotalBufNum	= ubBB_GetTxTotalBufNum(BB_DATA_VIDEO_BG,BB_TX_MASTER);
//						ubUsedBufNum 	= ubBB_GetTxUsedBufNum(BB_DATA_VIDEO_BG,BB_TX_MASTER);
//					}
//					else
//					{						
//						ubTotalBufNum	= ubBB_GetTxTotalBufNum(BB_DATA_VIDEO_LT,BB_TX_MASTER);
//						ubUsedBufNum 	= ubBB_GetTxUsedBufNum(BB_DATA_VIDEO_LT,BB_TX_MASTER);
//					}					
//					//=================================================================================					
//					if((ubTotalBufNum - ubUsedBufNum) >= 1)
//						ubBbBufFlg = 1;								
//					else
//						ubBbBufFlg = 0;
//				#endif
//					
//					if(ubBsBufFlg && ubBbBufFlg)
//					{
//						ulTemp = ulKNL_GetBsBufAddr(ubIsp1SrcNum);
//						if(ulTemp == BUF_FAIL)
//						{
//							printd(DBG_ErrorLvl, "(Path1)BUF_VDO_BS Err !!!\r\n");					
//							ubBUF_ReleaseSenYuvBuf(sensor_cfg.xtSENAddr.ulPath1_Addr);	
//						}else{
//							//(2)Get the Resource First				
//							ubKNL_ImgRdy = 0;
//							KNL_SetNodeState(ubIsp1SrcNum,KNL_NODE_H264_ENC,KNL_NODE_START);

//							//(3)Video Encode					
//							// H264 Encode							
//							tNodeInfo = tKNL_GetNodeInfo(ubIsp1SrcNum,KNL_NODE_H264_ENC);						
//							ubKNL_ImgSrc = ubIsp1SrcNum;				
//							ubKNL_ImgEnc((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,sensor_cfg.xtSENAddr.ulPath1_Addr,ulTemp);            
//						}
//					}
//					else
//					{
//						ubBUF_ReleaseSenYuvBuf(sensor_cfg.xtSENAddr.ulPath1_Addr);
//					}							
//				}
            }
			else
			{
				if(VDO_ENC_METHOD == ENC_I_WHEN_BUSY)
				{             
					sensor_cfg.xtSENAddr.ulPath1_Addr = SEN->STR1_STA << 8;					
					ulTemp = ulKNL_GetBsBufAddr(ubIsp1SrcNum);				
					if(ulTemp == BUF_FAIL)
					{
						printd(DBG_ErrorLvl, "(Path1)BUF_VDO_BS Err !!!\r\n");					
						ubBUF_ReleaseSenYuvBuf(SEN->STR1_STA << 8);									
					}					
					else
					{				
						//(2)Get the Resource First				
						ubKNL_ImgRdy = 0;
						KNL_SetNodeState(ubIsp1SrcNum,KNL_NODE_H264_ENC,KNL_NODE_START);

						//(3)Video Encode					
						// H264 Encode
						tNodeInfo = tKNL_GetNodeInfo(ubIsp1SrcNum,KNL_NODE_H264_ENC);									
						ubKNL_ImgSrc = ubIsp1SrcNum;	
#if OP_STA						
						if((sensor_state.ubInputType == SENSOR_CVBS_NTSC)||(sensor_state.ubInputType == SENSOR_CVBS_PAL))
						{
							ubKNL_ImgEnc((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,SEN_Get16MCvbsAddress(),ulTemp);		
						}
						else
						{	
							ubKNL_ImgEnc((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,SEN->STR1_STA << 8,ulTemp);
						}
#else
						ubKNL_ImgEnc((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,SEN->STR1_STA << 8,ulTemp);
#endif
					}
				}
				else if(VDO_ENC_METHOD == DROP_FRM_WHEN_BUSY)
				{
					//Check BS-Buffer
					//==========================================================					
					if(ubKNL_SrcNumMap(ubIsp1SrcNum) == 0)
					{
					#ifdef S2019A
						if(ubBUF_GetVdoMainBsFreeBufNum(BUF_VDO_MAIN_BS0))
					#else
						if(uwBUF_GetVdoMainBs0FreeNum())
					#endif
							ubBsBufFlg = 1;
						else
							ubBsBufFlg = 0;
					}
					else if(ubKNL_SrcNumMap(ubIsp1SrcNum) == 1)
					{
					#ifdef S2019A
						if(ubBUF_GetVdoMainBsFreeBufNum(BUF_VDO_MAIN_BS1))
					#else
						if(uwBUF_GetVdoMainBs1FreeNum())
					#endif
							ubBsBufFlg = 1;
						else
							ubBsBufFlg = 0;
					}
					else if(ubKNL_SrcNumMap(ubIsp1SrcNum) == 2)
					{
					#ifdef S2019A
						if(ubBUF_GetVdoMainBsFreeBufNum(BUF_VDO_MAIN_BS2))
					#else
						if(uwBUF_GetVdoMainBs2FreeNum())
					#endif
							ubBsBufFlg = 1;
						else
							ubBsBufFlg = 0;
					}
					else if(ubKNL_SrcNumMap(ubIsp1SrcNum) == 3)
					{
					#ifdef S2019A
						if(ubBUF_GetVdoMainBsFreeBufNum(BUF_VDO_MAIN_BS3))
					#else
						if(uwBUF_GetVdoMainBs3FreeNum())
					#endif
							ubBsBufFlg = 1;
						else
							ubBsBufFlg = 0;
					}					
					
					//Check BB-Buffer
					//==========================================================
					#if RTC676x						
						tNodeInfo = tKNL_GetNodeInfo(ubIsp1SrcNum,KNL_NODE_H264_ENC);
						
						if(H264_GetPeriod((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx) == 0)
						{
							ubTotalBufNum	= uwBUF_GetVdoPacketizeBigTotalNum();
							ubUsedBufNum 	= ubTotalBufNum-uwBUF_GetVdoPacketizeBigFreeNum();
						}
						else
						{						
							ubTotalBufNum	= uwBUF_GetVdoPacketizeSmallTotalNum();
							ubUsedBufNum 	= ubTotalBufNum-uwBUF_GetVdoPacketizeSmallFreeNum();
						}
						
						if((ubTotalBufNum - ubUsedBufNum) >= 1)
							ubBbBufFlg = 1;
						else
							ubBbBufFlg = 0;
                        
                        if((USBD_UVC_MODE == tUSBD_GetClassMode())&&(16 == (ulDDR_GetCapacity() >> 20)))
                        {
                            ubBsBufFlg = 1;
                            ubBbBufFlg = 1;
                        }
					#elif A7130
						//Check Next Output Frame is I or P -Frame
						//---------------------------------------------------------------------------------
						tNodeInfo = tKNL_GetNodeInfo(ubIsp1SrcNum,KNL_NODE_H264_ENC);						
						if(H264_GetPeriod((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx) == 0)
						{							
							ubTotalBufNum	= ubBB_GetTxTotalBufNum(BB_DATA_VIDEO_BG,BB_TX_MASTER);
							ubUsedBufNum 	= ubBB_GetTxUsedBufNum(BB_DATA_VIDEO_BG,BB_TX_MASTER);
						}
						else
						{							
							ubTotalBufNum	= ubBB_GetTxTotalBufNum(BB_DATA_VIDEO_LT,BB_TX_MASTER);
							ubUsedBufNum 	= ubBB_GetTxUsedBufNum(BB_DATA_VIDEO_LT,BB_TX_MASTER);
						}					
						//=================================================================================							
						if((ubTotalBufNum - ubUsedBufNum) >= 1)
							ubBbBufFlg = 1;								
						else
							ubBbBufFlg = 0;
					#endif

					
					if(ubBsBufFlg && ubBbBufFlg)
					{
						sensor_cfg.xtSENAddr.ulPath1_Addr = SEN->STR1_STA << 8;					
						ulTemp = ulKNL_GetBsBufAddr(ubIsp1SrcNum);					
						if(ulTemp == BUF_FAIL)
						{
							printd(DBG_ErrorLvl, "(Path1)BUF_VDO_BS Err !!!\r\n");					
							ubBUF_ReleaseSenYuvBuf(SEN->STR1_STA << 8);									
						}					
						else
						{
							//(2)Get the Resource First				
							ubKNL_ImgRdy = 0;
							KNL_SetNodeState(ubIsp1SrcNum,KNL_NODE_H264_ENC,KNL_NODE_START);

							//(3)Video Encode					
							// H264 Encode													
							tNodeInfo = tKNL_GetNodeInfo(ubIsp1SrcNum,KNL_NODE_H264_ENC);						
							ubKNL_ImgSrc = ubIsp1SrcNum;	
#if OP_STA							
							if((sensor_state.ubInputType == SENSOR_CVBS_NTSC)||(sensor_state.ubInputType == SENSOR_CVBS_PAL))
							{
								ubKNL_ImgEnc((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,SEN_Get16MCvbsAddress(),ulTemp);
							}
							else
							{
								ubKNL_ImgEnc((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,SEN->STR1_STA << 8,ulTemp);
							}	
#else
							ubKNL_ImgEnc((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,SEN->STR1_STA << 8,ulTemp);
#endif							
						}
					}
					else
					{
						ubBUF_ReleaseSenYuvBuf(SEN->STR1_STA << 8);	
					}
				}
            }
		}
		else
		{			
			ubBUF_ReleaseSenYuvBuf(SEN->STR1_STA << 8);									
		}				
		
		//New Buffer for ISP1
		ulTemp = ulBUF_GetSen1YuvFreeBuf();
		if(ulTemp != BUF_FAIL)
		{				
			SEN->STR1_STA = ulTemp >> 8;
		}
	}
	else if(ubSEN_GetPathSrc(SENSOR_PATH1) != KNL_SRC_NONE)
	{		
		ubBUF_ReleaseSen1YuvBuf(SEN->STR1_STA << 8);
		SEN_SetResChgFlg(SENSOR_PATH1, FALSE);
        ubTemp = ubSEN_GetResChgDropCnt() + 1;
        SEN_SetResChgDropCnt(ubTemp);
	}
}

#endif
#define KNL_MAJORVER    2       //!< Major version = 2
#define KNL_MINORVER    20     	//!< Minor version = 20
uint16_t uwKNL_GetVersion (void)
{
    return ((KNL_MAJORVER << 8) + KNL_MINORVER);
}

void KNL_SetMasterId(uint32_t ulId)
{
	tKNL_Info.ulMasterId = ulId;
}

void KNL_SetSlaveId(uint8_t ubSlaveIdx,uint32_t ulId)
{
	tKNL_Info.ubSlaveIdx 				= ubSlaveIdx;
	tKNL_Info.ulSlaveId[ubSlaveIdx]		= ulId;	
}

uint32_t ulKNL_GetMasterId(void)
{
	return tKNL_Info.ulMasterId;
}

uint32_t ulKNL_GetSlaveId(uint8_t ubSlaveIdx)
{
	return tKNL_Info.ulSlaveId[ubSlaveIdx];
}
#if (defined(BSP_DVR_SDK) || (defined(BSP_RVCS_SDK)&&defined(OP_STA)&& APP_PHOTOGRAPH_FUNC_ENABLE) )
void KNL_SetLocalSnapshotYuvBuf(uint32_t ulBufAddr)
{
	ulKNL_LocalSnapshotYuvAddr = ulBufAddr;
}

void KNL_SetLocalSnapshotBsBuf(uint32_t ulBufAddr)
{
	ulKNL_LocalSnapshotBsAddr = ulBufAddr;
}

uint32_t ulKNL_GetLocalSnapshotBsBuf(void)
{
	return ulKNL_LocalSnapshotBsAddr;
}

void KNL_LocalSnapshotTrig(void)
{	
	tKNL_LocalSnapshotStatus = KNL_BUSY;
    ubKNL_LocalSnapshotProcFg = 1;
}

void KNL_LocalSnapshotRelease(void)
{	
	ubKNL_LocalSnapshotProcFg = 0;
}

uint8_t ubKNL_GetLocalSnapshotProc(void)
{
	return ubKNL_LocalSnapshotProcFg;
}

void KNL_SetLocalSnapShotSz(uint32_t ulBsSz)
{
	ulKNL_LocalSnapshotSz = ulBsSz;
}

uint32_t ulKNL_GetLocalSnapshotSz(void)
{
	return ulKNL_LocalSnapshotSz;
}
#endif
#if (defined(BSP_DVR_SDK))
void KNL_Recrpt(pvRecordNtyFunc pfunc)
{
    pRecStsRpt = pfunc;
}
uint8_t KNL_ChkSDPlugIn(void)
{
    if(FS_ChkMediaExist(tKNL_FsMediaInfo.MediaSel) == FS_MEDIA_IN)
        return 1;
    else
		return 0;
}
#endif
void PKT_UpdateInfo(uint8_t ubAckFlg)
{
	ubPkt_AckStatus[(ulPkt_MonitIdx++)%KNL_ACK_STATIC_NUM] = ubAckFlg;
}

#ifdef RTC676x
uint32_t ulRTC676x_GetMaxBw(void)	//Used @STA/CAM
{
	uint32_t ulOutBw = 0;	//Unit -> Byte	
	uint32_t ulMaxVdoPktLen;
#if (RF_MODE_SW_SEL == RF_MODE_SW_OLD)
	if(KNL_CurRwBbRateMode == PREF_BBR_BPSK)
#elif (RF_MODE_SW_SEL == RF_MODE_SW_NEW)
	if(0)
#endif
	{				
		if(rf_get_bandwidth_config() == BW_FULL_BANDWIDTH)
		{			
			if(KNL_GetEvenSlot() == 1200)			
				ulMaxVdoPktLen = RW_S2M_SZ_BPSK_1T_1200-PKT_HEADER_SZ;	
			else if(KNL_GetEvenSlot() == 1667)			
				ulMaxVdoPktLen = RW_S2M_SZ_BPSK_1T_1667-PKT_HEADER_SZ;			
			
			ulOutBw = (600*ulMaxVdoPktLen)/1;				
		}
		else if(rf_get_bandwidth_config() == BW_HALF_BANDWIDTH)
		{
			if(KNL_GetEvenSlot() == 1200)
				ulMaxVdoPktLen = RW_S2M_SZ_BPSK_NT_1200-PKT_HEADER_SZ;	
			else if(KNL_GetEvenSlot() == 1667)
				ulMaxVdoPktLen = RW_S2M_SZ_BPSK_NT_1667-PKT_HEADER_SZ;
			
			ulOutBw = (600*ulMaxVdoPktLen)/2;
		}
		else
		{
			if(KNL_GetEvenSlot() == 1200)
				ulMaxVdoPktLen = RW_S2M_SZ_BPSK_NT_1200-PKT_HEADER_SZ;	
			else if(KNL_GetEvenSlot() == 1667)
				ulMaxVdoPktLen = RW_S2M_SZ_BPSK_NT_1667-PKT_HEADER_SZ;
			
			ulOutBw = (600*ulMaxVdoPktLen)/4;			
		}
	}
#if (RF_MODE_SW_SEL == RF_MODE_SW_OLD)
	else if(KNL_CurRwBbRateMode == PREF_BBR_QPSK)
#elif (RF_MODE_SW_SEL == RF_MODE_SW_NEW)
	else if(tKNL_RfModulationMode == MODE_QPSK)
#endif
	{				
		if(rf_get_bandwidth_config() == BW_FULL_BANDWIDTH)
		{			
			if(KNL_GetEvenSlot() == 1200)
				ulMaxVdoPktLen = RW_S2M_SZ_QPSK_1T_1200-PKT_HEADER_SZ;	
			else if(KNL_GetEvenSlot() == 1667)
				ulMaxVdoPktLen = RW_S2M_SZ_QPSK_1T_1667-PKT_HEADER_SZ;	
			
			ulOutBw = (600*ulMaxVdoPktLen)/1;				
		}
		else if(rf_get_bandwidth_config() == BW_HALF_BANDWIDTH)
		{
			if(KNL_GetEvenSlot() == 1200)
				ulMaxVdoPktLen = RW_S2M_SZ_QPSK_NT_1200-PKT_HEADER_SZ;	
			else if(KNL_GetEvenSlot() == 1667)
				ulMaxVdoPktLen = RW_S2M_SZ_QPSK_NT_1667-PKT_HEADER_SZ;
						
			ulOutBw = (600*ulMaxVdoPktLen)/2;
		}
		else
		{
			if(KNL_GetEvenSlot() == 1200)
				ulMaxVdoPktLen = RW_S2M_SZ_QPSK_NT_1200-PKT_HEADER_SZ;
			else if(KNL_GetEvenSlot() == 1667)
				ulMaxVdoPktLen = RW_S2M_SZ_QPSK_NT_1667-PKT_HEADER_SZ;			
			
			ulOutBw = (600*ulMaxVdoPktLen)/4;				
		}		
	}
#if (RF_MODE_SW_SEL == RF_MODE_SW_OLD)
	else if(KNL_CurRwBbRateMode == PREF_BBR_16QAM)
#elif (RF_MODE_SW_SEL == RF_MODE_SW_NEW)
	else if(tKNL_RfModulationMode == MODE_16QAM)
#endif
	{
		if(rf_get_bandwidth_config() == BW_FULL_BANDWIDTH)
		{			
			if(KNL_GetEvenSlot() == 1200)
				ulMaxVdoPktLen = RW_S2M_SZ_16QAM_1T_1200-PKT_HEADER_SZ;	
			else if(KNL_GetEvenSlot() == 1667)
				ulMaxVdoPktLen = RW_S2M_SZ_16QAM_1T_1667-PKT_HEADER_SZ;	
			
			ulOutBw = (600*ulMaxVdoPktLen)/1;				
		}
		else if(rf_get_bandwidth_config() == BW_HALF_BANDWIDTH)
		{
			if(KNL_GetEvenSlot() == 1200)
				ulMaxVdoPktLen = RW_S2M_SZ_16QAM_NT_1200-PKT_HEADER_SZ;	
			else if(KNL_GetEvenSlot() == 1667)
				ulMaxVdoPktLen = RW_S2M_SZ_16QAM_NT_1667-PKT_HEADER_SZ;			
			
			ulOutBw = (600*ulMaxVdoPktLen)/2;
		}
		else
		{
			if(KNL_GetEvenSlot() == 1200)
				ulMaxVdoPktLen = RW_S2M_SZ_16QAM_NT_1200-PKT_HEADER_SZ;				
			else if(KNL_GetEvenSlot() == 1667)
				ulMaxVdoPktLen = RW_S2M_SZ_16QAM_NT_1667-PKT_HEADER_SZ;	
			
			ulOutBw = (600*ulMaxVdoPktLen)/4;				
		}
	}
	
	return ulOutBw;			
}
#endif


//#ifdef RTC676x
//uint32_t ulRTC676x_GetRtBw(uint8_t ubMaxStaNum,uint8_t ubRole)
//{
//#if OP_STA
//	uint8_t ubAckOkCnt = 0;
//	uint8_t i;
//	uint32_t ulOutBw = 0;	//Unit -> Byte
//	
//	uint32_t ulMaxVdoPktLen;
//#endif

//#if OP_AP	
//	if(ubKNL_GetRtCommLinkStatus(ubRole))
//	{
//		return (20*1024);
//	}
//	else
//	{
//		return 0;
//	}
//#endif
//	
//#if OP_STA
//	return ulKNL_TestBw;
//	//return 70*1024;
//	if(ubKNL_GetRtCommLinkStatus(0))
//	{
//		for(i=0;i<KNL_ACK_STATIC_NUM;i++)
//		{
//			if(ubPkt_AckStatus[i])
//				ubAckOkCnt++;
//		}		
//		
//		//ulOutBw = ((600*PKT_VDO_PAYLOAD_SZ*((uint32_t)ubAckOkCnt))/KNL_ACK_STATIC_NUM)/ubMaxStaNum;
//		if(KNL_CurRwBbRateMode == PREF_BBR_BPSK)
//		{				
//			if(rf_get_bandwidth_config() == BW_FULL_BANDWIDTH)
//			{			
//				ulMaxVdoPktLen = RW_S2M_SZ_BPSK_1T-PKT_HEADER_SZ;	
//				ulOutBw = ((600*ulMaxVdoPktLen*((uint32_t)ubAckOkCnt))/KNL_ACK_STATIC_NUM)/1;				
//			}
//			else if(rf_get_bandwidth_config() == BW_HALF_BANDWIDTH)
//			{
//				ulMaxVdoPktLen = RW_S2M_SZ_BPSK_1T-PKT_HEADER_SZ;	
//				ulOutBw = ((600*ulMaxVdoPktLen*((uint32_t)ubAckOkCnt))/KNL_ACK_STATIC_NUM)/2;
//			}
//			else
//			{
//				ulMaxVdoPktLen = RW_S2M_SZ_BPSK_1T-PKT_HEADER_SZ;	
//				ulOutBw = ((600*ulMaxVdoPktLen*((uint32_t)ubAckOkCnt))/KNL_ACK_STATIC_NUM)/4;				
//			}
//		}
//		else if(KNL_CurRwBbRateMode == PREF_BBR_QPSK)
//		{				
//			if(rf_get_bandwidth_config() == BW_FULL_BANDWIDTH)
//			{			
//				ulMaxVdoPktLen = RW_S2M_SZ_QPSK_1T-PKT_HEADER_SZ;	
//				ulOutBw = ((600*ulMaxVdoPktLen*((uint32_t)ubAckOkCnt))/KNL_ACK_STATIC_NUM)/1;				
//			}
//			else if(rf_get_bandwidth_config() == BW_HALF_BANDWIDTH)
//			{
//				ulMaxVdoPktLen = RW_S2M_SZ_QPSK_1T-PKT_HEADER_SZ;	
//				ulOutBw = ((600*ulMaxVdoPktLen*((uint32_t)ubAckOkCnt))/KNL_ACK_STATIC_NUM)/2;
//			}
//			else
//			{
//				ulMaxVdoPktLen = RW_S2M_SZ_QPSK_1T-PKT_HEADER_SZ;	
//				ulOutBw = ((600*ulMaxVdoPktLen*((uint32_t)ubAckOkCnt))/KNL_ACK_STATIC_NUM)/4;				
//			}		
//		}
//		else if(KNL_CurRwBbRateMode == PREF_BBR_16QAM)
//		{
//			if(rf_get_bandwidth_config() == BW_FULL_BANDWIDTH)
//			{			
//				ulMaxVdoPktLen = RW_S2M_SZ_16QAM_1T-PKT_HEADER_SZ;	
//				ulOutBw = ((600*ulMaxVdoPktLen*((uint32_t)ubAckOkCnt))/KNL_ACK_STATIC_NUM)/1;				
//			}
//			else if(rf_get_bandwidth_config() == BW_HALF_BANDWIDTH)
//			{
//				ulMaxVdoPktLen = RW_S2M_SZ_16QAM_NT-PKT_HEADER_SZ;	
//				ulOutBw = ((600*ulMaxVdoPktLen*((uint32_t)ubAckOkCnt))/KNL_ACK_STATIC_NUM)/2;
//			}
//			else
//			{
//				ulMaxVdoPktLen = RW_S2M_SZ_16QAM_NT-PKT_HEADER_SZ;	
//				ulOutBw = ((600*ulMaxVdoPktLen*((uint32_t)ubAckOkCnt))/KNL_ACK_STATIC_NUM)/4;				
//			}
//		}
//		
//		return ulOutBw;		
//	}
//	else
//	{
//		return 0;
//	}
//#endif	
//}
//#endif


#ifdef RTC676x
uint32_t ulRTC676x_GetRtBw(uint8_t ubRole)
{
#if OP_STA
	uint8_t ubAckOkCnt = 0;
	uint8_t i;
	uint32_t ulOutBw = 0;	//Unit -> Byte
	
	uint32_t ulMaxVdoPktLen;
#endif

#if OP_AP	
	if(ubKNL_GetRtCommLinkStatus(ubRole))
	{
		return (20*1024);
	}
	else
	{
		return 0;
	}
#endif
	
#if OP_STA	
	if(ubKNL_GetRtCommLinkStatus(0))
	{
		for(i=0;i<KNL_ACK_STATIC_NUM;i++)
		{
			if(ubPkt_AckStatus[i])
				ubAckOkCnt++;
		}				
	#if (RF_MODE_SW_SEL == RF_MODE_SW_OLD)	
		if(KNL_CurRwBbRateMode == PREF_BBR_BPSK)
	#elif (RF_MODE_SW_SEL == RF_MODE_SW_NEW)
		if(0)
	#endif
		{				
			if(rf_get_bandwidth_config() == BW_FULL_BANDWIDTH)
			{			
				if(KNL_GetEvenSlot() == 1200)
					ulMaxVdoPktLen = RW_S2M_SZ_BPSK_1T_1200-PKT_HEADER_SZ;
				else if(KNL_GetEvenSlot() == 1667)
					ulMaxVdoPktLen = RW_S2M_SZ_BPSK_1T_1667-PKT_HEADER_SZ;					
				
				ulOutBw = ((600*ulMaxVdoPktLen*((uint32_t)ubAckOkCnt))/KNL_ACK_STATIC_NUM)/1;				
			}
			else if(rf_get_bandwidth_config() == BW_HALF_BANDWIDTH)
			{
				if(KNL_GetEvenSlot() == 1200)
					ulMaxVdoPktLen = RW_S2M_SZ_BPSK_NT_1200-PKT_HEADER_SZ;
				else if(KNL_GetEvenSlot() == 1667)
					ulMaxVdoPktLen = RW_S2M_SZ_BPSK_NT_1667-PKT_HEADER_SZ;				
				
				ulOutBw = ((600*ulMaxVdoPktLen*((uint32_t)ubAckOkCnt))/KNL_ACK_STATIC_NUM)/2;
			}
			else
			{
				if(KNL_GetEvenSlot() == 1200)
					ulMaxVdoPktLen = RW_S2M_SZ_BPSK_NT_1200-PKT_HEADER_SZ;
				else if(KNL_GetEvenSlot() == 1667)
					ulMaxVdoPktLen = RW_S2M_SZ_BPSK_NT_1667-PKT_HEADER_SZ;
				
				ulOutBw = ((600*ulMaxVdoPktLen*((uint32_t)ubAckOkCnt))/KNL_ACK_STATIC_NUM)/4;				
			}
		}
	#if (RF_MODE_SW_SEL == RF_MODE_SW_OLD)
		else if(KNL_CurRwBbRateMode == PREF_BBR_QPSK)
	#elif (RF_MODE_SW_SEL == RF_MODE_SW_NEW)
		else if(tKNL_RfModulationMode == MODE_QPSK)
	#endif
		{				
			if(rf_get_bandwidth_config() == BW_FULL_BANDWIDTH)
			{			
				if(KNL_GetEvenSlot() == 1200)
					ulMaxVdoPktLen = RW_S2M_SZ_QPSK_1T_1200-PKT_HEADER_SZ;	
				else if(KNL_GetEvenSlot() == 1667)
					ulMaxVdoPktLen = RW_S2M_SZ_QPSK_1T_1667-PKT_HEADER_SZ;
				
				ulOutBw = ((600*ulMaxVdoPktLen*((uint32_t)ubAckOkCnt))/KNL_ACK_STATIC_NUM)/1;				
			}
			else if(rf_get_bandwidth_config() == BW_HALF_BANDWIDTH)
			{
				if(KNL_GetEvenSlot() == 1200)
					ulMaxVdoPktLen = RW_S2M_SZ_QPSK_NT_1200-PKT_HEADER_SZ;
				else if(KNL_GetEvenSlot() == 1667)
					ulMaxVdoPktLen = RW_S2M_SZ_QPSK_NT_1667-PKT_HEADER_SZ;
				
				ulOutBw = ((600*ulMaxVdoPktLen*((uint32_t)ubAckOkCnt))/KNL_ACK_STATIC_NUM)/2;
			}
			else
			{
				if(KNL_GetEvenSlot() == 1200)
					ulMaxVdoPktLen = RW_S2M_SZ_QPSK_NT_1200-PKT_HEADER_SZ;	
				else if(KNL_GetEvenSlot() == 1667)
					ulMaxVdoPktLen = RW_S2M_SZ_QPSK_NT_1667-PKT_HEADER_SZ;
				
				ulOutBw = ((600*ulMaxVdoPktLen*((uint32_t)ubAckOkCnt))/KNL_ACK_STATIC_NUM)/4;				
			}		
		}
	#if (RF_MODE_SW_SEL == RF_MODE_SW_OLD)
		else if(KNL_CurRwBbRateMode == PREF_BBR_16QAM)
	#elif (RF_MODE_SW_SEL == RF_MODE_SW_NEW)
		else if(tKNL_RfModulationMode == MODE_16QAM)
	#endif		
		{
			if(rf_get_bandwidth_config() == BW_FULL_BANDWIDTH)
			{			
				if(KNL_GetEvenSlot() == 1200)
					ulMaxVdoPktLen = RW_S2M_SZ_16QAM_1T_1200-PKT_HEADER_SZ;	
				else if(KNL_GetEvenSlot() == 1667)
					ulMaxVdoPktLen = RW_S2M_SZ_16QAM_1T_1667-PKT_HEADER_SZ;	
				
				ulOutBw = ((600*ulMaxVdoPktLen*((uint32_t)ubAckOkCnt))/KNL_ACK_STATIC_NUM)/1;				
			}
			else if(rf_get_bandwidth_config() == BW_HALF_BANDWIDTH)
			{
				if(KNL_GetEvenSlot() == 1200)
					ulMaxVdoPktLen = RW_S2M_SZ_16QAM_NT_1200-PKT_HEADER_SZ;	
				else if(KNL_GetEvenSlot() == 1667)
					ulMaxVdoPktLen = RW_S2M_SZ_16QAM_NT_1667-PKT_HEADER_SZ;								
				
				ulOutBw = ((600*ulMaxVdoPktLen*((uint32_t)ubAckOkCnt))/KNL_ACK_STATIC_NUM)/2;
			}
			else
			{
				if(KNL_GetEvenSlot() == 1200)
					ulMaxVdoPktLen = RW_S2M_SZ_16QAM_NT_1200-PKT_HEADER_SZ;	
				else if(KNL_GetEvenSlot() == 1667)
					ulMaxVdoPktLen = RW_S2M_SZ_16QAM_NT_1667-PKT_HEADER_SZ;
				
				ulOutBw = ((600*ulMaxVdoPktLen*((uint32_t)ubAckOkCnt))/KNL_ACK_STATIC_NUM)/4;				
			}
		}
		
		return ulOutBw;		
	}
	else
	{
		return 0;
	}
#endif	
}
#endif


uint8_t ubKNL_GetQp(uint8_t ubCodecIdx)
{
	return ubKNL_Qp[ubCodecIdx];
}

uint8_t ubKNL_SrcNumMap(uint8_t ubSrcNum)
{
#if (defined(OP_AP) && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
    if(tKNL_RecordAct.tSimFolder == KNL_SIM_FLD && tKNL_GetRecordFunc() == KNL_VIDEO_PLAY && ubKNL_PlayRtCfged == 1)
        return ubKNL_PlayRtSTA;
#endif
#if (defined(OP_STA) && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
    if(tKNL_GetRecordFunc() == KNL_VIDEO_PLAY)
        return ubKNL_GetRole();
#endif    
	if((ubSrcNum == KNL_SRC_1_MAIN)||(ubSrcNum == KNL_SRC_1_SUB)||(ubSrcNum == KNL_SRC_1_AUX)||(ubSrcNum == KNL_SRC_1_OTHER_A)||(ubSrcNum == KNL_SRC_1_OTHER_B))
	{
		return KNL_STA1;
	}
	else if((ubSrcNum == KNL_SRC_2_MAIN)||(ubSrcNum == KNL_SRC_2_SUB)||(ubSrcNum == KNL_SRC_2_AUX)||(ubSrcNum == KNL_SRC_2_OTHER_A)||(ubSrcNum == KNL_SRC_2_OTHER_B))
	{
		return KNL_STA2;
	}
	else if((ubSrcNum == KNL_SRC_3_MAIN)||(ubSrcNum == KNL_SRC_3_SUB)||(ubSrcNum == KNL_SRC_3_AUX)||(ubSrcNum == KNL_SRC_3_OTHER_A)||(ubSrcNum == KNL_SRC_3_OTHER_B))
	{
		return KNL_STA3;
	}
	else if((ubSrcNum == KNL_SRC_4_MAIN)||(ubSrcNum == KNL_SRC_4_SUB)||(ubSrcNum == KNL_SRC_4_AUX)||(ubSrcNum == KNL_SRC_4_OTHER_A)||(ubSrcNum == KNL_SRC_4_OTHER_B))
	{
		return KNL_STA4;
	}
	else if(ubSrcNum == KNL_SRC_MASTER_AP)
	{
		return KNL_MASTER_AP;
	}
#if defined(BSP_DVR_SDK)
    else if(ubSrcNum == KNL_SRC_PREVIEW_LOCAL || ubSrcNum == KNL_SRC_STORAGE_LOCAL)
    {
        return KNL_STA2;
    }
#endif
	printd(DBG_ErrorLvl, "Err @ubKNL_SrcNumMap\r\n");
	return 0xFF;
}

#if defined(BSP_DVR_SDK)
KNL_POSITION ubKNL_GetSrcNumPosition(KNL_SRC ubSrcNum)
{
    uint8_t ubSrcNumMap ;
    ubSrcNumMap = ubKNL_SrcNumMap(ubSrcNum);
    if(ubSrcNumMap <= KNL_STA4 && ubSrcNum <= KNL_SRC_4_OTHER_B)
        return KNL_REMOTE;
    else if(ubSrcNumMap <= KNL_STA4 && ubSrcNum <= KNL_SRC_STORAGE_LOCAL)
        return KNL_LOCAL;    
	else						//justin 2019.09.03
		return KNL_POSI_NONE;
}
#endif
uint8_t ubKNL_GetMaxStaNum(void)
{
	switch(ubKNL_GetOpMode())
	{
		case KNL_OPMODE_VBM_1T:
		case KNL_OPMODE_BUC_1T:
			return 1;
		case KNL_OPMODE_VBM_2T:
		case KNL_OPMODE_BUC_2T_1T1B:
		case KNL_OPMODE_BUC_2T_1L1R:
			return 2;
		case KNL_OPMODE_VBM_4T:
		case KNL_OPMODE_BUC_4T:
			return 4;
		default:
			return 0;
	}
}

void KNL_SetPlyMode(KNL_PLY_MODE tPlyMode)
{
	uint32_t i;
	
	for(i=0; i<4; i++)
	{
		if(NULL == KNL_AvgPlyQ[i].Id)
		{
			KNL_AvgPlyQ[i].Def.queue_sz = KNL_AVG_PLY_QUEUE_NUM;
			KNL_AvgPlyQ[i].Def.item_sz  = sizeof(KNL_AVG_PLY_PROCESS);
			KNL_AvgPlyQ[i].Id = osMessageCreate(&KNL_AvgPlyQ[i].Def, NULL);
		}
	}
	if(tPlyMode == KNL_AVG_PLY)
	{
		osThreadDef(KNLAvgPlyThread, 
					KNL_AvgPlyThread, 
					THREAD_PRIO_KNL_AVG_PLY, 
					4, 
					THREAD_STACK_KNL_AVG_PLY);
		for(i=0; i<4; i++)
		{
			ubKNL_AvgPlyStartFlg[i] = 0;
			if(NULL == KNL_AvgThrd[i].Id)
			{
				KNL_AvgThrd[i].Id = osThreadCreate(osThread(KNLAvgPlyThread), (void*)i);
				if( KNL_AvgThrd[i].Id==NULL )
				{
					printd(DBG_ErrorLvl, "Create KNL Avg Ply Thread[%d] fail\n",i);
				}
			}
		}
	}
	tKNL_Info.tPlyMode = tPlyMode;
}

KNL_PLY_MODE tKNL_GetPlyMode(void)
{
	return tKNL_Info.tPlyMode;
}

void KNL_SetStartPlyNum(uint8_t ubFrameNum)
{
	ubKNL_AvgPlyStartNum = ubFrameNum;
}

uint8_t ubKNL_GetStartPlyNum(void)
{
	return ubKNL_AvgPlyStartNum;
}

void KNL_SetVdoFps(uint8_t ubFps)
{
	tKNL_Info.ubVdoFps = ubFps;
}

uint8_t ubKNL_GetVdoFps(void)
{
	return tKNL_Info.ubVdoFps;
}

void KNL_SetOnlineStaNum(uint8_t ubNum)
{
	tKNL_Info.ubOnlineStaNum = ubNum;
}

uint8_t ubKNL_GetOnlineStaNum(void)
{
	return tKNL_Info.ubOnlineStaNum;
}

uint32_t ulKNL_RfBigBufSize,ulKNL_RfSmallBufSize;

void KNL_SetRfBigBufSize(uint32_t ulBufSize)
{
	ulKNL_RfBigBufSize = ulBufSize;
}

void KNL_SetRfSmallBufSize(uint32_t ulBufSize)
{
	ulKNL_RfSmallBufSize = ulBufSize;
}

uint32_t ulKNL_GetRfBigBufSize(void)
{
	return ulKNL_RfBigBufSize;
}

uint32_t ulKNL_GetRfSmallBufSize(void)
{
	return ulKNL_RfSmallBufSize;
}
	
uint32_t ulKNL_GetBbIpBufSz(void)
{
	uint32_t ulBufSz = 0;
#ifdef A7130
	uint32_t ulBufStartAddr, ulBufEndAddr;	
#if defined(OP_AP)	

#if (APP_DUAL_HOST_ENABLE == 1)
	BB_SetSlotMode(BB_SLOT_1);		
	BB_SetAccessReadVdoBufNum(1,3);		//I frame number, P frame number	
#endif
#endif
	
	if((VDO_MAIN_H_SIZE(KNL_DISP_SINGLE) <= HD_WIDTH) && (VDO_MAIN_V_SIZE(KNL_DISP_SINGLE) <= HD_HEIGHT))
	{		
	#if defined(BSP_DVR_SDK)
		KNL_SetRfBigBufSize(BIG_BUF_UNDER_HD_DVR);
		KNL_SetRfSmallBufSize(SMALL_BUF_UNDER_HD_DVR);			
	#else
		KNL_SetRfBigBufSize(BIG_BUF_UNDER_HD_GENERAL);
		KNL_SetRfSmallBufSize(SMALL_BUF_UNDER_HD_GENERAL);				
	#endif
		BB_SetVideoAudioBufSize(ulKNL_GetRfBigBufSize(),ulKNL_GetRfSmallBufSize(),((8)*1024));
	}
	else 
	{
	#if (defined(BSP_VBM_SDK) && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
		KNL_SetRfBigBufSize(BIG_BUF_OVER_HD_VBM_REMOTE_PLY);
		KNL_SetRfSmallBufSize(SMALL_BUF_OVER_HD_VBM_REMOTE_PLY);			
	#else
		KNL_SetRfBigBufSize(BIG_BUF_OVER_HD_GENERAL);
		KNL_SetRfSmallBufSize(SMALL_BUF_OVER_HD_VBM_GENERAL);		
	#endif
		BB_SetVideoAudioBufSize(ulKNL_GetRfBigBufSize(),ulKNL_GetRfSmallBufSize(),((8)*1024));
	}	
	
	BB_VariableInit(ulBUF_GetFreeAddr());
	ulBufStartAddr = ulBB_GetBasebandUseAddr(BB_USE_START);
	ulBufEndAddr   = ulBB_GetBasebandUseAddr(BB_USE_END);
	ulBufSz 	   = ulBufEndAddr - ulBufStartAddr + 1;
#endif
	return ulBufSz;
}

void KNL_WirelessDevBufInit(void)
{
#ifdef A7130
	uint32_t ulBufSz = 0;

	ulBufSz = ulKNL_GetBbIpBufSz();
	BUF_BufInit(BUF_BB_IP, 1, ulBufSz, 0);	//IP Buffer	
#endif
#ifdef RTC676x
	static uint8_t ubRfBufInitFlag = FALSE;

    if((16 == (ulDDR_GetCapacity() >> 20)) && (USBD_UVC_MODE == tUSBD_GetClassMode()))
    {       
		BUF_BufInit(BUF_VDO_PACKETIZE_BIG,1,MAX_VDO_BIG_FRAM_SZ,0);
		BUF_BufInit(BUF_VDO_PACKETIZE_SMALL,2,MAX_VDO_BIG_FRAM_SZ,0);	//Same size for Big/Small Buffer
		
        BUF_BufInit(BUF_PACKET0,8,1536,0);
    }else{
	// Richwave RF Driver
	BUF_BufInit(BUF_RF_DRIVER, 1, RF_MEMORY_POOL_SIZE, 0);		//Used for Richwave Internal
	
	// Richwave frame buffer	
	BUF_BufInit(BUF_RW_FRAME, 1, BUF_SZ_MAX_VDO+BUF_SZ_MAX_ADO+(BUF_SZ_PKT*5),0);	//1 Video Frame + 1 Audio Frame + 1 PKT Buf + 4 PKT Buf
	
	//For Transmit
	if(ubKNL_GetAdjBufEnable())
	{
		KNL_SetRfBigBufSize(MAX_VDO_BIG_FRAM_SZ);
		KNL_SetRfSmallBufSize(MAX_VDO_SMALL_FRAM_SZ);			
		
		BUF_BufInit(BUF_VDO_PACKETIZE_BIG,BUF_NUM_VDO_PACKETIZE_BIG,ulKNL_GetRfBigBufSize(),0);
		BUF_BufInit(BUF_VDO_PACKETIZE_SMALL,BUF_NUM_VDO_PACKETIZE_ADJ-BUF_NUM_VDO_PACKETIZE_BIG,ulKNL_GetRfSmallBufSize(),0);
	}
	else
	{		
		KNL_SetRfBigBufSize(MAX_VDO_BIG_FRAM_SZ);
		KNL_SetRfSmallBufSize(MAX_VDO_SMALL_FRAM_SZ);				
		
		BUF_BufInit(BUF_VDO_PACKETIZE_BIG,BUF_NUM_VDO_PACKETIZE_BIG,ulKNL_GetRfBigBufSize(),0);
		BUF_BufInit(BUF_VDO_PACKETIZE_SMALL,BUF_NUM_VDO_PACKETIZE-BUF_NUM_VDO_PACKETIZE_BIG,ulKNL_GetRfSmallBufSize(),0);
	}
	
	BUF_BufInit(BUF_ADO_PACKETIZE,BUF_NUM_ADO_PACKETIZE,(16)*1024,0);
	
	//For Receive (Video)
#if defined(OP_AP)
	BUF_BufInit(BUF_VDO_PACKETIZE0,BUF_NUM_VDO_PACKETIZE_RCV,MAX_VDO_BIG_FRAM_SZ,0);	
	BUF_BufInit(BUF_VDO_PACKETIZE1,BUF_NUM_VDO_PACKETIZE_RCV,MAX_VDO_BIG_FRAM_SZ,0);
	BUF_BufInit(BUF_VDO_PACKETIZE2,BUF_NUM_VDO_PACKETIZE_RCV,MAX_VDO_BIG_FRAM_SZ,0);
	BUF_BufInit(BUF_VDO_PACKETIZE3,BUF_NUM_VDO_PACKETIZE_RCV,MAX_VDO_BIG_FRAM_SZ,0);
#endif
	
	//For Receive (Audio)
	BUF_BufInit(BUF_ADO_PACKETIZE0,BUF_NUM_ADO_PACKETIZE_RCV,(16)*1024,0);
#if defined(OP_AP)
	BUF_BufInit(BUF_ADO_PACKETIZE1,BUF_NUM_ADO_PACKETIZE_RCV,(16)*1024,0);
	BUF_BufInit(BUF_ADO_PACKETIZE2,BUF_NUM_ADO_PACKETIZE_RCV,(16)*1024,0);
	BUF_BufInit(BUF_ADO_PACKETIZE3,BUF_NUM_ADO_PACKETIZE_RCV,(16)*1024,0);
#endif
	
	//For Receive (Common)
	BUF_BufInit(BUF_PACKET0,BUF_NUM_PACKET,1536,0);
#if defined(OP_AP)
	BUF_BufInit(BUF_PACKET1,BUF_NUM_PACKET,1536,0);
	BUF_BufInit(BUF_PACKET2,BUF_NUM_PACKET,1536,0);
	BUF_BufInit(BUF_PACKET3,BUF_NUM_PACKET,1536,0);
#endif
    }

	if(FALSE == ubRfBufInitFlag)
	{		
		BUF_Reset(BUF_VDO_PACKETIZE_BIG);
		BUF_Reset(BUF_VDO_PACKETIZE_SMALL);
		
		BUF_Reset(BUF_ADO_PACKETIZE);
		
		BUF_Reset(BUF_VDO_PACKETIZE0);
		BUF_Reset(BUF_VDO_PACKETIZE1);
		BUF_Reset(BUF_VDO_PACKETIZE2);
		BUF_Reset(BUF_VDO_PACKETIZE3);
		
		BUF_Reset(BUF_ADO_PACKETIZE0);
		BUF_Reset(BUF_ADO_PACKETIZE1);
		BUF_Reset(BUF_ADO_PACKETIZE2);
		BUF_Reset(BUF_ADO_PACKETIZE3);
		
		BUF_Reset(BUF_PACKET0);
		BUF_Reset(BUF_PACKET1);
		BUF_Reset(BUF_PACKET2);
		BUF_Reset(BUF_PACKET3);
		ubRfBufInitFlag = TRUE;
	}
#endif
#if (defined(S2019A) || (defined(OP_AP) && defined(sWIFIBDG)))
	uint32_t ulSPRF_BufSize = 0;
	#if (defined(RVCS_APP) || (defined(OP_AP) && defined(sWIFIBDG)))
	uint32_t ulSPRF_DtBufSize = 0;
	#endif
	ulSPRF_BufSize = ulsPRF_BufSetup(ulBUF_GetFreeAddr());
	BUF_BufInit(BUF_sPRF, 1, ulSPRF_BufSize, 0);
	#if (defined(RVCS_APP) || (defined(OP_AP) && defined(sWIFIBDG)))
	ulSPRF_DtBufSize = ulWiFiDt_BufSetup(ulBUF_GetFreeAddr());
	BUF_BufInit(BUF_WIFI_DT, 1, ulSPRF_DtBufSize, 0);
	#endif
#endif
}

//------------------------------------------------------------------------------
void KNL_SetAdoInfo(ADO_KNL_PARA_t tAdoInfo)
{
	memcpy(&tKNL_AdoInfo, &tAdoInfo, sizeof(tAdoInfo));
}
//------------------------------------------------------------------------

void KNL_SetVdoGop(uint32_t ulGop)
{
	tKNL_Info.ulGop = ulGop;
}

//------------------------------------------------------------------------------
uint32_t ulKNL_GetVdoGop(void)
{
	return tKNL_Info.ulGop;
}

//------------------------------------------------------------------------------
uint32_t ulKNL_GetVdoFrmIdx(uint8_t ubCh)
{
	return ulKNL_CurFrmIdx[ubCh];
}

//------------------------------------------------------------------------------

void KNL_SetTXRSlotNum(uint8_t ubSlotNum)
{
	tKNL_Info.ubMaxSlotNum = ubSlotNum;
}

uint8_t ubKNL_GetTRXSlotNum(void)
{
	return tKNL_Info.ubMaxSlotNum;
}

//------------------------------------------------------------------------------
void KNL_SetVdoScaleParam(uint8_t ubSrcNum, KNL_NODE tNodeName, KNL_SCALE tScale)
{
	uint8_t ubNodeIdx;

	for(ubNodeIdx = 0; ubNodeIdx < KNL_MAX_NODE_NUM; ubNodeIdx++)
	{
		if(tNodeName == tKNL_VdoNodeInfo[ubSrcNum][ubNodeIdx].ubCurNode)
		{
			tKNL_VdoNodeInfo[ubSrcNum][ubNodeIdx].ubHScale = tScale;
			tKNL_VdoNodeInfo[ubSrcNum][ubNodeIdx].ubVScale = tScale;
			break;
		}
	}
}
//------------------------------------------------------------------------------
uint8_t ubKNL_GetVdoScaleParam(uint8_t ubSrcNum)
{
	KNL_NODE_INFO tNodeInfo;
	uint8_t ubKNL_ScaleParam = 0;

	if(ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)
	{
		tNodeInfo = tKNL_GetNodeInfo(ubSrcNum, KNL_NODE_H264_DEC);
		ubKNL_ScaleParam = ((KNL_SCALE_X0P5   == tNodeInfo.ubHScale) || (KNL_SCALE_X0P5  == tNodeInfo.ubVScale))?1:
							((KNL_SCALE_X0P25 == tNodeInfo.ubHScale) || (KNL_SCALE_X0P25 == tNodeInfo.ubVScale))?2:0;
	}
	return ubKNL_ScaleParam;
}

//------------------------------------------------------------------------------
void KNL_Init(void)
{
	KNL_ROLE tKNLRole;
	uint8_t ubCodecIdx = 0;

	ubKNL_PerDbgEn			= KNL_PERDBG_OFF;
	pKNL_PerDbgFunc[0]		= NULL;
	pKNL_PerDbgFunc[1]		= NULL;
	tKNL_CapHQImgSte      	= KNL_CAPHQ_DIS;
	ubKNL_SysStopFlag		= FALSE;
	ubKNL_BbPathAct			= FALSE;
	pLcdCropScaleParam 		= NULL;
	ptKNL_VdoRoleMap2SrcNum = NULL;
	ptKNL_AdoRoleMap2SrcNum = NULL;
	tKNL_Info.ubDisp1SrcNum = KNL_SRC_NONE;
	tKNL_Info.ubDisp2SrcNum = KNL_SRC_NONE;
	tKNL_Info.ubDisp3SrcNum = KNL_SRC_NONE;
	tKNL_Info.ubDisp4SrcNum = KNL_SRC_NONE;
	tKNL_delMergeHSrc		= KNL_SRC_NONE;
	tKNL_TuningMode 		= KNL_TUNINGMODE_OFF;
	ubKNL_ChgResFlg			= FALSE;
	ubKNL_ImgBusyFlg		= FALSE;
	ubKNL_WorSts			= 1;
	tKNL_WorMode			= BB_DISABLE_ALL_STA_WAKEUP;
	ubKNL_UsbdAdoEncAct		= 0;
	ubKNL_UsbdAdoEncStFlag	= TRUE;
	ubKNL_UsbdVdoViewType	= 1;
	KNL_SwDispInfo.ubSetupFlag = FALSE;	
	KNL_SwDispInfo.ubDispBufChgFlag = FALSE;
	ubKNL_StbLinkStsRrefFlag = FALSE;
	for(tKNLRole = KNL_STA1; tKNLRole <= KNL_STA4; tKNLRole++)
	{
		KNL_AvgThrd[tKNLRole].Id            = NULL;
		KNL_AvgPlyQ[tKNLRole].Id            = NULL;
		ubKNL_VdoBsBusyCnt[tKNLRole]		= 0;
		ubKNL_VdoResendITwcFlg[tKNLRole]	= FALSE;
		ubKNL_VdoChkSrcNumFlg[tKNLRole]	 	= FALSE;
		ubKNL_VdoResChgTwcFlg[tKNLRole]     = FALSE;
		ubKNL_AppResendIFrmFlg[tKNLRole]	= FALSE;
		ubKNL_FrmLossFlag[tKNLRole]			= FALSE;
		KNL_SwDispInfo.tSrcNum[tKNLRole] 	= KNL_SRC_NONE;
		KNL_SwDispInfo.tSrcLocate[tKNLRole] = KNL_DISP_LOCATION_ERR;
	}
	for(tKNLRole = KNL_STA1; tKNLRole <= KNL_MAX_ROLE; tKNLRole++)
		ubKNL_WakeUpFlag[tKNLRole] = FALSE;
	for(ubCodecIdx = 0; ubCodecIdx < 4; ubCodecIdx++)
		ulKNL_CurFrmIdx[ubCodecIdx] = 0;
	tKNL_DmyPatColor.ubY  = 0x10;
	tKNL_DmyPatColor.ubCb = 0x80;
	tKNL_DmyPatColor.ubCr = 0x80;

	KNL_NodeStateReset();
	KNL_VdoReset();
	KNL_SetAuxInfoFunc(1);		//Add Aux-Information for packet transmission
	KNL_SetStartPlyNum(5);		//Start play frame number for AVG-PLY

    KNL_SetVdoGop(KNL_TX_GOP);
	KNL_SetTXRSlotNum(DISPLAY_MODE);
	KNL_SetOnlineStaNum(ubKNL_GetTRXSlotNum());

#if defined(OP_STA)	
#if APP_UVC_CAM_ENABLE
	KNL_ExtraDataInit();
#endif
#endif

#ifdef RTC676x
	if(APP_MODULATION_MODE == MODULATION_FIXED_QPSK)
	{
		KNL_CurRwBbRateMode = PREF_BBR_QPSK;
		KNL_NewRwBbRateMode = PREF_BBR_QPSK;
	}
	else if(APP_MODULATION_MODE == MODULATION_FIXED_16QAM)
	{
		KNL_CurRwBbRateMode = PREF_BBR_16QAM;
		KNL_NewRwBbRateMode = PREF_BBR_16QAM;
	}
	else if(APP_MODULATION_MODE == MODULATION_AUTO)
	{
		KNL_CurRwBbRateMode = PREF_BBR_QPSK;
		KNL_NewRwBbRateMode = PREF_BBR_QPSK;
	}
#endif
    
	osMutexDef(tKNL_LinkSem);
	tKNL_LinkSem = osMutexCreate(osMutex(tKNL_LinkSem));

	osSemaphoreDef(tKNL_ImgSem);
	tKNL_ImgSem	= osSemaphoreCreate(osSemaphore(tKNL_ImgSem), 1);
	osSemaphoreDef(KnlH264CdcWaitSem);
	osKNL_H264CdcWaitSem = osSemaphoreCreate(osSemaphore(KnlH264CdcWaitSem), 1);

	osSemaphoreDef(tKNL_TwcSem);
	tKNL_TwcSem	= osSemaphoreCreate(osSemaphore(tKNL_TwcSem), 1);

	osSemaphoreDef(KnlBsBufCtrlSem);
	tKNL_BsBufCtrlSem = osSemaphoreCreate(osSemaphore(KnlBsBufCtrlSem), 1);
	
	osSemaphoreDef(tKNL_LinkActiveTimeSem);
	tKNL_LinkActiveTimeSem	= osSemaphoreCreate(osSemaphore(tKNL_LinkActiveTimeSem), 1);
	
	osSemaphoreDef(tKNL_ErrCntSem);
	tKNL_ErrCntSem	= osSemaphoreCreate(osSemaphore(tKNL_ErrCntSem), 1);	
	
	osSemaphoreDef(tKNL_GetFramSzSem);
	tKNL_GetFramSzSem	= osSemaphoreCreate(osSemaphore(tKNL_GetFramSzSem), 1);	
	
	osSemaphoreDef(tKNL_AuxAccSem);
	tKNL_AuxAccSem	= osSemaphoreCreate(osSemaphore(tKNL_AuxAccSem), 1);
	
	osSemaphoreDef(tKNL_UvcFlgAccSem);
	tKNL_UvcFlgAccSem	= osSemaphoreCreate(osSemaphore(tKNL_UvcFlgAccSem), 1);
	osSemaphoreDef(tKNL_CrcAccSem);
	tKNL_CrcAccSem	= osSemaphoreCreate(osSemaphore(tKNL_CrcAccSem), 1);

	//osSemaphoreDef(tKNL_AccSendApiSem);
	//tKNL_AccSendApiSem	= osSemaphoreCreate(osSemaphore(tKNL_AccSendApiSem), 1);
	osMessageQDef(KNL_VDOPROCESS, KNL_PROC_QUEUE_NUM, KNL_PROCESS);
	KNL_VdoCodecProcQueue = osMessageCreate(osMessageQ(KNL_VDOPROCESS), NULL);

	osMessageQDef(KNL_ADOPROCESS, KNL_PROC_QUEUE_NUM, KNL_PROCESS);
	KNL_AdoCodecProcQueue = osMessageCreate(osMessageQ(KNL_ADOPROCESS), NULL);

#if (defined(OP_AP) && defined(BSP_DVR_SDK))
	osMessageQDef(KNL_VDOINPROCESS, ubKNL_GetSensorBufNumber()*2, KNL_PROCESS);
#else
	osMessageQDef(KNL_VDOINPROCESS, ubKNL_GetSensorBufNumber()*2, KNL_PROCESS);
#endif
	KNL_VdoInProcQueue = osMessageCreate(osMessageQ(KNL_VDOINPROCESS), NULL);	

#if (APP_DUAL_HOST_ENABLE == 1)
	osMessageQDef(KNL_USBMONITPROCESS, 6, KNL_PROCESS);
	KNL_UsbMonitQueue = osMessageCreate(osMessageQ(KNL_USBMONITPROCESS), NULL);
	
	osMessageQDef(KNL_USBRESETPROCESS, 6, KNL_PROCESS);
	KNL_UsbResetQueue = osMessageCreate(osMessageQ(KNL_USBRESETPROCESS), NULL);
#endif
	
#if (defined(OP_STA) || defined(BSP_DVR_SDK))
	osMessageQDef(KNL_RESSWPROCESS, 2, KNL_PROCESS);
	KNL_ResSwProcQueue = osMessageCreate(osMessageQ(KNL_RESSWPROCESS), NULL);

#endif
	osMessageQDef(KNL_COMMTXPROCESS, KNL_PROC_QUEUE_NUM, KNL_PROCESS);
	KNL_CommTxProcQueue = osMessageCreate(osMessageQ(KNL_COMMTXPROCESS), NULL);

	osMessageQDef(KNL_AVG_TWC_MONIT, 32, KNL_PROCESS);
	KNL_TwcMonitQueue = osMessageCreate(osMessageQ(KNL_AVG_TWC_MONIT), NULL);

	osThreadDef(KNLVdoInProcThread, KNL_VdoInProcThread, THREAD_PRIO_KNL_VDOIN_PROC, 1, THREAD_STACK_KNL_VDOIN_PROC);
	osThreadCreate(osThread(KNLVdoInProcThread), NULL);
#if (defined(OP_STA) || defined(BSP_DVR_SDK))
	osThreadDef(KNLResSwProcThread, KNL_ResSwProcThread, THREAD_PRIO_KNL_RESSW_PROC, 1, THREAD_STACK_KNL_RESSW_PROC);
	osThreadCreate(osThread(KNLResSwProcThread), NULL);

#endif

	osThreadDef(KNLCommTxProcThread, KNL_CommTxProcThread, THREAD_PRIO_COMM_TX_VDO, 1, THREAD_STACK_COMM_TX_VDO);
	osThreadCreate(osThread(KNLCommTxProcThread), NULL);

	osThreadDef(KNLVdoCodecProcThread, KNL_VdoCodecProcThread, THREAD_PRIO_KNL_PROC, 1, THREAD_STACK_KNL_PROC);
	osThreadCreate(osThread(KNLVdoCodecProcThread), NULL);

	osThreadDef(KNLAdoCodecProcThread, KNL_AdoCodecProcThread, THREAD_PRIO_KNL_PROC, 1, THREAD_STACK_KNL_PROC);
	osThreadCreate(osThread(KNLAdoCodecProcThread), NULL);

	osThreadDef(KNLTwcMonitThread, KNL_TwcMonitThread, THREAD_PRIO_KNL_TWC_MONIT, 1, THREAD_STACK_KNL_TWC_MONIT);
	osThreadCreate(osThread(KNLTwcMonitThread), NULL);

	osThreadDef(SysMonitThread, KNL_SysMonitThread, THREAD_PRIO_SYS_MONIT, 1, THREAD_STACK_SYS_MONIT);
    osThreadCreate(osThread(SysMonitThread), NULL);

	osThreadDef(KNLSecMonitThread, KNL_SecMonitThread, THREAD_PRIO_SEC_MONIT, 1, THREAD_STACK_SEC_MONIT);
	osThreadCreate(osThread(KNLSecMonitThread), NULL);

#if (APP_DUAL_HOST_ENABLE == 1)
	osThreadDef(KNLUsbMonitThread, KNL_UsbMonitThread, THREAD_PRIO_USB_MONIT, 1, THREAD_STACK_USB_MONIT);
	osThreadCreate(osThread(KNLUsbMonitThread), NULL);
	
	osThreadDef(KNLUsbResetThread, KNL_UsbResetThread, THREAD_PRIO_USB_RESET, 1, THREAD_STACK_USB_RESET);
	osThreadCreate(osThread(KNLUsbResetThread), NULL);
#endif
	
	tKNL_JpgLcdChCtrl = JPG_LCDCH_DISABLE;
	osMutexDef(KNL_JpgLcdCtrlMutex);
	osKNL_JpgLcdChMutex = osMutexCreate(osMutex(KNL_JpgLcdCtrlMutex));

#if APP_TIMESTAMP_FUNC_ENABLE
    osThreadDef(KNLTimeStampThread, KNL_TimeStampThread, THREAD_PRIO_TIME_STAMP, 1, THREAD_STACK_TIME_STAMP);
	osThreadCreate(osThread(KNLTimeStampThread), NULL);
#endif

#if (APP_REC_FUNC_ENABLE && OP_STA)
    osThreadDef(KNLTxRecThread, KNL_TxRecThread, THREAD_PRIO_TX_REC, 1, THREAD_STACK_TX_REC);
    KNL_TxRecThreadId = osThreadCreate(osThread(KNLTxRecThread), NULL);
#endif
#if (defined(OP_STA) && !defined(S2019A))
    osThreadDef(KNLGOPSyncThread, KNL_GOPSyncThread, THREAD_PRIO_GOPSYNC, 1, THREAD_STACK_SYNCGOP);
    osThreadCreate(osThread(KNLGOPSyncThread), NULL);
#endif

	tKNL_RecordAct.tRecordFunc 	   = KNL_RECORDFUNC_DISABLE;
#if defined(BSP_DVR_SDK)
	tKNL_RecordAct.pRecordStsNtyCb = NULL;
#else
	tKNL_RecordAct.pRecordStsNtyCb = NULL;
#endif
	tKNL_RecordAct.tRecordSts	   = KNL_RECORDING_STOP;
    tKNL_RecordAct.tSimFolder     = KNL_REAL_FLD;
	for(tKNLRole = KNL_STA1; tKNLRole <= KNL_STA4; tKNLRole++)
		tKNL_RecordAct.ubPhotoCapSrc[tKNLRole] = KNL_SRC_NONE;
	osKNL_RecordMsgQue = NULL;
#if (APP_PHOTOGRAPH_FUNC_ENABLE || APP_REC_FUNC_ENABLE)
	osMutexDef(KNL_RecordFuncMutex);
	osKNL_RecordFuncMutex = osMutexCreate(osMutex(KNL_RecordFuncMutex));
	osMessageQDef(KNL_RecordMsgQue, 1, KNL_RecordAct_t);
    osKNL_RecordMsgQue = osMessageCreate(osMessageQ(KNL_RecordMsgQue), NULL);
	osThreadDef(KNL_RecordThd, KNL_RecordThread, THREAD_PRIO_KNLRECORD_HANDLER, 1, THREAD_STACK_KNLRECORD_HANDLER);
	osKNL_RecordThreadId = osThreadCreate(osThread(KNL_RecordThd), NULL);
#endif

#if APP_REC_FUNC_ENABLE
    osThreadDef(KNLRecSdMonitorThread, KNL_RecSdMonitorThread, THREAD_PRIO_KNL_SD_HANDLER, 1, THREAD_STACK_KNL_SD_HANDLER);
	KNL_RecSdMonitorThreadId = osThreadCreate(osThread(KNLRecSdMonitorThread), NULL);
    KNL_RECnPLYCBFuncRegistered();
#endif

#if (defined(OP_AP) && KNL_LCD_FUNC_ENABLE)
	osSemaphoreDef(KnlLcdDispInfoSem);
	osKNL_LcdDispInfoSem = osSemaphoreCreate(osSemaphore(KnlLcdDispInfoSem), 1);
#endif
	ubKNL_TargetFps = 0;
#if (defined(RTC676x) && defined(OP_AP) && TRXBW_RPT_EN)
	osMutexDef(KnlTrxBwSyncMutex);
	osKNL_TrxBwMutex = osMutexCreate(osMutex(KnlTrxBwSyncMutex));
	for(tKNLRole = KNL_STA1; tKNLRole <= KNL_STA4; tKNLRole++)
		ulKNL_TrxBwRpt[tKNLRole] = 0;
#endif
#if APP_TIMESTAMP_FUNC_ENABLE
    osThreadDef(KNLRtcMonitorThread, KNL_RtcMonitorThread, THREAD_PRIO_KNL_RTC_MONIT_HANDLER, 1, THREAD_STACK_RTC_MONIT);
	osThreadCreate(osThread(KNLRtcMonitorThread), NULL);
#endif
#ifdef S2019A
	#ifdef OP_STA
	for(ubCodecIdx = 0; ubCodecIdx < 4; ubCodecIdx++)
		memset(&tKNL_H264EncInfo[ubCodecIdx], 0, sizeof(KNL_EncInfo_t));  
	#endif
	ubKNL_EncIfrmFlag 	= FALSE;
	osSemaphoreDef(KnlEncISem);
	osKNL_EncIfrmSem = osSemaphoreCreate(osSemaphore(KnlEncISem), 1);
	#if sPRF_LTYMEAS_EN
	tKNL_VdoLatency.ubEn  = TRUE;
	tKNL_VdoLatency.ubDbg = FALSE;
	for(tKNLRole = KNL_STA1; tKNLRole <= KNL_STA4; tKNLRole++)
	{
		memset(&tKNL_VdoLatency.tLatency[tKNLRole], 0, sizeof(SPRF_LatyInfo_t));
		tKNL_VdoLatency.tLatency[tKNLRole].ubvsTmIdx  = 0;
		tKNL_VdoLatency.tLatency[tKNLRole].ubsTmIdx   = 0;
		tKNL_VdoLatency.tLatency[tKNLRole].ubUpdFlag  = FALSE;
		tKNL_VdoLatency.tLatency[tKNLRole].ubDispFlag = FALSE;
		tKNL_VdoLatency.tLatency[tKNLRole].ubRefhFlag = FALSE;
	}
	#ifdef OP_AP
	osMessageQDef(KnlLatyDataQue, 12, SPRF_LatyInfo_t);
	osKNL_LatyDataQue = osMessageCreate(osMessageQ(KnlLatyDataQue), NULL);
	osThreadDef(KnlCalcLatyThd, KNL_CalcLatencyThread, osPriorityAboveNormal, 1, 512);
	osThreadCreate(osThread(KnlCalcLatyThd), NULL);
	#endif	//! End of #ifdef OP_AP
	#endif	//! End of #if sPRF_LTYMEAS_EN
#endif	//! End of #ifdef S2019A
#if (defined(S2019A) || (defined(OP_AP) && defined(sWIFIBDG)))
	memset(&tKNL_VdoBsOvfInfo, 0, sizeof(KNL_VdoBsOvf_t));
	#if (defined(OP_AP) && (defined(RVCS_APP) || defined(sWIFIBDG)))
	osKNL_ApBgdThdId = NULL;
	osKNL_ApBdgQue   = NULL;
	tKNL_ApBdgInfo.tBgdSrcNum   = KNL_SRC_NONE;
	tKNL_ApBdgInfo.ubIfrmFlag   = FALSE;
	tKNL_ApBdgInfo.ubResChgFlag = FALSE;
	tKNL_ApBdgInfo.ubErrFlag    = FALSE;
	#endif
#endif	//! End of #if (defined(S2019A) || (defined(OP_AP) && defined(sWIFIBDG)))
	ubKNL_RstVdoGrpFlag = FALSE;
#ifdef OP_STA
	osMessageQDef(KnlHqImgUvcQue, 1, uint8_t);
	osKNL_HQImgUvcQue = osMessageCreate(osMessageQ(KnlHqImgUvcQue), NULL);
	osMessageQDef(KnlCapHqImgFinQue, 1, uint8_t);
	osKNL_CapHQImgQue = osMessageCreate(osMessageQ(KnlCapHqImgFinQue), NULL);
#endif
	tKNL_JpegSigProc.ubProcFlag = FALSE;
	tKNL_JpegSigProc.osWaitSem  = NULL;
}

//------------------------------------------------------------------------------
void KNL_Stop(void)
{
	if(TRUE == ubKNL_SysStopFlag)
		return;
#ifdef A7130
	BB_Stop();
#endif
	
#ifdef RTC676x
	RTC676x_Stop();
#endif
	
	ubKNL_SysStopFlag = TRUE;
}
//------------------------------------------------------------------------------
void KNL_ReStart(void)
{
	if(FALSE == ubKNL_SysStopFlag)
		return;
#ifdef A7130
	BB_Start(THREAD_STACK_BB_HANDLER, THREAD_PRIO_BB_HANDLER);
#endif
	ubKNL_SysStopFlag = FALSE;
}
//------------------------------------------------------------------------------
uint32_t ulKNL_GetDataBitRate(uint8_t ubDataType,uint8_t ubCodecIdx)
{
	if(ubDataType == 0)	//Video
	{
		return ulKNL_VdoOutAccCnt[ubCodecIdx];
	}
	else				//Audio
	{
		return ulKNL_AdoOutAccCnt;
	}
}
//------------------------------------------------------------------------------
uint32_t ulKNL_GetFps(KNL_FPS_TYPE tFpsType,uint8_t ubSrcNum)
{
	if(tFpsType == KNL_FPS_OUT)
	{
		return ulKNL_OutVdoFpsCnt[ubSrcNum];
	}
	else if (tFpsType == KNL_FPS_IN)
	{
		return ulKNL_InVdoFpsCnt[ubSrcNum];
	}
	else
	{
		uint8_t ubSrcNumMap = ubKNL_SrcNumMap(ubSrcNum);

		return ulKNL_FrmTRxNum[ubSrcNumMap];
	}
}

#ifndef S2019A
//Justin 2019.12.11
//=======================================================================================
uint8_t ubKNL_AccessErrCnt(KNL_OPERATION tOperation,uint8_t ubValue)
{
	uint8_t ubTemp;
	
	osSemaphoreWait(tKNL_ErrCntSem, osWaitForever);
	
	if(tOperation == KNL_OPERATION_SET)
	{
		ubKNL_ErrCnt = ubValue;	
		ubTemp = ubKNL_ErrCnt;
	}
	else if(tOperation == KNL_OPERATION_GET)
	{
		ubTemp = ubKNL_ErrCnt;		
	}	
	else if(tOperation == KNL_OPERATION_MINUS)
	{
		if(ubKNL_ErrCnt > 0)
		{
			ubKNL_ErrCnt--;
		}
		else
		{
			printf("Err @%s\r\n",__func__);
		}
		ubTemp = ubKNL_ErrCnt;
	}
	else if(tOperation == KNL_OPERATION_PLUS)
	{
		ubKNL_ErrCnt++;
		ubTemp = ubKNL_ErrCnt;
	}

	osSemaphoreRelease(tKNL_ErrCntSem);
	
	return ubTemp;
}
//=======================================================================================
uint8_t ubKNL_AccessLinkActiveTime(KNL_OPERATION tOperation,uint8_t ubValue)
{
	uint8_t ubTemp;
	
	osSemaphoreWait(tKNL_LinkActiveTimeSem, osWaitForever);
	
	if(tOperation == KNL_OPERATION_SET)
	{
		ubKNL_LinkActiveTime = ubValue;	
		ubTemp = ubKNL_LinkActiveTime;
	}
	else if(tOperation == KNL_OPERATION_GET)
	{
		ubTemp = ubKNL_LinkActiveTime;		
	}	
	else if(tOperation == KNL_OPERATION_MINUS)
	{
		if(ubKNL_LinkActiveTime > 0)
		{
			ubKNL_LinkActiveTime--;
		}
		else
		{
			printf("Err @%s\r\n",__func__);
		}
		ubTemp = ubKNL_LinkActiveTime;
	}

	osSemaphoreRelease(tKNL_LinkActiveTimeSem);
	
	return ubTemp;
}
#endif

#if (APP_DUAL_HOST_ENABLE == 1)
void KNL_UvcRdyEvent(uint8_t ubIndex)
{
	KNL_PROCESS tProc;
	
	printf("UvcRdyEvent:%d\r\n",ubIndex);

	tProc.ubEvent = 0;	//Normal Event(Ready Event)
	tProc.ulIdx = ubIndex;
	osMessagePut(KNL_UsbMonitQueue,&tProc,0);	
}

void KNL_UvcErrEvent(uint8_t ubIndex)
{
	KNL_PROCESS tProc;
	
	printf("UvcErrEvent:%d\r\n",ubIndex);

	tProc.ubEvent = 1;	//Special Event(Error Event)
	tProc.ulIdx = ubIndex;
	osMessagePut(KNL_UsbMonitQueue,&tProc,0);	
}

void KNL_CxTimeOutEvent(void)
{
	KNL_PROCESS tProc;	

	tProc.ubEvent = 1;				//Special Event(Error Event)
	tProc.ulIdx = USBH_UVC1_DEVICE_ID;
	osMessagePut(KNL_UsbMonitQueue,&tProc,0);	
	
	tProc.ubEvent = 1;				//Special Event(Error Event)
	tProc.ulIdx = USBH_UVC2_DEVICE_ID;
	osMessagePut(KNL_UsbMonitQueue,&tProc,0);
}
static void KNL_UsbResetThread(void const *argument)
{
	KNL_PROCESS tProc;
	
	while(1)
	{
		osMessageGet(KNL_UsbResetQueue, &tProc, osWaitForever);
		printf("Reset UVC(%d)\r\n",tProc.ulIdx);
		
		if(tProc.ulIdx == USBH_UVC1_DEVICE_ID)
		{
		#if defined(POWER_UVC1_IO)
			printf("UVC1 -> Power Off\r\n");
			POWER_UVC1_IO = 0;			
			osDelay(KNL_USB_OFF2ON_TIME);
			printf("UVC1 -> Power On\r\n");
			POWER_UVC1_IO = 1;			
		#endif
		}
		else if(tProc.ulIdx == USBH_UVC2_DEVICE_ID)
		{
		#if defined(POWER_UVC2_IO)
			printf("UVC2 -> Power Off\r\n");
			POWER_UVC2_IO = 0;			
			osDelay(KNL_USB_OFF2ON_TIME);
			printf("UVC2 -> Power On\r\n");
			POWER_UVC2_IO = 1;			
		#endif
		}
	}
}
static void KNL_UsbMonitThread(void const *argument)
{
//	uint8_t ubUsbDeviceId1 = 0;
//	uint8_t ubUsbDeviceId2 = 5;
	KNL_PROCESS tProc;		
	char *pargv[16];
	
	while(1)
	{
		osMessageGet(KNL_UsbMonitQueue, &tProc, osWaitForever);		
		osDelay(100);
		printf("USB_Idx(S)[%d] @ %d Event\r\n",tProc.ulIdx,tProc.ubEvent);

		if(tProc.ubEvent == 0)
		{
			//Stream Mapping
			if((ubKNL_UvcStreamMap[0] == 0xFF) && (ubKNL_UvcStreamMap[1] == 0xFF))
			{
				ubKNL_UvcStreamMap[0] = tProc.ulIdx;
			}
			else if(ubKNL_UvcStreamMap[0] != 0xFF)
			{
				ubKNL_UvcStreamMap[1] = tProc.ulIdx;
			}	
			
			pargv[0] = "uvc_start";
			if(tProc.ulIdx == 0)
				pargv[1] = "0";
			else if(tProc.ulIdx == 5)
				pargv[1] = "5";
			
			pargv[2] = "h264";
			pargv[3] = "1280";
			pargv[4] = "720";
			pargv[5] = "30";
			pargv[6] = "preview";		
			
			//cmd_uvc_start(7,pargv);
			Cmd_uvc_start(7,pargv);
		}
		else
		{			
			if(osMessagePut(KNL_UsbResetQueue, &tProc, 0) != osOK)
			{				
				printd(DBG_ErrorLvl, "KNL_UsbResetQueue->Full !!!!\r\n");
			}	
		}
	
		printf("USB_Idx(E)[%d] @ %d Event\r\n",tProc.ulIdx,tProc.ubEvent);
	}
}
#endif	


#if (defined(OP_AP) && (APP_USBD_COMPOSITE_MODE & USBD_MULTI_UAC))
static uint8_t ubUacStartFlag = 0;
int KNL_UacIsoInStart(uint32_t ulSamplesPerSec)
{
    ubUacStartFlag = 1;
    printd(DBG_InfoLvl, "KNL_UacIsoInStart %x\r\n", ubUacStartFlag);
	APP_UacCmd(UI_ADO_ADCSAMPLERATE,0x04,(uint8_t *)&ulSamplesPerSec);
	return 1;
} 

void KNL_UacIsoInStop(void)
{
    ubUacStartFlag = 0;
	BUF_Reset(BUF_USBD_ADO);
	osMessageReset(osKNL_UsbdUacQue);
    printd(DBG_InfoLvl, "KNL_UacIsoInStop %x\r\n", ubUacStartFlag);
}

int KNL_UacVolumeCtrl(uint8_t ubchannel, uint8_t ubctrl, uint16_t *volume)
{
	static uint16_t uwVolume[2] = {0x1900,0x1900};
	
    printd(DBG_InfoLvl, "KNL_UacVolumeCtrl %x %x %x\r\n", ubchannel,ubctrl,volume[0]);
	switch (ubctrl) 
	{
		case 0x01://UAC_SET_CUR:
			uwVolume[ubchannel&0x0F] = volume[0];
			APP_UacCmd(UI_ADO_ADCVOLL+(ubchannel&0x0F),0x02,(uint8_t *)volume);
		break;
		
		case 0x81://UAC_GET_CUR:
			volume[0] = uwVolume[ubchannel&0x0F] ;
			break;

		case 0x82://UAC_GET_MIN:
			volume[0] = 0x1400 ;	//Settings for Volume Control 0x1400: 5120 * 0.00390625 dB  = 20
			break;
		
		case 0x83://UAC_GET_MAX:
			volume[0] = 0x1E00 ;	//Settings for Volume Control 0x1E00: 7680 * 0.00390625 dB =30  
			break;

		case 0x84://UAC_GET_RES:
			volume[0] = 128 ;	//Settings for Volume Control 0x0200: 512 * 0.00390625 dB 	= 0.5
			break;
		
		default:

		  break;
	}
	
	return 1;
}

int KNL_UacMuteCtrl(uint8_t ubchannel, uint8_t ubctrl, uint8_t *enable)//(unsigned char channel, unsigned char ctrl, unsigned short *enable);
{
	static uint8_t ubKNL_UacbMute[2] = {0};
    printd(DBG_InfoLvl, "KNL_UacMuteCtrl %x %x %x\r\n", ubchannel,ubctrl,enable[0]);
	switch (ubctrl) 
	{
		case 0x01://UAC_SET_CUR:
			ubKNL_UacbMute[ubchannel&0x0F] = enable[0];
			APP_UacCmd(UI_ADO_ADCMUTE,0x01,enable);
		break;
		
		case 0x81://UAC_GET_CUR:
			enable[0] = ubKNL_UacbMute[ubchannel&0x0F] ;
			break;
		
		default:
		  break;
	}	

	return 1;
}
#endif	
//------------------------------------------------------------------------------

#if RTC676x
#if OP_STA
#define MAXTIMES_TO_NOLINK		4	//(4*10)+20 = 60 sec to RF Software-Reset
#else
#define MAXTIMES_TO_NOLINK		52
#endif
uint8_t ubKNL_NoLinkTimes = 0;
void KNL_RfInitProcess(RW_RF_EVENT tEvent)
{
	switch(tEvent)
	{
		case LINK_EVENT:
			tKNL_RwRfState = LINK_STATE;		
			break;
		case NO_LINK_EVENT:
			ubKNL_NoLinkTimes++;
			if(ubKNL_NoLinkTimes >= MAXTIMES_TO_NOLINK)
			{
				printf("Force to NoLink State\r\n");				
				tKNL_RwRfState = NO_LINK_STATE;
				
				ubKNL_NoLinkTimes = 0;
			}				
			break;
		case NO_INTERRUPT_EVENT:
			tKNL_RwRfState = NO_INTERRUPT_STATE;
			break;
		default:
			break;
	}
}
void KNL_RfLinkProcess(RW_RF_EVENT tEvent)
{
	switch(tEvent)
	{
		case LINK_EVENT:			
			break;
		case NO_LINK_EVENT:
			tKNL_RwRfState = NO_LINK_STATE;
			break;
		case NO_INTERRUPT_EVENT:
			tKNL_RwRfState = NO_INTERRUPT_STATE;
			break;
		default:
			break;
	}
}
void KNL_RfNoLinkProcess(RW_RF_EVENT tEvent)
{	
	switch(tEvent)
	{
		case LINK_EVENT:
			tKNL_RwRfState = LINK_STATE;			
			break;
		case NO_LINK_EVENT:	
			tKNL_RwRfState = SW_RESET_STATE;
			ubKNL_RwResetCnt = MAX_RW_RESET_TIME1;
			break;
		case NO_INTERRUPT_EVENT:
			tKNL_RwRfState = NO_INTERRUPT_STATE;			
			break;
		default:
			break;
	}
}

void KNL_RfSwResetProcess(RW_RF_EVENT tEvent)
{
	uint8_t reset = 1;
	
	switch(tEvent)
	{
		case LINK_EVENT:
			tKNL_RwRfState = LINK_STATE;			
			break;		
		case NO_LINK_EVENT:
		case NO_INTERRUPT_EVENT:					
			if(ubKNL_RwResetCnt)
			{
			#if defined(RTC676x)
				printf("RF_SWR(S)->%d\r\n",ubKNL_RwResetCnt);				
				rf_setopt(RF_OPT_SW_RST, &reset, 1);
				printf("RF_SWR(E)->%d\r\n",ubKNL_RwResetCnt);
			#endif
			}
			else
			{
				tKNL_RwRfState = SYS_RESTART_STATE;	
			}			
			if(ubKNL_RwResetCnt)
				ubKNL_RwResetCnt--;			
			break;
		default:
			break;
	}
}

void KNL_RfNoInterruptProcess(RW_RF_EVENT tEvent)
{	
	switch(tEvent)
	{
		case LINK_EVENT:
			tKNL_RwRfState = LINK_STATE;			
			break;
		case NO_LINK_EVENT:		
			tKNL_RwRfState = SW_RESET_STATE;	
			ubKNL_RwResetCnt = MAX_RW_RESET_TIME2;
			break;
		case NO_INTERRUPT_EVENT:					
			tKNL_RwRfState = SW_RESET_STATE;	
			ubKNL_RwResetCnt = MAX_RW_RESET_TIME2;		
			break;
		default:
			break;
	}			
}

void KNL_RfSysRestartProcess(RW_RF_EVENT tEvent)
{	
	tEvent = tEvent;	//Avoid Warning
	
	printf("RF Err1\r\n");		
	printf("RF Err2\r\n");				
	printf("RF Err3\r\n");				
	printf("Restart System !!!\r\n");
#if APP_PC_CONNECT_EN
	if(ubKNL_GetPcConnEnterStatus()==0 && ubKNL_GetPcConnSdFwuStatus()==0)
#endif
	{
		SYS_Reboot();
		while(1);
	}
}

void KNL_UpdateRfState(RW_RF_EVENT tEvent)
{	
	switch(tKNL_RwRfState)
	{
		case INIT_STATE:
			//printf("INIT_STATE\r\n");
			KNL_RfInitProcess(tEvent);
			break;
		case LINK_STATE:
			//printf("LINK_STATE\r\n");
			KNL_RfLinkProcess(tEvent);
			break;
		case NO_LINK_STATE:
			//printf("NO_LINK_STATE\r\n");
			KNL_RfNoLinkProcess(tEvent);
			break;
		case SW_RESET_STATE:
			printf("SW_RESET_STATE\r\n");
			KNL_RfSwResetProcess(tEvent);
			break;		
		case NO_INTERRUPT_STATE:
			printf("NO_INTERRUPT_STATE\r\n");
			KNL_RfNoInterruptProcess(tEvent);
			break;
		case SYS_RESTART_STATE:
			printf("SYS_RESTART_STATE\r\n");
			KNL_RfSysRestartProcess(tEvent);
			break;
		default:
			break;			
	}
}

void KNL_RfModeSwInit(void)
{
	if(APP_MODULATION_MODE == MODULATION_FIXED_QPSK)
	{
		tKNL_RfModeSwInfo.tMode = MODE_QPSK;
		tKNL_RfModulationMode  	= MODE_QPSK;
	}
	else if(APP_MODULATION_MODE == MODULATION_FIXED_16QAM)
	{
		tKNL_RfModeSwInfo.tMode = MODE_16QAM;
		tKNL_RfModulationMode  	= MODE_16QAM;
	}
	else if(APP_MODULATION_MODE == MODULATION_AUTO)
	{		
		tKNL_RfModeSwInfo.tMode = MODE_QPSK;
		tKNL_RfModulationMode  	= MODE_QPSK;
	}
	tKNL_RfModeSwInfo.ubModeUpdateFlg = 0;
	tKNL_RfModeSwInfo.ubRcUpdateFlg	= 0;
}

void KNL_RfQpskProcess(RW_MODULATION_EVENT tEvent)
{
	switch(tEvent)
	{
		case EVENT_TRX_GOOD:
			if(APP_MODULATION_MODE == MODULATION_AUTO)
			{				
				printf("{QPSK->QPSKTO16QAM}\r\n");
				tKNL_RfModeSwInfo.tMode = MODE_QPSKTO16QAM;	

				tKNL_RfModeSwInfo.ubModeUpdateFlg = 1;
			}
			break;
		case EVENT_TRX_NOTGOOD:			
			break;
		default:
			break;
	}
}

void KNL_RfQpskTo16QamProcess(RW_MODULATION_EVENT tEvent)
{
	switch(tEvent)
	{
		case EVENT_TRX_GOOD:
			if(APP_MODULATION_MODE == MODULATION_AUTO)
			{
				printf("{QPSKTO16QAM->16QAM}\r\n");
				tKNL_RfModeSwInfo.tMode = MODE_16QAM;	
				
				tKNL_RfModeSwInfo.ubRcUpdateFlg	= 1;
			}
			break;
		case EVENT_TRX_NOTGOOD:
			if(APP_MODULATION_MODE == MODULATION_AUTO)
			{
				printf("{QPSKTO16QAM->QPSK}\r\n");				
				tKNL_RfModeSwInfo.tMode = MODE_QPSK;

				tKNL_RfModeSwInfo.ubModeUpdateFlg = 1;
			}			
			break;
		default:
			break;
	}
}

void KNL_Rf16QamProcess(RW_MODULATION_EVENT tEvent)
{
	switch(tEvent)
	{
		case EVENT_TRX_GOOD:			
			break;
		case EVENT_TRX_NOTGOOD:	
			if(APP_MODULATION_MODE == MODULATION_AUTO)
			{				
				printf("{16QAM->QPSK}\r\n");
				tKNL_RfModeSwInfo.tMode = MODE_QPSK;
				
				tKNL_RfModeSwInfo.ubModeUpdateFlg	= 1;
				tKNL_RfModeSwInfo.ubRcUpdateFlg		= 1;
			}			
			break;
		default:
			break;
	}
}

void KNL_UpdateRfModulationMode(RW_MODULATION_EVENT tEvent)
{	
	switch(tKNL_RfModeSwInfo.tMode)
	{
		case MODE_QPSK:	
			KNL_RfQpskProcess(tEvent);
			break;
		case MODE_QPSKTO16QAM:
			KNL_RfQpskTo16QamProcess(tEvent);			
			break;
		case MODE_16QAM:	
			KNL_Rf16QamProcess(tEvent);			
			break;	
		default:
			break;			
	}
}
#endif

#ifdef RTC676x
#if APP_RTC676X_BRIDGE_COEXISTENCE_ENABLE
void KNL_ModifyFreqTableProcess(uint8_t ubNewFreqTable)
{
#if (DISPLAY_MODE == DISPLAY_1T1R)	
	if(ubKNL_TwcSend(KNL_STA1, TWC_FREQ_TABLE, &ubNewFreqTable, 1, 16) != TWC_SUCCESS)
	{
		printf("TWC0(FreqTable) -> Fail\r\n");				
	}
	else
	{
		printf("TWC0(FreqTable) -> Ok\r\n");	
	}
	osDelay(80);
#elif (DISPLAY_MODE == DISPLAY_2T1R)
	if(ubKNL_TwcSend(KNL_STA1, TWC_FREQ_TABLE, &ubNewFreqTable, 1, 16) != TWC_SUCCESS)
	{
		printf("TWC0(FreqTable) -> Fail\r\n");				
	}
	else
	{
		printf("TWC0(FreqTable) -> Ok\r\n");	
	}
	osDelay(80);
	
	if(ubKNL_TwcSend(KNL_STA2, TWC_FREQ_TABLE, &ubNewFreqTable, 1, 16) != TWC_SUCCESS)
	{
		printf("TWC1(FreqTable) -> Fail\r\n");				
	}
	else
	{
		printf("TWC1(FreqTable) -> Ok\r\n");	
	}
	osDelay(80);	
	
#elif (DISPLAY_MODE == DISPLAY_4T1R)
	if(ubKNL_TwcSend(KNL_STA1, TWC_FREQ_TABLE, &ubNewFreqTable, 1, 16) != TWC_SUCCESS)
	{
		printf("TWC0(FreqTable) -> Fail\r\n");				
	}
	else
	{
		printf("TWC0(FreqTable) -> Ok\r\n");	
	}
	osDelay(80);
	
	if(ubKNL_TwcSend(KNL_STA2, TWC_FREQ_TABLE, &ubNewFreqTable, 1, 16) != TWC_SUCCESS)
	{
		printf("TWC1(FreqTable) -> Fail\r\n");				
	}
	else
	{
		printf("TWC1(FreqTable) -> Ok\r\n");	
	}
	osDelay(80);
	
	if(ubKNL_TwcSend(KNL_STA3, TWC_FREQ_TABLE, &ubNewFreqTable, 1, 16) != TWC_SUCCESS)
	{
		printf("TWC2(FreqTable) -> Fail\r\n");				
	}
	else
	{
		printf("TWC2(FreqTable) -> Ok\r\n");	
	}
	osDelay(80);
	
	if(ubKNL_TwcSend(KNL_STA4, TWC_FREQ_TABLE, &ubNewFreqTable, 1, 16) != TWC_SUCCESS)
	{
		printf("TWC3(FreqTable) -> Fail\r\n");				
	}
	else
	{
		printf("TWC3(FreqTable) -> Ok\r\n");	
	}
	osDelay(80);
#endif
}
#endif
#endif


#if RTC676x
#if APP_RTC676X_FOTA_ENABLE
//-----------------------------------------

#ifdef OP_AP 
FOTA_STATUS tKNL_SendFwData(KNL_ROLE tSta,uint32_t ulAddr,uint32_t ulSize)	//[FOTA] Send Firmware Data to Target STA
{	
	uint8_t ubLinkRole;
	uint8_t ubTotalBufNum;
	uint8_t ubUsedBufNum;
	KNL_PROCESS tProc;	
	uint32_t ulExtSz;	
	
	ubLinkRole = tSta;
	
	//Check Link Status
	//----------------------------------------------------------
	if(ubKNL_GetCommLinkStatus(ubLinkRole) == BB_LOST_LINK)	
	{		
		return FOTA_LOST_LINK;
	}
	
	//Check Queue-Num Status
	//----------------------------------------------------------
	ubTotalBufNum = BUF_NUM_ADO_PACKETIZE;
	ubUsedBufNum  = osMessages(KNL_AdoPacketizeQue);
	if((ubTotalBufNum-ubUsedBufNum) < 1)
	{
		return FOTA_NO_FREE_BUF;
	}
	
	//Add Aux Information
	//------------------------------------------------------------------------------------------------------------	
	ulExtSz = ulKNL_AddAuxInfo(KNL_ADO_PKT,(uint8_t)tSta,ulAddr,ulSize, 0, 0, 0, KNL_TIMER_Get1ms());	
	
	//Next Node
	if(tSta == KNL_STA1)
		tProc.ubSrcNum = KNL_SRC_1_OTHER_A;
	else if(tSta == KNL_STA2)
		tProc.ubSrcNum = KNL_SRC_2_OTHER_A;
	else if(tSta == KNL_STA3)
		tProc.ubSrcNum = KNL_SRC_3_OTHER_A;
	else if(tSta == KNL_STA4)
		tProc.ubSrcNum = KNL_SRC_4_OTHER_A;
	
	tProc.ubCodecIdx	= 0;	
	tProc.tPktType	 	= PKT_FOTA;		
	tProc.ulDramAddr2 	= ulAddr;				
	tProc.ulSize		= ulExtSz;
	if(osMessagePut(KNL_AdoPacketizeQue, &tProc, 0) == osErrorResource)
	{					
		printd(DBG_ErrorLvl, "PktQ->F\r\n");
		return FOTA_QUEUE_FAIL;
	}	
	else
	{
		return FOTA_QUEUE_OK;
	}
}

//[Justin] Update for FOTA
//------------------------------------------------------
uint8_t ubKNL_FotaFlg[4] = {0,0,0,0};
FOTA_STATUS tKNL_FotaStatus = FOTA_INIT;
static void KNL_FotaThread(void const *argument);

void KNL_StartFota(KNL_ROLE tRole)
{
	ubKNL_FotaFlg[tRole] = 1;
}

FOTA_STATUS tKNL_GetFotaStatus(void)
{
	return tKNL_FotaStatus;
}

uint16_t uwFotaCnt = 0;
static void KNL_FotaThread(void const *argument)
{	
	//printf("FOTA Thread\r\n");
	while(1)
	{
		if(ubKNL_FotaFlg[0])	
		{			
			printf("FOTA_Start[0]\r\n");
			ubKNL_FotaFlg[0] = 0;			
			tKNL_FotaStatus = FOTA_INIT;
			tKNL_StartFotaProcess(KNL_STA1);
		}
		else if(ubKNL_FotaFlg[1])		
		{
			printf("FOTA_Start[1]\r\n");
			ubKNL_FotaFlg[1] = 0;			
			tKNL_FotaStatus = FOTA_INIT;
			tKNL_StartFotaProcess(KNL_STA2);
		}
		else if(ubKNL_FotaFlg[2])		
		{
			printf("FOTA_Start[2]\r\n");
			ubKNL_FotaFlg[2] = 0;			
			tKNL_FotaStatus = FOTA_INIT;
			tKNL_StartFotaProcess(KNL_STA3);
		}
		else if(ubKNL_FotaFlg[3])		
		{
			printf("FOTA_Start[3]\r\n");
			ubKNL_FotaFlg[3] = 0;			
			tKNL_FotaStatus = FOTA_INIT;
			tKNL_StartFotaProcess(KNL_STA4);
		}
		//uwFotaCnt++;
		//printf("FotaThread:%d\r\n",uwFotaCnt);
		osDelay(1000);
	}
}


//======================================================
void KNL_StopFotaProcess(void)
{
	ubKNL_FotaForceStopFlg = 1;
}

uint8_t ubKNL_ChkFotaStatusValid(void)
{
	if(tKNL_FotaStatus == FOTA_FILE_OK)
	{
		return 0;
	}
	else
	{
		return 1;
	}		
}

FOTA_STATUS tKNL_StartFotaProcess(KNL_ROLE tRole)
{	
	uint8_t ubDdgFlg[10]={1,1,1,1,1,1,1,1,1,1};
	uint8_t ubDbgIdx = 0;
	
	uint8_t ubWaitCnt = 20;
	uint8_t i;
	uint32_t ulUnitNum = 0;		
	uint8_t ubFsTimeout = 20;
	FS_MEDIA_SEL MediaSel;
	FS_GET_A_SINGLE_FILE_INTO_t SingleFileInfo;
	FS_GET_A_SERIES_FILE_INTO_t SeriesFileInfo;
	FS_Q_STATUS FsWaitStatus;
	FS_FILE_INFO_t tFwFileInfo;
	FS_SRC_NUM SrcNum;
	uint32_t ulStartRun = 0;	
	uint32_t ulRdAccSz=0;
	uint32_t ulPacketizeAddr=0;	
	
	tKNL_FotaStatus = FOTA_START;	//Record Status			
	
	ubKNL_GetFotaTwcFlg[tRole] = 0;
	ubKNL_FotaForceStopFlg = 0;
	ubKNL_FotaStatusRptInPercent = 0;
	
	//------------------------------
	//find fw file
	//------------------------------
	SingleFileInfo.OutputFileInfo = &tFwFileInfo;      
	SingleFileInfo.FileName.ubLen =sizeof(FOTA_TARGET_FILE_NAME)-1;    
	strncpy(SingleFileInfo.FileName.chName, FOTA_TARGET_FILE_NAME, SingleFileInfo.FileName.ubLen);   
	strncpy(SingleFileInfo.FileName.chExt, "bin", 3);

	MediaSel = FS_MEDIA_0;
	FS_GetFileInfo(MediaSel, A_SINGLE_INFO, SingleFileInfo, SeriesFileInfo, FILE_PATH1);
	//ubFsTimeout = 60;
	ubFsTimeout = 20;
	while(1)
	{
	   if(ubKNL_FotaForceStopFlg)
	   {		  
		   tKNL_FotaStatus = FOTA_STOP;	//Record Status
		   return FOTA_STOP;
	   }
	   FsWaitStatus = FS_ChkGetFileInfoStatus(MediaSel);
	   if(FsWaitStatus==FS_GET_INFO_FAIL)
	   {		   
		   printd(DBG_ErrorLvl, "FWU->Get File Info Err!\n");		   
		   tKNL_FotaStatus = FOTA_READ_FILE_FAIL;	//Record Status		   
		   return FOTA_READ_FILE_FAIL;
	   }
	   else if(FsWaitStatus==FS_GET_INFO_OK)
	   {
		   break;
	   }
	   else
	   {
			if(ubKNL_FotaForceStopFlg)
			{				
				tKNL_FotaStatus = FOTA_STOP;//Record Status				
				return FOTA_STOP;
			}
	   
		   osDelay(50);
		   if(!--ubFsTimeout)
		   {
			   printd(DBG_ErrorLvl, "FWU->Get File Info Timeout!\n");			   
			   tKNL_FotaStatus = FOTA_READ_FILE_FAIL;//Record Status			   
			   return FOTA_READ_FILE_FAIL;
		   }
	   }
	}	 
     
	printf("FN:%s,Fcls:%d,Sz:0x%x\r\n",tFwFileInfo.FileName.chName,tFwFileInfo.ulFirstClus,(uint32_t)tFwFileInfo.ullFileSize);
	ulKNL_FotaDataSize = (uint32_t)tFwFileInfo.ullFileSize;
   
    //-----------------------------------------------------------------
	if(ulKNL_FotaDataSize == 0)
	{		
		tKNL_FotaStatus = FOTA_READ_FILE_FAIL;//Record Status		
		return FOTA_READ_FILE_FAIL;
	}
	else
	{		
		tKNL_FotaStatus = FOTA_FILE_OK;//Record Status
	}
   
	//------------------------------
	//chk available source num
	//------------------------------
	SrcNum = FS_VDO_SRC_0;

	//! Read ISP Memory
	ubFsTimeout = 60;

	//------------------------
	//Addr(Start FOTA)
	//     FW Data(15KB)
	//Addr(Start FOTA + 15KB)
	//Addr(Start Packetize)
	//...
	//========================	
	ulPacketizeAddr = ulBUF_GetBlkBufAddr(0,BUF_FOTA) + (FOTA_MAX_SZ_PER_FRM*1);
	//ulPacketizeAddr = ulBUF_GetBlkBufAddr(0,BUF_FOTA) + (FOTA_MAX_SZ_PER_FRM*4);
   
	ulRdAccSz = 0;
	
	while(ulRdAccSz < ulKNL_FotaDataSize)
	{			
		//Calculate Percent
		//----------------------------------------------------------
		ubDbgIdx = (ulRdAccSz*10)/ulKNL_FotaDataSize;
		if(ubDdgFlg[ubDbgIdx])
		{			
			ubDdgFlg[ubDbgIdx] = 0;
			ubKNL_FotaStatusRptInPercent = ubDbgIdx*10;
			printf("Percent:%d\r\n",ubKNL_FotaStatusRptInPercent);
		}
		//==========================================================		
		
		if(ubKNL_FotaForceStopFlg)
		{
			ubKNL_FotaTrxFlg = 0;			
			tKNL_FotaStatus = FOTA_STOP;//Record Status			
			return FOTA_STOP;
		}
			
		if((ulKNL_FotaDataSize-ulRdAccSz) >=  FOTA_MAX_SZ_PER_FRM)		
		//if((ulKNL_FotaDataSize-ulRdAccSz) >=  (FOTA_MAX_SZ_PER_FRM*4))	
		{			
			//printf("(Ofs:0x%x,Sz:0x%x)\r\n",ulRdAccSz,FOTA_MAX_SZ_PER_FRM);
			//printf("(Ofs:0x%x,Sz:0x%x)\r\n",ulRdAccSz,FOTA_MAX_SZ_PER_FRM*4);
			ubFsTimeout = 60;			
			
			if(FS_ReadFile(MediaSel, ulBUF_GetBlkBufAddr(0,BUF_FOTA)+0, SrcNum, tFwFileInfo.ulFirstClus, tFwFileInfo.NoFatChainFlag, ulRdAccSz, FOTA_MAX_SZ_PER_FRM*1) == FS_SEND_Q_SUCCESS)			
			//if(FS_ReadFile(MediaSel, ulBUF_GetBlkBufAddr(0,BUF_FOTA)+0, SrcNum, tFwFileInfo.ulFirstClus, tFwFileInfo.NoFatChainFlag, ulRdAccSz, FOTA_MAX_SZ_PER_FRM*4) == FS_SEND_Q_SUCCESS)
			{
			   while(FS_ChkReadStatus(MediaSel, SrcNum) != FS_PLY_READ_OK)
			   {
					if(ubKNL_FotaForceStopFlg)
					{
						ubKNL_FotaTrxFlg = 0;						
						tKNL_FotaStatus = FOTA_STOP;//Record Status						
						return FOTA_STOP;
					}
		
				   osDelay(50);
				   if(!--ubFsTimeout)
				   {
					   printf("Read FW file Fail !!\n");
					   //return -1;					   
					   tKNL_FotaStatus = FOTA_READ_FILE_FAIL;//Record Status					   
					   return FOTA_READ_FILE_FAIL;
				   }
			   }			   
			}				
			
			ulKNL_FotaDataPacketize(1, ulStartRun,ulBUF_GetBlkBufAddr(0,BUF_FOTA)+0,ulKNL_FotaDataSize,ulPacketizeAddr+0,0);				
			//ulKNL_FotaDataPacketize(4, ulStartRun,ulBUF_GetBlkBufAddr(0,BUF_FOTA)+0,ulKNL_FotaDataSize,ulPacketizeAddr+0,0);
			
			//ubKNL_FotaDataSend(tRole,ulPacketizeAddr,FOTA_MAX_SZ_PER_FRM*1);		
			if(ubKNL_FotaDataSend(tRole,ulPacketizeAddr,FOTA_MAX_SZ_PER_FRM*1) == 0)
			{				
				tKNL_FotaStatus = FOTA_SEND_FAIL;//Record Status				
				return FOTA_SEND_FAIL;
			}
			//ubKNL_FotaDataSend(KNL_STA1,ulPacketizeAddr,FOTA_MAX_SZ_PER_FRM*4);
	
			for(i=0;i<1;i++)
			//for(i=0;i<4;i++)
			{
				ulStartRun++;
				ulRdAccSz = ulRdAccSz+FOTA_MAX_SZ_PER_FRM;
			}								
		}			
		else
		{				
			if(((ulKNL_FotaDataSize-ulRdAccSz) % FOTA_MAX_SZ_PER_FRM) == 0)
			{
				ulUnitNum = (ulKNL_FotaDataSize-ulRdAccSz)/FOTA_MAX_SZ_PER_FRM;
			}
			else
			{
				ulUnitNum = (ulKNL_FotaDataSize-ulRdAccSz)/FOTA_MAX_SZ_PER_FRM;
				ulUnitNum++;
			}
			if(FS_ReadFile(MediaSel, ulBUF_GetBlkBufAddr(0,BUF_FOTA)+0, SrcNum, tFwFileInfo.ulFirstClus, tFwFileInfo.NoFatChainFlag, ulRdAccSz, ulKNL_FotaDataSize-ulRdAccSz) == FS_SEND_Q_SUCCESS)
			{
			   while(FS_ChkReadStatus(MediaSel, SrcNum) != FS_PLY_READ_OK)
			   {
				   	if(ubKNL_FotaForceStopFlg)
					{
						ubKNL_FotaTrxFlg = 0;						
						tKNL_FotaStatus = FOTA_STOP;//Record Status						
						return FOTA_STOP;
					}
					
				   osDelay(50);
				   if(!--ubFsTimeout)
				   {
					   printf("Read FW file Fail !!\n");
					   //return -1;					  
					   tKNL_FotaStatus = FOTA_READ_FILE_FAIL; //Record Status					   
					   return FOTA_READ_FILE_FAIL;
				   }
			   }			   
			}			
			
			//=======================================================================================				
			ulKNL_FotaDataPacketize(ulUnitNum,ulStartRun,ulBUF_GetBlkBufAddr(0,BUF_FOTA)+0,ulKNL_FotaDataSize,ulPacketizeAddr+0,0);			
			
			//ubKNL_FotaDataSend(tRole,ulPacketizeAddr,FOTA_MAX_SZ_PER_FRM*ulUnitNum);	
			if(ubKNL_FotaDataSend(tRole,ulPacketizeAddr,FOTA_MAX_SZ_PER_FRM*ulUnitNum) == 0)
			{				
				tKNL_FotaStatus = FOTA_SEND_FAIL;//Record Status				
				return FOTA_SEND_FAIL;
			}
			
			ulRdAccSz = ulKNL_FotaDataSize;					
		}
		
		//osDelay(20);		
	}	

	while(ubWaitCnt--)
	{
		if(ubKNL_FotaForceStopFlg)
		{
			ubKNL_FotaTrxFlg = 0;			
			tKNL_FotaStatus = FOTA_STOP;//Record Status			
			return FOTA_STOP;
		}
					
		if(ubKNL_GetFotaTwcFlg[tRole])
		{			
			printf("Got Rsp:%d\r\n",ubWaitCnt);
			
			ubKNL_FotaStatusRptInPercent = 100;
			printf("Percent:%d\r\n",ubKNL_FotaStatusRptInPercent);			
			tKNL_FotaStatus = FOTA_SEND_OK;//Record Status			
			return FOTA_SEND_OK;			
		}
		else
		{
			printf("Without Rsp:%d\r\n",ubWaitCnt);
		}
		osDelay(100);
	}	
	
	tKNL_FotaStatus = FOTA_SEND_FAIL;	//Record Status
	return FOTA_SEND_FAIL;
}

uint32_t ulKNL_FotaDataPacketize(uint8_t ubAccessUnit,uint32_t ulStartRun,uint32_t ulInputAddr,uint32_t ulInputSize,uint32_t ulBufAddr,uint8_t ubFwType)
{	
	uint32_t ulNumOfFrm;	//16bits -> 32bits, for operation issue
	uint32_t i;				//16bits -> 32bits, for operation issue
	uint8_t *pTemp;
	
	if((ulInputSize % FOTA_MAX_SZ_PER_FRM) == 0)
	{
		ulNumOfFrm = ulInputSize/FOTA_MAX_SZ_PER_FRM;
	}
	else
	{
		ulNumOfFrm = ulInputSize/FOTA_MAX_SZ_PER_FRM;
		ulNumOfFrm++;
	}
	
	for(i=0;i<ubAccessUnit;i++)
	{
		pTemp = (uint8_t *)(ulBufAddr+((FOTA_MAX_SZ_PER_FRM+FOTA_INFO_SZ+FOTA_DUMMY_SZ)*(i+0)));
			
		*pTemp++ = (ulInputSize & 0x000000FF);			//RealFwSz[0]
		*pTemp++ = (ulInputSize & 0x0000FF00) >> 8;		//RealFwSz[1]
		*pTemp++ = (ulInputSize & 0x00FF0000) >> 16;	//RealFwSz[2]	
		*pTemp++ = (ulInputSize & 0xFF000000) >> 24;	//RealFwSz[3]

		*pTemp++ = ((ulNumOfFrm*FOTA_MAX_SZ_PER_FRM) & 0x000000FF);			//PadFwSz[0]
		*pTemp++ = ((ulNumOfFrm*FOTA_MAX_SZ_PER_FRM) & 0x0000FF00) >> 8;	//PadFwSz[1]	
		*pTemp++ = ((ulNumOfFrm*FOTA_MAX_SZ_PER_FRM) & 0x00FF0000) >> 16;	//PadFwSz[2]	
		*pTemp++ = ((ulNumOfFrm*FOTA_MAX_SZ_PER_FRM) & 0xFF000000) >> 24;	//PadFwSz[3]
		
		*pTemp++ = (ulNumOfFrm & 0x000000FF);				//NumOfFrm[0]
		*pTemp++ = (ulNumOfFrm & 0x0000FF00) >> 8;			//NumOfFrm[1]	
		
		*pTemp++ = (FOTA_MAX_SZ_PER_FRM & 0x000000FF);		//SzPerFrm[0]
		*pTemp++ = (FOTA_MAX_SZ_PER_FRM & 0x0000FF00)>>8;	//SzPerFrm[0]	

		*pTemp++ = ubFwType;	//FwType		

		*pTemp++ = ((i+ulStartRun) & 0x000000FF);		//FrmIdx[0]
		*pTemp++ = ((i+ulStartRun) & 0x0000FF00) >>8;	//FrmIdx[1]	
		
		*pTemp++ = 0;		//Rsv		

		if(tDMAC_MemCopy(ulInputAddr+(FOTA_MAX_SZ_PER_FRM*(i+0)),(uint32_t)pTemp,FOTA_MAX_SZ_PER_FRM,NULL) != DMAC_OK)
		{
			printf("DMA Copy Fail @%s\r\n",__func__);
			return 0;
		}		
	}
	return (ulNumOfFrm*FOTA_MAX_SZ_PER_FRM);
}

uint8_t ubKNL_FotaDataSend(KNL_ROLE tRole,uint32_t ulAddr,uint32_t ulSize)
{
	uint32_t m;
	uint32_t ulNumOfFrm;
	uint8_t ubUsedBufNum;
	FOTA_STATUS tFotaStatus;
	
	if((ulSize % FOTA_MAX_SZ_PER_FRM) == 0)
	{
		ulNumOfFrm = ulSize/FOTA_MAX_SZ_PER_FRM;
	}
	else
	{
		ulNumOfFrm = ulSize/FOTA_MAX_SZ_PER_FRM;
		ulNumOfFrm++;
	}
	//printf("Num:%d @FotaDataSend\r\n",ulNumOfFrm);	
	
	for(m=0;m<ulNumOfFrm;m++)
	{				
		ubUsedBufNum  = osMessages(KNL_AdoPacketizeQue);				
		//if((BUF_NUM_ADO_PACKETIZE-ubUsedBufNum) >= 1)
		if((BUF_NUM_ADO_PACKETIZE-ubUsedBufNum) >= 2)
		{
			//-------------------------
			while(ubKNL_FotaTrxFlg)
			{
				osDelay(10);
			}
			ubKNL_FotaTrxFlg = 1;
			//=========================			

			tFotaStatus = tKNL_SendFwData(tRole,ulAddr+((FOTA_INFO_SZ+FOTA_MAX_SZ_PER_FRM+FOTA_DUMMY_SZ)*m),FOTA_INFO_SZ+FOTA_MAX_SZ_PER_FRM);			
			
			if(tFotaStatus != FOTA_QUEUE_OK)
			{
				//printf("Fail to SendFwData[%d]:%d\r\n",m,tFotaStatus);
				printf("Send->Fail[%d]:%d\r\n",m,tFotaStatus);
				ubKNL_FotaTrxFlg = 0;
				return 0;
			}
		}
		else
		{
			while(1)
			{			
				osDelay(20);				
				ubUsedBufNum  = osMessages(KNL_AdoPacketizeQue);
				//if((BUF_NUM_ADO_PACKETIZE-ubUsedBufNum) >= 1)
				if((BUF_NUM_ADO_PACKETIZE-ubUsedBufNum) >= 2)
					break;
			}
			
			//-------------------------
			while(ubKNL_FotaTrxFlg)
			{
				osDelay(10);
			}
			ubKNL_FotaTrxFlg = 1;
			//=========================			
			
			tFotaStatus = tKNL_SendFwData(tRole,ulAddr+((FOTA_INFO_SZ+FOTA_MAX_SZ_PER_FRM+FOTA_DUMMY_SZ)*m),FOTA_INFO_SZ+FOTA_MAX_SZ_PER_FRM);			
			if(tFotaStatus != FOTA_QUEUE_OK)
			{
				//printf("Fail to SendFwData[%d]:%d\r\n",m,tFotaStatus);
				printf("Send->Fail[%d]:%d\r\n",m,tFotaStatus);
				ubKNL_FotaTrxFlg = 0;
				return 0;
			}					
		}
	
	#if 0		
		//Check Queue-Num Status
		//----------------------------------------------------------				
		ubUsedBufNum  = osMessages(KNL_AdoPacketizeQue);
		
		if((BUF_NUM_ADO_PACKETIZE-ubUsedBufNum) == 1)
		{			
			uwDummyDelay = 60;
		}
		else if((BUF_NUM_ADO_PACKETIZE-ubUsedBufNum) == 2)
		{			
			uwDummyDelay = 40;
		}
		else if((BUF_NUM_ADO_PACKETIZE-ubUsedBufNum) < (BUF_NUM_ADO_PACKETIZE/2))
		{			
			uwDummyDelay = 20;
		}
		else if((BUF_NUM_ADO_PACKETIZE-ubUsedBufNum) == (BUF_NUM_ADO_PACKETIZE/2))
		{				
			uwDummyDelay = 10;
		}
		else
		{
			uwDummyDelay = 0;
			
		}			
		if(uwDummyDelay)
			osDelay(uwDummyDelay);
	#endif
	}
	return 1;	
}
#endif	//End of AP
#endif	//End of APP_RTC676X_FOTA_ENABLE
#endif	//End of RTC676x
static void KNL_SecMonitThread(void const *argument)
{
	
#ifdef RTC676x	
	uint8_t ubLinkStatus[KNL_RF_MONIT_TIME];	
	uint8_t ubLinkFlg;	
	uint8_t k;	
#endif
	uint8_t i;
	uint32_t ulSecCnt = 0;
	
	uint64_t udlIsrCntPrevious = 0,udlIsrCntNow = 400;
	uint8_t ubIsrErrFlg = 0;
	uint8_t ubStartMonitIsrFlg = 0;
#ifdef RTC676x	
	uint8_t reset = 1;
	uint8_t ubErrCnt=0;
#endif
	
#if OP_AP
	uint8_t ubTemp[4];
	uint8_t ubStaMap;	
#endif
#ifdef OP_STA
	#ifdef RTC676x

	#if (APP_MODULATION_MODE == MODULATION_AUTO)
		#define TRANS_TIME		4	
		#define REC_TIME		4		
		//#define REC_TIME_MAX	12
		#define REC_TIME_16QAM	4
		#define REC_TIME_QPSK	12		
	#if (RF_MODE_SW_SEL	== RF_MODE_SW_OLD)
		uint32_t ulPreBw[REC_TIME];
		int iPreRateMode = PREF_BBR_QPSK;
		uint8_t j;
	#endif
	#if (RF_MODE_SW_SEL	== RF_MODE_SW_NEW)			
		uint8_t ubAccCnt = 0;
		uint32_t ulAccBw = 0;		
		uint8_t ubUpdateInfoFlg = 0;	
	#endif
		uint32_t ulAvgBw = 0;
	#endif

//	uint8_t reset = 1;
	uint32_t ulRtBw;	//KB
	uint32_t ulMaxBw;	//KB
	int free_buf_count = 0;
    size_t free_buf_count_len = sizeof(free_buf_count);
	int BwRptType = BW_QUARTER_BANDWIDTH;
	#endif
	#ifndef S2019A
	KNL_PROCESS tKNLInfo;
	#endif
#endif

	ulSecCnt = ulSecCnt;						//Avoid Warning
	udlIsrCntPrevious = udlIsrCntPrevious;		//Avoid Warning
	udlIsrCntNow = udlIsrCntNow;				//Avoid Warning	
	ubIsrErrFlg = ubIsrErrFlg;					//Avoid Warning
	ubStartMonitIsrFlg = ubStartMonitIsrFlg;	//Avoid Warning
#ifdef RTC676x	
	for(i=0;i<KNL_RF_MONIT_TIME;i++)
		ubLinkStatus[i] = 0;
#endif

	while(1)
	{		
#ifndef S2019A
		/*
		//Output Bit-Rate (Video Data)
		ulKNL_VdoOutAccCnt[0] = ulKNL_VdoOutAccCntTemp[0];
		ulKNL_VdoOutAccCntTemp[0] = 0;	

		ulKNL_VdoOutAccCnt[1] = ulKNL_VdoOutAccCntTemp[1];
		ulKNL_VdoOutAccCntTemp[1] = 0;

		ulKNL_VdoOutAccCnt[2] = ulKNL_VdoOutAccCntTemp[2];
		ulKNL_VdoOutAccCntTemp[2] = 0;

		ulKNL_VdoOutAccCnt[3] = ulKNL_VdoOutAccCntTemp[3];
		ulKNL_VdoOutAccCntTemp[3] = 0;		
		*/
#endif
		//Output/Input Frame-Rate (Video Data)
		for(i = 0; i < KNL_SRC_NUM; i++)
		{
			ulKNL_OutVdoFpsCnt[i] = ulKNL_OutVdoFpsCntTemp[i];
			ulKNL_OutVdoFpsCntTemp[i] = 0;
#if defined(BSP_DVR_SDK)
			ulKNL_H264EncCnt[i] = ulKNL_H264EncCntTemp[i];
			ulKNL_H264EncCntTemp[i] = 0;	

			ulKNL_H264DecCnt[i] = ulKNL_H264DecCntTemp[i];
			ulKNL_H264DecCntTemp[i] = 0;			

			ulKNL_JpegEncCnt[i] = ulKNL_JpegEncCntTemp[i];
			ulKNL_JpegEncCntTemp[i] = 0;
			
			ulKNL_JpegDecCnt[i] = ulKNL_JpegDecCntTemp[i];
			ulKNL_JpegDecCntTemp[i] = 0;
#endif			
			
//			ulKNL_InVdoFpsCnt[i] = ulKNL_InVdoFpsCntTemp[i];
//			ulKNL_InVdoFpsCntTemp[i] = 0;
		}
		for(i = 0; i < KNL_MAX_ROLE; i++)
		{
			ulKNL_FrmTRxNum[i] = ulKNL_FrmTRxNumTemp[i];
			ulKNL_FrmTRxNumTemp[i] = 0;
		}
//		printd(DBG_InfoLvl, "VdoTp[0]:%d KB\r\n",(ulKNL_VdoOutAccCnt[0])/8/1024);
//		printd(DBG_InfoLvl, "VdoTp[1]:%d KB\r\n",(ulKNL_VdoOutAccCnt[1])/8/1024);
//		printd(DBG_InfoLvl, "VdoTp[2]:%d KB\r\n",(ulKNL_VdoOutAccCnt[2])/8/1024);
//		printd(DBG_InfoLvl, "VdoTp[3]:%d KB\r\n",(ulKNL_VdoOutAccCnt[3])/8/1024);
#if (defined(OP_AP) && (defined(A7130) || defined(S2019A)))
		if(pKNL_PerDbgFunc[0])
		{
			for(i = 0; i < 4; i++)
			{
			#ifdef A7130
				pKNL_PerDbgFunc[0](PER_FPS_RPT, i, ulKNL_GetFps(KNL_BB_FRM_OK, (KNL_SRC_1_MAIN+i)));
				if(ubKNL_GetCommLinkStatus(KNL_STA1 + i) == BB_LINK)
				{
					uint32_t ulRfBwRpt = 0;

					ulRfBwRpt = (ulBB_GetBBFlow((BB_GET_DATA_FLOW)(BB_GET_RXSTA1_VDO_FLOW + i))*8)/8192;
					pKNL_PerDbgFunc[0](PER_RFBW_RPT, i, ulRfBwRpt);
				}
			#endif
			#ifdef S2019A
				if(sPRF_DEVDRV_EN == tsPRF_GetDrvSts((sPRF_DevId_t)(sPRF_STA1+i)))
				{
					pKNL_PerDbgFunc[0](PER_FPS_RPT, i, ulKNL_GetFps(KNL_BB_FRM_OK, (KNL_SRC_1_MAIN+i)));
					pKNL_PerDbgFunc[0](PER_SPRFSTS_RPT, i, 0);
				}
			#endif
			}
		}
		printd(DBG_CriticalLvl, "FPS:%d,%d,%d,%d\r\n",
			ulKNL_GetFps(KNL_BB_FRM_OK, KNL_SRC_1_MAIN),
			ulKNL_GetFps(KNL_BB_FRM_OK, KNL_SRC_2_MAIN),
			ulKNL_GetFps(KNL_BB_FRM_OK, KNL_SRC_3_MAIN),
			ulKNL_GetFps(KNL_BB_FRM_OK, KNL_SRC_4_MAIN));
#endif

#if OP_AP		
#if defined(BSP_DVR_SDK)
		printd(DBG_ErrorLvl, "(Sec:S1:S2:HE:HD:JE:JD:%d,%d,%d,%d,%d,%d,%d)\r\n",ulSecCnt++,ulKNL_OutVdoFpsCnt[KNL_SRC_STORAGE_LOCAL],ulKNL_OutVdoFpsCnt[KNL_SRC_PREVIEW_LOCAL],ulKNL_H264EncCnt[KNL_SRC_STORAGE_LOCAL],ulKNL_H264DecCnt[KNL_SRC_1_MAIN],ulKNL_JpegEncCnt[KNL_SRC_PREVIEW_LOCAL],ulKNL_JpegDecCnt[KNL_SRC_PREVIEW_LOCAL]);		
#else
		ubTemp[0] = ubTRX_GetLinkStatus(KNL_STA1);
		ubTemp[1] = ubTRX_GetLinkStatus(KNL_STA2);
		ubTemp[2] = ubTRX_GetLinkStatus(KNL_STA3);
		ubTemp[3] = ubTRX_GetLinkStatus(KNL_STA4);
#endif		
		ubStaMap = 0;
		if(ubTemp[0])
		{
			ubStaMap = ubStaMap | 0x01;
		}
		if(ubTemp[1])
		{
			ubStaMap = ubStaMap | 0x02;
		}
		if(ubTemp[2])
		{
			ubStaMap = ubStaMap | 0x04;
		}
		if(ubTemp[3])
		{
			ubStaMap = ubStaMap | 0x08;
		}
//		printf("Map:0x%x\r\n",ubStaMap);
	#if (KNL_DYNAMIC_SLOT == 1)
	#ifdef RTC676x
		KNL_SendStaOnLineInfo(ubStaMap);
	#endif
	#endif
		//printd(DBG_CriticalLvl, "Link:%d,%d,%d,%d\r\n",ubTemp[0],ubTemp[1],ubTemp[2],ubTemp[3]);
	#ifdef RTC676x
		ubKNL_OutFps[0] = ubKNL_OutFpsTemp[0];
		ubKNL_OutFps[1] = ubKNL_OutFpsTemp[1];
		ubKNL_OutFps[2] = ubKNL_OutFpsTemp[2];
		ubKNL_OutFps[3] = ubKNL_OutFpsTemp[3];
		
		ubKNL_OutFpsTemp[0] = 0;
		ubKNL_OutFpsTemp[1] = 0;
		ubKNL_OutFpsTemp[2] = 0;
		ubKNL_OutFpsTemp[3] = 0;

		if(pKNL_PerDbgFunc[0])
		{
			for(i = 0; i < 4; i++)
				pKNL_PerDbgFunc[0](PER_FPS_RPT, i, ubKNL_OutFps[i]);
		}
		
		printd(DBG_CriticalLvl, "Sec(%d)->(%d,%d,%d,%d_%d,%d,%d,%d)\r\n",ulSecCnt++,ubTemp[0],ubTemp[1],ubTemp[2],ubTemp[3],ubKNL_OutFps[0],ubKNL_OutFps[1],ubKNL_OutFps[2],ubKNL_OutFps[3]);
#if defined(BSP_DVR_SDK)
		printf("S_FPS:%d,%d\r\n",ulKNL_OutVdoFpsCnt[KNL_SRC_PREVIEW_LOCAL],ulKNL_OutVdoFpsCnt[KNL_SRC_STORAGE_LOCAL]);		
#endif			
	#endif
#endif

#if OP_STA			
	#ifdef RTC676x
	
		//RF Bandwidth Information
		ulRtBw = ulRTC676x_GetRtBw(0)/1024;		
		ulMaxBw = ulRTC676x_GetMaxBw()/1024;		
		
		rf_getopt(RF_DRV_OPT_TX_FREE_BUF_CNT, &free_buf_count, &free_buf_count_len);			

		printd(DBG_CriticalLvl, "Sec(%d)->(%d,%d,%d,%d,%d,%d)\r\n",ulSecCnt,rf_get_link_status(rf_get_remote_id(0)),ulMaxBw,ulRtBw,free_buf_count,osMessages(KNL_VdoPacketizeQue),ubRC_GetAvgQp(0));				
		ulSecCnt++;
	
	#if (APP_MODULATION_MODE == MODULATION_AUTO)
		//Transmission Modulation Monitor
		#if (RF_MODE_SW_SEL	== RF_MODE_SW_OLD)
		ulPreBw[ulSecCnt%REC_TIME] = ulRtBw;	
		#endif
		if(ulSecCnt > TRANS_TIME)		
		{
		#if (RF_MODE_SW_SEL	== RF_MODE_SW_NEW)	
			ubAccCnt++;
			ulAccBw += ulRtBw;
			//printf("AccCntBw[%d]:%d\r\n",ubAccCnt,ulAccBw);
			
			if((tKNL_RfModeSwInfo.tMode == MODE_QPSK) && (ubAccCnt >= REC_TIME_QPSK))
				ubUpdateInfoFlg = 1;
			else if((tKNL_RfModeSwInfo.tMode == MODE_QPSKTO16QAM) && (ubAccCnt >= REC_TIME_16QAM))
				ubUpdateInfoFlg = 1;
			else if((tKNL_RfModeSwInfo.tMode == MODE_16QAM) && (ubAccCnt >= REC_TIME_16QAM))
				ubUpdateInfoFlg = 1;
		#endif
			
		#if (RF_MODE_SW_SEL	== RF_MODE_SW_OLD)
			if((ulSecCnt % REC_TIME) == 0)			
		#endif
		#if (RF_MODE_SW_SEL	== RF_MODE_SW_NEW)
			if(ubUpdateInfoFlg)			
		#endif
			{				
			#if (RF_MODE_SW_SEL	== RF_MODE_SW_OLD)	
				ulAvgBw = 0;
				for(j=0;j<REC_TIME;j++)
				{
					ulAvgBw += ulPreBw[j];
				}
				ulAvgBw = ulAvgBw/REC_TIME;
				fKNL_PreRatio = ((float)ulAvgBw)/((float)ulMaxBw);
			#endif
			#if (RF_MODE_SW_SEL	== RF_MODE_SW_NEW)				
				ulAvgBw = ulAccBw/ubAccCnt;
				fKNL_PreRatio = ((float)ulAvgBw)/((float)ulMaxBw);
				ubAccCnt = 0;
				ulAccBw = 0;
				ulAvgBw = 0;
				ubUpdateInfoFlg = 0;
			#endif
				
				if(!ubPAIR_GetInPairIngFlg())		
				{	
					//printf("AR:%.2f\r\n",fKNL_PreRatio);
					
				#if (RF_MODE_SW_SEL == RF_MODE_SW_NEW)						
					if(tKNL_RfModulationMode == MODE_QPSK)
					{
						if(fKNL_PreRatio > KNL_RATIO_QPSKTO16QAM)
							KNL_UpdateRfModulationMode(EVENT_TRX_GOOD);
						else
							KNL_UpdateRfModulationMode(EVENT_TRX_NOTGOOD);
					}					
					else if(tKNL_RfModulationMode == MODE_16QAM)
					{
						if(fKNL_PreRatio > KNL_RATIO_16QAMTOQPSK)
							KNL_UpdateRfModulationMode(EVENT_TRX_GOOD);
						else
							KNL_UpdateRfModulationMode(EVENT_TRX_NOTGOOD);
					}					
				#endif					
				
				#if (RF_MODE_SW_SEL == RF_MODE_SW_OLD)
					if((iPreRateMode == PREF_BBR_QPSK) && (fKNL_PreRatio > KNL_RATIO_QPSKTO16QAM))
					{
						printf("QPSK->16QAM\r\n");
						KNL_NewRwBbRateMode = PREF_BBR_16QAM;
						iPreRateMode = PREF_BBR_16QAM;
					}
					else if((iPreRateMode == PREF_BBR_16QAM) && (fKNL_PreRatio < KNL_RATIO_16QAMTOQPSK))
					{
						printf("16QAM->QPSK\r\n");
						KNL_NewRwBbRateMode = PREF_BBR_QPSK;
						iPreRateMode = PREF_BBR_QPSK;
					}
				#endif
				}
			}
		}	
	#endif
				
		//Slot Mode Switch
		BwRptType = rf_get_bandwidth_config();
		if(BwRptType == BW_FULL_BANDWIDTH)
		{			
			KNL_CurBwType = BW_FULL_BANDWIDTH;
			//printf("Full-BW*(1)\r\n");			
		}
		else if(BwRptType == BW_HALF_BANDWIDTH)
		{
			KNL_CurBwType = BW_HALF_BANDWIDTH;
			//printf("Full-BW*(1/2)\r\n");
		}
		else if(BwRptType == BW_QUARTER_BANDWIDTH)
		{
			KNL_CurBwType = BW_QUARTER_BANDWIDTH;
			//printf("Full-BW*(1/4)\r\n");
		}
		else if(BwRptType == BW_NONE) 
		{
			//printf("Full-BW*(0)\r\n");
		}
		else 
		{
			//printf("Full-BW->Err\r\n");
		}
		
		if(KNL_CurBwType != KNL_PreBwType)
		{
			if(KNL_CurBwType == BW_FULL_BANDWIDTH)
			{
				KNL_SetTXRSlotNum(1);				
				
				printf("Full-BW*(1)\r\n");
			}
			else if(KNL_CurBwType == BW_HALF_BANDWIDTH)
			{
				KNL_SetTXRSlotNum(2);				
				printf("Full-BW*(1/2)\r\n");
			}
			else if(KNL_CurBwType == BW_QUARTER_BANDWIDTH)
			{
				KNL_SetTXRSlotNum(4);				
				printf("Full-BW*(1/4)\r\n");
			}
			if(RC_MODE_DYNAMIC_FPS2 == ubRC_GetOpMode((H264_ENCODE_INDEX)ENCODE_0))
			{
				RC_DynamicFpsMode(ubKNL_GetSysMaxFps(),RC_MIN_FPS,RC_SECTION_NUM,1);
			}
		}
		KNL_PreBwType = KNL_CurBwType;
		#if TRXBW_RPT_EN
		tKNLInfo.ubTwcCmd 	  = TWC_TRXBW_RPT;
		tKNLInfo.ubTargetRole = KNL_MASTER_AP;
		if(osMessagePut(KNL_TwcMonitQueue, &tKNLInfo, 0) == osErrorResource)
		{
			printd(DBG_ErrorLvl, "KNL_TwcMonitQ->Full !!!!\r\n");
		}
		#endif
    #endif
	#ifndef S2019A
		if(KNL_PERDBG_ON == ubKNL_PerDbgEn)
		{
			tKNLInfo.ubTwcCmd = TWC_SYNC_FRAME;
			tKNLInfo.ubTargetRole = KNL_MASTER_AP;
			if(osMessagePut(KNL_TwcMonitQueue, &tKNLInfo, 0) == osErrorResource)
			{
				printd(DBG_ErrorLvl, "KNL_TwcMonitQ->Full !!!!\r\n");
			}
		}
	#endif
#endif
		
#ifdef RTC676x		
		//Software Reset Mechanism for CRC-Fail or Err-Report of Internal RF Driver
		//==========================================================================
		if(ubKNL_AccessErrCnt(KNL_OPERATION_GET,0) >= KNL_ERR_CNT_TH)
		{			
			ubKNL_ErrFlg[ulSecCnt%KNL_ERR_STATIC] = 1;			
		}
		else
		{			
			ubKNL_ErrFlg[ulSecCnt%KNL_ERR_STATIC] = 0;		
		}
		ubKNL_AccessErrCnt(KNL_OPERATION_SET,0);
		
		ubErrCnt = 0;
		for(i=0;i<KNL_ERR_STATIC;i++)
		{
			if(ubKNL_ErrFlg[i])
				ubErrCnt++;	
		}
		if(ubErrCnt == KNL_ERR_STATIC)
		{			
			for(i=0;i<KNL_ERR_STATIC;i++)
			{
				ubKNL_ErrFlg[i] = 0;	
			}			
			printf("RF_SWR(S)\r\n");				
			rf_setopt(RF_OPT_SW_RST, &reset, 1);
			printf("RF_SWR(E)\r\n");
		}

		//State Machine
		//==============		
		if(ulSecCnt>5)
		{
			ubStartMonitIsrFlg = 1;
		}
		if(ubStartMonitIsrFlg && ubKNL_InitBBFlg)
		{
			udlIsrCntNow = udlRTC676x_GetIsrCnt();			
			
			if(udlIsrCntNow == udlIsrCntPrevious)
				ubIsrErrFlg = 1;
			else
				ubIsrErrFlg = 0;
			
			udlIsrCntPrevious = udlIsrCntNow;
		}
		else
		{
			ubIsrErrFlg = 0;
		}		

		//if(!ubPAIR_GetInPairIngFlg())		
		if((!ubPAIR_GetInPairIngFlg())&& ubRTC676x_GetRunState())
		{
		#if OP_STA
			if(rf_get_link_status(rf_get_remote_id(0)))
			{
				ubLinkStatus[ulSecCnt%KNL_RF_MONIT_TIME] = 1;
			}
			else
			{
				ubLinkStatus[ulSecCnt%KNL_RF_MONIT_TIME] = 0;
			}
		#endif
		#if OP_AP
			if(rf_get_link_status(rf_get_remote_id(0))||rf_get_link_status(rf_get_remote_id(1))||rf_get_link_status(rf_get_remote_id(2))||rf_get_link_status(rf_get_remote_id(3)))
			{			
				ubLinkStatus[ulSecCnt%KNL_RF_MONIT_TIME] = 1;
			}
			else
			{
				ubLinkStatus[ulSecCnt%KNL_RF_MONIT_TIME] = 0;
			}
		#endif
			
			if((ulSecCnt%KNL_RF_MONIT_TIME) == 0)
			{
				ubLinkFlg = 0;
				for(k=0;k<KNL_RF_MONIT_TIME;k++)
				{
					if(ubLinkStatus[k])
					{
						ubLinkFlg = 1;
						break;
					}
				}
				
				if(ubIsrErrFlg)
				{
					//printf("(No Interrupt)\r\n");
					KNL_UpdateRfState(NO_INTERRUPT_EVENT);	
				}
				else
				{
					if(ubLinkFlg)
					{
						//printf("(LINK)\r\n");
						KNL_UpdateRfState(LINK_EVENT);
					}
					else
					{
						//printf("(NO LINK)\r\n");
						KNL_UpdateRfState(NO_LINK_EVENT);
					}
				}

				//Clear Static
				for(i=0;i<KNL_RF_MONIT_TIME;i++)
					ubLinkStatus[i] = 0;				
			}			
		}		
	#endif
		osDelay(1000);
	}
}

//------------------------------------------------------------------------------
#if APP_TIMESTAMP_FUNC_ENABLE
static void KNL_RtcMonitorThread(void const *argument)
{
	while(1)
	{
		wRTC_GETCALENDAR(&tKNL_SysCalendar);
		osDelay(500);
	}
}
#endif
//------------------------------------------------------------------------------
#if (defined(OP_STA) || (defined(OP_AP) && defined(BSP_DVR_SDK)))
void KNL_IspDsFunc(void)
{
	uint8_t ubISP_DS[32] = {
        12,  12,  12,  12,  12,  12,  12,  12,
        12,  12,  12,  12,  12,  12,  12,  12,
        12,  12,  12,  12,  12,  12,  12,  12,
        12,  12,  12,  12,  12,  12,  12,  12,
    };
	uint8_t ubIdx;
	uint32_t ulBwDsYPos = 0;
	KNL_SRC tSrcNum;
	uint16_t uwV;
	static uint8_t ubKNL_RfIspDsEnFlag = FALSE;

	if(ptKNL_VdoRoleMap2SrcNum)
		tSrcNum = ptKNL_VdoRoleMap2SrcNum(KNL_MAIN_PATH, (KNL_ROLE)ubKNL_GetRole());
	else
		tSrcNum = (KNL_SRC)(KNL_SRC_1_MAIN + ubKNL_GetRole());
	uwV = uwKNL_GetVdoV(tSrcNum);
#if APP_TIMESTAMP_FUNC_ENABLE
#if OP_STA
	if( ubRtcSync == TRUE )
#endif
#if (defined(OP_AP) && defined(BSP_DVR_SDK))
	if(1)
#endif
	{
	#if (BSP_RTC_TIMER_SEL != RTC_TIMER_NULL)
		ubISP_DS[0] = tKNL_SysCalendar.uwYear  / 1000;
		ubISP_DS[1] = (tKNL_SysCalendar.uwYear / 100)%10;
		ubISP_DS[2] = (tKNL_SysCalendar.uwYear / 10)%10;
		ubISP_DS[3] = (tKNL_SysCalendar.uwYear)%10;

		ubISP_DS[4] = 10;                                 //-
		ubISP_DS[5] = (tKNL_SysCalendar.ubMonth / 10)%10;
		ubISP_DS[6] = (tKNL_SysCalendar.ubMonth)%10;

		ubISP_DS[7] = 10;                                 //-
		ubISP_DS[8] = (tKNL_SysCalendar.ubDate / 10)%10;
		ubISP_DS[9] = (tKNL_SysCalendar.ubDate)%10;
		ubISP_DS[10] = 12;

		ubISP_DS[11] = (tKNL_SysCalendar.ubHour / 10)%10;
		ubISP_DS[12] = (tKNL_SysCalendar.ubHour)%10;
		ubISP_DS[13] = 11;                                //:
		ubISP_DS[14] = (tKNL_SysCalendar.ubMin / 10)%10;
		ubISP_DS[15] = (tKNL_SysCalendar.ubMin)%10;
		ubISP_DS[16] = 11;                                //:
		ubISP_DS[17] = (tKNL_SysCalendar.ubSec / 10)%10;
		ubISP_DS[18] = (tKNL_SysCalendar.ubSec)%10;
	#endif
		if(uwRtcPosY != (uwV - (16 * ((uwV > VGA_HEIGHT)?2:1) * 2)))
			uwRtcPosY = (uwV - (16 * ((uwV > VGA_HEIGHT)?2:1) * 2));
		ISP_OsdLine1Display(DS_PATH1, &ubISP_DS[0], 32, uwRtcPosX, uwRtcPosY);
#if defined(BSP_DVR_SDK)
#if defined(OP_AP)
		ISP_OsdLine1Display(DS_PATH2, &ubISP_DS[0], 32, uwRtcPosX+200, uwRtcPosY);
#else
        ISP_OsdLine1Display(DS_PATH2, &ubISP_DS[0], 32, uwRtcPosX, uwRtcPosY);
#endif
#elif defined(BSP_VBM_SDK)
        ISP_OsdLine1Display(DS_PATH2, &ubISP_DS[0], 32, ((VDO_SUB_H_SIZE>>1) - 320)  , (VDO_SUB_V_SIZE-50));
#endif
	}
	else
	{
		uwRtcPosX = 0;
		uwRtcPosY = (uwV - (16 * ((uwV > VGA_HEIGHT)?2:1) * 2));
	}
#else
	{
		uwRtcPosX = 0;
		uwRtcPosY = (uwV - (16 * ((uwV > VGA_HEIGHT)?2:1) * 2));
	}
#endif

	if(uwKNL_GetVdoH(ubKNL_GetRole()) == FHD_WIDTH)
	{
		ISP_SetLine1Gain(DS_PATH1, DS_GAIN2);
		ISP_SetLine2Gain(DS_PATH1, DS_GAIN2);
#if (defined(OP_STA)&&defined(APP_TXREC_STREAM_SEL)&&(APP_TXREC_STREAM_SEL!=0))
        ISP_SetLine1Gain(DS_PATH2, DS_GAIN2);
        ISP_SetLine2Gain(DS_PATH2, DS_GAIN2);
#endif
		ulBwDsYPos = uwRtcPosY + 16 * DS_GAIN2;
	}
	else if(uwKNL_GetVdoH(ubKNL_GetRole()) == HD_WIDTH)
	{
		ISP_SetLine1Gain(DS_PATH1, DS_GAIN2);
		ISP_SetLine2Gain(DS_PATH1, DS_GAIN2);
#if (defined(OP_STA)&&defined(APP_TXREC_STREAM_SEL)&&(APP_TXREC_STREAM_SEL!=0))
        ISP_SetLine1Gain(DS_PATH2, DS_GAIN2);
		ISP_SetLine2Gain(DS_PATH2, DS_GAIN2);
#endif
		ulBwDsYPos = uwRtcPosY + 16 * DS_GAIN2;
	}
	else
	{
#if (defined(OP_AP) && defined(BSP_DVR_SDK))
		ISP_SetLine1Gain(DS_PATH1, DS_GAIN2);
		ISP_SetLine2Gain(DS_PATH1, DS_GAIN2);
		ulBwDsYPos = uwRtcPosY + 16 * DS_GAIN2;
#else
        ISP_SetLine1Gain(DS_PATH1, DS_GAIN1);
        ISP_SetLine2Gain(DS_PATH1, DS_GAIN1);
        ulBwDsYPos = uwRtcPosY + 16 * DS_GAIN1;
#endif
	}
#if !defined(BSP_DVR_SDK)
	if((KNL_PERDBG_OFF == ubKNL_PerDbgEn) && (FALSE == ubKNL_RfIspDsEnFlag))
		return;
#endif
	for(ubIdx = 0; ubIdx < 32; ubIdx++)
		ubISP_DS[ubIdx] = 12;
	if(KNL_PERDBG_ON == ubKNL_PerDbgEn)
	{
#if (defined(A7130) || defined(RTC676x))
		uint8_t ubLinkSts;
        uint32_t ulRfBwRpt = 0;

	#ifdef A7130
		ubLinkSts = ubKNL_GetRtCommLinkStatus(KNL_MASTER_AP);
#if defined(BSP_DVR_SDK)
		ulRfBwRpt = 0;
#else
		ulRfBwRpt = ulBB_GetBBFlow(BB_GET_TXMAP_VOD_FLOW) / 1024;
#endif
	#endif
	#ifdef RTC676x
		ubLinkSts = ubKNL_GetRtCommLinkStatus(0);
		ulRfBwRpt = ulRTC676x_GetRtBw(0) / 1024;
	#endif
		ubISP_DS[0] = FONT_L;
		ubISP_DS[1] = FONT_i;
		ubISP_DS[2] = FONT_n;
		ubISP_DS[3] = FONT_k;
		ubISP_DS[4] = FONT_COLON;
		ubISP_DS[5] = (ubLinkSts / 1) % 10;
		ubISP_DS[6] = FONT_SPACE;
		ubISP_DS[7] = FONT_B;
		ubISP_DS[8] = FONT_W;
		ubISP_DS[9] = FONT_COLON;
		ubISP_DS[10] = ((ulRfBwRpt / 100) % 10 == 0)?FONT_SPACE:(ulRfBwRpt / 100) % 10;
		ubISP_DS[11] = (ulRfBwRpt / 10) % 10;
		ubISP_DS[12] = (ulRfBwRpt / 1) % 10;
		ubISP_DS[13] = FONT_K;
		ubISP_DS[14] = FONT_B;
		ubISP_DS[15] = FONT_SPACE;
        ubISP_DS[16] = (ubKNL_GetRxFrameNumber / 10) % 10;
        ubISP_DS[17] = (ubKNL_GetRxFrameNumber / 1) % 10;
#endif
#if (defined(S2019A) && defined(OP_STA))
		uint8_t ubDsValue = 0;
        uint32_t ulRfBwRpt = 0;

		ubISP_DS[0]  = ubsPRF_GetAttachedDevNums();
		ubISP_DS[1]  = FONT_SPACE;
		ubISP_DS[2]  = FONT_L;
		ubISP_DS[3]  = tsPRF_GetRateLvl();
		ubISP_DS[4]  = FONT_SPACE;
		ubDsValue    = ubKNL_GetSPRFDataBufNum(tsPRF_GetDevId());
		ubISP_DS[5]  = (ubDsValue / 10) % 10;
		ubISP_DS[6]  = (ubDsValue / 1) % 10;
		ubISP_DS[7]  = FONT_SPACE;
		ubISP_DS[8]  = FONT_COLON;
		ubDsValue 	 = ubRC_GetAvgQp(0);
		ubISP_DS[9]  = (ubDsValue / 10) % 10;
		ubISP_DS[10] = (ubDsValue / 1) % 10;
		ubISP_DS[11] = FONT_SPACE;
		ubISP_DS[12] = FONT_COLON;
		ubDsValue 	 = tsPRF_GetPER(tsPRF_GetDevId());
		ubISP_DS[13] = (ubDsValue / 10) % 10;
		ubISP_DS[14] = (ubDsValue / 1) % 10;
		ubISP_DS[15] = FONT_SPACE;
		ulRfBwRpt 	 = ulKNL_GetDataBitRate(KNL_DATA_TYPE_VDO, 0)/8192;
		ubISP_DS[16] = ((ulRfBwRpt / 100) % 10 == 0)?FONT_SPACE:(ulRfBwRpt / 100) % 10;
		ubISP_DS[17] = (ulRfBwRpt / 10) % 10;
		ubISP_DS[18] = (ulRfBwRpt / 1) % 10;
		ubISP_DS[19] = FONT_K;
		ubISP_DS[20] = FONT_B;
#endif
		ISP_OsdLine2Display(DS_PATH1, &ubISP_DS[0], 32, uwRtcPosX, ulBwDsYPos);
		ubKNL_RfIspDsEnFlag = TRUE;
	}
	else if((TRUE == ubKNL_RfIspDsEnFlag) && (KNL_PERDBG_OFF == ubKNL_PerDbgEn))
	{
		ISP_OsdLine2Display(DS_PATH1, &ubISP_DS[0], 32, uwRtcPosX, ulBwDsYPos);
		ubKNL_RfIspDsEnFlag = FALSE;
	}
}
//------------------------------------------------------------------------------
pvImgDsUpdFunc pKNL_ImgDsUpdFunc = NULL;
void KNL_ImgCtrlDsFunc(void)
{
	KNL_ImgCtrlDsInfo_t tDsInfo;
	KNL_SRC tSrcNum;
	static uint8_t ubKNL_RfImgDsEnFlag = FALSE;

	if(ptKNL_VdoRoleMap2SrcNum)
		tSrcNum = ptKNL_VdoRoleMap2SrcNum(KNL_MAIN_PATH, (KNL_ROLE)ubKNL_GetRole());
	else
		tSrcNum = (KNL_SRC)(KNL_SRC_1_MAIN + ubKNL_GetRole());
	tDsInfo.uwImg_HSize  = uwKNL_GetVdoH(tSrcNum);
	tDsInfo.uwImg_VSize  = uwKNL_GetVdoV(tSrcNum);
	tDsInfo.ulDs_BufAddr = ulBUF_GetBlkBufAddr(0, BUF_IMG_DS1);
#if APP_TIMESTAMP_FUNC_ENABLE
	if(ubRtcSync == TRUE)
	{
		if(uwRtcPosY != (tDsInfo.uwImg_VSize - IMG_DS3_Height))
		{
			uwRtcPosX = (VGA_WIDTH == tDsInfo.uwImg_HSize)?(70*4):(DISPLAY_MODE == DISPLAY_2T1R)?210:0;
			uwRtcPosY = tDsInfo.uwImg_VSize - IMG_DS3_Height;
		}
		ubKNL_RfImgDsEnFlag = TRUE;
	}
#else
	uwRtcPosX = 0;
	uwRtcPosY = tDsInfo.uwImg_VSize - IMG_DS3_Height;
	ubKNL_RfImgDsEnFlag = FALSE;
#endif
	tDsInfo.ubDsEn = ((KNL_PERDBG_OFF == ubKNL_PerDbgEn) && (FALSE == ubKNL_RfImgDsEnFlag))?FALSE:TRUE;
	tDsInfo.uwDs_PosX = uwRtcPosX;
	tDsInfo.uwDs_PosY = uwRtcPosY;
	tDsInfo.ubDs[0]   = ubKNL_GetRxFrameNumber;
	if(pKNL_ImgDsUpdFunc)
		pKNL_ImgDsUpdFunc(tDsInfo);
}
//------------------------------------------------------------------------------
void KNL_SetDsUpdCbFunc(pvImgDsUpdFunc pImgDsCb)
{
	pKNL_ImgDsUpdFunc = pImgDsCb;
}
#endif

//------------------------------------------------------------------------------
#if APP_TIMESTAMP_FUNC_ENABLE
static void KNL_TimeStampThread(void const *argument)
{
#if OP_STA
    uint32_t ulRtcReSyncTime = 3600000;        //60 Min (60*60*1000)
    uint32_t ulRtcReSyncCnt  = 0;
#endif
	while(1)
	{
#if OP_AP
		osDelay(5000);
#elif OP_STA
		#ifdef RVCS_APP
		if(sPRF_APDIRECT_MODE == tKNL_sPRFDrvMd)
		{
			ubRtcSync = FALSE;
			osDelay(300);
			continue;
		}
		#endif
		if( ubRtcSync == FALSE )
		{
			if(ubKNL_GetCommLinkStatus(KNL_MASTER_AP))
			{
				if(ubKNL_TwcSend(KNL_MASTER_AP, TWC_SYNC_TIMESTAMP, 0, 1, 16) != TWC_SUCCESS)
					printf(" TWC_SYNC_TIMESTAMP -> Fail\r\n");
			#ifdef S2019A
				osDelay(100);
				continue;
			#endif
			}
		}
		else
		{
            ulRtcReSyncCnt += 30;
            if(ubKNL_GetCommLinkStatus(KNL_MASTER_AP))
            {
                if(ulRtcReSyncCnt > ulRtcReSyncTime)
                {
                    if(ubKNL_TwcSend(KNL_MASTER_AP, TWC_SYNC_TIMESTAMP, 0, 1, 16) != TWC_SUCCESS)
						printf(" TWC_SYNC_TIMESTAMP -> Fail\r\n");
                    else ulRtcReSyncCnt = 0;
                }
            }
            else    ulRtcReSyncCnt = ulRtcReSyncTime-3000;
		}
		osDelay(30);
#endif
	}
}
#endif

#if (APP_REC_FUNC_ENABLE && OP_STA)
static void KNL_TxRecThread(void const *argument)
{
	while(1)
	{
        KNL_TXRecordProcess();
		osDelay(TXREC_TIMEOUT_SCALE);
	}
}
#endif

#if (defined(OP_STA) && !defined(S2019A))
static void KNL_GOPSyncThread(void const *argument)
{
	while(1)
	{
		if(ubGopSync & KNL_GOPSYNC_RECV)
		{
			if(!ubKNL_GetCommLinkStatus(KNL_MASTER_AP))
			{
				ubGopSync = KNL_GOPSYNC_INIT;
				osDelay(500);
				continue;
			}
			osDelay(2000);
		}
		else
		{
			KNL_PROCESS tKNLInfo;

			tKNLInfo.ubTwcCmd = TWC_SYNC_GOP;
			tKNLInfo.ubTargetRole = KNL_MASTER_AP;
			if(osMessagePut(KNL_TwcMonitQueue, &tKNLInfo, 0) == osErrorResource)
			{
				printd(DBG_ErrorLvl, "KNL_TwcMonitQ->Full !!!!\r\n");
			}
			else ubGopSync |= KNL_GOPSYNC_SEND;
			osDelay(100);
		}             
	}
}
#endif 

//------------------------------------------------------------------------------
#if APP_ADO_FUNC_ENABLE
static void KNL_AdoEncMonitThread(void const *argument)
{
	ADO_Queue_INFO tAdoInfo;
	KNL_PROCESS tProcess;
	KNL_SRC tKNL_AdoSrcNum;
	uint32_t ulAddr,ulSize;
	uint8_t ubSrcNum;

	while(1)
	{
		//Get Queue from Audio Interface
		osMessageGet(tKNL_EncEventQue, &tAdoInfo, osWaitForever);
		
		if(KNL_VIDEO_PLAY == tKNL_GetRecordFunc())
			continue;
		
		if(tAdoInfo.EncType == NONE)
		{
			if(tKNL_AdoInfo.HwCompressMode == COMPRESS_ALAW)
			{
				printd(DBG_Debug3Lvl, "AdoEncQ(ALAW) : Addr:0x%x,SZ:0x%x\r\n",tAdoInfo.SrcAddr,tAdoInfo.SrcSize);
			}
			else if(tKNL_AdoInfo.HwCompressMode == COMPRESS_NONE)
			{
				printd(DBG_Debug3Lvl, "AdoEncQ(PCM) : Addr:0x%x,SZ:0x%x\r\n",tAdoInfo.SrcAddr,tAdoInfo.SrcSize);
			}
			ulAddr = tAdoInfo.SrcAddr;
			ulSize = tAdoInfo.SrcSize;
		}
		else if(tAdoInfo.EncType == ADO32)
		{
			printd(DBG_Debug3Lvl, "AdoEncQ(Audio32) : Addr:0x%x,SZ:0x%x\r\n",tAdoInfo.SrcAddr,tAdoInfo.SrcSize);
			ulAddr = tAdoInfo.SrcAddr;
			ulSize = tAdoInfo.SrcSize;
		}
		else if(tAdoInfo.EncType == ALAW)
		{	
			printd(DBG_Debug3Lvl, "AdoEncQ(Alaw) : Addr:0x%x,SZ:0x%x\r\n",tAdoInfo.SrcAddr,tAdoInfo.SrcSize);
			ulAddr = tAdoInfo.SrcAddr;
			ulSize = tAdoInfo.SrcSize;
		}
		else if(tAdoInfo.EncType == AAC)
		{	
			printd(DBG_Debug3Lvl, "AdoEncQ(AAC) : Addr:0x%x,SZ:0x%x\r\n",tAdoInfo.SrcAddr,tAdoInfo.SrcSize);
			ulAddr = tAdoInfo.SrcAddr;
			ulSize = tAdoInfo.SrcSize;
		}

		tKNL_AdoSrcNum = KNL_SRC_NONE;
		//Send Queue to processthread
		for(ubSrcNum = KNL_SRC_1_OTHER_A; ubSrcNum <= KNL_SRC_4_OTHER_B; ubSrcNum++)
		{
			if(ubKNL_ExistNode(ubSrcNum, KNL_NODE_ADC))
			{
				#ifdef OP_STA
				if((ubSrcNum % 4) == ubKNL_GetRole())
				{
					tKNL_AdoSrcNum = (KNL_SRC)ubSrcNum;
					break;
				}
				#endif
				#ifdef OP_AP
				tKNL_AdoSrcNum = (KNL_SRC)ubSrcNum;
				break;
				#endif
			}
		}
		if((KNL_SRC_NONE != tKNL_AdoSrcNum) && (ubKNL_ChkAdoFlowAct(tKNL_AdoSrcNum)))
		{
		#ifdef S2019A
			tProcess.ubSrcNum	 = tKNL_AdoSrcNum;
			tProcess.ubCurNode 	 = KNL_NODE_ADC;
			tProcess.ubNextNode  = ubKNL_GetNextNode(tKNL_AdoSrcNum,KNL_NODE_ADC);
			tProcess.ulDramAddr1 = 0;
			if(sPRF_APDIRECT_MODE != tKNL_sPRFDrvMd)
			{
				uint32_t ulAdcBufAddr = 0;
				DMAC_RESULT tDmaResult = DMAC_OK;

				ulAdcBufAddr = ulBUF_GetAdcFreeBuf();
				if(BUF_FAIL == ulAdcBufAddr)
					continue;
				tDmaResult = tDMAC_MemCopy(ulAddr, ulAdcBufAddr, ulSize, NULL);
				if(DMAC_OK != tDmaResult)
				{
					ubBUF_ReleaseAdcBuf(ulAdcBufAddr);
					printd(DBG_ErrorLvl, "DMA NRDY @%s !\n", __func__);
					continue;
				}
				tProcess.ulDramAddr2 = ulAdcBufAddr;
				tProcess.ulSize 	 = ulKNL_AddAuxInfo(KNL_ADO_PKT, tKNL_AdoSrcNum, ulAdcBufAddr, ulSize, 0, 0, 0, KNL_TIMER_Get1ms());
			}
			else
			{
				tProcess.ulDramAddr2 = ulAddr;
				tProcess.ulSize		 = ulSize;
			}
		#else
			tProcess.ubSrcNum	 = tKNL_AdoSrcNum;
			tProcess.ubCurNode 	 = KNL_NODE_ADC;
			tProcess.ubNextNode  = ubKNL_GetNextNode(tKNL_AdoSrcNum,KNL_NODE_ADC);
			tProcess.ulDramAddr1 = 0;
			tProcess.ulDramAddr2 = ulAddr;
			tProcess.ulSize		 = ulSize;
		#endif
//			KNL_AdcBufProcess(tProcess);
			if(osMessagePut(KNL_AdoCodecProcQueue, &tProcess, 0) == osErrorResource)
			{
				printd(DBG_ErrorLvl, "KNL_ADO Q->Full !!!!\r\n");
			}
		}
	}
}
#endif
//------------------------------------------------------------------------------
#if (APP_REC_FUNC_ENABLE && ( OP_AP || ( OP_STA && APP_PLAY_REMOTE_ENABLE )))
uint8_t ubKNL_PLY_ADOBufChk(uint32_t ulSize)
{
#if APP_ADO_FUNC_ENABLE
    #if OP_AP
	if(ADO_DecBufWrtInChk(MOVIE_PLY, ALAW, ulSize)==DEC_BUF_EMPTY)
		return 1;
	else
		return 0;
    #else
	return 1;
    #endif
#else
	return 1;
#endif
}
//------------------------------------------------------------------------------
void KNL_PLY_ADOBufWrite(uint8_t EncType, uint32_t ulSrcAdr, uint32_t ulSize)
{
    #if (OP_STA && APP_PLAY_REMOTE_ENABLE)
    uint32_t ulAlawDecAddr;
    uint32_t ulAlawDecSz;
    uint32_t ulAdo32EncAddr;
    ADO_AUD32_ENC_INFO tAdo32EncInfo;
	ADO_ENC_PACK_INFO_t *AdoEncPackInfo;
	uint32_t ulEncAddr;

    //alaw decode
    ulAlawDecAddr = ulBUF_GetAdcFreeBuf();
    if(BUF_FAIL == ulAlawDecAddr)
        return;
    if(ulTxPlyAdo32EncRemainDataSz!=0)
    {
        memcpy((uint8_t*)ulAlawDecAddr, (uint8_t*)ubTxPlyAdo32EncRemainDataBuf, ulTxPlyAdo32EncRemainDataSz);
    }
    if( ADO_Alaw_Decode(ulSrcAdr, ulAlawDecAddr+ulTxPlyAdo32EncRemainDataSz, ulSize, &ulAlawDecSz)==ALAW_ERROR )
    {
        printd(DBG_ErrorLvl, "KNL PLY ADOBufWrite fail->alaw sw dec fail!\n");
		if(ubBUF_ReleaseAdcBuf(ulAlawDecAddr) == BUF_OK)
			printd(DBG_Debug3Lvl, "KNL PLY ADOBufWrite->Release alaw dec buf Ok\r\n");
		else
			printd(DBG_ErrorLvl, "KNL PLY ADOBufWrite fail->Release alaw dec buf Fail\r\n");
        return;
    }
    
    //ado32 encode
    ulAdo32EncAddr = ulBUF_GetAdcFreeBuf();
    if(BUF_FAIL == ulAdo32EncAddr)
	{
		if(ubBUF_ReleaseAdcBuf(ulAlawDecAddr) == BUF_OK)
			printd(DBG_Debug3Lvl, "KNL PLY ADOBufWrite->Release alaw dec buf Ok\r\n");
		else
			printd(DBG_ErrorLvl, "KNL PLY ADOBufWrite fail->Release alaw dec buf Fail\r\n");
        return;
	}
	
	AdoEncPackInfo = (ADO_ENC_PACK_INFO_t*)ulAdo32EncAddr;
	ulEncAddr = ulAdo32EncAddr + sizeof(ADO_ENC_PACK_INFO_t);
	
	memset((uint8_t*)AdoEncPackInfo, 0x0, sizeof(ADO_ENC_PACK_INFO_t));
	memcpy(AdoEncPackInfo->chADO_StreamTag, ADO_STREAM_TAG, sizeof(ADO_STREAM_TAG)-1);
	AdoEncPackInfo->ulStartupFlag = ulTxPlyAdo32EncFirstFlg;
	AdoEncPackInfo->ulTimestamp   = KNL_TIMER_Get1ms();
    if(ulTxPlyAdo32EncFirstFlg==1)
        ulTxPlyAdo32EncFirstFlg = 0;
	#if(defined(S2019A) && defined(BSP_RVCS_SDK))
    tAdo32EncInfo = ADO_Ado32_Encode(0, ulAlawDecAddr, ulEncAddr, ulAlawDecSz+ulTxPlyAdo32EncRemainDataSz);
    #else
    tAdo32EncInfo = ADO_Ado32_Encode(0, ulAlawDecAddr, ulEncAddr, ulAlawDecSz);
    #endif
    if(!tAdo32EncInfo.ulOutputSize)
    {
        printd(DBG_ErrorLvl, "KNL PLY ADOBufWrite fail->ADO32 ENC Fail @%s !\n", __func__);
		if(ubBUF_ReleaseAdcBuf(ulAlawDecAddr) == BUF_OK)
			printd(DBG_Debug3Lvl, "KNL PLY ADOBufWrite->Release alaw dec buf Ok\r\n");
		else
			printd(DBG_ErrorLvl, "KNL PLY ADOBufWrite fail->Release alaw dec buf Fail\r\n");
		if(ubBUF_ReleaseAdcBuf(ulAdo32EncAddr) == BUF_OK)
			printd(DBG_Debug3Lvl, "KNL PLY ADOBufWrite->Release alaw dec buf Ok\r\n");
		else
			printd(DBG_ErrorLvl, "KNL PLY ADOBufWrite fail->Release alaw dec buf Fail\r\n");
		return;
    }
	AdoEncPackInfo->ulEncodedSize = tAdo32EncInfo.ulOutputSize;
	// set other info
	AdoEncPackInfo->EncType    = ADO32;
	AdoEncPackInfo->SampleRate = SAMPLERATE_16kHZ;
	AdoEncPackInfo->Channel    = MONO;
	AdoEncPackInfo->ubReserved = 0;
	
    //move remain data to remain buffer
    ulTxPlyAdo32EncRemainDataSz = tAdo32EncInfo.ulRemainSize;
    if(tAdo32EncInfo.ulRemainSize!=0)
    {
        memcpy((uint8_t*)ubTxPlyAdo32EncRemainDataBuf, (uint8_t*)tAdo32EncInfo.ulRemainStartAddr, ulTxPlyAdo32EncRemainDataSz);
    }

    //send to rf
	KNL_TxAdoPly(ulAdo32EncAddr, tAdo32EncInfo.ulOutputSize+sizeof(ADO_ENC_PACK_INFO_t));

    //release alaw dec buffer
    if(ubBUF_ReleaseAdcBuf(ulAlawDecAddr) == BUF_OK)
        printd(DBG_Debug3Lvl, "KNL PLY ADOBufWrite->Release alaw dec buf Ok\r\n");
    else
        printd(DBG_ErrorLvl, "KNL PLY ADOBufWrite fail->Release alaw dec buf Fail\r\n");
    
    //release ado32 enc buffer
    if(ubBUF_ReleaseAdcBuf(ulAdo32EncAddr) == BUF_OK)
        printd(DBG_Debug3Lvl, "KNL PLY ADOBufWrite->Release alaw dec buf Ok\r\n");
    else
        printd(DBG_ErrorLvl, "KNL PLY ADOBufWrite fail->Release alaw dec buf Fail\r\n");
	
    #elif OP_AP
    ADO_Queue_INFO pAdoInfo;
	pAdoInfo.PlyType = MOVIE_PLY;
	pAdoInfo.EncType = (ADO_ENCODE_TYPE)EncType;
	pAdoInfo.SrcAddr = ulSrcAdr;
	pAdoInfo.SrcSize = ulSize;
	if(ubADO_DecBufWrtIn(&pAdoInfo)==0)
	{
		printf("KNL PLY ADOBufWrite fail->DecBufWrt fail\n");
	}
    #endif
}
void KNL_PLY_ADODacMute(uint8_t ubMuteFlg)
{
	if(ubMuteFlg==0)
		ADO_SetDacMute(DAC_MR_0p5DB_1SAMPLE, ADO_OFF);
	else
		ADO_SetDacMute(DAC_MR_0p5DB_1SAMPLE, ADO_ON);
}
#if (OP_STA && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
void KNL_TxAdoPly(uint32_t ulSrcAdr, uint32_t ulSize)
{
	KNL_SRC tKNL_AdoSrcNum;
	uint8_t ubSrcNum;
	KNL_PROCESS tProcess;
	
	tKNL_AdoSrcNum = KNL_SRC_NONE;
	//Send Queue to processthread
	for(ubSrcNum = KNL_SRC_1_OTHER_A; ubSrcNum <= KNL_SRC_4_OTHER_B; ubSrcNum++)
	{
		if(ubKNL_ExistNode(ubSrcNum, KNL_NODE_ADC))
		{
			if((ubSrcNum % 4) == ubKNL_GetRole())
			{
				tKNL_AdoSrcNum = (KNL_SRC)ubSrcNum;
				break;
			}
		}
	}
	if((KNL_SRC_NONE != tKNL_AdoSrcNum) && (ubKNL_ChkAdoFlowAct(tKNL_AdoSrcNum)))
	{
	#ifdef S2019A
		tProcess.ubSrcNum	 = tKNL_AdoSrcNum;
		tProcess.ubCurNode 	 = KNL_NODE_ADC;
		tProcess.ubNextNode  = ubKNL_GetNextNode(tKNL_AdoSrcNum, KNL_NODE_ADC);
		tProcess.ulDramAddr1 = 0;
		if(sPRF_APDIRECT_MODE != tKNL_sPRFDrvMd)
		{
			uint32_t ulAdcBufAddr = 0;
			DMAC_RESULT tDmaResult = DMAC_OK;

			ulAdcBufAddr = ulBUF_GetAdcFreeBuf();
			if(BUF_FAIL == ulAdcBufAddr) {
				return;
			}
			tDmaResult = tDMAC_MemCopy(ulSrcAdr, ulAdcBufAddr, ulSize, NULL);
			if(DMAC_OK != tDmaResult)
			{
				ubBUF_ReleaseAdcBuf(ulAdcBufAddr);
				printd(DBG_ErrorLvl, "DMA NRDY @%s !\n", __func__);
				return;
			}

			tProcess.ulDramAddr2 = ulAdcBufAddr;
			tProcess.ulSize 	 = ulKNL_AddAuxInfo(KNL_ADO_PKT, tKNL_AdoSrcNum, ulAdcBufAddr, ulSize, 0, 0, 0, KNL_TIMER_Get1ms());
		}
		else
		{
			tProcess.ulDramAddr2 = ulSrcAdr;
			tProcess.ulSize 	 = ulSize;
		}
	#else
		tProcess.ubSrcNum	 = tKNL_AdoSrcNum;
		tProcess.ubCurNode 	 = KNL_NODE_ADC;
		tProcess.ubNextNode  = ubKNL_GetNextNode(tKNL_AdoSrcNum,KNL_NODE_ADC);
		tProcess.ulDramAddr1 = 0;
		tProcess.ulDramAddr2 = ulSrcAdr;
		tProcess.ulSize		 = ulSize;
	#endif
//			KNL_AdcBufProcess(tProcess);
		if(osMessagePut(KNL_AdoCodecProcQueue, &tProcess, 0) == osErrorResource)
		{
			printd(DBG_ErrorLvl, "KNL_ADO Q->Full !!!!\r\n");
		}
	}
}
#endif
#endif
//------------------------------------------------------------------------------
#if APP_ADO_FUNC_ENABLE
static void KNL_AdoDecMonitThread(void const *argument)
{	
	ADO_DAC_EVENT tKNL_DacEvent;

	while(1)
	{
		//Get Queue from Audio Interface
		osMessageGet(tKNL_DecEventQue, &tKNL_DacEvent, osWaitForever);
		switch(tKNL_DacEvent)
		{
			case DAC_RDY:
				ADO_SetDacMute(DAC_MR_0p5DB_1SAMPLE, ADO_OFF);
				SPEAKER_EN(TRUE);
				break;
			case PLAY_BUF_EMP:
				printd(DBG_CriticalLvl, "-Dac play empty-\n");
				break;
		}
	}
}
#endif
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// FS setting
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
#include "FATSRCH_API.h"
#include "SD_API.h"
#include "SF_API.h"
//------------------------------------------------------------------------------
// general hook
//------------------------------------------------------------------------------
void KNL_FsDmaFill(uint32_t ulDesAddr, uint32_t ulPattern, uint32_t ulSize)
{
	DMAC_RESULT Result;
	Result = tDMAC_MemSet(ulPattern, ulDesAddr, ulSize, NULL);
	if( Result!=DMAC_OK )
	{
		printd(DBG_CriticalLvl, "KNL->FS DMA_Fill FAIL[Result=%d]\n",Result);
	}
}
//------------------------------------------------------------------------------
extern uint32_t Image$$RW_IRAM1$$Base;
void KNL_FsDmaCopy(uint32_t ulDesAddr, uint32_t ulSrcAddr, uint32_t ulSize)
{
#if KNL_FS_CIPHER_DMA_EN
	uint32_t ulDMAC_DdrBsz;
	uint32_t ulRoSize = ulMMU_GetICacheSize();
		
	ulDMAC_DdrBsz = ulDDR_GetCapacity();
	if(((ulDesAddr%ulDMAC_DdrBsz) < ulRoSize ) ||( (ulDesAddr+ulSize)> ulDMAC_DdrBsz))
	{
		printf("KNL->FsDmaCopy fail!! [wrt data in code area][0x%X/0x%X/0x%X]\n",ulSrcAddr, ulDesAddr, ulSize);
		return;
	}
	
	if( ulSize < 1024 )
	{
		memcpy((uint8_t*)ulDesAddr, (uint8_t*)ulSrcAddr, ulSize);
	}
	else
	{		
		CIPHER_DMACopy(ulSrcAddr, ulDesAddr, ulSize);
	}
#else
	tDMAC_MemCopy(ulSrcAddr, ulDesAddr, ulSize, NULL);
#endif
}
//------------------------------------------------------------------------------
FS_CALENDAR_t KNL_FsRtcCalendar(void)
{
	FS_CALENDAR_t Calendar;
#if (BSP_RTC_TIMER_SEL == RTC_TIMER_INTERNAL || BSP_RTC_TIMER_SEL == RTC_TIMER_NULL)
	RTC_Calendar_t tCalendar;	
#elif (BSP_RTC_TIMER_SEL == RTC_TIMER_EXTERNAL)
	RTC_PCF85063A_Calendar_t tCalendar;
#endif
	wRTC_GETCALENDAR(&tCalendar);
	Calendar.uwYear  = tCalendar.uwYear;
	Calendar.ubMonth = tCalendar.ubMonth;
	Calendar.ubDay   = tCalendar.ubDate;
	Calendar.ubHour  = tCalendar.ubHour;
	Calendar.ubMin   = tCalendar.ubMin;
	Calendar.ubSec   = tCalendar.ubSec;
	return Calendar;
}
//------------------------------------------------------------------------------
uint32_t ulKNL_FsFatSearch(uint32_t ulTargetData, uint32_t ulSrchStartAddr, uint32_t ulSrchLen, uint32_t ulRptAddr)
{
	uint32_t ulFAT_SRC_IP_Timeout;
	FATSRCH_RESULT FatSrchFlag;
	uint32_t ulRptNum;
	
	ulFAT_SRC_IP_Timeout = 0;
	while(1)
	{
		if(ubFATSRCH_ChkRdy()==1)
			break;
		else
		{
			osDelay(20);
			ulFAT_SRC_IP_Timeout += 20;
			if( ulFAT_SRC_IP_Timeout > 300 )
			{
				printd(DBG_ErrorLvl, "KNL FsFatSearch fail->fat search ip timeout\n");
				return 0xFFFFFFFF;
			}
		}
	}
	
	FatSrchFlag = tFATSRCH_Srch(FATSRCH_32_BIT, ulTargetData, ulSrchStartAddr, ulSrchLen, ulRptAddr);
	if( FatSrchFlag==FATSRCH_FAIL )
	{
		printd(DBG_ErrorLvl, "KNL FsFatSearch fail->fat search ip fail\n");
		return 0xFFFFFFFF;
	}
	ulRptNum = ulFATSRCH_GetRptLen() / 8;
	
	return ulRptNum;
}
//------------------------------------------------------------------------------
void KNL_FsWdtTimerClr(void)
{
	WDT_TimerClr(WDT_RST);
}
//------------------------------------------------------------------------------
uint32_t ulKNL_FsCrc32(uint32_t ulSrcAddr, uint32_t ulSize)
{
	CRC_t CRC2_Setup;
	uint32_t ulTemp;

	CRC2_Setup.CRC_INIT_VALUE = INIT_ALL_FF;
	CRC2_Setup.CRC_FINAL_XOR_VALUE = XOR_ALL_FF;
	CRC2_Setup.CRC_ORDER = 31;
	
	ulTemp = ulCRC_Calc(CRC2_Setup, CRC_P_32, ulSrcAddr, ulSize);
	
	return ulTemp;
}
//------------------------------------------------------------------------------
// SD hook
//------------------------------------------------------------------------------
uint8_t ubKNL_FsSdExist(void)
{
	return ubSD_ChkCardIn(tSD_GetDevIF());
}
//------------------------------------------------------------------------------
uint8_t ubKNL_FsSdIFSetup(void)
{
	return ubSD_ChkIFSetup();
}
//------------------------------------------------------------------------------
uint32_t ulKNL_FsSdIdentify(void)
{
	uint8_t ubIdentifyFlag;
	uint32_t ulTotalSectors;
	
	if(ubKNL_FsSdExist()==0)
		return 0;
	
	ubIdentifyFlag = ubSD_Identify(tSD_GetDevIF());
	if(ubIdentifyFlag!=1)
		return 0;
	
	ulTotalSectors = ulSD_GetTotalSector(tSD_GetDevIF());
	
	return ulTotalSectors;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_FsSdWrite(uint32_t ulSrcAddr, uint32_t ulLba, uint32_t ulSize)
{
	uint8_t ubStatus;
#if KNL_FS_SD_POLLING_EN
	ubStatus = ubSD_Write(tSD_GetDevIF(), ulSrcAddr, ulLba, ulSize, 1);
#else
	ubStatus = ubSD_Write(tSD_GetDevIF(), ulSrcAddr, ulLba, ulSize, 0);
#endif
	return ubStatus;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_FsSdRead(uint32_t ulDstAddr, uint32_t ulLba, uint32_t ulSize)
{
	uint8_t ubStatus;
#if KNL_FS_SD_POLLING_EN
	ubStatus = ubSD_Read(tSD_GetDevIF(), ulDstAddr, ulLba, ulSize, 1);
#else
	ubStatus = ubSD_Read(tSD_GetDevIF(), ulDstAddr, ulLba, ulSize, 0);
#endif
	return ubStatus;
}
//------------------------------------------------------------------------------
uint8_t ulKNL_MscMediaExist(void)
{
	
	return ubKNL_FsSdExist();
}
//------------------------------------------------------------------------------
uint32_t ulKNL_MscGetSdBlockSz(void)
{
	uint32_t ulBlkSz;
	
	ulBlkSz = ulKNL_FsSdIdentify();
	
	return ulBlkSz;
}
//------------------------------------------------------------------------------
void KNL_FsSdPlugInHook(void)
{
#if APP_PC_CONNECT_EN

	ubKNL_PcConnEnterFlg = 0;	
	ubKNL_LeavePcConnectFirstFlg = 0;
	FWU_Disable();
#endif	
#if KNL_DEBUG_APP_Q_FULL_EN
	KNL_AutoEnterFileListStart();
#endif
}
//------------------------------------------------------------------------------
void KNL_FsSdPlugOutHook(void)
{	
#if APP_PC_CONNECT_EN

	FWU_Enable();
	if((KNL_PcConnCbFunc_SdCardPlugout!=NULL)&&ubKNL_PcConnEnterFlg)
		KNL_PcConnCbFunc_SdCardPlugout();
#endif
}
//------------------------------------------------------------------------------
// SF hook
//------------------------------------------------------------------------------
uint8_t ubKNL_FsSfExist(void)
{
	return 1;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_FsSfIFSetup(void)
{
	return 1;
}
//------------------------------------------------------------------------------
uint32_t ulKNL_FsSfIdentify(void)
{	
	return 1;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_FsSfWrite(uint32_t ulSrcAddr, uint32_t ulAddr, uint32_t ulSize)
{
	SF_DMA_Info_t info;
	info.ulSFStaAddr 		= ulAddr;
	info.ulRAMStaAddr 		= ulSrcAddr;
	info.ulLength 			= ulSize;
	info.tRAMType 			= SF_DDR_DMA;
	info.tDir 				= SF_DMA_WRITE;
	info.tWaitRdyMethod     = SF_STRAIGHT_WAIT;
	info.ubCrcOrder 		= 16;
	info.ulCrcPolynomial 	= 0xA001;
	SF_DisableWrProtect();
	ulSF_DMA(&info, NULL);
	SF_EnableWrProtect();
	return 1;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_FsSfRead(uint32_t ulDstAddr, uint32_t ulAddr, uint32_t ulSize)
{
	SF_DMA_Info_t info;
	info.ulSFStaAddr 		= ulAddr;
	info.ulRAMStaAddr 		= ulDstAddr;
	info.ulLength 			= ulSize;
	info.tRAMType 			= SF_DDR_DMA;
	info.tDir 				= SF_DMA_READ;
	info.tWaitRdyMethod     = SF_STRAIGHT_WAIT;
	info.ubCrcOrder 		= 16;
	info.ulCrcPolynomial 	= 0xA001;
	ulSF_DMA(&info, NULL);
	return 1;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_FsSfErase(uint8_t ubEraseMode, uint32_t ulAddr, uint32_t ulSize)
{
	SF_DisableWrProtect();
	SF_Erase(ubEraseMode, ulAddr, ulSize, 0);
	SF_EnableWrProtect();
	return 1;
}
//------------------------------------------------------------------------------
void KNL_FsSfPlugInHook(void)
{
	
}
//------------------------------------------------------------------------------
void KNL_FsSfPlugOutHook(void)
{
	
}
//------------------------------------------------------------------------------
FS_STREAM_BUF_INFO_t tFsBufInfo;
void KNL_FsStreamBufInfo(FS_MEDIA_TYPE MediaType)
{
	if(MediaType==FS_MEDIA_TYPE_SD)
	{
		//vdo buffer
		tFsBufInfo.Vdo.BufEnable = FS_OFF;
		//jpg buffer
		tFsBufInfo.Jpg.BufEnable = FS_ON;
		tFsBufInfo.Jpg.ulSize    = 0x80000;
		//user defing buffer
		tFsBufInfo.UserDef.BufEnable = FS_OFF;
#if !defined(BSP_DVR_SDK)
	#if APP_PHOTOGRAPH_FUNC_ENABLE
		//vdo buffer
		tFsBufInfo.Vdo.BufEnable = FS_OFF;
		//jpg buffer
		tFsBufInfo.Jpg.BufEnable = FS_ON;
		tFsBufInfo.Jpg.ulSize    = 0x20000;
		//user defing buffer
		tFsBufInfo.UserDef.BufEnable = FS_OFF;
	#endif
	#if APP_REC_FUNC_ENABLE
		#if defined(OP_STA)
        #if (defined(APP_TXREC_STREAM_SEL)&&(APP_TXREC_STREAM_SEL==2))         
        //vdo buffer -> VGAx1+HDx1
		tFsBufInfo.Vdo.BufEnable = FS_ON;
		tFsBufInfo.Vdo.ubNum     = 2;	//VGAx1+HDx1
		tFsBufInfo.Vdo.Res[0]    = FS_RES_HD;
		tFsBufInfo.Vdo.ulSize[0] = 0x200000;
		tFsBufInfo.Vdo.Res[1]    = FS_RES_HD;
		tFsBufInfo.Vdo.ulSize[1] = 0x200000; 
        #else
		//vdo buffer -> FHDx1
		tFsBufInfo.Vdo.BufEnable = FS_ON;
		tFsBufInfo.Vdo.ubNum     = 1;	//FHDx1
		tFsBufInfo.Vdo.Res[0]    = FS_RES_FHD;
		tFsBufInfo.Vdo.ulSize[0] = 0x200000;
        #endif
		//jpg buffer
		tFsBufInfo.Jpg.BufEnable = FS_ON;
		#if defined(BSP_VBM_SDK)
		tFsBufInfo.Jpg.ulSize    = 0x20000;	// avoid memory over 32MB
		#else
		tFsBufInfo.Jpg.ulSize    = 0x80000;
		#endif
		//user defing buffer
		tFsBufInfo.UserDef.BufEnable = FS_OFF;
		#else
		//vdo buffer -> HDx4
		tFsBufInfo.Vdo.BufEnable = FS_ON;
		tFsBufInfo.Vdo.ubNum     = 4;	//HDx4
		tFsBufInfo.Vdo.Res[0]    = FS_RES_HD;
		tFsBufInfo.Vdo.ulSize[0] = 0x100000;
		tFsBufInfo.Vdo.Res[1]    = FS_RES_HD;
		tFsBufInfo.Vdo.ulSize[1] = 0x100000;
		tFsBufInfo.Vdo.Res[2]    = FS_RES_HD;
		tFsBufInfo.Vdo.ulSize[2] = 0x100000;
		tFsBufInfo.Vdo.Res[3]    = FS_RES_HD;
		tFsBufInfo.Vdo.ulSize[3] = 0x100000;
		//jpg buffer
		tFsBufInfo.Jpg.BufEnable = FS_ON;
		tFsBufInfo.Jpg.ulSize    = 0x80000;
		//user defing buffer
		tFsBufInfo.UserDef.BufEnable = FS_OFF;
		#endif
	#endif
#else
	#if defined(APP_TXREC_STREAM_SEL)
		//vdo buffer -> FHDx1
		tFsBufInfo.Vdo.BufEnable = FS_ON;
		tFsBufInfo.Vdo.ubNum     = 1;
		tFsBufInfo.Vdo.Res[0]    = FS_RES_FHD;
		tFsBufInfo.Vdo.ulSize[0] = 0x200000;
		//jpg buffer
		tFsBufInfo.Jpg.BufEnable = FS_OFF;
		tFsBufInfo.Jpg.ulSize    = 0x80000;
		//user defing buffer
		tFsBufInfo.UserDef.BufEnable = FS_OFF;
	#else
		#if APP_DUAL_FS_ENABLE
		//vdo buffer -> FHDx1+HDx1
		tFsBufInfo.Vdo.BufEnable = FS_ON;
		tFsBufInfo.Vdo.ubNum     = 2;
		tFsBufInfo.Vdo.Res[0]    = FS_RES_HD;
		tFsBufInfo.Vdo.ulSize[0] = 0x100000;
		tFsBufInfo.Vdo.Res[1]    = FS_RES_FHD;
		tFsBufInfo.Vdo.ulSize[1] = 0x200000;
		//jpg buffer
		tFsBufInfo.Jpg.BufEnable = FS_ON;
		tFsBufInfo.Jpg.ulSize    = 0x80000;
		//user defing buffer
		tFsBufInfo.UserDef.BufEnable = FS_OFF;
		#else
		//vdo buffer -> FHDx1+HDx1
		tFsBufInfo.Vdo.BufEnable = FS_ON;
		tFsBufInfo.Vdo.ubNum     = 2;
		tFsBufInfo.Vdo.Res[0]    = FS_RES_HD;
		tFsBufInfo.Vdo.ulSize[0] = 0x200000;
		tFsBufInfo.Vdo.Res[1]    = FS_RES_FHD;
		tFsBufInfo.Vdo.ulSize[1] = 0x500000;
		//jpg buffer
		tFsBufInfo.Jpg.BufEnable = FS_ON;
		tFsBufInfo.Jpg.ulSize    = 0x80000;
		//user defing buffer
		tFsBufInfo.UserDef.BufEnable = FS_OFF;
		#endif
	#endif
#endif
	}
	else if(MediaType==FS_MEDIA_TYPE_SF)
	{
		//vdo buffer
		tFsBufInfo.Vdo.BufEnable = FS_OFF;
		//jpg buffer
		tFsBufInfo.Jpg.BufEnable = FS_ON;
		tFsBufInfo.Jpg.ulSize    = 0x20000;
		//user defing buffer
		tFsBufInfo.UserDef.BufEnable = FS_OFF;
	}
}
//------------------------------------------------------------------------------
void KNL_FsSetting(uint32_t ulBufStartAddr)
{
	FS_MEDIA_SEL MediaSel;
	
	// decicde media num and type
#if ( APP_SD_FUNC_ENABLE==1 && APP_REC_FUNC_ENABLE==0 && APP_PHOTOGRAPH_FUNC_ENABLE==1 && APP_PHOTO_STORE_SEL==APP_FS_MEDIA_TYPE_SD )
	tKNL_FsMediaInfo.InitPara.ubMediaNum = 1;
	tKNL_FsMediaInfo.MediaType[FS_MEDIA_0] = FS_MEDIA_TYPE_SD;
#elif ( APP_SD_FUNC_ENABLE==0 && APP_REC_FUNC_ENABLE==0 && APP_PHOTOGRAPH_FUNC_ENABLE==1 &&	APP_PHOTO_STORE_SEL==APP_FS_MEDIA_TYPE_SF )
	tKNL_FsMediaInfo.InitPara.ubMediaNum = 1;
	tKNL_FsMediaInfo.MediaType[FS_MEDIA_0] = FS_MEDIA_TYPE_SF;
#elif ( APP_SD_FUNC_ENABLE==1 && APP_REC_FUNC_ENABLE==1 && APP_PHOTOGRAPH_FUNC_ENABLE==1 &&	APP_PHOTO_STORE_SEL==APP_FS_MEDIA_TYPE_SD )
	tKNL_FsMediaInfo.InitPara.ubMediaNum = 1;
	tKNL_FsMediaInfo.MediaType[FS_MEDIA_0] = FS_MEDIA_TYPE_SD;
#elif ( APP_SD_FUNC_ENABLE==1 && APP_REC_FUNC_ENABLE==1 && APP_PHOTOGRAPH_FUNC_ENABLE==1 &&	APP_PHOTO_STORE_SEL==APP_FS_MEDIA_TYPE_SF )
	tKNL_FsMediaInfo.InitPara.ubMediaNum = 2;
	tKNL_FsMediaInfo.MediaType[FS_MEDIA_0] = FS_MEDIA_TYPE_SD;
	tKNL_FsMediaInfo.MediaType[FS_MEDIA_1] = FS_MEDIA_TYPE_SF;
#elif( APP_SD_FUNC_ENABLE==1 && APP_REC_FUNC_ENABLE==0 && APP_PHOTOGRAPH_FUNC_ENABLE==1 &&	APP_PHOTO_STORE_SEL==APP_FS_MEDIA_TYPE_SF )
	tKNL_FsMediaInfo.InitPara.ubMediaNum = 2;
	tKNL_FsMediaInfo.MediaType[FS_MEDIA_0] = FS_MEDIA_TYPE_SF;
	tKNL_FsMediaInfo.MediaType[FS_MEDIA_1] = FS_MEDIA_TYPE_SD;
#elif( APP_SD_FUNC_ENABLE==1 && APP_REC_FUNC_ENABLE==1 && APP_PHOTOGRAPH_FUNC_ENABLE==0 )
	tKNL_FsMediaInfo.InitPara.ubMediaNum = 1;
	tKNL_FsMediaInfo.MediaType[FS_MEDIA_0] = FS_MEDIA_TYPE_SD;
#elif( APP_SD_FUNC_ENABLE==1 && APP_REC_FUNC_ENABLE==0 && APP_PHOTOGRAPH_FUNC_ENABLE==0 )
	tKNL_FsMediaInfo.InitPara.ubMediaNum = 1;
	tKNL_FsMediaInfo.MediaType[FS_MEDIA_0] = FS_MEDIA_TYPE_SD;
#endif
	
	// first media
	MediaSel = FS_MEDIA_0;
	tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaType = tKNL_FsMediaInfo.MediaType[MediaSel];
	if(tKNL_FsMediaInfo.MediaType[MediaSel]==FS_MEDIA_TYPE_SD)
	{
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaExist       = ubKNL_FsSdExist;
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaIFSetup     = ubKNL_FsSdIFSetup;
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaIdentify    = ulKNL_FsSdIdentify;
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaPlugInHook  = KNL_FsSdPlugInHook;
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaPlugOutHook = KNL_FsSdPlugOutHook;
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaWrite       = ubKNL_FsSdWrite;
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaRead        = ubKNL_FsSdRead;
	}
	else if(tKNL_FsMediaInfo.MediaType[MediaSel]==FS_MEDIA_TYPE_SF)
	{
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].ulSF_TotalSz     = pSF_Info->ulSize;
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].ulSF_UseStartOfs = 0x1000000;
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].ulSF_UseSz       = 0x1000000;
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaExist       = ubKNL_FsSfExist;
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaIFSetup     = ubKNL_FsSfIFSetup;
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaIdentify    = ulKNL_FsSfIdentify;
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaPlugInHook  = KNL_FsSfPlugInHook;
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaPlugOutHook = KNL_FsSfPlugOutHook;
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaWrite       = ubKNL_FsSfWrite;
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaRead        = ubKNL_FsSfRead;
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaErase       = ubKNL_FsSfErase;
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].ubMediaEreseMode_SE  = SF_SE;
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].ubMediaEreseMode_LBE = SF_LBE;
	}
	tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].ulMediaInDebounceNum  = 10;
	tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].ulMediaOutDebounceNum = 50;
#if (defined(OP_STA) && (defined(BSP_VBM_SDK)||defined(BSP_RVCS_SDK)) && APP_REC_FUNC_ENABLE==1)
	tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].BufWrtTh = FS_BUF_WRT_TH_128KB;
#elif (APP_REC_FUNC_ENABLE==1)
	tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].BufWrtTh = FS_BUF_WRT_TH_512KB;
#else
	tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].BufWrtTh = FS_BUF_WRT_TH_128KB;
#endif
	KNL_FsStreamBufInfo(tKNL_FsMediaInfo.MediaType[MediaSel]);
	memcpy(&tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].StreamBuf, &tFsBufInfo, sizeof(tFsBufInfo));
	tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].uwMaxRollingGroupIdxNum = 65535;
	
#if APP_FS_CUSTOMER1_PATH_ENABLE
	tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].FldStrcMode = DCIM_WITH_VDO_PHOTO_FLD;
	tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].Cust1_DefVideoFldName.ubLen = 5;
	memcpy(tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].Cust1_DefVideoFldName.chName, "VIDEO", tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].Cust1_DefVideoFldName.ubLen);
	tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].Cust1_DefPhotoFldName.ubLen = 5;
	memcpy(tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].Cust1_DefPhotoFldName.chName, "PHOTO", tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].Cust1_DefPhotoFldName.ubLen);
#else
	tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].FldStrcMode = STANDARD_DCIM;
	tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].ulRecFldMaxSupFileNum = 1000;
	memcpy(tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].chDefRecFldName, "SONIX", 5);
#endif
	
	tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].EmgFuncEnable = FS_ON;
	tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].ulEmgFldMaxSupFileNum = 1000;
	tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].DefEmgFldName.ubLen = 3;
	memcpy(tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].DefEmgFldName.chName, "EMG", tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].DefEmgFldName.ubLen);
	tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].TimelapseFuncEnable = FS_ON;
	tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].ulTimelapseFldMaxSupFileNum = 1000;
	tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].DefTimelapseFldName.ubLen = 8;
	memcpy(tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].DefTimelapseFldName.chName, "TIMELAPS", tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].DefTimelapseFldName.ubLen);
	
	tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].ubDefRecFileNameLen = 4;
	memcpy(tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].chDefRecFileName, "SNX_", tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].ubDefRecFileNameLen);
	
	// second media
	if(tKNL_FsMediaInfo.InitPara.ubMediaNum==2)
	{
		MediaSel = FS_MEDIA_1;
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaType = tKNL_FsMediaInfo.MediaType[MediaSel];
		if(tKNL_FsMediaInfo.MediaType[MediaSel]==FS_MEDIA_TYPE_SD)
		{
			tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaExist       = ubKNL_FsSdExist;
			tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaIFSetup     = ubKNL_FsSdIFSetup;
			tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaIdentify    = ulKNL_FsSdIdentify;
			tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaPlugInHook  = KNL_FsSdPlugInHook;
			tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaPlugOutHook = KNL_FsSdPlugOutHook;
			tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaWrite       = ubKNL_FsSdWrite;
			tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaRead        = ubKNL_FsSdRead;
		}
		else if(tKNL_FsMediaInfo.MediaType[MediaSel]==FS_MEDIA_TYPE_SF)
		{
			tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].ulSF_TotalSz     = pSF_Info->ulSize;
			tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].ulSF_UseStartOfs = 0x1000000;
			tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].ulSF_UseSz       = 0x1000000;
			tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaExist       = ubKNL_FsSfExist;
			tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaIFSetup     = ubKNL_FsSfIFSetup;
			tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaIdentify    = ulKNL_FsSfIdentify;
			tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaPlugInHook  = KNL_FsSfPlugInHook;
			tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaPlugOutHook = KNL_FsSfPlugOutHook;
			tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaWrite       = ubKNL_FsSfWrite;
			tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaRead        = ubKNL_FsSfRead;
			tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].MediaErase       = ubKNL_FsSfErase;
			tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].ubMediaEreseMode_SE  = SF_SE;
			tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].ubMediaEreseMode_LBE = SF_LBE;
		}
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].ulMediaInDebounceNum  = 10;
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].ulMediaOutDebounceNum = 50;
#if (defined(OP_STA) && (defined(BSP_VBM_SDK)||defined(BSP_RVCS_SDK)) && APP_REC_FUNC_ENABLE==1)
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].BufWrtTh = FS_BUF_WRT_TH_128KB;
#elif (APP_REC_FUNC_ENABLE==1)
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].BufWrtTh = FS_BUF_WRT_TH_512KB;
#else
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].BufWrtTh = FS_BUF_WRT_TH_128KB;
#endif
		KNL_FsStreamBufInfo(tKNL_FsMediaInfo.MediaType[MediaSel]);
		memcpy(&tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].StreamBuf, &tFsBufInfo, sizeof(tFsBufInfo));
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].uwMaxRollingGroupIdxNum = 65535;
		
#if APP_FS_CUSTOMER1_PATH_ENABLE
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].FldStrcMode = DCIM_WITH_VDO_PHOTO_FLD;
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].Cust1_DefVideoFldName.ubLen = 5;
		memcpy(tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].Cust1_DefVideoFldName.chName, "VIDEO", tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].Cust1_DefVideoFldName.ubLen);
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].Cust1_DefPhotoFldName.ubLen = 5;
		memcpy(tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].Cust1_DefPhotoFldName.chName, "PHOTO", tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].Cust1_DefPhotoFldName.ubLen);
#else
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].FldStrcMode = STANDARD_DCIM;
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].ulRecFldMaxSupFileNum = 1000;
		memcpy(tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].chDefRecFldName, "SONIX", 5);
#endif
		
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].EmgFuncEnable = FS_ON;
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].ulEmgFldMaxSupFileNum = 1000;
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].DefEmgFldName.ubLen = 3;
		memcpy(tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].DefEmgFldName.chName, "EMG", tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].DefEmgFldName.ubLen);
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].TimelapseFuncEnable = FS_ON;
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].ulTimelapseFldMaxSupFileNum = 1000;
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].DefTimelapseFldName.ubLen = 8;
		memcpy(tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].DefTimelapseFldName.chName, "TIMELAPS", tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].DefTimelapseFldName.ubLen);
		
		tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].ubDefRecFileNameLen = 4;
		memcpy(tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].chDefRecFileName, "SNX_", tKNL_FsMediaInfo.InitPara.MediaInfo[MediaSel].ubDefRecFileNameLen);
	}
	
	tKNL_FsMediaInfo.InitPara.ulBufStartAddr   = ulBufStartAddr;
	tKNL_FsMediaInfo.InitPara.DdrCapacity      = ulDDR_GetCapacity;
	tKNL_FsMediaInfo.InitPara.DmaFill          = KNL_FsDmaFill;
	tKNL_FsMediaInfo.InitPara.DmaCopy          = KNL_FsDmaCopy;
	tKNL_FsMediaInfo.InitPara.Get1ms           = KNL_TIMER_Get1ms;
	tKNL_FsMediaInfo.InitPara.RtcCalendar      = KNL_FsRtcCalendar;
	tKNL_FsMediaInfo.InitPara.GetRtcLongTime   = ulRTC_RdRtcTime;
	tKNL_FsMediaInfo.InitPara.FatSearch        = ulKNL_FsFatSearch;
	tKNL_FsMediaInfo.InitPara.WdtTimerClr      = KNL_FsWdtTimerClr;
	tKNL_FsMediaInfo.InitPara.Crc32            = ulKNL_FsCrc32;
	tKNL_FsMediaInfo.InitPara.DumpDbgLogEnable = FS_OFF;
	tKNL_FsMediaInfo.InitPara.DumpDbgLogLibVer.ubREC_Lib_Ver[0] = (uwREC_GetVersion()&0xFF00)>>8;
	tKNL_FsMediaInfo.InitPara.DumpDbgLogLibVer.ubREC_Lib_Ver[1] = (uwREC_GetVersion()&0xFF);
	tKNL_FsMediaInfo.InitPara.DumpDbgLogLibVer.ubPLY_Lib_Ver[0] = (uwPLY_GetVersion()&0xFF00)>>8;
	tKNL_FsMediaInfo.InitPara.DumpDbgLogLibVer.ubPLY_Lib_Ver[1] = (uwPLY_GetVersion()&0xFF);
	
	tKNL_FsMediaInfo.InitPara.StoreKnlDbgInfoHook = KNL_StoreDbgInfo;
	
	tKNL_FsMediaInfo.InitPara.ForceStoppingWrtFileHook = KNL_ForceStopRec;
	tKNL_FsMediaInfo.InitPara.ulHiddenInfOffset = ((KNL_JPG_SOI_SIZE+KNL_JPG_EXIF_SIZE+KNL_JPG_FRAMEHEADER_SIZE)/16+2)*16;
	tKNL_FsMediaInfo.InitPara.ulHiddenInfSize = KNL_JPG_HEADER_SIZE;
	ulFS_HiddenInfSizeSetting(tKNL_FsMediaInfo.InitPara.ulHiddenInfOffset,tKNL_FsMediaInfo.InitPara.ulHiddenInfSize);
	
	//set default media is FS_MEDIA_0
	KNL_FS_MediaSel(FS_MEDIA_0);
}
//------------------------------------------------------------------------------
void KNL_FS_MediaSel(FS_MEDIA_SEL MediaSel)
{
	tKNL_FsMediaInfo.MediaSel = MediaSel;
	printf("KNL->FS_MediaSel=%d\n",tKNL_FsMediaInfo.MediaSel);
}
//------------------------------------------------------------------------------
FS_MEDIA_SEL KNL_GetFsMedia(void)
{
	return tKNL_FsMediaInfo.MediaSel;
}
//------------------------------------------------------------------------------
void KNL_FS_NormalLoopingOnSetting(FS_MEDIA_SEL MediaSel)
{
	if(tKNL_FsMediaInfo.MediaType[MediaSel]==FS_MEDIA_TYPE_SD)
	{
#if APP_FS_CUSTOMER1_PATH_ENABLE
		FS_LoopingOn(MediaSel, LOOPING_CUST1_VIDEO, 1800);
#else
		FS_LoopingOn(MediaSel, LOOPING_NORMAL, 1800);
#endif
	}
	else if(tKNL_FsMediaInfo.MediaType[MediaSel]==FS_MEDIA_TYPE_SF)
	{
		FS_LoopingOn(MediaSel, LOOPING_NORMAL, 2);
	}
}
//------------------------------------------------------------------------------
void KNL_BufInit(void)
{
	KNL_NODE_INFO tNodeInfo;
	float fBufSize;	
	uint8_t ubNodeExist;
	uint8_t ubSrc;
	uint32_t i;
	uint32_t ulAddr;
#if KNL_USBH_FUNC_ENABLE
	#if KNL_USBH_UVCCLASS_ENABLE
	uint8_t uvc_stream_num = 0;
	USBH_UVC_FRAME_INFO uvc_frame_info;
	#endif    
#endif
	
	uint32_t ulBuf_S,ulBuf_E;
	
	uint32_t ulJpgBsBufSize;
#if (defined(BSP_DVR_SDK) || (defined(BSP_RVCS_SDK)&&defined(OP_STA)&& APP_PHOTOGRAPH_FUNC_ENABLE))
	uint32_t ulJpgBsStartAddr;
	uint32_t ulTempYUV_StartAddr;
	uint32_t ulTempYUV_EndAddr;
	uint32_t ulTempYUV_BufSize;
	ulJpgBsStartAddr = ulJpgBsStartAddr;
	ulTempYUV_StartAddr = ulTempYUV_StartAddr;
	ulTempYUV_EndAddr = ulTempYUV_EndAddr;
	ulTempYUV_BufSize = ulTempYUV_BufSize;
#endif

	ulJpgBsBufSize = ulJpgBsBufSize;
	ulJpgBsBufSize = KNL_JPG_HEADER_SIZE+KNL_JPG_BS_SIZE;
#if defined(BSP_DVR_SDK)
	ulTempYUV_BufSize = uwKNL_GetVdoH(KNL_SRC_STORAGE_LOCAL)*uwKNL_GetVdoV(KNL_SRC_STORAGE_LOCAL)*1.5;
#endif

#if (defined(BSP_RVCS_SDK)&&defined(OP_STA)&&APP_PHOTOGRAPH_FUNC_ENABLE)
    ulTempYUV_BufSize = uwKNL_GetVdoH(KNL_CamSnapshotSrcGet())*uwKNL_GetVdoV(KNL_CamSnapshotSrcGet())*1.5;
    printf("H=%x,V=%x,BZ=%x,YZ=%x\n",uwKNL_GetVdoH(KNL_CamSnapshotSrcGet()),uwKNL_GetVdoV(KNL_CamSnapshotSrcGet()),ulJpgBsBufSize,ulTempYUV_BufSize);
#endif

	if(BUF_INFO_OUTPUT)
		printf("== SYS:%d KB ==\r\n",ulBUF_GetFreeAddr()/1024);
	
	ulBuf_S = ulBUF_GetFreeAddr();
	//COMM Node
	//================================================================
	ubNodeExist = ubKNL_ChkExistNode(KNL_NODE_COMM_TX_VDO) | ubKNL_ChkExistNode(KNL_NODE_COMM_RX_VDO)| ubKNL_ChkExistNode(KNL_NODE_COMM_TX_ADO)| ubKNL_ChkExistNode(KNL_NODE_COMM_RX_ADO);
#if APP_UVC_CAM_ENABLE
	ubNodeExist = 0;
#endif
	if(ubNodeExist)
	{
		KNL_WirelessDevBufInit();
	}
	ulBuf_E = ulBUF_GetFreeAddr();
	if(BUF_INFO_OUTPUT)
		printf("== BB/RF:%d KB ==\r\n",(ulBuf_E-ulBuf_S)/1024);

#if USBD_ENABLE	
	ulBuf_S = ulBUF_GetFreeAddr();
	
	fBufSize = USBD_BufSetup(ulBUF_GetFreeAddr());
	BUF_BufInit(BUF_USBD_IP,1,fBufSize,0);
	#ifdef OP_AP
	if((tUSBD_GetClassMode() == USBD_COMPOSITE_MODE) && (TRUE == ubUSBD_ChkCompMscClass()))
	{
	#define KNL_USBDUVC_AUX_SIZE		(32)
	#define KNL_USBDMSC_AUX_SIZE		(16)
	#define USBDVDO_SUBFRAME_SIZE		(4 * 1024)
#if(ADO_ENC_TYPE==AUDIO32_ENC)
	#define USBDADO_SUBFRAME_SIZE		(7 * AUDIO32_ENCODE_SIZE)
#elif(ADO_ENC_TYPE==SW_AAC_ENC)
	#define USBDADO_SUBFRAME_SIZE		(32768)
#elif(ADO_ENC_TYPE==SW_ALAW_ENC)
	#define USBDADO_SUBFRAME_SIZE		(16384)
#endif
	#define UVC_OFS_CH_INFO				(12)
	#define UVC_OFS_AUX_INFO			(13)
	#define UVC_OFS_TIME_STAMP			(14)
	#define UVC_OFS_NUM_SUB_FRAME		(22)
	#define UVC_OFS_SUB_FRAME_IDX		(23)
	#define UVC_OFS_SUB_FRAME_LEN		(24)
	#define UVC_OFS_TOTAL_FRAME_IDX		(26)
	#define UVC_OFS_RESERVED			(27)
	#define UVC_OFS_DATAGAP				(192)
	#define UVC_OFS_SUB_FRAME_DATA		KNL_USBDUVC_AUX_SIZE
		fBufSize = USBDVDO_SUBFRAME_SIZE + KNL_USBDUVC_AUX_SIZE + USBD_UVC_DUMMY_SZ;
		BUF_BufInit(BUF_USBD_VDO, BUF_NUM_USBD_VDO, fBufSize, 0);
		BUF_Reset(BUF_USBD_VDO);
		fBufSize = USBDADO_SUBFRAME_SIZE + KNL_USBDUVC_AUX_SIZE + USBD_UVC_DUMMY_SZ;
		BUF_BufInit(BUF_USBD_ADO, BUF_NUM_USBD_ADO, fBufSize, 0);
		BUF_Reset(BUF_USBD_ADO);
	}
	
	if((ubUSBD_GetMultiDrvMode() & USBD_MULTI_UAC)||(tUSBD_GetClassMode() == USBD_UAC_MODE))
	{	
	#define KNL_USBDUAC_AUX_SIZE		(32)
	#define UAC_OFS_DATAGAP				(192)
	    fBufSize = USBDADO_SUBFRAME_SIZE + KNL_USBDUAC_AUX_SIZE + UAC_OFS_DATAGAP;
		BUF_BufInit(BUF_USBD_ADO, 10, fBufSize, 0);
		BUF_Reset(BUF_USBD_ADO);
	}
	#endif
	
	ulBuf_E = ulBUF_GetFreeAddr();
	if(BUF_INFO_OUTPUT)
		printf("== USB:%d KB ==\r\n",(ulBuf_E-ulBuf_S)/1024);
#endif

#if APP_ADO_FUNC_ENABLE
	//Audio
	//================================================================
	ulBuf_S = ulBUF_GetFreeAddr();
	//IP
	if(ubKNL_ChkExistNode(KNL_NODE_ADC) || ubKNL_ChkExistNode(KNL_NODE_DAC))
	{
		BUF_BufInit(BUF_ADO_IP,1,ulADO_GetTotalBuffSize(&tKNL_AdoInfo),0);
	}
	ulBuf_E = ulBUF_GetFreeAddr();
	if(BUF_INFO_OUTPUT)
		printf("== ADO-IP:%d KB ==\r\n",(ulBuf_E-ulBuf_S)/1024);
	//ADC
	ulBuf_S = ulBUF_GetFreeAddr();
	if(ubKNL_ChkExistNode(KNL_NODE_ADC_BUF))
	{
		BUF_BufInit(BUF_ADO_ADC,BUF_NUM_ADC,ulKNL_AlignAdoPktSz(ulADO_BufTh[tKNL_AdoInfo.BufTh.Adc]),0);
		BUF_Reset(BUF_ADO_ADC);
	}
	ulBuf_E = ulBUF_GetFreeAddr();
	if(BUF_INFO_OUTPUT)
		printf("== ADC:%d KB ==\r\n",(ulBuf_E-ulBuf_S)/1024);
	//DAC
	ulBuf_S = ulBUF_GetFreeAddr();

#if (APP_DUAL_HOST_ENABLE == 1)
	for(i=0;i<1;i++)
#else
	for(i=0;i<4;i++)
#endif
	{
		if(ubKNL_ExistNode(KNL_SRC_1_OTHER_A+i,KNL_NODE_DAC_BUF) || ubKNL_ExistNode(KNL_SRC_1_OTHER_B+i,KNL_NODE_DAC_BUF))
		{
#if (OP_AP && APP_PLAY_REMOTE_ENABLE)
			BUF_BufInit(BUF_ADO_DAC0+i,BUF_NUM_DAC,ulKNL_AlignAdoPktSz(ulADO_BufTh[tKNL_AdoInfo.BufTh.Dac]*2),0);
#else
			BUF_BufInit(BUF_ADO_DAC0+i,BUF_NUM_DAC,ulKNL_AlignAdoPktSz(ulADO_BufTh[tKNL_AdoInfo.BufTh.Dac]),0);
#endif
			BUF_Reset(BUF_ADO_DAC0+i);
		}
	}
	ulBuf_E = ulBUF_GetFreeAddr();
	if(BUF_INFO_OUTPUT)
		printf("== DAC:%d KB ==\r\n",(ulBuf_E-ulBuf_S)/1024);
#endif	//! End of #if APP_ADO_FUNC_ENABLE

	//For MAC
#if APP_MAC_FUNC_ENABLE
	uint32_t ulMacMemSize;
	ulMacMemSize = ulEth_GetTotalBufferSize();
	printd(DBG_CriticalLvl, "MAC Buf:0x%X(%d)\r\n",ulMacMemSize, ulMacMemSize);
	BUF_BufInit(BUF_MAC,1,ulMacMemSize,0);
#endif

#if !defined(BSP_DVR_SDK)
#if APP_FS_FILE_LIST_STYLE
	fBufSize = ( 1920 * 1088 * 1.5 );
	BUF_BufInit(BUF_THM_SHOWING_READ_TEMP,1,fBufSize,0);
	BUF_BufInit(BUF_THM_SHOWING_DEC_YUV,1,fBufSize,0);
#endif
#endif
	
#if APP_SD_FUNC_ENABLE
	uint32_t ulSdNeedMemSize;
	ulSdNeedMemSize = ulSD_GetTotalBufSize();
	printd(DBG_CriticalLvl, "SD Buf:0x%X(%d)\r\n",ulSdNeedMemSize, ulSdNeedMemSize);
	BUF_BufInit(BUF_SD,1,ulSdNeedMemSize,0);
#endif
	
    //FS
#if ((APP_REC_FUNC_ENABLE || APP_PHOTOGRAPH_FUNC_ENABLE) || (APP_SD_FUNC_ENABLE==1 && APP_REC_FUNC_ENABLE==0 && APP_PHOTOGRAPH_FUNC_ENABLE==0))
#if (defined(VBM_PU) || defined(VBM_BU) || defined(BSP_DVR_SDK) || (defined(BUC_CU) && !defined(BSP_DVR_SDK)) || (defined(BUC_CAM) && defined(BSP_RVCS_SDK)))
	uint32_t ulNeedMemSize;
	KNL_FsSetting(0);
	ulNeedMemSize = ulFS_GetTotalBufSize(&tKNL_FsMediaInfo.InitPara);
	printd(DBG_CriticalLvl, "FS Buf:0x%X(%d)\r\n",ulNeedMemSize, ulNeedMemSize);
	BUF_BufInit(BUF_FS,1,ulNeedMemSize,0);
#endif
#endif

    // REC NON-DVR STA
#if (defined(OP_STA) && !defined(BSP_DVR_SDK))
	
	ulBuf_S = ulBUF_GetFreeAddr();
	if(ubKNL_GetIspEnable())
	{
    // ISP pipe
	//================================================================
    fBufSize = (float)ISP_WIDTH*(float)ISP_HEIGHT*10/8;
    BUF_BufInit(BUF_ISP_3DNR_IP, 1, fBufSize, 0);	    //ISP(3DNR) IP Buffer

    fBufSize = 0x58000;
    BUF_BufInit(BUF_ISP_MD_W0_IP, 1, fBufSize, 0);	    //ISP(MD_W0) IP Buffer
    fBufSize = 0x800;
    BUF_BufInit(BUF_ISP_MD_W1_IP, 1, fBufSize, 0);	    //ISP(MD_W1) IP Buffer
    fBufSize = 0x800;
    BUF_BufInit(BUF_ISP_MD_W2_IP, 1, fBufSize, 0);	    //ISP(MD_W2) IP Buffer

    // IQ bin file (128k)
	//================================================================
	fBufSize = 0x20000;
	BUF_BufInit(BUF_IQ_BIN_FILE, 1, fBufSize, 0);	    //IQ bin file Buffer
    //================================================================
    }
	ulBuf_E = ulBUF_GetFreeAddr();
	if(BUF_INFO_OUTPUT)
		printf("== ISP/MD/IQ:%d KB ==\r\n",(ulBuf_E-ulBuf_S)/1024);
	SEN_SetPathAddr(ISP_3DNR, ulBUF_GetBlkBufAddr(0, BUF_ISP_3DNR_IP));
    SEN_SetPathAddr(ISP_MD_W0, ulBUF_GetBlkBufAddr(0, BUF_ISP_MD_W0_IP));
    SEN_SetPathAddr(ISP_MD_W1, ulBUF_GetBlkBufAddr(0, BUF_ISP_MD_W1_IP));
    SEN_SetPathAddr(ISP_MD_W2, ulBUF_GetBlkBufAddr(0, BUF_ISP_MD_W2_IP));
    SEN_SetPathAddr(IQ_BIN_FILE, ulBUF_GetBlkBufAddr(0, BUF_IQ_BIN_FILE));
#if (((defined(BSP_VBM_SDK)||defined(BSP_RVCS_SDK)) && APP_REC_FUNC_ENABLE) || ((defined(BSP_VBM_SDK)||defined(BSP_RVCS_SDK)) && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE))
//=======================================================================================================================
	// Keep reocrding sub stream. Sub stream used memory must be fixed while change display mode in VBM. 
    // For Aux Source
    for(i=0;i<4;i++)
    {
        if(ubKNL_ExistNode(KNL_SRC_1_AUX+i,KNL_NODE_H264_ENC))
        {
            tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_AUX+i,KNL_NODE_H264_ENC);        
            fBufSize = ulH264_GetENCBufferSize(tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
            if(tNodeInfo.ubCodecIdx == ENCODE_0)
            {
                BUF_BufInit(BUF_IMG_ENC,1,fBufSize,0);
            }
            else if(tNodeInfo.ubCodecIdx == ENCODE_1)
            {
                BUF_BufInit(BUF_IMG_ENC,1,fBufSize,1);
            }
            else if(tNodeInfo.ubCodecIdx == ENCODE_2)
            {
                BUF_BufInit(BUF_IMG_ENC,1,fBufSize,2);
            }
            else if(tNodeInfo.ubCodecIdx == ENCODE_3)
            {
                BUF_BufInit(BUF_IMG_ENC,1,fBufSize,3);
            }
        }
    }

	//Aux Bitstream
#if (APP_DUAL_HOST_ENABLE == 1)
	for(i=0;i<3;i++)
#else
	for(i=0;i<4;i++)
#endif
	{
		if(ubKNL_ExistNode(KNL_SRC_1_AUX+i,KNL_NODE_VDO_BS_BUF1))
		{
			tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_AUX+i,KNL_NODE_VDO_BS_BUF1);
			if(ubKNL_GetAdjBufEnable())
				fBufSize = ( ((uint32_t)tNodeInfo.uwVdoH) * ((uint32_t)tNodeInfo.uwVdoV) * 1.5 )/KNL_MIN_COMPRESS_RATIO_ADJ;
			else
				fBufSize = ( ((uint32_t)tNodeInfo.uwVdoH) * ((uint32_t)tNodeInfo.uwVdoV) * 1.5 )/KNL_MIN_COMPRESS_RATIO;
			
			BUF_Reset(BUF_VDO_AUX_BS0+i);
#if (defined(VDO_SUBPATH_ENABLE)&&(VDO_SUBPATH_ENABLE!=0))			
			BUF_BufInit(BUF_VDO_AUX_BS0+i,BUF_NUM_VDO_BS_SUBSTREAM,fBufSize,0);			
#else
			if(ubKNL_GetAdjBufEnable())	           
				BUF_BufInit(BUF_VDO_AUX_BS0+i,BUF_NUM_VDO_BS_ADJ,fBufSize,0);
			else
				BUF_BufInit(BUF_VDO_AUX_BS0+i,BUF_NUM_VDO_BS,fBufSize,0);
#endif            
		}
	}	

    // Sensor YUV
    if(!(ubSEN_GetScaleMode() == SEN_SCALEUP_MODE) && ubKNL_ChkExistNode(KNL_NODE_SEN_YUV_BUF))
    {
        ubSrc = ubSEN_GetPathSrc(SENSOR_PATH2);
        if(ubSrc != KNL_SRC_NONE)
        {
            if ((KNL_GetTuningToolMode() == KNL_TUNINGMODE_ON) && (USBD_UVC_MODE == tUSBD_GetClassMode()))
                fBufSize = ((float)uwKNL_GetVdoH(ubSrc))*((float)uwKNL_GetVdoV(ubSrc)) * 2;
            else
                fBufSize = ((float)uwKNL_GetVdoH(ubSrc))*((float)uwKNL_GetVdoV(ubSrc)) * 1.5;
            BUF_BufInit(BUF_SEN_2_YUV,ubKNL_GetSensorBufNumber(),fBufSize,0);
            BUF_Reset(BUF_SEN_2_YUV);
        }
        ubSrc = ubSEN_GetPathSrc(SENSOR_PATH3);
        if(ubSrc != KNL_SRC_NONE)
        {
            if ((KNL_GetTuningToolMode() == KNL_TUNINGMODE_ON) && (USBD_UVC_MODE == tUSBD_GetClassMode()))
                fBufSize = ((float)uwKNL_GetVdoH(ubSrc))*((float)uwKNL_GetVdoV(ubSrc)) * 2;
            else
                fBufSize = ((float)uwKNL_GetVdoH(ubSrc))*((float)uwKNL_GetVdoV(ubSrc)) * 1.5;
            BUF_BufInit(BUF_SEN_3_YUV,ubKNL_GetSensorBufNumber(),fBufSize,0);
            BUF_Reset(BUF_SEN_3_YUV);
        }    
    }

    //REC
#if APP_REC_FUNC_ENABLE
		uint32_t ulResiMemSize, ulRecTime;
		uint32_t  ulRecStartAddr;

		ulRecStartAddr = ulBUF_GetFreeAddr();
		if(KNL_VIDEO_PLAY == tKNL_GetRecordFunc())
		{
			ulResiMemSize = (1 == ubKNL_VdoPlayActNum)?ulKNL_GetRECnPLYMemorySize(REC_MEM_MODE,KNL_RP_1FHD):
							(2 == ubKNL_VdoPlayActNum)?ulKNL_GetRECnPLYMemorySize(REC_MEM_MODE,KNL_RP_2HD):
							(4 == ubKNL_VdoPlayActNum)?ulKNL_GetRECnPLYMemorySize(REC_MEM_MODE,KNL_RP_4VGA):
													   ulKNL_GetRECnPLYMemorySize(REC_MEM_MODE,KNL_RP_4VGA);
		}
		else
		{
			if(DISPLAY_MODE == DISPLAY_1T1R)
            {
#if defined(HD_SUB_RES_FPS)            
                if(HD_SUB_RES_FPS == 60)
                    ulResiMemSize = ulKNL_GetRECnPLYMemorySize(REC_MEM_MODE,KNL_R_1HD60FPS);    // Used Fixed Memory Size
                else
#endif
                    ulResiMemSize = ulKNL_GetRECnPLYMemorySize(REC_MEM_MODE,KNL_R_1FHD);    // Used Fixed Memory Size
            }
			else if (DISPLAY_MODE == DISPLAY_2T1R)
				ulResiMemSize = ulKNL_GetRECnPLYMemorySize(REC_MEM_MODE,KNL_R_1FHD);//KNL_R_1FHD//KNL_RP_1HD
			else
				ulResiMemSize = ulKNL_GetRECnPLYMemorySize(REC_MEM_MODE,KNL_R_1FHD);
		}
		BUF_BufInit(BUF_REC,1,(ulResiMemSize+MP4_SIMSTSZ_SIZE*REC_SRC_NUM),0);

		if(KNL_RECORDING_STOP == tKNL_RecordAct.tRecordSts)
		{
			vREC_FileFormatSet(REC_FILE_MP4);
			KNL_RecFileFormatConfigInit();
			ulRecTime = ulREC_ModeSet(REC_MEM_MODE,ulResiMemSize);
			printd(DBG_InfoLvl, "MaxRECTime %d minutes BufAddr:%x BufSz:%x \r\n", ulRecTime, ulRecStartAddr, ulResiMemSize);
			Media_Init(ulBUF_GetBlkBufAddr(0,BUF_REC));
			printd(DBG_InfoLvl, "ulMedia_GetBufSz:0x%x\r\n", ulMedia_GetBufSz());

			if(REC_MemModeGet() == REC_MEM_MODE_SEPERATE)
				PLY_SetStartAddr(ulBUF_GetBlkBufAddr(0,BUF_REC) + ulMedia_GetBufSz());
			else
				PLY_SetStartAddr(ulBUF_GetBlkBufAddr(0,BUF_REC) + MP4_HEAD_SIZE + MP4_SIMSTSZ_SIZE*REC_SRC_NUM);

			printd(DBG_InfoLvl, "ulPLY_GetBufSz:0x%x\n", ulPLY_GetBufSz());
			printd(DBG_InfoLvl, "REC_PLAY MEM ADDR: START=0x%x, END=0x%x\n", ulBUF_GetBlkBufAddr(0,BUF_REC), ulBUF_GetBlkBufAddr(0,BUF_REC) + ulMedia_GetBufSz() + ulPLY_GetBufSz());
		}
#elif APP_PHOTOGRAPH_FUNC_ENABLE
#if (defined(BSP_RVCS_SDK)&&defined(OP_STA))
		BUF_BufInit(BUF_REC, 1, ulJpgBsBufSize, 0);
#else
        BUF_BufInit(BUF_REC, 1, ulJpgBsBufSize*4, 0);
#endif
#endif
    //Photo
#if APP_PHOTOGRAPH_FUNC_ENABLE
#if (defined(BSP_RVCS_SDK)&&defined(OP_STA))
        ulKNL_JPGAddr = ulBUF_GetBlkBufAddr(0,BUF_REC);
#else
        ulKNL_JPGAddr[0] = ulBUF_GetBlkBufAddr(0,BUF_REC);
        for(i=0;i<4;i++)
            ulKNL_JPGAddr[i] = ulKNL_JPGAddr[0] + (ulJpgBsBufSize*i);
#endif
#endif
#endif
//=======================================================================================================================
	ulBuf_S = ulBUF_GetFreeAddr();
	//SEN_YUV Node
	//================================================================	
	ubSrc = ubSEN_GetPathSrc(SENSOR_PATH1);
#if (((defined(BSP_VBM_SDK)||defined(BSP_RVCS_SDK)) && APP_REC_FUNC_ENABLE) || ((defined(BSP_VBM_SDK)||defined(BSP_RVCS_SDK)) && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE))
	// Modify for TX play. Release Sensor YUV Buffer at playing TX, And Sensor interrrupt need disable.
	if(ubSrc != KNL_SRC_NONE && ubKNL_ChkExistNode(KNL_NODE_SEN_YUV_BUF))
#else
	if(ubSrc != KNL_SRC_NONE)
#endif
	{
        if(ubKNL_GetIspEnable())
        {
            if ((KNL_GetTuningToolMode() == KNL_TUNINGMODE_ON) && (USBD_UVC_MODE == tUSBD_GetClassMode())) {
                fBufSize = ((float)uwKNL_GetVdoH(ubSrc)) * ((float)uwKNL_GetVdoV(ubSrc)) * 2;
            } else {
                fBufSize = ((float)uwKNL_GetVdoH(ubSrc)) * ((float)uwKNL_GetVdoV(ubSrc)) * 1.5;
            }
            if(ubSEN_GetScaleMode() == SEN_SCALEUP_MODE)
            {
                fBufSize = ((float)uwKNL_GetVdoH(ubSrc)) * ((float)uwKNL_GetVdoV(ubSrc)) * 1.5 *2 *2;
            }
            #if (defined(OP_STA) && (USBD_UVC_MJ_FMT == USBD_UVC_FMT) && USBD_ENABLE)
            if(TRUE == ubKNL_GetHQImgCapEn())
            {
                fBufSize = tKNL_CapHQImg.uwHQ_H * tKNL_CapHQImg.uwHQ_V * 1.5;
                BUF_BufInit(BUF_SEN_1_YUV, 1, fBufSize, 0);
                BUF_Reset(BUF_SEN_1_YUV);
                fBufSize = KNL_MJ_BUF_ALIGN_1K + KNL_JPG_HEADER_SIZE + KNL_UVCMJ_HQBS_SIZE;
                BUF_BufInit(BUF_USBD_VDO, 1, fBufSize, 0);
                BUF_Reset(BUF_USBD_VDO);
                printd(DBG_CriticalLvl, "  Final Free Buf = 0x%X\r\n", ulBUF_GetFreeAddr());
                return;
            }
            #endif
        }
        else
        {		
            fBufSize = ((float)uwKNL_GetVdoH(ubSrc)) * ((float)uwKNL_GetVdoV(ubSrc)) * 1.5;
            
        }
		if(ubSEN_GetScaleMode() == SEN_SCALEUP_MODE)
            BUF_BufInit(BUF_SEN_1_YUV,1,fBufSize,0);
        else
            BUF_BufInit(BUF_SEN_1_YUV,ubKNL_GetSensorBufNumber(),fBufSize,0);
		BUF_Reset(BUF_SEN_1_YUV);
	}
    
#if !(((defined(BSP_VBM_SDK)||defined(BSP_RVCS_SDK)) && APP_REC_FUNC_ENABLE) || ((defined(BSP_VBM_SDK)||defined(BSP_RVCS_SDK)) && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE))
    if(!(ubSEN_GetScaleMode() == SEN_SCALEUP_MODE))
    {
        ubSrc = ubSEN_GetPathSrc(SENSOR_PATH2);
        if(ubSrc != KNL_SRC_NONE)
        {
            if ((KNL_GetTuningToolMode() == KNL_TUNINGMODE_ON) && (USBD_UVC_MODE == tUSBD_GetClassMode()))
                fBufSize = ((float)uwKNL_GetVdoH(ubSrc))*((float)uwKNL_GetVdoV(ubSrc)) * 2;
            else
                fBufSize = ((float)uwKNL_GetVdoH(ubSrc))*((float)uwKNL_GetVdoV(ubSrc)) * 1.5;
            BUF_BufInit(BUF_SEN_2_YUV,ubKNL_GetSensorBufNumber(),fBufSize,0);
            BUF_Reset(BUF_SEN_2_YUV);
        }
        ubSrc = ubSEN_GetPathSrc(SENSOR_PATH3);
        if(ubSrc != KNL_SRC_NONE)
        {
            if ((KNL_GetTuningToolMode() == KNL_TUNINGMODE_ON) && (USBD_UVC_MODE == tUSBD_GetClassMode()))
                fBufSize = ((float)uwKNL_GetVdoH(ubSrc))*((float)uwKNL_GetVdoV(ubSrc)) * 2;
            else
                fBufSize = ((float)uwKNL_GetVdoH(ubSrc))*((float)uwKNL_GetVdoV(ubSrc)) * 1.5;
            BUF_BufInit(BUF_SEN_3_YUV,ubKNL_GetSensorBufNumber(),fBufSize,0);
            BUF_Reset(BUF_SEN_3_YUV);
        }    
    }
#endif
	ulBuf_E = ulBUF_GetFreeAddr();
	if(BUF_INFO_OUTPUT)
		printf("== SEN:%d KB ==\r\n",(ulBuf_E-ulBuf_S)/1024);
	
	ulBuf_S = ulBUF_GetFreeAddr();		

	if(SEN_USE == SEN_TP9950)
	{	
		fBufSize = 0xA8C00<<1;                                 //(1280*(720/2)*3/2)*2
	}
	else if(SEN_USE == SEN_RN6752)
	{
		fBufSize = 0xA8C00; 
	}else{
        fBufSize = 0;
    }
    BUF_BufInit(BUF_VDO_TEMP1, 1, fBufSize, 0); 
    SEN_SetPathAddr(IMG_TEMP1, ulBUF_GetBlkBufAddr(0, BUF_VDO_TEMP1));
	
	ulBuf_E = ulBUF_GetFreeAddr();
	if(BUF_INFO_OUTPUT)
		printf("== CVBS:%d KB ==\r\n",(ulBuf_E-ulBuf_S)/1024);
    //================================================================
#if USBD_ENABLE
	ulBuf_S = ulBUF_GetFreeAddr();
	if((DISPLAY_1T1R == DISPLAY_MODE) && ((USBD_UVC_MODE == tUSBD_GetClassMode()) || (TRUE == ubUSBD_ChkCompUvcClass())) &&
	   (KNL_TUNINGMODE_OFF == KNL_GetTuningToolMode()))
	{
	#define KNL_UVC_YUVBUF_NUM	2
		fBufSize = 640 * 480 * 2;
		BUF_BufInit(BUF_USBD_VDO, KNL_UVC_YUVBUF_NUM, (fBufSize+USBD_UVC_HEADER_LEN), 0);
		BUF_Reset(BUF_USBD_VDO);
	}
	
	ulBuf_E = ulBUF_GetFreeAddr();
	if(BUF_INFO_OUTPUT)
		printf("== UVC:%d KB ==\r\n",(ulBuf_E-ulBuf_S)/1024);
	
#endif
#ifdef BIO_BU
	BUF_BufInit(BUF_FD_RECT_OSD, 1, FD_OSD_BUF_SZ, 0);
#endif

#if IMG_DS_EN
	fBufSize = IMG_DSGetBufferSize(IMG_DS1_HD_Width, IMG_DS3_Height);
	BUF_BufInit(BUF_IMG_DS1, 1, fBufSize, 0);
#endif

#endif
	
	// REC ALL AP or DVR STA
#if (defined(OP_AP) || !((defined(BSP_VBM_SDK) || defined(BSP_RVCS_SDK)) || ((defined(BSP_VBM_SDK) || defined(BSP_RVCS_SDK)) && APP_PLAY_REMOTE_ENABLE)))
#if APP_REC_FUNC_ENABLE
	uint32_t ulResiMemSize, ulRecTime;
	uint32_t  ulRecStartAddr;

	ulRecStartAddr = ulBUF_GetFreeAddr();
	if(KNL_VIDEO_PLAY == tKNL_GetRecordFunc())
	{
#if !defined(BSP_DVR_SDK)
        #if ((defined(BSP_VBM_SDK) || defined(BSP_RVCS_SDK)) && APP_PLAY_REMOTE_ENABLE)
		ulResiMemSize = (1 == ubKNL_VdoPlayActNum)?ulKNL_GetRECnPLYMemorySize(REC_MEM_MODE,KNL_RP_1FHD):
		#else
		ulResiMemSize = (1 == ubKNL_VdoPlayActNum)?ulKNL_GetRECnPLYMemorySize(REC_MEM_MODE,KNL_RP_1FHD):
		#endif
						(2 == ubKNL_VdoPlayActNum)?ulKNL_GetRECnPLYMemorySize(REC_MEM_MODE,KNL_RP_2HD):
						(4 == ubKNL_VdoPlayActNum)?ulKNL_GetRECnPLYMemorySize(REC_MEM_MODE,KNL_RP_4VGA):
												   ulKNL_GetRECnPLYMemorySize(REC_MEM_MODE,KNL_RP_4VGA);
#else
		ulResiMemSize = (1 == ubKNL_VdoPlayActNum)?ulKNL_GetRECnPLYMemorySize(REC_MEM_MODE,KNL_RP_1FHD):
						(2 == ubKNL_VdoPlayActNum)?ulKNL_GetRECnPLYMemorySize(REC_MEM_MODE,KNL_RP_1HD_1FHD):
						(4 == ubKNL_VdoPlayActNum)?ulKNL_GetRECnPLYMemorySize(REC_MEM_MODE,KNL_RP_4VGA):
												   ulKNL_GetRECnPLYMemorySize(REC_MEM_MODE,KNL_RP_4VGA);
#endif
	}
	else
	{
		if(DISPLAY_MODE == DISPLAY_1T1R)
			ulResiMemSize = ulKNL_GetRECnPLYMemorySize(REC_MEM_MODE,KNL_R_1FHD);	// Used Fixed Memory Size
		else if (DISPLAY_MODE == DISPLAY_2T1R)
#if defined(OP_AP)
#if defined(BSP_DVR_SDK)
			ulResiMemSize = ulKNL_GetRECnPLYMemorySize(REC_MEM_MODE,KNL_RP_1HD_1FHD);
#else
			ulResiMemSize = ulKNL_GetRECnPLYMemorySize(REC_MEM_MODE,KNL_RP_2HD);
#endif		
#else
			ulResiMemSize = ulKNL_GetRECnPLYMemorySize(REC_MEM_MODE,KNL_R_1FHD);
#endif		
		else
#if defined(OP_AP)      
			ulResiMemSize = ulKNL_GetRECnPLYMemorySize(REC_MEM_MODE,KNL_RP_4VGA);
#else
			ulResiMemSize = ulKNL_GetRECnPLYMemorySize(REC_MEM_MODE,KNL_R_1FHD);
#endif
	}
	BUF_BufInit(BUF_REC,1,ulResiMemSize+MP4_SIMSTSZ_SIZE*REC_SRC_NUM,0);

	if(KNL_RECORDING_STOP == tKNL_RecordAct.tRecordSts)
	{
		vREC_FileFormatSet(REC_FILE_MP4);
		KNL_RecFileFormatConfigInit();
		ulRecTime = ulREC_ModeSet(REC_MEM_MODE,ulResiMemSize);
		printd(DBG_InfoLvl, "MaxRECTime %d minutes BufAddr:%x BufSz:%x \r\n", ulRecTime, ulRecStartAddr, ulResiMemSize);
		Media_Init(ulBUF_GetBlkBufAddr(0,BUF_REC));
		printd(DBG_InfoLvl, "ulMedia_GetBufSz:0x%x\r\n", ulMedia_GetBufSz());

		if(REC_MemModeGet() == REC_MEM_MODE_SEPERATE)
			PLY_SetStartAddr(ulBUF_GetBlkBufAddr(0,BUF_REC) + ulMedia_GetBufSz());
		else
			PLY_SetStartAddr(ulBUF_GetBlkBufAddr(0,BUF_REC) + MP4_HEAD_SIZE + MP4_SIMSTSZ_SIZE*REC_SRC_NUM);

		printd(DBG_InfoLvl, "ulPLY_GetBufSz:0x%x\n", ulPLY_GetBufSz());
		printd(DBG_InfoLvl, "REC_PLAY MEM ADDR: START=0x%x, END=0x%x\n", ulBUF_GetBlkBufAddr(0,BUF_REC), ulBUF_GetBlkBufAddr(0,BUF_REC) + ulMedia_GetBufSz() + ulPLY_GetBufSz());
	}
#elif APP_PHOTOGRAPH_FUNC_ENABLE
	#if (defined(BSP_DVR_SDK) || (defined(BSP_RVCS_SDK)&&defined(OP_STA)))
	ulJpgBsStartAddr = ulBUF_GetFreeAddr();
	ulTempYUV_StartAddr = ulJpgBsStartAddr + ulJpgBsBufSize;
	ulTempYUV_StartAddr = ulBUF_AlignAddrTo1K(ulTempYUV_StartAddr);
	ulTempYUV_EndAddr = ulTempYUV_StartAddr + ulTempYUV_BufSize;
	ulTempYUV_EndAddr = ulBUF_AlignAddrTo1K(ulTempYUV_EndAddr);
	BUF_BufInit(BUF_REC, 1, ulTempYUV_EndAddr-ulJpgBsStartAddr, 0);
	#else
	BUF_BufInit(BUF_REC, 1, ulJpgBsBufSize*4, 0);
	#endif
#endif

    //Photo
#if APP_PHOTOGRAPH_FUNC_ENABLE
	#if (defined(BSP_DVR_SDK) || (defined(BSP_RVCS_SDK)&&defined(OP_STA)))
	ulKNL_JPGAddr = ulBUF_GetBlkBufAddr(0,BUF_REC);
	KNL_SetLocalSnapshotBsBuf(ulKNL_JPGAddr);
	ulTempYUV_StartAddr = ulKNL_JPGAddr + ulJpgBsBufSize;
	ulTempYUV_StartAddr = ulBUF_AlignAddrTo1K(ulTempYUV_StartAddr);
	KNL_SetLocalSnapshotYuvBuf(ulTempYUV_StartAddr);
	#else
	ulKNL_JPGAddr[0] = ulBUF_GetBlkBufAddr(0,BUF_REC);
	for(i=0;i<4;i++)
		ulKNL_JPGAddr[i] = ulKNL_JPGAddr[0] + (ulJpgBsBufSize*i);
	#endif
#endif
#endif

#if (defined(OP_AP) && defined(BSP_DVR_SDK))
    //LCD Node
    //================================================================
    ubNodeExist = ubKNL_ChkExistNode(KNL_NODE_LCD);
    if(ubNodeExist)
    {
        ulBuf_S = ulBUF_GetFreeAddr();
        
        fBufSize = ulKNL_CalLcdBufSz();
        BUF_BufInit(BUF_LCD_IP,1,fBufSize,0);
        
        ulBuf_E = ulBUF_GetFreeAddr();
        if(BUF_INFO_OUTPUT)
            printf("== LCD:%d KB ==\r\n",(ulBuf_E-ulBuf_S)/1024);
    }
#endif

	//H264_DEC Node
	//================================================================
	ulBuf_S = ulBUF_GetFreeAddr();
	//For Main Source

#if (APP_DUAL_HOST_ENABLE == 1)
	for(i=0;i<3;i++)
#else
	for(i=0;i<4;i++)
#endif
	{
		if(ubKNL_ExistNode(KNL_SRC_1_MAIN+i,KNL_NODE_H264_DEC))
		{
			tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_MAIN+i,KNL_NODE_H264_DEC);
			fBufSize = ulH264_GetDECBufferSize(tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
			if(tNodeInfo.ubCodecIdx == DECODE_0)
			{
				BUF_BufInit(BUF_IMG_DEC,1,fBufSize,0);
			}
			else if(tNodeInfo.ubCodecIdx == DECODE_1)
			{
				BUF_BufInit(BUF_IMG_DEC,1,fBufSize,1);
			}
			else if(tNodeInfo.ubCodecIdx == DECODE_2)
			{
				BUF_BufInit(BUF_IMG_DEC,1,fBufSize,2);
			}
			else if(tNodeInfo.ubCodecIdx == DECODE_3)
			{
				BUF_BufInit(BUF_IMG_DEC,1,fBufSize,3);
			}
		}
	}
	//For Aux Source

#if (APP_DUAL_HOST_ENABLE == 1)
	for(i=0;i<3;i++)
#else
	for(i=0;i<4;i++)
#endif
	{
		if(ubKNL_ExistNode(KNL_SRC_1_AUX+i,KNL_NODE_H264_DEC))
		{
			tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_AUX+i,KNL_NODE_H264_DEC);
			fBufSize = ulH264_GetDECBufferSize(tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
			if(tNodeInfo.ubCodecIdx == DECODE_0)
			{
				BUF_BufInit(BUF_IMG_DEC,1,fBufSize,0);
			}
			else if(tNodeInfo.ubCodecIdx == DECODE_1)
			{
				BUF_BufInit(BUF_IMG_DEC,1,fBufSize,1);
			}
			else if(tNodeInfo.ubCodecIdx == DECODE_2)
			{
				BUF_BufInit(BUF_IMG_DEC,1,fBufSize,2);
			}
			else if(tNodeInfo.ubCodecIdx == DECODE_3)
			{
				BUF_BufInit(BUF_IMG_DEC,1,fBufSize,3);
			}
		}
	}
	//For Sub Source

#if (APP_DUAL_HOST_ENABLE == 1)
	for(i=0;i<3;i++)
#else
	for(i=0;i<4;i++)
#endif
	{
		if(ubKNL_ExistNode(KNL_SRC_1_SUB+i,KNL_NODE_H264_DEC))
		{
			tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_SUB+i,KNL_NODE_H264_DEC);
			fBufSize = ulH264_GetDECBufferSize(tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
			if(tNodeInfo.ubCodecIdx == DECODE_0)
			{
				BUF_BufInit(BUF_IMG_DEC,1,fBufSize,0);
			}
			else if(tNodeInfo.ubCodecIdx == DECODE_1)
			{
				BUF_BufInit(BUF_IMG_DEC,1,fBufSize,1);
			}
			else if(tNodeInfo.ubCodecIdx == DECODE_2)
			{
				BUF_BufInit(BUF_IMG_DEC,1,fBufSize,2);
			}
			else if(tNodeInfo.ubCodecIdx == DECODE_3)
			{
				BUF_BufInit(BUF_IMG_DEC,1,fBufSize,3);
			}
		}
	}
	ulBuf_E = ulBUF_GetFreeAddr();
	if(BUF_INFO_OUTPUT)
		printf("H264-IP(Decoder):%d\r\n",(ulBuf_E-ulBuf_S)/1024);

	//H264_ENC Node	
	//================================================================
	ulBuf_S = ulBUF_GetFreeAddr();
	
	//For Main Source
	for(i=0;i<4;i++)
	{
		if(ubKNL_ExistNode(KNL_SRC_1_MAIN+i,KNL_NODE_H264_ENC))
		{
			tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_MAIN+i,KNL_NODE_H264_ENC);
			fBufSize = ulH264_GetENCBufferSize(tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
			if(tNodeInfo.ubCodecIdx == ENCODE_0)
			{
				BUF_BufInit(BUF_IMG_ENC,1,fBufSize,0);
			}
			else if(tNodeInfo.ubCodecIdx == ENCODE_1)
			{
				BUF_BufInit(BUF_IMG_ENC,1,fBufSize,1);
			}
			else if(tNodeInfo.ubCodecIdx == ENCODE_2)
			{
				BUF_BufInit(BUF_IMG_ENC,1,fBufSize,2);
			}
			else if(tNodeInfo.ubCodecIdx == ENCODE_3)
			{
				BUF_BufInit(BUF_IMG_ENC,1,fBufSize,3);
			}
		}
	}
#if (defined(OP_AP) ||!(((defined(BSP_VBM_SDK)||defined(BSP_RVCS_SDK)) && APP_REC_FUNC_ENABLE) || ((defined(BSP_VBM_SDK)||defined(BSP_RVCS_SDK)) && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)))
	//For Aux Source
	for(i=0;i<4;i++)
	{
		if(ubKNL_ExistNode(KNL_SRC_1_AUX+i,KNL_NODE_H264_ENC))
		{
			tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_AUX+i,KNL_NODE_H264_ENC);		
			fBufSize = ulH264_GetENCBufferSize(tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
			if(tNodeInfo.ubCodecIdx == ENCODE_0)
			{
				BUF_BufInit(BUF_IMG_ENC,1,fBufSize,0);
			}
			else if(tNodeInfo.ubCodecIdx == ENCODE_1)
			{
				BUF_BufInit(BUF_IMG_ENC,1,fBufSize,1);
			}
			else if(tNodeInfo.ubCodecIdx == ENCODE_2)
			{
				BUF_BufInit(BUF_IMG_ENC,1,fBufSize,2);
			}
			else if(tNodeInfo.ubCodecIdx == ENCODE_3)
			{
				BUF_BufInit(BUF_IMG_ENC,1,fBufSize,3);
			}
		}
	}
#endif
	//For Sub Source
	for(i=0;i<4;i++)
	{
		if(ubKNL_ExistNode(KNL_SRC_1_SUB+i,KNL_NODE_H264_ENC))
		{
			tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_SUB+i,KNL_NODE_H264_ENC);		
			fBufSize = ulH264_GetENCBufferSize(tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
			if(tNodeInfo.ubCodecIdx == ENCODE_0)
			{
				BUF_BufInit(BUF_IMG_ENC,1,fBufSize,0);
			}
			else if(tNodeInfo.ubCodecIdx == ENCODE_1)
			{
				BUF_BufInit(BUF_IMG_ENC,1,fBufSize,1);
			}
			else if(tNodeInfo.ubCodecIdx == ENCODE_2)
			{
				BUF_BufInit(BUF_IMG_ENC,1,fBufSize,2);
			}
			else if(tNodeInfo.ubCodecIdx == ENCODE_3)
			{
				BUF_BufInit(BUF_IMG_ENC,1,fBufSize,3);
			}
		}
	}	

#if (defined(OP_AP) && defined(BSP_DVR_SDK))
	if(ubKNL_ExistNode(KNL_SRC_STORAGE_LOCAL,KNL_NODE_H264_ENC))
	{
		tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_STORAGE_LOCAL,KNL_NODE_H264_ENC);
		fBufSize = ulH264_GetENCBufferSize(tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
		if(tNodeInfo.ubCodecIdx == ENCODE_0)
		{
			BUF_BufInit(BUF_IMG_ENC,1,fBufSize,0);
		}
		else if(tNodeInfo.ubCodecIdx == ENCODE_1)
		{
			BUF_BufInit(BUF_IMG_ENC,1,fBufSize,1);
		}
		else if(tNodeInfo.ubCodecIdx == ENCODE_2)
		{
			BUF_BufInit(BUF_IMG_ENC,1,fBufSize,2);
		}
		else if(tNodeInfo.ubCodecIdx == ENCODE_3)
		{
			BUF_BufInit(BUF_IMG_ENC,1,fBufSize,3);
		}
	}
#endif
	
	ulBuf_E = ulBUF_GetFreeAddr();
	if(BUF_INFO_OUTPUT)
		printf("H264-IP(Encoder):%d\r\n",(ulBuf_E-ulBuf_S)/1024);

	ulBuf_S = ulBUF_GetFreeAddr();
	//VDO_BS_BUF Node
	//================================================================
	//(For BS_BUF1)
	//Main
#if (defined(OP_AP) && defined(BSP_DVR_SDK))
	for(i=0;i<1;i++)	//AP(BSP_DVR_SDK = 1)	
#else

#if (APP_DUAL_HOST_ENABLE == 1)
	for(i=0;i<3;i++)
#else
	for(i=0;i<4;i++)
#endif
#endif
	{
		if(ubKNL_ExistNode(KNL_SRC_1_MAIN+i,KNL_NODE_VDO_BS_BUF1))
		{
			tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_MAIN+i,KNL_NODE_VDO_BS_BUF1);
			printd(DBG_InfoLvl, "	BS[%dx%d]\n", tNodeInfo.uwVdoH, tNodeInfo.uwVdoV);
#if (defined(OP_AP) && defined(BSP_DVR_SDK))
            fBufSize = ( ((uint32_t)tNodeInfo.uwVdoH) * ((uint32_t)tNodeInfo.uwVdoV) * 1.5 )/KNL_MIN_COMPRESS_RATIO_LR;
#else
			if(ubKNL_GetAdjBufEnable())	
				fBufSize = ( ((uint32_t)tNodeInfo.uwVdoH) * ((uint32_t)tNodeInfo.uwVdoV) * 1.5 )/KNL_MIN_COMPRESS_RATIO_ADJ;
			else
				fBufSize = ( ((uint32_t)tNodeInfo.uwVdoH) * ((uint32_t)tNodeInfo.uwVdoV) * 1.5 )/KNL_MIN_COMPRESS_RATIO;
#endif
		#if (defined(S2019A) || (defined(OP_AP) && defined(sWIFIBDG)))
			#ifdef S2019A
			fBufSize /= 2;
			#endif
			tKNL_VdoBsOvfInfo.ulBsBufSize = fBufSize;
			#if (defined(OP_AP) && (defined(RVCS_APP) || defined(sWIFIBDG)))
			BUF_BufInit(BUF_WIFI_BDG, BUF_NUM_BDG_VDO_BS, fBufSize, 0);
			BUF_Reset(BUF_WIFI_BDG);
			#endif
		#endif
			
		//justin 2020.04.15
			if(ubKNL_GetAdjBufEnable())			
				BUF_BufInit(BUF_VDO_MAIN_BS0+i,BUF_NUM_VDO_BS_ADJ,fBufSize,0);
			else
#if (!APP_REC_FUNC_ENABLE && APP_PHOTOGRAPH_FUNC_ENABLE)
                BUF_BufInit(BUF_VDO_MAIN_BS0+i,BUF_NUM_VDO_BS_NOREC,fBufSize,0);
#else
                BUF_BufInit(BUF_VDO_MAIN_BS0+i,BUF_NUM_VDO_BS,fBufSize,0);
#endif
			BUF_Reset(BUF_VDO_MAIN_BS0+i);
		#if (defined(OP_AP) && ((USBD_UVC_H264_FMT == USBD_UVC_FMT) || (USBD_UVC_H265_FMT == USBD_UVC_FMT)) && USBD_ENABLE)
			if((DISPLAY_1T1R == DISPLAY_MODE) && ((USBD_UVC_MODE == tUSBD_GetClassMode()) || (TRUE == ubUSBD_ChkCompUvcClass())))
			{
				uint8_t ubUvcBsBuf = 2;
				if(USBD_UVC_H265_FMT == USBD_UVC_FMT)
					ubUvcBsBuf = 6;
				BUF_BufInit(BUF_USBD_VDO, ubUvcBsBuf, (fBufSize+USBD_UVC_HEADER_LEN), 0);
				BUF_Reset(BUF_USBD_VDO);
			}
		#endif
		}
	}
	//Sub

#if (APP_DUAL_HOST_ENABLE == 1)
	for(i=0;i<3;i++)
#else
	for(i=0;i<4;i++)
#endif
	{
		if(ubKNL_ExistNode(KNL_SRC_1_SUB+i,KNL_NODE_VDO_BS_BUF1))
		{
			tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_SUB+i,KNL_NODE_VDO_BS_BUF1);			
			
			if(ubKNL_GetAdjBufEnable())	
			{
				fBufSize = ( ((uint32_t)tNodeInfo.uwVdoH) * ((uint32_t)tNodeInfo.uwVdoV) * 1.5 )/KNL_MIN_COMPRESS_RATIO_ADJ;	
				BUF_BufInit(BUF_VDO_SUB_BS00+i,BUF_NUM_VDO_BS_ADJ,fBufSize,0);
			}
			else
			{
				fBufSize = ( ((uint32_t)tNodeInfo.uwVdoH) * ((uint32_t)tNodeInfo.uwVdoV) * 1.5 )/KNL_MIN_COMPRESS_RATIO;	
				BUF_BufInit(BUF_VDO_SUB_BS00+i,BUF_NUM_VDO_BS,fBufSize,0);
			}
			
			BUF_Reset(BUF_VDO_SUB_BS00+i);
		}
	}
#if (defined(OP_AP) ||!(((defined(BSP_VBM_SDK)||defined(BSP_RVCS_SDK)) && APP_REC_FUNC_ENABLE) || ((defined(BSP_VBM_SDK)||defined(BSP_RVCS_SDK)) && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)))
	//Aux

#if (APP_DUAL_HOST_ENABLE == 1)
	for(i=0;i<3;i++)
#else
	for(i=0;i<4;i++)
#endif
	{
		if(ubKNL_ExistNode(KNL_SRC_1_AUX+i,KNL_NODE_VDO_BS_BUF1))
		{
			tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_AUX+i,KNL_NODE_VDO_BS_BUF1);
			if(ubKNL_GetAdjBufEnable())
				fBufSize = ( ((uint32_t)tNodeInfo.uwVdoH) * ((uint32_t)tNodeInfo.uwVdoV) * 1.5 )/KNL_MIN_COMPRESS_RATIO_ADJ;
			else
				fBufSize = ( ((uint32_t)tNodeInfo.uwVdoH) * ((uint32_t)tNodeInfo.uwVdoV) * 1.5 )/KNL_MIN_COMPRESS_RATIO;
			
			BUF_Reset(BUF_VDO_AUX_BS0+i);
#if (defined(OP_STA)&&defined(VDO_SUBPATH_ENABLE)&&(VDO_SUBPATH_ENABLE==1))			
			BUF_BufInit(BUF_VDO_AUX_BS0+i,BUF_NUM_VDO_BS_SUBSTREAM,fBufSize,0);			
#else
			if(ubKNL_GetAdjBufEnable())	           
				BUF_BufInit(BUF_VDO_AUX_BS0+i,BUF_NUM_VDO_BS_ADJ,fBufSize,0);
			else
				BUF_BufInit(BUF_VDO_AUX_BS0+i,BUF_NUM_VDO_BS,fBufSize,0);
#endif            
		}
	}	
#endif

#if (defined(OP_AP) && defined(BSP_DVR_SDK))	
	if(ubKNL_ExistNode(KNL_SRC_STORAGE_LOCAL,KNL_NODE_H264_ENC))
	{
		tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_STORAGE_LOCAL,KNL_NODE_VDO_BS_BUF1);
		
		fBufSize = ( ((uint32_t)tNodeInfo.uwVdoH) * ((uint32_t)tNodeInfo.uwVdoV) * 1.5 )/KNL_MIN_COMPRESS_RATIO;
		BUF_BufInit(BUF_VDO_MAIN_BS0+tNodeInfo.ubCodecIdx,BUF_NUM_VDO_BS_STORAGE,fBufSize,0);
		BUF_Reset(BUF_VDO_MAIN_BS0+tNodeInfo.ubCodecIdx);		
	}
#endif
	ulBuf_E = ulBUF_GetFreeAddr();
	if(BUF_INFO_OUTPUT)
		printf("== H264-BS:%d KB ==\r\n",(ulBuf_E-ulBuf_S)/1024);
	//(For BS_BUF2)	

#if (APP_DUAL_HOST_ENABLE == 1)
	for(i=0;i<3;i++)
#else
	for(i=0;i<4;i++)
#endif
	{
		if(ubKNL_ExistNode(KNL_SRC_1_SUB+i,KNL_NODE_VDO_BS_BUF2))
		{
			tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_SUB+i,KNL_NODE_VDO_BS_BUF2);
			fBufSize = ( ((uint32_t)tNodeInfo.uwVdoH) * ((uint32_t)tNodeInfo.uwVdoV) * 1.5 )/KNL_MIN_COMPRESS_RATIO;
			BUF_BufInit(BUF_VDO_SUB_BS01+i,BUF_NUM_VDO_BS,fBufSize,0);
			BUF_Reset(BUF_VDO_SUB_BS01+i);
		}
	}

	#if (((USBD_UVC_MJ_FMT == USBD_UVC_FMT) || (USBD_UVC_H264_FMT == USBD_UVC_FMT))  && USBD_ENABLE)	//! UVC for MJPEG
		#ifdef OP_AP
		if((DISPLAY_1T1R == DISPLAY_MODE) && ((USBD_UVC_MODE == tUSBD_GetClassMode()) || (TRUE == ubUSBD_ChkCompUvcClass())))
		#else
		if((KNL_TUNINGMODE_OFF == KNL_GetTuningToolMode()) && ((USBD_UVC_MODE == tUSBD_GetClassMode()) || (TRUE == ubUSBD_ChkCompUvcClass())))
		#endif
		{
		#define KNL_UVC_MJBUF_NUM	2
			fBufSize = KNL_MJ_BUF_ALIGN_1K + KNL_JPG_HEADER_SIZE + KNL_UVCMJ_BS_SIZE;
			BUF_BufInit(BUF_USBD_VDO, KNL_UVC_MJBUF_NUM, fBufSize, 0);
			BUF_Reset(BUF_USBD_VDO);
		}
	#endif

	BUF_Reset(BUF_RESV_YUV);
	#ifdef OP_AP
	if((TRUE == ubKNL_BbPathAct) || (APP_REC_FUNC_ENABLE || APP_PHOTOGRAPH_FUNC_ENABLE))
	{
		KNL_DISP_TYPE tDispType;
		tNodeInfo.uwVdoH = tNodeInfo.uwVdoV = 0;
		for(i = 0; i < 4; i++)
		{
			if(ubKNL_ExistNode(KNL_SRC_1_MAIN+i, KNL_NODE_H264_DEC))
			{
				tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_MAIN+i, KNL_NODE_H264_DEC);
				break;
			}
		}
		tDispType = tKNL_GetDispType();
		switch(ubKNL_GetOpMode())
		{
			case KNL_OPMODE_VBM_1T:
			case KNL_OPMODE_BUC_1T:
				fBufSize = (tNodeInfo.uwVdoH * tNodeInfo.uwVdoV * 3) >> 1;
				BUF_BufInit(BUF_RESV_YUV, 1, fBufSize, 0);
				break;
			case KNL_OPMODE_VBM_4T:
			case KNL_OPMODE_BUC_4T:
				if((TRUE == ubKNL_BbPathAct) || (KNL_DISP_SINGLE == tDispType) ||
				   (KNL_DISP_H == tDispType) || (KNL_DISP_QUAD == tDispType) ||
				   (KNL_DISP_3T_2L1R == tDispType) || (KNL_DISP_3T_1L2R == tDispType) ||
				   (KNL_DISP_3T_2T1B == tDispType) || (KNL_DISP_3T_1T2B == tDispType) ||
				   (KNL_DISP_3T_3COL == tDispType))
				{
					fBufSize = (tNodeInfo.uwVdoH * tNodeInfo.uwVdoV * 3) >> 1;
					BUF_BufInit(BUF_RESV_YUV, 1, fBufSize, 0);
				}
				break;
			default:
				break;
		}
	}
	#endif

#if !(defined(OP_AP) && defined(BSP_DVR_SDK))
    //LCD Node
    //================================================================
    ubNodeExist = ubKNL_ChkExistNode(KNL_NODE_LCD);
    if(ubNodeExist)
    {
        ulBuf_S = ulBUF_GetFreeAddr();
        
        fBufSize = ulKNL_CalLcdBufSz();
        BUF_BufInit(BUF_LCD_IP,1,fBufSize,0);
        
        ulBuf_E = ulBUF_GetFreeAddr();
        if(BUF_INFO_OUTPUT)
            printf("== LCD:%d KB ==\r\n",(ulBuf_E-ulBuf_S)/1024);
    }
#endif    

    if((ubNodeExist == 0)&&(ubKNL_ChkExistNode(KNL_NODE_UVC_MJPG)))
    {   
        BUF_Reset(BUF_DEC_YUV);   
        fBufSize = (tNodeInfo.uwVdoH * tNodeInfo.uwVdoV * 3) >> 1;
        BUF_BufInit(BUF_DEC_YUV, 1, fBufSize, 0);
    }
    
	//IMG_MERGE Node
	//================================================================
	ubNodeExist = ubKNL_ChkExistNode(KNL_NODE_IMG_MERGE_H)|ubKNL_ChkExistNode(KNL_NODE_IMG_MERGE_BUF);
	if(ubNodeExist)
	{
		fBufSize  = ulKNL_GetImgMergeBufSz();
		BUF_BufInit(BUF_IMG_MERGE, 1, fBufSize, 0);
		//Clear Merge Buffer @Dummy Buffer
		if((tKNL_GetDispType() == KNL_DISP_H) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0))
		{
			ulAddr = ulBUF_GetBlkBufAddr(0, BUF_IMG_MERGE);
			ubSrc = ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
			tDMAC_MemSet (0x00,ulAddr,((float)uwKNL_GetLcdDmyImgH())*((float)uwKNL_GetVdoV(ubSrc))*1.5,NULL);
		}
	}
	else if(KNL_DISP_H == tKNL_GetDispType())
	{
		fBufSize = ulKNL_GetImgMergeBufSz();
		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
			fBufSize += KNL_JPG_BS_SIZE;
		BUF_BufInit(BUF_IMG_MERGE, 1, fBufSize, 0);
		ulAddr = ulBUF_GetBlkBufAddr(0, BUF_IMG_MERGE);
		KNL_CreateBlackDmyPat(ulAddr, fBufSize);
	}
	else if((((KNL_DISP_3T_2L1R == tKNL_GetDispType()) || (KNL_DISP_3T_1L2R == tKNL_GetDispType())) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)) ||
		    (((KNL_DISP_3T_2T1B == tKNL_GetDispType()) || (KNL_DISP_3T_1T2B == tKNL_GetDispType())) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0))  ||
	         ((KNL_DISP_3T_3COL == tKNL_GetDispType()) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)))
	{
		fBufSize = ulKNL_GetImgMergeBufSz();
		BUF_BufInit(BUF_IMG_MERGE, 1, fBufSize, 0);
		ulAddr = ulBUF_GetBlkBufAddr(0, BUF_IMG_MERGE);
		KNL_CreateBlackDmyPat(ulAddr, fBufSize);
	}

#if ((KNL_USBH_FUNC_ENABLE) && (KNL_USBH_UVCCLASS_ENABLE) && (!defined(KNL_USBH_SPRF)))
	ulBuf_S = ulBUF_GetFreeAddr();
	
	memset(&uvc_frame_info, 0, sizeof(USBH_UVC_FRAME_INFO));
	#if defined (CONFIG_DUAL_HOST)

	#if (APP_DUAL_HOST_ENABLE == 1)
		uvc_stream_num = 2;
	#else	
		uvc_stream_num = 4;
	#endif	
	for(i = 0; i < uvc_stream_num; i++) {
	#if (APP_DUAL_HOST_ENABLE == 1)
		uvc_frame_info.fmt[i]      = USBH_UVC_H264;
	#else
		uvc_frame_info.fmt[i]      = USBH_UVC_MJPEG;
	#endif				
		uvc_frame_info.ulWidth[i]  = 1280;
		uvc_frame_info.ulHeight[i] = 720;
	}
	fBufSize = ulUSBH_GetBufferSize(0, 1, uvc_stream_num, uvc_frame_info);
	#else
	uvc_stream_num = 2;
	for(i = 0; i < uvc_stream_num; i++) {
		uvc_frame_info.fmt[i]      = USBH_UVC_MJPEG;
		uvc_frame_info.ulWidth[i]  = 1280;
		uvc_frame_info.ulHeight[i] = 720;
	}
	fBufSize = ulUSBH_GetBufferSize(0, 0, uvc_stream_num, uvc_frame_info);
	#endif
	BUF_BufInit(BUF_USBH_IP, 1, fBufSize, 0);
	//justin 2020.09.02
	//printf("USB_TRX Init\r\n");
	BUF_BufInit(BUF_USB_TRX, 1, 1024, 0);	//512 Byte for TX, 512 Byte for RX		
	
	ulBuf_E = ulBUF_GetFreeAddr();
	if(BUF_INFO_OUTPUT)
		printf("== USB(Host):%d KB ==\r\n",(ulBuf_E-ulBuf_S)/1024);
#endif

#if (defined(OP_AP) && defined(BSP_DVR_SDK))	
	BUF_BufInit(BUF_JPG_BS2,1,(VDO_LOCAL_PREVIEW_H_SIZE*VDO_LOCAL_PREVIEW_V_SIZE)/3,0);
#endif
  
#if ((defined(OP_STA) && defined(BSP_DVR_SDK)) || (defined(OP_AP) && defined(BSP_DVR_SDK)))
	if(!ubKNL_GetPlayBackIngFlg())
	{
        //SEN_YUV Node
        //================================================================  
        ubSrc = ubSEN_GetPathSrc(SENSOR_PATH1);
        if(ubSrc != KNL_SRC_NONE)
        {
            if ((KNL_GetTuningToolMode() == KNL_TUNINGMODE_ON) && (USBD_UVC_MODE == tUSBD_GetClassMode())) {
                fBufSize = ((float)uwKNL_GetVdoH(ubSrc))*((float)uwKNL_GetVdoV(ubSrc)) * 2;
            } else {
                fBufSize = ((float)uwKNL_GetVdoH(ubSrc))*((float)uwKNL_GetVdoV(ubSrc)) * 1.5;
            }
			if(BUF_INFO_OUTPUT)
				printf("BUF INTA %d %d %d %d\n",ubSrc,ISP_WIDTH,ISP_HEIGHT,(uint32_t)fBufSize);
            BUF_BufInit(BUF_SEN_1_YUV,ubKNL_GetSensorBufNumber(),fBufSize,0);
            BUF_Reset(BUF_SEN_1_YUV);
        }
        ubSrc = ubSEN_GetPathSrc(SENSOR_PATH2);
        if(ubSrc != KNL_SRC_NONE)
        {
            fBufSize = ((float)uwKNL_GetVdoH(ubSrc))*((float)uwKNL_GetVdoV(ubSrc))*1.5;
			if(BUF_INFO_OUTPUT)
				printf("BUF INTB %d %d %d %d\n",ubSrc,uwKNL_GetVdoH(ubSrc),uwKNL_GetVdoV(ubSrc),(uint32_t)fBufSize);
            BUF_BufInit(BUF_SEN_2_YUV,ubKNL_GetSensorBufNumber(),fBufSize,0);
            BUF_Reset(BUF_SEN_2_YUV);
        }
        ubSrc = ubSEN_GetPathSrc(SENSOR_PATH3);
        if(ubSrc != KNL_SRC_NONE)
        {
            if ((KNL_GetTuningToolMode() == KNL_TUNINGMODE_ON) && (USBD_UVC_MODE == tUSBD_GetClassMode()))
                fBufSize = ((float)uwKNL_GetVdoH(ubSrc))*((float)uwKNL_GetVdoV(ubSrc)) * 2;
            else
                fBufSize = ((float)uwKNL_GetVdoH(ubSrc))*((float)uwKNL_GetVdoV(ubSrc)) * 1.5;
            BUF_BufInit(BUF_SEN_3_YUV,ubKNL_GetSensorBufNumber(),fBufSize,0);
            BUF_Reset(BUF_SEN_3_YUV);
        }
        // ISP pipe
        //================================================================
        fBufSize = (float)ISP_WIDTH*(float)ISP_HEIGHT*10/8;
        BUF_BufInit(BUF_ISP_3DNR_IP, 1, fBufSize, 0);       //ISP(3DNR) IP Buffer
    
        fBufSize = 0x58000;
        BUF_BufInit(BUF_ISP_MD_W0_IP, 1, fBufSize, 0);      //ISP(MD_W0) IP Buffer
        fBufSize = 0x800;
        BUF_BufInit(BUF_ISP_MD_W1_IP, 1, fBufSize, 0);      //ISP(MD_W1) IP Buffer
        fBufSize = 0x800;
        BUF_BufInit(BUF_ISP_MD_W2_IP, 1, fBufSize, 0);      //ISP(MD_W2) IP Buffer
        // IQ bin file (128k)
        //================================================================
        fBufSize = 0x20000;
        BUF_BufInit(BUF_IQ_BIN_FILE, 1, fBufSize, 0);       //IQ bin file Buffer
    
        SEN_SetPathAddr(ISP_3DNR, ulBUF_GetBlkBufAddr(0, BUF_ISP_3DNR_IP));
        SEN_SetPathAddr(ISP_MD_W0, ulBUF_GetBlkBufAddr(0, BUF_ISP_MD_W0_IP));
        SEN_SetPathAddr(ISP_MD_W1, ulBUF_GetBlkBufAddr(0, BUF_ISP_MD_W1_IP));
        SEN_SetPathAddr(ISP_MD_W2, ulBUF_GetBlkBufAddr(0, BUF_ISP_MD_W2_IP));
        SEN_SetPathAddr(IQ_BIN_FILE, ulBUF_GetBlkBufAddr(0, BUF_IQ_BIN_FILE));
#if USBD_ENABLE
        if((DISPLAY_1T1R == DISPLAY_MODE) && ((USBD_UVC_MODE == tUSBD_GetClassMode()) || (TRUE == ubUSBD_ChkCompUvcClass())) &&
           (KNL_TUNINGMODE_OFF == KNL_GetTuningToolMode()))
        {
	#define KNL_UVC_YUVBUF_NUM	2
            fBufSize = 640 * 480 * 2;
            BUF_BufInit(BUF_USBD_VDO, KNL_UVC_YUVBUF_NUM, (fBufSize+USBD_UVC_HEADER_LEN), 0);
            BUF_Reset(BUF_USBD_VDO);
        }
#endif
#ifdef BIO_BU
        BUF_BufInit(BUF_FD_RECT_OSD, 1, FD_OSD_BUF_SZ, 0);
#endif
    
#if IMG_DS_EN
        fBufSize = IMG_DSGetBufferSize(IMG_DS1_HD_Width, IMG_DS3_Height);
        BUF_BufInit(BUF_IMG_DS1, 1, fBufSize, 0);
#endif
    }
    
#endif

#if defined(RTC676x)
#if APP_RTC676X_FOTA_ENABLE
	//FOTA
	//-------------------------------------------------
	BUF_BufInit(BUF_FOTA, 1, FOTA_ALLOC_BUF_SZ, 0);
	//=================================================
#endif
#endif
	///printd(DBG_InfoLvl, "Final Free Buf : 0x%x\r\n", ulBUF_GetFreeAddr());
	printf("Final Free Buf : 0x%x\r\n", ulBUF_GetFreeAddr());
}

//------------------------------------------------------------------------------
#if (defined(OP_STA)&&(defined(BSP_VBM_SDK)||defined(BSP_RVCS_SDK))&&defined(VDO_SUBPATH_ENABLE)&&(VDO_SUBPATH_ENABLE!=0))
// Used for display mode change in VBM, Memory initial except aux stream.
void KNL_DpSwBufInit(void)
{
	KNL_NODE_INFO tNodeInfo;
	float fBufSize;	
	uint8_t ubNodeExist;
	uint8_t ubSrc;
	uint32_t i;
	uint32_t ulAddr;
#if KNL_USBH_FUNC_ENABLE
	#if KNL_USBH_UVCCLASS_ENABLE
	uint8_t uvc_stream_num = 0;
	USBH_UVC_FRAME_INFO uvc_frame_info;
	#endif    
#endif
	uint32_t ulBuf_S,ulBuf_E;
    
    BUF_SetFreeAddr(ulBUF_GetBlkBufAddr(0,BUF_SEN_1_YUV));
#if (defined(OP_STA) && !defined(BSP_DVR_SDK))
    //=======================================================================================================================
	ulBuf_S = ulBUF_GetFreeAddr();
	//SEN_YUV Node
	//================================================================	
	ubSrc = ubSEN_GetPathSrc(SENSOR_PATH1);
	if(ubSrc != KNL_SRC_NONE)
	{
        if(ubKNL_GetIspEnable())
        {
            if ((KNL_GetTuningToolMode() == KNL_TUNINGMODE_ON) && (USBD_UVC_MODE == tUSBD_GetClassMode())) {
                fBufSize = ((float)uwKNL_GetVdoH(ubSrc)) * ((float)uwKNL_GetVdoV(ubSrc)) * 2;
            } else {
                fBufSize = ((float)uwKNL_GetVdoH(ubSrc)) * ((float)uwKNL_GetVdoV(ubSrc)) * 1.5;
            }
            if(ubSEN_GetScaleMode() == SEN_SCALEUP_MODE)
            {
                fBufSize = ((float)uwKNL_GetVdoH(ubSrc)) * ((float)uwKNL_GetVdoV(ubSrc)) * 1.5 *2 *2;
            }
            #if (defined(OP_STA) && (USBD_UVC_MJ_FMT == USBD_UVC_FMT) && USBD_ENABLE)
            if(TRUE == ubKNL_GetHQImgCapEn())
            {
                fBufSize = tKNL_CapHQImg.uwHQ_H * tKNL_CapHQImg.uwHQ_V * 1.5;
                BUF_BufInit(BUF_SEN_1_YUV, 1, fBufSize, 0);
                BUF_Reset(BUF_SEN_1_YUV);
                fBufSize = KNL_MJ_BUF_ALIGN_1K + KNL_JPG_HEADER_SIZE + KNL_UVCMJ_HQBS_SIZE;
                BUF_BufInit(BUF_USBD_VDO, 1, fBufSize, 0);
                BUF_Reset(BUF_USBD_VDO);
                printd(DBG_CriticalLvl, "  Final Free Buf = 0x%X\r\n", ulBUF_GetFreeAddr());
                return;
            }
            #endif
        }
        else
            fBufSize = ((float)uwKNL_GetVdoH(ubSrc)) * ((float)uwKNL_GetVdoV(ubSrc)) * 1.5;

        if(ubSEN_GetScaleMode() == SEN_SCALEUP_MODE)
            BUF_BufInit(BUF_SEN_1_YUV,1,fBufSize,0);
        else
            BUF_BufInit(BUF_SEN_1_YUV,ubKNL_GetSensorBufNumber(),fBufSize,0);
		BUF_Reset(BUF_SEN_1_YUV);
	}
    
	ulBuf_E = ulBUF_GetFreeAddr();
	if(BUF_INFO_OUTPUT)
		printf("== SEN:%d KB ==\r\n",(ulBuf_E-ulBuf_S)/1024);
	
	ulBuf_S = ulBUF_GetFreeAddr();		

	if(SEN_USE == SEN_TP9950)
	{	
		fBufSize = 0xA8C00<<1;                                 //(1280*(720/2)*3/2)*2
	}
	else if(SEN_USE == SEN_RN6752)
	{
		fBufSize = 0xA8C00; 
	}else{
        fBufSize = 0;
    }
    BUF_BufInit(BUF_VDO_TEMP1, 1, fBufSize, 0); 
    SEN_SetPathAddr(IMG_TEMP1, ulBUF_GetBlkBufAddr(0, BUF_VDO_TEMP1));
	
	ulBuf_E = ulBUF_GetFreeAddr();
	if(BUF_INFO_OUTPUT)
		printf("== CVBS:%d KB ==\r\n",(ulBuf_E-ulBuf_S)/1024);
    //================================================================
#if USBD_ENABLE
	ulBuf_S = ulBUF_GetFreeAddr();
	if((DISPLAY_1T1R == DISPLAY_MODE) && ((USBD_UVC_MODE == tUSBD_GetClassMode()) || (TRUE == ubUSBD_ChkCompUvcClass())) &&
	   (KNL_TUNINGMODE_OFF == KNL_GetTuningToolMode()))
	{
	#define KNL_UVC_YUVBUF_NUM	2
		fBufSize = 640 * 480 * 2;
		BUF_BufInit(BUF_USBD_VDO, KNL_UVC_YUVBUF_NUM, (fBufSize+USBD_UVC_HEADER_LEN), 0);
		BUF_Reset(BUF_USBD_VDO);
	}
	
	ulBuf_E = ulBUF_GetFreeAddr();
	if(BUF_INFO_OUTPUT)
		printf("== UVC:%d KB ==\r\n",(ulBuf_E-ulBuf_S)/1024);
	
#endif
#ifdef BIO_BU
	BUF_BufInit(BUF_FD_RECT_OSD, 1, FD_OSD_BUF_SZ, 0);
#endif

#if IMG_DS_EN
	fBufSize = IMG_DSGetBufferSize(IMG_DS1_HD_Width, IMG_DS3_Height);
	BUF_BufInit(BUF_IMG_DS1, 1, fBufSize, 0);
#endif

#endif
	//H264_DEC Node
	//================================================================
	ulBuf_S = ulBUF_GetFreeAddr();
	//For Main Source

#if (APP_DUAL_HOST_ENABLE == 1)
	for(i=0;i<3;i++)
#else
	for(i=0;i<4;i++)
#endif
	{
		if(ubKNL_ExistNode(KNL_SRC_1_MAIN+i,KNL_NODE_H264_DEC))
		{
			tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_MAIN+i,KNL_NODE_H264_DEC);
			fBufSize = ulH264_GetDECBufferSize(tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
			if(tNodeInfo.ubCodecIdx == DECODE_0)
			{
				BUF_BufInit(BUF_IMG_DEC,1,fBufSize,0);
			}
			else if(tNodeInfo.ubCodecIdx == DECODE_1)
			{
				BUF_BufInit(BUF_IMG_DEC,1,fBufSize,1);
			}
			else if(tNodeInfo.ubCodecIdx == DECODE_2)
			{
				BUF_BufInit(BUF_IMG_DEC,1,fBufSize,2);
			}
			else if(tNodeInfo.ubCodecIdx == DECODE_3)
			{
				BUF_BufInit(BUF_IMG_DEC,1,fBufSize,3);
			}
		}
	}
	//For Aux Source

#if (APP_DUAL_HOST_ENABLE == 1)
	for(i=0;i<3;i++)
#else
	for(i=0;i<4;i++)
#endif
	{
		if(ubKNL_ExistNode(KNL_SRC_1_AUX+i,KNL_NODE_H264_DEC))
		{
			tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_AUX+i,KNL_NODE_H264_DEC);
			fBufSize = ulH264_GetDECBufferSize(tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
			if(tNodeInfo.ubCodecIdx == DECODE_0)
			{
				BUF_BufInit(BUF_IMG_DEC,1,fBufSize,0);
			}
			else if(tNodeInfo.ubCodecIdx == DECODE_1)
			{
				BUF_BufInit(BUF_IMG_DEC,1,fBufSize,1);
			}
			else if(tNodeInfo.ubCodecIdx == DECODE_2)
			{
				BUF_BufInit(BUF_IMG_DEC,1,fBufSize,2);
			}
			else if(tNodeInfo.ubCodecIdx == DECODE_3)
			{
				BUF_BufInit(BUF_IMG_DEC,1,fBufSize,3);
			}
		}
	}
	//For Sub Source

#if (APP_DUAL_HOST_ENABLE == 1)
	for(i=0;i<3;i++)
#else
	for(i=0;i<4;i++)
#endif
	{
		if(ubKNL_ExistNode(KNL_SRC_1_SUB+i,KNL_NODE_H264_DEC))
		{
			tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_SUB+i,KNL_NODE_H264_DEC);
			fBufSize = ulH264_GetDECBufferSize(tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
			if(tNodeInfo.ubCodecIdx == DECODE_0)
			{
				BUF_BufInit(BUF_IMG_DEC,1,fBufSize,0);
			}
			else if(tNodeInfo.ubCodecIdx == DECODE_1)
			{
				BUF_BufInit(BUF_IMG_DEC,1,fBufSize,1);
			}
			else if(tNodeInfo.ubCodecIdx == DECODE_2)
			{
				BUF_BufInit(BUF_IMG_DEC,1,fBufSize,2);
			}
			else if(tNodeInfo.ubCodecIdx == DECODE_3)
			{
				BUF_BufInit(BUF_IMG_DEC,1,fBufSize,3);
			}
		}
	}
	ulBuf_E = ulBUF_GetFreeAddr();
	if(BUF_INFO_OUTPUT)
		printf("H264-IP(Decoder):%d\r\n",(ulBuf_E-ulBuf_S)/1024);

	//H264_ENC Node	
	//================================================================
	ulBuf_S = ulBUF_GetFreeAddr();
	
	//For Main Source
	for(i=0;i<4;i++)
	{
		if(ubKNL_ExistNode(KNL_SRC_1_MAIN+i,KNL_NODE_H264_ENC))
		{
			tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_MAIN+i,KNL_NODE_H264_ENC);
			fBufSize = ulH264_GetENCBufferSize(tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
			if(tNodeInfo.ubCodecIdx == ENCODE_0)
			{
				BUF_BufInit(BUF_IMG_ENC,1,fBufSize,0);
			}
			else if(tNodeInfo.ubCodecIdx == ENCODE_1)
			{
				BUF_BufInit(BUF_IMG_ENC,1,fBufSize,1);
			}
			else if(tNodeInfo.ubCodecIdx == ENCODE_2)
			{
				BUF_BufInit(BUF_IMG_ENC,1,fBufSize,2);
			}
			else if(tNodeInfo.ubCodecIdx == ENCODE_3)
			{
				BUF_BufInit(BUF_IMG_ENC,1,fBufSize,3);
			}
		}
	}
	//For Sub Source
	for(i=0;i<4;i++)
	{
		if(ubKNL_ExistNode(KNL_SRC_1_SUB+i,KNL_NODE_H264_ENC))
		{
			tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_SUB+i,KNL_NODE_H264_ENC);		
			fBufSize = ulH264_GetENCBufferSize(tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
			if(tNodeInfo.ubCodecIdx == ENCODE_0)
			{
				BUF_BufInit(BUF_IMG_ENC,1,fBufSize,0);
			}
			else if(tNodeInfo.ubCodecIdx == ENCODE_1)
			{
				BUF_BufInit(BUF_IMG_ENC,1,fBufSize,1);
			}
			else if(tNodeInfo.ubCodecIdx == ENCODE_2)
			{
				BUF_BufInit(BUF_IMG_ENC,1,fBufSize,2);
			}
			else if(tNodeInfo.ubCodecIdx == ENCODE_3)
			{
				BUF_BufInit(BUF_IMG_ENC,1,fBufSize,3);
			}
		}
	}	

	ulBuf_E = ulBUF_GetFreeAddr();
	if(BUF_INFO_OUTPUT)
		printf("H264-IP(Encoder):%d\r\n",(ulBuf_E-ulBuf_S)/1024);

	ulBuf_S = ulBUF_GetFreeAddr();
	//VDO_BS_BUF Node
	//================================================================
	//(For BS_BUF1)
	//Main
#if (APP_DUAL_HOST_ENABLE == 1)
	for(i=0;i<3;i++)
#else
	for(i=0;i<4;i++)
#endif
	{
		if(ubKNL_ExistNode(KNL_SRC_1_MAIN+i,KNL_NODE_VDO_BS_BUF1))
		{
			tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_MAIN+i,KNL_NODE_VDO_BS_BUF1);
			printd(DBG_InfoLvl, "	BS[%dx%d]\n", tNodeInfo.uwVdoH, tNodeInfo.uwVdoV);
			if(ubKNL_GetAdjBufEnable())	
				fBufSize = ( ((uint32_t)tNodeInfo.uwVdoH) * ((uint32_t)tNodeInfo.uwVdoV) * 1.5 )/KNL_MIN_COMPRESS_RATIO_ADJ;
			else
				fBufSize = ( ((uint32_t)tNodeInfo.uwVdoH) * ((uint32_t)tNodeInfo.uwVdoV) * 1.5 )/KNL_MIN_COMPRESS_RATIO;
		#ifdef S2019A
			fBufSize /= 2;
			tKNL_VdoBsOvfInfo.ulBsBufSize = fBufSize;
		#endif
			
		//justin 2020.04.15
			if(ubKNL_GetAdjBufEnable())			
				BUF_BufInit(BUF_VDO_MAIN_BS0+i,BUF_NUM_VDO_BS_ADJ,fBufSize,0);
			else
#if (!APP_REC_FUNC_ENABLE && APP_PHOTOGRAPH_FUNC_ENABLE)
                BUF_BufInit(BUF_VDO_MAIN_BS0+i,BUF_NUM_VDO_BS_NOREC,fBufSize,0);
#else
                BUF_BufInit(BUF_VDO_MAIN_BS0+i,BUF_NUM_VDO_BS,fBufSize,0);
#endif
			BUF_Reset(BUF_VDO_MAIN_BS0+i);
		#if (defined(OP_AP) && (USBD_UVC_H264_FMT == USBD_UVC_FMT) && USBD_ENABLE)
			if((DISPLAY_1T1R == DISPLAY_MODE) && ((USBD_UVC_MODE == tUSBD_GetClassMode()) || (TRUE == ubUSBD_ChkCompUvcClass())))
			{
			#define KNL_UVC_BSBUF_NUM	2
				BUF_BufInit(BUF_USBD_VDO, KNL_UVC_BSBUF_NUM, (fBufSize+USBD_UVC_HEADER_LEN), 0);
				BUF_Reset(BUF_USBD_VDO);
			}
		#endif
		}
	}
	//Sub

#if (APP_DUAL_HOST_ENABLE == 1)
	for(i=0;i<3;i++)
#else
	for(i=0;i<4;i++)
#endif
	{
		if(ubKNL_ExistNode(KNL_SRC_1_SUB+i,KNL_NODE_VDO_BS_BUF1))
		{
			tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_SUB+i,KNL_NODE_VDO_BS_BUF1);			
			
			if(ubKNL_GetAdjBufEnable())	
			{
				fBufSize = ( ((uint32_t)tNodeInfo.uwVdoH) * ((uint32_t)tNodeInfo.uwVdoV) * 1.5 )/KNL_MIN_COMPRESS_RATIO_ADJ;	
				BUF_BufInit(BUF_VDO_SUB_BS00+i,BUF_NUM_VDO_BS_ADJ,fBufSize,0);
			}
			else
			{
				fBufSize = ( ((uint32_t)tNodeInfo.uwVdoH) * ((uint32_t)tNodeInfo.uwVdoV) * 1.5 )/KNL_MIN_COMPRESS_RATIO;	
				BUF_BufInit(BUF_VDO_SUB_BS00+i,BUF_NUM_VDO_BS,fBufSize,0);
			}
			
			BUF_Reset(BUF_VDO_SUB_BS00+i);
		}
	}

	ulBuf_E = ulBUF_GetFreeAddr();
	if(BUF_INFO_OUTPUT)
		printf("== H264-BS:%d KB ==\r\n",(ulBuf_E-ulBuf_S)/1024);
	//(For BS_BUF2)	

#if (APP_DUAL_HOST_ENABLE == 1)
	for(i=0;i<3;i++)
#else
	for(i=0;i<4;i++)
#endif
	{
		if(ubKNL_ExistNode(KNL_SRC_1_SUB+i,KNL_NODE_VDO_BS_BUF2))
		{
			tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_SUB+i,KNL_NODE_VDO_BS_BUF2);
			fBufSize = ( ((uint32_t)tNodeInfo.uwVdoH) * ((uint32_t)tNodeInfo.uwVdoV) * 1.5 )/KNL_MIN_COMPRESS_RATIO;
			BUF_BufInit(BUF_VDO_SUB_BS01+i,BUF_NUM_VDO_BS,fBufSize,0);
			BUF_Reset(BUF_VDO_SUB_BS01+i);
		}
	}

	#if (((USBD_UVC_MJ_FMT == USBD_UVC_FMT) || (USBD_UVC_H264_FMT == USBD_UVC_FMT))  && USBD_ENABLE)	//! UVC for MJPEG
		if((KNL_TUNINGMODE_OFF == KNL_GetTuningToolMode()) && ((USBD_UVC_MODE == tUSBD_GetClassMode()) || (TRUE == ubUSBD_ChkCompUvcClass())))
		{
		#define KNL_UVC_MJBUF_NUM	2
			fBufSize = KNL_MJ_BUF_ALIGN_1K + KNL_JPG_HEADER_SIZE + KNL_UVCMJ_BS_SIZE;
			BUF_BufInit(BUF_USBD_VDO, KNL_UVC_MJBUF_NUM, fBufSize, 0);
			BUF_Reset(BUF_USBD_VDO);
		}
	#endif

	BUF_Reset(BUF_RESV_YUV);

	//LCD Node
	//================================================================
	ubNodeExist = ubKNL_ChkExistNode(KNL_NODE_LCD);
	if(ubNodeExist)
	{
		ulBuf_S = ulBUF_GetFreeAddr();
		
		fBufSize = ulKNL_CalLcdBufSz();
		BUF_BufInit(BUF_LCD_IP,1,fBufSize,0);
		
		ulBuf_E = ulBUF_GetFreeAddr();
		if(BUF_INFO_OUTPUT)
			printf("== LCD:%d KB ==\r\n",(ulBuf_E-ulBuf_S)/1024);
	}

	//IMG_MERGE Node
	//================================================================
	ubNodeExist = ubKNL_ChkExistNode(KNL_NODE_IMG_MERGE_H)|ubKNL_ChkExistNode(KNL_NODE_IMG_MERGE_BUF);
	if(ubNodeExist)
	{
		fBufSize  = ulKNL_GetImgMergeBufSz();
		BUF_BufInit(BUF_IMG_MERGE, 1, fBufSize, 0);
		//Clear Merge Buffer @Dummy Buffer
		if((tKNL_GetDispType() == KNL_DISP_H) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0))
		{
			ulAddr = ulBUF_GetBlkBufAddr(0, BUF_IMG_MERGE);
			ubSrc = ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
			tDMAC_MemSet (0x00,ulAddr,((float)uwKNL_GetLcdDmyImgH())*((float)uwKNL_GetVdoV(ubSrc))*1.5,NULL);
		}
	}
	else if(KNL_DISP_H == tKNL_GetDispType())
	{
		fBufSize = ulKNL_GetImgMergeBufSz();
		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
			fBufSize += KNL_JPG_BS_SIZE;
		BUF_BufInit(BUF_IMG_MERGE, 1, fBufSize, 0);
		ulAddr = ulBUF_GetBlkBufAddr(0, BUF_IMG_MERGE);
		KNL_CreateBlackDmyPat(ulAddr, fBufSize);
	}

#if ((KNL_USBH_FUNC_ENABLE) && (KNL_USBH_UVCCLASS_ENABLE) && (!defined(KNL_USBH_SPRF)))
	ulBuf_S = ulBUF_GetFreeAddr();
	
	memset(&uvc_frame_info, 0, sizeof(USBH_UVC_FRAME_INFO));
	#if defined (CONFIG_DUAL_HOST)

	#if (APP_DUAL_HOST_ENABLE == 1)
		uvc_stream_num = 2;
	#else	
		uvc_stream_num = 4;
	#endif	
	for(i = 0; i < uvc_stream_num; i++) {
	#if (APP_DUAL_HOST_ENABLE == 1)
		uvc_frame_info.fmt[i]      = USBH_UVC_H264;
	#else
		uvc_frame_info.fmt[i]      = USBH_UVC_MJPEG;
	#endif				
		uvc_frame_info.ulWidth[i]  = 1280;
		uvc_frame_info.ulHeight[i] = 720;
	}
	fBufSize = ulUSBH_GetBufferSize(0, 1, uvc_stream_num, uvc_frame_info);
	#else
	uvc_stream_num = 2;
	for(i = 0; i < uvc_stream_num; i++) {
		uvc_frame_info.fmt[i]      = USBH_UVC_MJPEG;
		uvc_frame_info.ulWidth[i]  = 1280;
		uvc_frame_info.ulHeight[i] = 720;
	}
	fBufSize = ulUSBH_GetBufferSize(0, 0, uvc_stream_num, uvc_frame_info);
	#endif
	BUF_BufInit(BUF_USBH_IP, 1, fBufSize, 0);
	BUF_BufInit(BUF_USB_TRX, 1, 1024, 0);	//512 Byte for TX, 512 Byte for RX		
	
	ulBuf_E = ulBUF_GetFreeAddr();
	if(BUF_INFO_OUTPUT)
		printf("== USB(Host):%d KB ==\r\n",(ulBuf_E-ulBuf_S)/1024);
#endif
	printf("Final Free Buf : 0x%x\r\n", ulBUF_GetFreeAddr());
}
#endif
//------------------------------------------------------------------------------
uint32_t ulKNL_ResetICntMS=0;
void KNL_ResendIActionExt(TWC_TAG GetSta,uint8_t *pData)	//Resend I action for external use
{
	uint32_t ulKNL_ResetICnt;

	GetSta = GetSta;
	pData  = pData;
	if((KNL_CAPHQ_EN == *(pData + 3)) && (KNL_CAPHQ_DIS == tKNL_CapHQImgSte))
		tKNL_CapHQImgSte = KNL_CAPHQ_EN;
	if(KNL_CAPHQ_EN == tKNL_CapHQImgSte)
		return;
#ifdef S2019A
	if(TRUE == ubKNL_ChgResFlg)
		return;
#endif
	//printd(DBG_CriticalLvl, "SDI=%d %d\r\n", *pData , *(pData+1));
	ulKNL_ResetICnt = (*((uint16_t*)pData))*1000;
	printd(DBG_CriticalLvl, "[%d]Rsnd I CntDwn=%d, V:%d\n", GetSta, ulKNL_ResetICnt, *(pData + 4));	// Resend I Frame Counter
	if(ulKNL_ResetICnt == 0)
	{
        memset(&ubKNL_ResetIFlg[0],1,KNL_SRC_NUM);
		ubKNL_RstVdoGrpFlag = *(pData + 4);
#ifdef S2019A		
		if(FALSE == ubKNL_RstVdoGrpFlag)
			KNL_StopSPRFTxProcess(TRUE);
#endif
	}
	else
		ulKNL_ResetICntMS = ulKNL_ResetICnt;
}

void KNL_ResendIActionInt(TWC_TAG GetSta,uint8_t *pData)//Resend I action for internal(KNL) use
{
	GetSta = GetSta;
	pData  = pData;
	memset(&ubKNL_ResetIFlg[0],1,KNL_SRC_NUM);
	printd(DBG_CriticalLvl, "Resend I\r\n");
}

void KNL_SyncFrameAction(TWC_TAG GetSta,uint8_t *pData)
{
    GetSta = GetSta;
    pData  = pData;

#if OP_AP
    {
		if(KNL_PERDBG_ON == ubKNL_PerDbgEn)
		{
			KNL_PROCESS tKNLInfo;
			tKNLInfo.ubTwcCmd = TWC_SYNC_FRAME; 
			tKNLInfo.ubTargetRole = *pData; 
			if(osMessagePut(KNL_TwcMonitQueue, &tKNLInfo, 0) == osErrorResource)
			{
				printd(DBG_ErrorLvl, "KNL_TwcMonitQ->Full !!!!\r\n");
			}
		}
    }
#elif OP_STA
    {
        ubKNL_GetRxFrameNumber = *pData;
    }
#endif
}

#ifdef RTC676x
#if APP_RTC676X_FOTA_ENABLE
void KNL_FotaAction(TWC_TAG GetSta,uint8_t *pData)
{
	GetSta = GetSta;
    pData  = pData;
#if OP_AP
    {		
		//printf("KNL_FotaAction[%d] @AP\r\n",GetSta);
		ubKNL_GetFotaTwcFlg[GetSta] = 1;
    }
#elif OP_STA
    {		
		//printf("KNL_FotaAction @STA\r\n");
    }
#endif
}
#endif
#if APP_RTC676X_BRIDGE_COEXISTENCE_ENABLE	
void KNL_FreqTableAction(TWC_TAG GetSta,uint8_t *pData)
{
#if OP_STA	
    uint8_t ubFreqTableExp;	
#endif
	GetSta = GetSta;
    pData  = pData;
#if OP_AP
    {
		printf("KNL_FreqTableAction @AP\r\n");
    }
#elif OP_STA
    {		
		ubFreqTableExp = *pData;
		
		printf("RcvFT->%d\r\n",ubFreqTableExp);	
		
		if(!ubPAIR_GetInPairIngFlg())
		{			
			if(ubKNL_FreqKeepCnt == 0)
			{
				ubKNL_FreqKeepCnt = 2;	

				ubKNL_FreqTableSel = ubFreqTableExp;				
				
				if(ubFreqTableExp == 0xF0)
				{				
					if(ubKNL_GetFreqTableInSf() != 0xF0)
					{
						rf_setopt(RF_OPT_FREQTABLE, frequency_table_Ch0,80);
					#if FREQ_SEL_DBG_EN
						printf("Update Id Information From Cmd\r\n");
					#endif
						KNL_SetFreqTableInSf(0xF0);
						KNL_SetFreqTable(0xF0);
						PAIR_IdTable.ubSelectCh = 0xF0;
						PAIR_SaveId();
					}
				}				
				else if(ubFreqTableExp == 0xF1)
				{				
					if(ubKNL_GetFreqTableInSf() != 0xF1)
					{
						rf_setopt(RF_OPT_FREQTABLE, frequency_table_Ch1,80);	
					#if FREQ_SEL_DBG_EN
						printf("Update Id Information From Cmd\r\n");
					#endif
						KNL_SetFreqTableInSf(0xF1);
						KNL_SetFreqTable(0xF1);
						PAIR_IdTable.ubSelectCh = 0xF1;
						PAIR_SaveId();
					}
				}				
				else if(ubFreqTableExp == 0xF2)
				{					
					if(ubKNL_GetFreqTableInSf() != 0xF2)
					{
						rf_setopt(RF_OPT_FREQTABLE, frequency_table_Ch2,80);
					#if FREQ_SEL_DBG_EN
						printf("Update Id Information From Cmd\r\n");
					#endif
						KNL_SetFreqTableInSf(0xF2);
						KNL_SetFreqTable(0xF2);
						PAIR_IdTable.ubSelectCh = 0xF2;
						PAIR_SaveId();
					}
				}				
			}
		}
    }
#endif
}
#endif
#endif
void KNL_SyncGOPAction(TWC_TAG GetSta,uint8_t *pData)
{
    GetSta = GetSta;
    pData  = pData;
#if OP_AP
    {
        KNL_PROCESS tKNLInfo;
        tKNLInfo.ubTwcCmd = TWC_SYNC_GOP;
        tKNLInfo.ubTargetRole = *pData;
        if(osMessagePut(KNL_TwcMonitQueue, &tKNLInfo, 0) == osErrorResource)
        {
            printd(DBG_ErrorLvl, "KNL_TwcMonitQ->Full !!!!\r\n");
        }
    }
#elif OP_STA
    {
        uint32_t ulDate;
        ulDate = (*pData<<24) + (*(pData+1)<<16) + (*(pData+2)<<8) + *(pData+3);
        KNL_SetVdoGop(ulDate);
        H264_SetGOP(ENCODE_0,ulDate);
#if (defined(VDO_SUBPATH_ENABLE)&&(VDO_SUBPATH_ENABLE!=0))
        H264_SetGOP(ENCODE_1,ulDate);
#endif             
        ubGopSync |= KNL_GOPSYNC_RECV;
    }
#endif
}

void KNL_StaOnLineAction(TWC_TAG GetSta,uint8_t *pData)
{
	uint8_t ubStaOnLineCnt = 0;
	uint8_t i;
	uint8_t ubTemp[4];
	
	GetSta = GetSta;
	pData  = pData;
	
	for(i=0;i<4;i++)
	{
		if(*pData++)
		{
			ubTemp[i] = 1;
			ubStaOnLineCnt++;
		}
		else
		{
			ubTemp[i] = 0;
		}
	}
	
#if (KNL_DYNAMIC_SLOT == 1)
	KNL_SetOnlineStaNum(ubStaOnLineCnt);
#endif
	
	printd(DBG_CriticalLvl, "StaOnLine:%d,%d,%d,%d\r\n",ubTemp[0],ubTemp[1],ubTemp[2],ubTemp[3]);	
}
void KNL_ResendIAction2(TWC_TAG GetSta,uint8_t *pData)
{
	uint8_t i;
	uint8_t ubBuf[8];

	GetSta = GetSta;
	pData  = pData;
	memset(&ubKNL_ResetIFlg[0],1,KNL_SRC_NUM);
	printd(DBG_CriticalLvl, "Resend I2\r\n");
	for(i=0;i<8;i++)
	{
		ubBuf[i] = *pData++;
	}
	printf("%s:STA_%d,Data_%d,%d,%d,%d,%d,%d,%d,%d\r\n",__func__,GetSta,ubBuf[0],ubBuf[1],ubBuf[2],ubBuf[3],ubBuf[4],ubBuf[5],ubBuf[6],ubBuf[7]);
}

uint8_t ubKNL_GetChgResFlg(void)
{
	return ubKNL_ChgResFlg;
}

//------------------------------------------------------------------------------
void KNL_ResetVdoProc(void)
{
	uint8_t ubCdcWaitCnt = 20;
	for(;;)
	{
		if(ubKNL_ChkImgRdy())
			break;
		if(!(--ubCdcWaitCnt))
		{
			printd(DBG_ErrorLvl, "H264 Cdc timeout@%s\r\n", __func__);
			break;
		}
		osDelay(10);
	}
	osMessageReset(KNL_VdoCodecProcQueue);
#if (defined(OP_STA) || defined(OP_AP) && (defined(BSP_DVR_SDK)))
    if(ubSEN_GetActiveFlg(SENSOR_PATH1))
        BUF_Reset(BUF_SEN_1_YUV);
#if !(defined(OP_AP) && defined(BSP_DVR_SDK))
    if(ubSEN_GetActiveFlg(SENSOR_PATH2))
        BUF_Reset(BUF_SEN_2_YUV);
#endif
    if(ubSEN_GetActiveFlg(SENSOR_PATH3))
        BUF_Reset(BUF_SEN_3_YUV);
#endif
}

//------------------------------------------------------------------------------
void KNL_VdoResSetting(TWC_TAG GetSta, uint8_t *pData)
{
#if (defined(OP_STA) || defined(BSP_DVR_SDK))
	KNL_PROCESS tKNLInfo;
	
	uint16_t uwKNL_NHSize = 0, uwKNL_NVSize = 0;
	uint16_t uwKNL_DynHSize = 0, uwKNL_DynVSize = 0;
	uint8_t ubSrcNum = 0;
	uint8_t ubChangeRes = 0;
	#if defined(OP_STA)
    MD_Switch(0);
	#endif
	tKNLInfo = tKNLInfo;//Avoid Warning

	uwKNL_DynHSize = (pData[0] << 8) + pData[1];
	uwKNL_DynVSize = (pData[2] << 8) + pData[3];
	ubSrcNum 	   = pData[4];
    ubChangeRes    = pData[5];
	uwKNL_NHSize   = uwKNL_GetVdoH(ubSrcNum);
	uwKNL_NVSize   = uwKNL_GetVdoV(ubSrcNum);
	if((uwKNL_NHSize != uwKNL_DynHSize) || (uwKNL_NVSize != uwKNL_DynVSize))
	{
		printf("VdoResSet:(%d,%d)->(%d,%d)\r\n",uwKNL_NHSize,uwKNL_NVSize,uwKNL_DynHSize,uwKNL_DynVSize);   
		if(((SEN_GetAhdCamType() == 12) || (SEN_GetAhdCamType() == 13)) && (uwKNL_DynHSize > 640))
		{	
			printf("AHD CAM IN and CVBS mode\r\n");
			return;
		}
	#if defined(RTC676x)
        if((USBD_UVC_MODE == tUSBD_GetClassMode())&&(16 == (ulDDR_GetCapacity() >> 20)))
        {
            
        }else{
            ubKNL_StopTrxFlg[0]  = 1;
            ubKNL_StopTrxFlg[1]  = 1;
            ubKNL_StopTrxFlg[2]  = 1;
			
			if(KNL_VdoPacketizeQue != NULL)	
				osMessageReset(KNL_VdoPacketizeQue);
			if(KNL_AdoPacketizeQue != NULL)
				osMessageReset(KNL_AdoPacketizeQue);
			if(KNL_TwcMonitQueue != NULL)
				osMessageReset(KNL_TwcMonitQueue);
        }
	#endif
		
	#ifdef A7130
		BB_ClearTxBuf(BB_TX_MASTER, BB_DATA_VIDEO);
	#endif
	#ifdef S2019A
		KNL_StopSPRFTxProcess(TRUE);
	#endif
		KNL_SetVdoH(ubSrcNum, uwKNL_DynHSize);
		KNL_SetVdoV(ubSrcNum, uwKNL_DynVSize);
		ubKNL_ChgResFlg = TRUE;
		KNL_AhdCamInSetBufFunc(uwKNL_DynHSize, uwKNL_DynVSize);
        if(ubChangeRes)
        {
            if((ubSrcNum == KNL_SRC_1_MAIN)||(ubSrcNum == KNL_SRC_2_MAIN)||(ubSrcNum == KNL_SRC_3_MAIN)||(ubSrcNum == KNL_SRC_4_MAIN))
            {
                SEN_SetResChgState(SENSOR_PATH1, uwKNL_DynHSize, uwKNL_DynVSize);
            }
            else if((ubSrcNum == KNL_SRC_1_SUB)||(ubSrcNum == KNL_SRC_2_SUB)||(ubSrcNum == KNL_SRC_3_SUB)||(ubSrcNum == KNL_SRC_4_SUB))
            {
                SEN_SetResChgState(SENSOR_PATH2, uwKNL_DynHSize, uwKNL_DynVSize);
            }
            else if((ubSrcNum == KNL_SRC_1_AUX)||(ubSrcNum == KNL_SRC_2_AUX)||(ubSrcNum == KNL_SRC_3_AUX)||(ubSrcNum == KNL_SRC_4_AUX))
            {
                SEN_SetResChgState(SENSOR_PATH3, uwKNL_DynHSize, uwKNL_DynVSize);
            }
        }
	#if ISP_DS_EN
		KNL_IspDsFunc();
	#endif

#if !((defined(BSP_VBM_SDK)||defined(BSP_RVCS_SDK))&& APP_REC_FUNC_ENABLE &&defined(VDO_SUBPATH_ENABLE)&&(VDO_SUBPATH_ENABLE!=0))
	if(ubKNL_GetSenThenEncEnable() || APP_TUNINGMODE_ON == APP_GetTuningToolMode())
#endif
	{
		tKNLInfo.ubSrcNum	 = ubSrcNum;		
		if(osMessagePut(KNL_ResSwProcQueue, &tKNLInfo, 100) != osOK)
		{
			printf("Res Switch Fail !!!\r\n");
		}

	}
	}
#endif
}
//------------------------------------------------------------------------------
void KNL_SetSensorRes(uint16_t *puwH, uint16_t *puwV)
{
	TWC_TAG GetSta;
	uint8_t ubData[6];
	if (puwH[0] > VDO_MAIN_H_SIZE(VDO_DISP_TYPE))		
		puwH[0] = VDO_MAIN_H_SIZE(VDO_DISP_TYPE);
	if (puwV[0] > VDO_MAIN_V_SIZE(VDO_DISP_TYPE))		
		puwV[0] = VDO_MAIN_V_SIZE(VDO_DISP_TYPE);   
	
	ubData[0] = puwH[0] >> 8;
	ubData[1] = puwH[0];
	ubData[2] = puwV[0] >> 8;
	ubData[3] = puwV[0];
	ubData[4] = KNL_SRC_1_MAIN;
	ubData[5] = 1;//0;
	
    KNL_VdoResSetting(GetSta, ubData);
//	// set H264 size
//    KNL_SetVdoH(KNL_SRC_1_MAIN, puwH[0]);
//    KNL_SetVdoV(KNL_SRC_1_MAIN, puwV[0]);        
//	ubKNL_ChgResFlg = TRUE;
}
//------------------------------------------------------------------------------
void KNL_AhdCamInSetResFunc(uint16_t uwH, uint16_t uwV)
{
	KNL_SetSensorRes(&uwH, &uwV);
}
//------------------------------------------------------------------------------
void KNL_AhdCamInSetBufFunc(uint16_t uwH, uint16_t uwV)
{
	if((uwH == 640) && (uwV == 480))
	{	
	//Sensor Buffer
#if (BSP_DDRSIZE == 16)
	#if (defined(RTC676x))
		KNL_SetYuvBufNub(2);
		KNL_SetSenThenEncEnable(0);
		//printf("640 set buf\n\r");
	#endif
#endif
	}
	else
	{
	//Sensor Buffer
#if (BSP_DDRSIZE == 16)
	#if (defined(RTC676x))
		KNL_SetYuvBufNub(1);
		KNL_SetSenThenEncEnable(1);
		//printf("HD set buf\n\r");
	#endif
#endif	
	}
}	
//------------------------------------------------------------------------------
#if APP_TIMESTAMP_FUNC_ENABLE
void KNL_TimeStampSync(TWC_TAG GetSta,uint8_t *pData)
{
#if (BSP_RTC_TIMER_SEL == RTC_TIMER_INTERNAL || BSP_RTC_TIMER_SEL == RTC_TIMER_NULL)
	RTC_Calendar_t tCalendar;
#elif (BSP_RTC_TIMER_SEL == RTC_TIMER_EXTERNAL)
	RTC_PCF85063A_Calendar_t tCalendar;
#endif

#if OP_STA

	GetSta = GetSta;
    tCalendar.uwYear  = (pData[0] << 8) + pData[1];
    tCalendar.ubMonth = pData[2];
    tCalendar.ubDate  = pData[3];
    tCalendar.ubHour  = pData[4];
    tCalendar.ubMin   = pData[5];
    tCalendar.ubSec   = pData[6];
    uwRtcPosX 		  = pData[7]*4;
    uwRtcPosY 		  = pData[8]*4;
    wRTC_SETBASECALENDAR(&tCalendar);
	wRTC_SETCALENDAR(&tCalendar);
	wRTC_GETCALENDAR(&tKNL_SysCalendar);
    ubRtcSync = TRUE;

#elif OP_AP

    uint8_t ubData[9];
	uint16_t uwV;
	KNL_SRC tSrcNum;

	if(!ubKNL_GetCommLinkStatus(GetSta))
		return;
    wRTC_GETCALENDAR(&tCalendar);
    ubData[0] = tCalendar.uwYear >> 8;
    ubData[1] = tCalendar.uwYear;
    ubData[2] = tCalendar.ubMonth;
    ubData[3] = tCalendar.ubDate;
    ubData[4] = tCalendar.ubHour;
    ubData[5] = tCalendar.ubMin;
    ubData[6] = tCalendar.ubSec;
	if(ptKNL_VdoRoleMap2SrcNum)
		tSrcNum = ptKNL_VdoRoleMap2SrcNum(KNL_MAIN_PATH, (KNL_ROLE)GetSta);
	else
		tSrcNum = (KNL_SRC)(KNL_SRC_1_MAIN + GetSta);
	uwV = uwKNL_GetVdoV(tSrcNum);
	#if ISP_DS_EN
	uwRtcPosY = (uwV - (16 * ((uwV > VGA_HEIGHT)?2:1) * 2)) / 4;
	#else
	uwRtcPosX = (VGA_WIDTH == uwKNL_GetVdoH(tSrcNum))?70:0;
	uwRtcPosY = uwV - IMG_DS3_Height;
	#endif
    ubData[7] = uwRtcPosX;
    ubData[8] = uwRtcPosY;
    if(ubKNL_TwcSend(GetSta, TWC_SYNC_TIMESTAMP, ubData, 9, 8) != TWC_SUCCESS)
        printd(DBG_ErrorLvl, " TWC_SYNC_TIMESTAMP(%d ) -> Fail\r\n",GetSta);
#endif
	printd(DBG_CriticalLvl, "[%x]TWC_SYNC_TIMESTAMP [%d]\r\n", GetSta, tCalendar.ubSec);
}
//------------------------------------------------------------------------------
void KNL_SyncTimeStamp2TX(void)
{    
	TWC_TAG tKNL_Role;

    for(tKNL_Role = TWC_STA1; tKNL_Role < ubKNL_GetTRXSlotNum(); tKNL_Role++)
    {
        KNL_TimeStampSync(tKNL_Role, 0);
    }
}
#endif
//------------------------------------------------------------------------------
void KNL_SdBlockSetup(void)
{
#if APP_SD_FUNC_ENABLE
	uint32_t ulSdBufStartAddr;
	SD_INIT_INFO_t SD_Info;
	
	ulSdBufStartAddr = ulBUF_GetBlkBufAddr(0,BUF_SD);	
	
#if defined(BSP_D_SN93714_TX_V1)
	SD_Info.DevIF = SD_3;
	SD_Info.ulDetPinAddr = (uint32_t*)(&GPIO->GPIO_I);
	SD_Info.ubDetPinOfs  = 8;
#elif defined(BSP_D_SN93716_TX_V1)
	SD_Info.DevIF = SD_2;
	SD_Info.ulDetPinAddr = (uint32_t*)(&SDIO_2->MS_IO_I2);
	SD_Info.ubDetPinOfs  = 1;
#else	
	SD_Info.DevIF = SD_1;
	SD_Info.ulDetPinAddr = (uint32_t*)(&SDIO_1->MS_IO_I2);
	SD_Info.ubDetPinOfs  = 1;
#endif
#if(BSP_SD_DEC_PIN_CUST_EN==0)
	SD_Info.DetPinMode = SD_DET_PIN_STANDARD;
#elif(BSP_SD_DEC_PIN_CUST_EN==1)
	SD_Info.DetPinMode = SD_DET_PIN_CUST;
#endif
	SD_Info.ulBufStartAddr = ulSdBufStartAddr;
	SD_Info.ulWatchDogTimeoutVal = WDT_TIMEOUT_CNT;
	SD_Info.Get1msHk = KNL_TIMER_Get1ms;
	SD_Init(SD_Info);
#else
	SD_FunctionDisable;
#endif
}
//------------------------------------------------------------------------------
void KNL_FsBlockSetup(void)
{
#if ((APP_REC_FUNC_ENABLE || APP_PHOTOGRAPH_FUNC_ENABLE) || (APP_SD_FUNC_ENABLE==1 && APP_REC_FUNC_ENABLE==0 && APP_PHOTOGRAPH_FUNC_ENABLE==0))
#if (defined(VBM_PU) || defined(VBM_BU) || defined(BUC_CAM) || defined(BSP_DVR_SDK) || (defined(BUC_CU) && !defined(BSP_DVR_SDK)))
	uint32_t ulTempFsBufSz;
	KNL_FsSetting(ulBUF_GetBlkBufAddr(0,BUF_FS));
	tKNL_FsMediaInfo.InitPara.ubFixedFat32 = FS_FIXED_FAT32_EN;
	tKNL_FsMediaInfo.InitPara.ubTimeZone = FS_TZ_NAEST;
	tKNL_FsMediaInfo.InitPara.ulHiddenInfOffset = ((KNL_JPG_SOI_SIZE+KNL_JPG_EXIF_SIZE+KNL_JPG_FRAMEHEADER_SIZE)/16+2)*16;
	tKNL_FsMediaInfo.InitPara.ulHiddenInfSize = KNL_JPG_HEADER_SIZE;
	FS_Init(&tKNL_FsMediaInfo.InitPara);
	ulTempFsBufSz = ulFS_GetTotalBufSize(&tKNL_FsMediaInfo.InitPara);
	printd(DBG_CriticalLvl, "FS buf size: 0x%x(%d) bytes\r\n",ulTempFsBufSz,ulTempFsBufSz);
	printf("FS Ver:%04x\r\n", uwFS_GetVersion());
#endif
#endif
}
//------------------------------------------------------------------------------
ALAW_RETURN_FLAG_t KNL_Alaw_Encode(uint32_t ulSrcAddr, uint32_t ulDstAddr, uint32_t ulInputSize, uint32_t *ulOutputSize)
{
	SNX_ALAW_PARA_t EncPara;
	int32_t EncFlag;
	
	if( ulInputSize%2 )
	{
		printd(DBG_ErrorLvl, "Alaw enc input size error!!\n");
		return ALAW_ERROR;
	}
	
	EncPara.type = AUD_CODEC_ENCODER;
	EncPara.samplerate = 16000;
	
	EncFlag = snx_alaw_encode(&EncPara, (int16_t*)ulSrcAddr, (uint8_t*)ulDstAddr, ulInputSize, (int32_t*)ulOutputSize);
	if(EncFlag!=AUD_CODEC_SUCCESS)
	{
		printd(DBG_ErrorLvl, "Alaw enc error!!\n");
		return ALAW_ERROR;
	}
	
	return ALAW_OK;
}
//------------------------------------------------------------------------------
ALAW_RETURN_FLAG_t KNL_Alaw_Decode(uint32_t ulSrcAddr, uint32_t ulDstAddr, uint32_t ulInputSize, uint32_t *ulOutputSize)
{
	SNX_ALAW_PARA_t DecPara;
	int32_t DecFlag;
	
	if( ulInputSize%2 )
	{
		printd(DBG_ErrorLvl, "Alaw dec input size error!!\n");
		return ALAW_ERROR;
	}
	
	DecPara.type = AUD_CODEC_DECODER;
	DecPara.samplerate = 16000;
	
	DecFlag = snx_alaw_decode(&DecPara, (uint8_t*)ulSrcAddr, (int16_t*)ulDstAddr, ulInputSize, (int32_t*)ulOutputSize);
	if(DecFlag!=AUD_CODEC_SUCCESS)
	{
		printd(DBG_ErrorLvl, "Alaw dec error!!\n");
		return ALAW_ERROR;
	}
	
	return ALAW_OK;
}
//------------------------------------------------------------------------------
void KNL_Ado32EncInit(uint8_t ubUseIdx, ADO_SNX_AUD32_FORMAT Format)
{
	snx_aud32_open(&KNL_Ado32_EncInfo[ubUseIdx], SNX_AUD32_TYPE_ENCODER, Format);
}
//------------------------------------------------------------------------------
void KNL_Ado32DecInit(uint8_t ubUseIdx, ADO_SNX_AUD32_FORMAT Format)
{
	snx_aud32_open(&KNL_Ado32_DecInfo[ubUseIdx], SNX_AUD32_TYPE_DECODER, Format);
}
//------------------------------------------------------------------------------
ADO_AUD32_ENC_INFO KNL_Ado32_Encode(uint8_t ubUseIdx, uint32_t ulSrcAddr, uint32_t ulDestAddr, uint32_t ulSize)
{
	SNX_AUD32_CONTEXT_t *aud32;
	ADO_AUD32_ENC_INFO EncOutInfo;
	int32_t slDestSize;
	uint32_t ulEncodeSize;
	
	aud32 = &KNL_Ado32_EncInfo[ubUseIdx];
	if (!aud32)
	{
		printd(DBG_ErrorLvl, "Audio32 encode fail.\n");
		return EncOutInfo;
	}
	
	EncOutInfo.ulOutputSize = 0;
	EncOutInfo.ulRemainStartAddr = 0;
	EncOutInfo.ulRemainSize = 0;
	
	ulEncodeSize = (ulSize/aud32->pcm_bytes_per_frame) * aud32->pcm_bytes_per_frame;
	
	EncOutInfo.ulOutputSize = snx_aud32_encode(aud32, (int8_t*)ulSrcAddr, (int8_t*)ulDestAddr, ulEncodeSize, &slDestSize);
	EncOutInfo.ulRemainStartAddr = ulSrcAddr + ulEncodeSize;
	EncOutInfo.ulRemainSize = ulSize - ulEncodeSize;
	
	return EncOutInfo;
}
//------------------------------------------------------------------------------
ADO_AUD32_DEC_INFO KNL_Ado32_Decode(uint8_t ubUseIdx, uint32_t ulSrcAddr, uint32_t ulDestAddr, uint32_t ulSize)
{
	SNX_AUD32_CONTEXT_t *aud32;
	ADO_AUD32_DEC_INFO DecOutInfo;
	int32_t slDestSize;
	
	DecOutInfo.ulResultSize = 0;
	
	aud32 = &KNL_Ado32_DecInfo[ubUseIdx];
	if (!aud32)
	{
		printd(DBG_ErrorLvl, "Audio32 decode fail.\n");
		return DecOutInfo;
	}
	
	DecOutInfo.ulResultSize = snx_aud32_decode(aud32, (int8_t*)ulSrcAddr, (int8_t*)ulDestAddr, ulSize, &slDestSize);

	return DecOutInfo;
}
//------------------------------------------------------------------------------
ADO_RETURN_FLAG KNL_AAC_EncInit(uint8_t ubUseIdx, uint8_t ubEncType, uint32_t ulSampleRate, uint32_t ulChannels)
{
#if(ADO_ENC_TYPE==SW_AAC_ENC)
	if(ubAAC_EncInit(ubUseIdx, ubEncType, ulSampleRate, ulChannels))
	{
		return ADO_SUCCESS;
	}
#endif
	printd(DBG_ErrorLvl, "ADO AAC[%d] enc init fail!\n",ubUseIdx);
	return ADO_FAIL;
}
//------------------------------------------------------------------------------
ADO_RETURN_FLAG KNL_AAC_DecInit(uint8_t ubUseIdx, uint8_t ubDecType, uint32_t ulSampleRate, uint32_t ulChannels)
{
#if(ADO_ENC_TYPE==SW_AAC_ENC)
	if(ubAAC_DecInit(ubUseIdx, ubDecType, ulSampleRate, ulChannels))
	{
		return ADO_SUCCESS;
	}
#endif
	printd(DBG_ErrorLvl, "ADO AAC[%d] dec init fail!\n",ubUseIdx);
	return ADO_FAIL;
}
//------------------------------------------------------------------------------
void KNL_AAC_EncUnInit(uint8_t ubUseIdx)
{
#if(ADO_ENC_TYPE==SW_AAC_ENC)
	AAC_EncUnInit(ubUseIdx);
#endif
}
//------------------------------------------------------------------------------
void KNL_AAC_DecUnInit(uint8_t ubUseIdx)
{
#if(ADO_ENC_TYPE==SW_AAC_ENC)
	AAC_DecUnInit(ubUseIdx);
#endif
}
//------------------------------------------------------------------------------
uint32_t ulKNL_AAC_GetEncUnitSize(uint8_t ubUseIdx)
{
#if(ADO_ENC_TYPE==SW_AAC_ENC)
	return ulAAC_GetEncUnitSize(ubUseIdx);
#else
	return 0;
#endif
}
//------------------------------------------------------------------------------
ADO_RETURN_FLAG KNL_AAC_EncEncode(uint8_t ubUseIdx, uint32_t SrcAddr, uint32_t SrcSize, uint32_t DestAddr, uint32_t *DestSize)
{
#if(ADO_ENC_TYPE==SW_AAC_ENC)
	if(ubAAC_EncEncode(ubUseIdx, (uint8_t*)SrcAddr, SrcSize, (uint8_t*)DestAddr, DestSize))
	{
		return ADO_SUCCESS;
	}
#endif
	printd(DBG_ErrorLvl, "ADO AAC[%d] encode fail!\n",ubUseIdx);
	return ADO_FAIL;
}
//------------------------------------------------------------------------------
ADO_RETURN_FLAG KNL_AAC_EncEncodeFlush(uint8_t ubUseIdx, uint32_t DestAddr, uint32_t *DestSize)
{
#if(ADO_ENC_TYPE==SW_AAC_ENC)
	if(ubAAC_EncFlushEncode(ubUseIdx, (uint8_t*)DestAddr, DestSize))
	{
		return ADO_SUCCESS;
	}
#endif
	printd(DBG_ErrorLvl, "ADO AAC[%d] encode flush fail!\n",ubUseIdx);
	return ADO_FAIL;
}
//------------------------------------------------------------------------------
ADO_RETURN_FLAG KNL_AAC_DecDecode(uint8_t ubUseIdx, uint32_t SrcAddr, uint32_t SrcSize, uint32_t DestAddr, uint32_t *DestSize)
{
#if(ADO_ENC_TYPE==SW_AAC_ENC)
	if(ubAAC_DecDecode(ubUseIdx, (uint8_t*)SrcAddr, SrcSize, (uint8_t*)DestAddr, DestSize))
	{
		return ADO_SUCCESS;
	}
#endif
	printd(DBG_ErrorLvl, "ADO AAC[%d] decode fail!\n",ubUseIdx);
	return ADO_FAIL;
}
//------------------------------------------------------------------------------
void KNL_AudioBlockSetup(void)
{
	if(APP_ADO_FUNC_ENABLE!=1)
	{
		printd(DBG_InfoLvl, "ADO function disabled!\r\n");
		return;
	}
#if APP_ADO_FUNC_ENABLE
	//=======================================================================
	if((ubKNL_ChkExistNode(KNL_NODE_ADC) || ubKNL_ChkExistNode(KNL_NODE_DAC)) && (ubKNL_InitAdoFlg == 0))
	{
		tKNL_AdoInfo.ubQ_InitFlg = 1;
		tKNL_AdoInfo.ulBufStartAddr = ulBUF_GetBlkBufAddr(0,BUF_ADO_IP);

		ADO_Setup(&tKNL_AdoInfo,&tKNL_EncEventQue,&tKNL_DecEventQue);

		//-----------------------------------
		// Receive time latency of ado data
		//-----------------------------------
		for(uint32_t i=0; i<ADO_SRC_NUM; i++)
		{
			ADO_SetRcvTimeLatency(i, 500);
		}

		//-----------------------------------
		// Queue data for smooth play
		//-----------------------------------
#if (defined(OP_STA) && defined(S2019A) && defined(RVCS_APP))
		ADO_SetQueueDataForSmoothPly(0);
#else
		ADO_SetQueueDataForSmoothPly(300);
#endif
		
		//--------------------------------------------
		// Local sound mix remote sound for recording
		//--------------------------------------------
		ADO_LocalRecMixRemoteSwitch(7, 7, ADO_OFF);
		
		//---------------------------------
		// Sigma-delta ADC gain
		//---------------------------------
        ADO_SetSigmaDeltaAdcGain(ADO_SIG_BOOST_37DB, ADO_SIG_PGA_33DB);

		//---------------------------------
		// ADC djust functions
		//---------------------------------
		ADO_SetAdcDcComp(0xA, 0x14, 0x25, ADO_OFF);	// DC compensation

		//---------------------------------
		// DAC djust functions
		//---------------------------------
		//ADO_SetDacR2RVol(R2R_VOL_n0DB);	// DAC R2R volume
		ADO_SetDacM2so(ADO_OFF);		// M2SO
		
#if APP_ADO_AEC_NR_TYPE == AEC_NR_HW
		ADO_SetDacGain(DAC_GAIN_n14DB, ADO_ON);
#endif
		//====================================	

		osThreadDef(ADOEncProcessThread, KNL_AdoEncMonitThread, THREAD_PRIO_ADO_ENC_PROC, 1, THREAD_STACK_ADO_PROC);
		osThreadCreate(osThread(ADOEncProcessThread), NULL);

		osThreadDef(ADODecProcessThread, KNL_AdoDecMonitThread, THREAD_PRIO_ADO_DEC_PROC, 1, THREAD_STACK_ADO_PROC);
		osThreadCreate(osThread(ADODecProcessThread), NULL);

		ubKNL_InitAdoFlg = 1;
	}
#endif
}
//------------------------------------------------------------------------------
void KNL_RecordingBlockSetup(void)
{
#if APP_REC_FUNC_ENABLE
	#if (APP_ADO_FUNC_ENABLE == 1)
	vREC_AdoEnableSet(1);
	#else
	vREC_AdoEnableSet(0);
	#endif

	#if defined(BSP_DVR_SDK)
	vREC_CWithSenSet(1);
	#endif

	osMessageQDef(KNL_QUEEMERGENCY, 30, REC_EMERGENCY);
	KNL_QueEmergency = osMessageCreate(osMessageQ(KNL_QUEEMERGENCY), NULL);
	REC_RegisteredEmergencyQueue(&KNL_QueEmergency);

	osThreadDef(KNLRecEmergencyThread, KNL_RecEmergencyThread, THREAD_PRIO_KNL_EMERGENCY_HANDLER, 1, THREAD_STACK_KNL_EMERGENCY_HANDLER);
	osThreadCreate(osThread(KNLRecEmergencyThread), NULL);

	REC_Init(KNL_REC_SOURCE_MODE, APP_FS_CUSTOMER1_PATH_ENABLE);
	printf("REC Ver:%04x\r\n", uwREC_GetVersion());

	Media_SemaphoreCreate();
	//Media_Init(ulBUF_GetBlkBufAddr(0,BUF_REC) );
	//printf("ulMedia_GetBufSz:0x%x\n", ulMedia_GetBufSz());
#if ( OP_AP || ( OP_STA && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE ))
	PLY_Init();
	//PLY_PinPonBuffInit(ulBUF_GetBlkBufAddr(0,BUF_REC) + ulMedia_GetBufSz());
	//printf("ulPLY_GetBufSz:0x%x\n", ulPLY_GetBufSz());
	//printf("REC_PLAY MEM ADDR: START=0x%x, END=0x%x\n", ulBUF_GetBlkBufAddr(0,BUF_REC), ulBUF_GetBlkBufAddr(0,BUF_REC) + ulMedia_GetBufSz() + ulPLY_GetBufSz());
	printf("PLY Ver:%04x\n", uwPLY_GetVersion());
#endif
	osMessageQDef(KnlStrgRecQue, 300, KNL_StrgRecInfo_t);
	osKNL_StrgRecQue = osMessageCreate(osMessageQ(KnlStrgRecQue), NULL);
	osThreadDef(KnlStrgRecThd, KNL_StorageRecFilesProc, osPriorityAboveNormal, 1, 1024);
	osThreadCreate(osThread(KnlStrgRecThd), NULL);
#endif
}
//------------------------------------------------------------------------------
void KNL_UsbDevBlockSetup(void)
{
	
#if USBD_ENABLE
	if((USBD_COMPOSITE_MODE == tUSBD_GetClassMode()) && (TRUE == ubUSBD_ChkCompMscClass()))
	{
        #ifdef OP_AP 
		ADO_SetOutputCbFunc(KNL_UpdateUsbdAdoData);         
		tUSBD_RegMscCbFunc(USBDM_OPC_ADO, KNL_RecvAdoDataFromApp);
        tUSBD_RegUvcReleaseBuffCbFunc(KNL_ReleaseUsbdBuf);
        #endif
	}
	if(USBD_MSC_MODE == tUSBD_GetClassMode())
	{
		USBD_SetMscCapacities(ulKNL_FsSdIdentify());
#if APP_PC_CONNECT_EN
        tUSBD_RegMscCbFunc(USBDM_OPC_MSCW, KNL_MscSectorWrite); 
        tUSBD_RegMscCbFunc(USBDM_OPC_MSCR, KNL_MscSectorRead); 
		tUSBD_RegMscCbFunc_MediaDetect(ulKNL_MscMediaExist);
		tUSBD_RegMscCbFunc_MediaCapacity(ulKNL_MscGetSdBlockSz);
		osMutexDef(osKNL_Mutex_PcConnect);
		osKNL_Mutex_PcConnect = osMutexCreate(osMutex(osKNL_Mutex_PcConnect));	
		tUSBD_RegSetConfigurationCbFunc(KNL_EnterPcConnect);
		tUSBD_RegSuspendCbFunc(KNL_LeavePcConnect);
#endif
	}
	#if (defined(OP_AP) && (APP_USBD_COMPOSITE_MODE & USBD_MULTI_UAC))
	if( USBD_UAC_MODE == tUSBD_GetClassMode() || USBD_MULTI_UAC & ubUSBD_GetMultiDrvMode())
	{

		ADO_SetOutputCbFunc(KNL_UpdateUsbdAdoData);         
		tUSBD_RegMscCbFunc(USBDM_OPC_ADO, KNL_RecvAdoDataFromApp);
        tUSBD_RegUvcReleaseBuffCbFunc(KNL_ReleaseUsbdBuf);	
	
		usbd_drv_uac_start_record_reg_cb(KNL_UacIsoInStart);
		usbd_drv_uac_stop_record_reg_cb(KNL_UacIsoInStop);
		usbd_drv_uac_ctrl_volume_reg_cb(KNL_UacVolumeCtrl);
		usbd_drv_uac_ctrl_mute_reg_cb(KNL_UacMuteCtrl);
		
		osMessageQDef(UsbdUacQue, 10, ADO_Queue_INFO);	
		osKNL_UsbdUacQue = osMessageCreate(osMessageQ(UsbdUacQue), NULL);
		osThreadDef(UsbdIsoInProcThread, KNL_UsbdIsoInProcThread, osPriorityHigh, 1, 512);
		osThreadCreate(osThread(UsbdIsoInProcThread), NULL);
		osThreadDef(UsbdIsoOutProcThread, KNL_UsbdIsoOutProcThread, osPriorityAboveNormal /*osPriorityAboveNormal osPriorityHigh osPriorityNormal*/, 1, 512);
		osThreadCreate(osThread(UsbdIsoOutProcThread), NULL);
	}	
	#endif
	#if defined(OP_STA)	
		#if APP_UVC_CAM_ENABLE	
		if((USBD_COMPOSITE_MODE == tUSBD_GetClassMode()) && (USBD_MULTI_MSC & ubUSBD_GetMultiDrvMode()))
		{
			tUSBD_RegMscCbFunc(USBDM_OPC_FWUW, FWU_MscSectorWrite); 
			tUSBD_RegMscCbFunc(USBDM_OPC_FWUR, FWU_MscSectorRead); 
		}
		#endif
	#endif	

	#if (defined(OP_AP) && (APP_USBD_COMPOSITE_MODE & USBD_MULTI_UVC))
	if((USBD_UVC_MODE == tUSBD_GetClassMode()) || (TRUE == ubUSBD_ChkCompUvcClass()))
	{
		tUSBD_UvcCtProcessCbFunc(APP_UvcCtCmd);
		tUSBD_UvcPuProcessCbFunc(APP_UvcPuCmd);
	}
	#endif		
	if((USBD_UVC_MODE == tUSBD_GetClassMode()) || (TRUE == ubUSBD_ChkCompUvcClass()))
	{
	#ifdef OP_STA
		if(KNL_TUNINGMODE_OFF == KNL_GetTuningToolMode())
		{
			tUSBD_RegUvcReleaseBuffCbFunc(KNL_ReleaseUsbdBuf);
			if(USBD_UVC_MJ_FMT == USBD_UVC_FMT)
			{
				KNL_SetHQImgSize((ISP_WIDTH * 2), (ISP_HEIGHT * 2));
				USBD_SetUvcStillImageCaptureInfo(TRUE, (ISP_WIDTH * 2), (ISP_HEIGHT * 2));
			}
			USBD_SetUserDefUvcFmt4CamSide((USBD_UVC_MJ_FMT == USBD_UVC_FMT)?USB_UVC_VS_FORMAT_MJPEG:
									      (USBD_UVC_H264_FMT == USBD_UVC_FMT)?USB_UVC_VS_FORMAT_FRAME_BASED:USB_UVC_VS_FORMAT_UNDEFINED);
		}
	#else
		if(DISPLAY_1T1R == DISPLAY_MODE)
		{
			tUSBD_RegUvcReleaseBuffCbFunc(KNL_ReleaseUsbdBuf);
			#if (defined(OP_AP))
			tUSBD_UvcSetImgInfCbFunc(KNL_RecvUsbdUvcSetImageInf);
			tUSBD_UvcSetStillImgInfCbFunc(KNL_UvcCapture);
			#endif
			if((USBD_UVC_MJ_FMT == USBD_UVC_FMT)&&(USBD_DEFU_CLASS == USBD_UVC_MODE))
				USBD_SetUvcStillImageCaptureInfo(TRUE, VDO_MAIN_H_SIZE(KNL_DISP_SINGLE), VDO_MAIN_V_SIZE(KNL_DISP_SINGLE));
			USBD_SetUserDefUvcFmt4LcdSide((USBD_UVC_MJ_FMT == USBD_UVC_FMT)?USB_UVC_VS_FORMAT_MJPEG:
									      ((USBD_UVC_H264_FMT == USBD_UVC_FMT) || (USBD_UVC_H265_FMT == USBD_UVC_FMT))?USB_UVC_VS_FORMAT_FRAME_BASED:USB_UVC_VS_FORMAT_UNDEFINED);
			if(USBD_UVC_H265_FMT == USBD_UVC_FMT)
				USBD_SetUvcFrmCompressFmt(USBD_UVC_FMT);
		}
	#endif
	}
	//tUSBD_UvcImgInfolistCbFunc(APP_UvcImageInf);		//sdk update UvcImg Info list 
	USBD_Start();


#endif
}
//------------------------------------------------------------------------------
void KNL_LcdBlockSetup(void)
{
	if(ubKNL_ChkExistNode(KNL_NODE_LCD))
	{
#if KNL_LCD_FUNC_ENABLE
		#if (defined(S2019A) && sPRF_LTYMEAS_EN)
		LCD_SetVsyncNtyCbFunc(KNL_LcdVsncIsr);
		#endif
		if(ubKNL_SetDispCropScaleParam() == 0)
		{
			printd(DBG_ErrorLvl, "Set Crop & Scale Parameter Fail !!!\r\n");
		}
		LCD_Start();
		ubKNL_InitLcdFlg = 1;
#endif
	}
	else
	{
		LCD_FuncDisable;
		ubKNL_InitLcdFlg = 0;
	}
}

//------------------------------------------------------------------------------
#if (!defined(S2019A)||defined(BSP_DVR_SDK))
void KNL_BlockInit(void)
{
	uint8_t ubNodeExist;
	KNL_NODE_INFO tNodeInfo;
	uint8_t i;
#if (defined(S2019A) || (defined(OP_AP) && defined(sWIFIBDG)))	
	sPRF_CbFunc_t tsPRF_CbFunc;
	uint8_t ubSPRF_InitSts = UNSUCCESS;
	uint8_t ubSPRF_InitCnt = 0;
	#ifdef S2019A   
    uint16_t uwVdoGop = KNL_TX_GOP;
	#endif
#endif
#ifdef RTC676x
	uint8_t ubTemp;
#endif	
	
	KNL_1MSCounterInit();
       
#ifdef OP_STA    
    printd(DBG_CriticalLvl, "KNL_Mode: %d %d %d %d %d %d\r\n",
                                                        DISPLAY_MODE,
                                                        APP_SD_FUNC_ENABLE,
                                                        APP_PHOTOGRAPH_FUNC_ENABLE,
                                                        APP_REC_FUNC_ENABLE,                                                         
                                                        APP_TIMESTAMP_FUNC_ENABLE,
                                                        BUF_NUM_VDO_BS);    
#endif 
#ifdef OP_AP    
    printd(DBG_CriticalLvl, "KNL_Mode: %d %d %d %d %d %d\r\n",
                                                        DISPLAY_MODE,
                                                        APP_SD_FUNC_ENABLE,
                                                        APP_PHOTOGRAPH_FUNC_ENABLE,
                                                        APP_REC_FUNC_ENABLE, 
                                                        APP_TIMESTAMP_FUNC_ENABLE,
                                                        BUF_NUM_VDO_BS);
#if APP_REC_FUNC_ENABLE
printd(DBG_CriticalLvl, "TX_GOP: %d\n", KNL_TX_RECGOP);
#else
printd(DBG_CriticalLvl, "TX_GOP: %d\n", KNL_TX_GOP);
#endif
#endif 
#if (defined(S2019A)&&defined(BSP_DVR_SDK)&&(APP_REC_FUNC_ENABLE==1))
    uwVdoGop = KNL_TX_RECGOP;
    KNL_SetVdoGop((uint32_t)uwVdoGop);
#endif

	//For MAC
#if APP_MAC_FUNC_ENABLE	
	uint32_t ulMacBufStartAddr;
	ETH_INIT_t MAC_Info;
	
	ulMacBufStartAddr = ulBUF_GetBlkBufAddr(0,BUF_MAC);
	
	MAC_Info.ulBufStartAddr = ulMacBufStartAddr;
	MAC_Info.TxIsrHook = NULL;
	MAC_Info.RxIsrHook = NULL;
	if(ubEth_Init(&MAC_Info)!=1)
	{
		printd(DBG_CriticalLvl, "MAC init fail!\n");
	}
	else
	{
		printd(DBG_CriticalLvl, "MAC init success!\n");
	}
#endif
	
	//! For SD
	KNL_SdBlockSetup();
	
	//! For FS
	KNL_FsBlockSetup();
	
	//For USBD
	KNL_UsbDevBlockSetup();

//DVR(Start)
//======================================================================================
//======================================================================================
#ifdef BSP_DVR_SDK
	#if ((defined(OP_AP) || (defined(OP_STA) && defined(VDO_SUBPATH_ENABLE) && (VDO_SUBPATH_ENABLE!=0))))
	if(KNL_SRC_NONE != ubSEN_GetPathSrc(SENSOR_PATH2))
	{
#define SENP1_ISR_CB_EN	0
		osPriority osLocDpPrity = osPriorityHigh;
		#ifdef OP_STA
		osLocDpPrity = (SENP1_ISR_CB_EN)?osPriorityHigh:osPriorityAboveNormal;
		#endif
		osMessageQDef(KnlLocProcQue, 4, KNL_LocProcInfo_t);
		osKNL_LocProcQue = osMessageCreate(osMessageQ(KnlLocProcQue), NULL);
		osThreadDef(KnlLocDpProcThd, KNL_LocalDpProc, osLocDpPrity, 1, 1024);
		osThreadCreate(osThread(KnlLocDpProcThd), NULL);
		SEN_SetHwEndIsrCbFunc(SENSOR_PATH2, KNL_LocalDpExec);
		#if (defined(OP_STA) && SENP1_ISR_CB_EN)
		if(KNL_SRC_NONE != ubSEN_GetPathSrc(SENSOR_PATH1))
			SEN_SetHwEndIsrCbFunc(SENSOR_PATH1, KNL_LocalDpExec);
		#endif
	}
	#endif
#endif
#if (defined(OP_AP) && defined(BSP_DVR_SDK))
	//LCD/JPEG-> Sensor	
	
	//For JPEG Codec
	//=======================================================================
	if(((APP_PHOTOGRAPH_FUNC_ENABLE || ubKNL_ChkExistNode(KNL_NODE_JPG_ENC) || ubKNL_ChkExistNode(KNL_NODE_JPG_DEC1) || ubKNL_ChkExistNode(KNL_NODE_JPG_DEC2)) ||
	    ((KNL_DISP_H == tKNL_GetDispType()) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0))) && (ubKNL_InitJpegFlg == 0))
	{
		JPEG_Init();
		KNL_SetJpegQp(32);

		osSemaphoreDef(JPEG_CodecSem);
		JPEG_CodecSem = osSemaphoreCreate(osSemaphore(JPEG_CodecSem), 1);
		
		osSemaphoreDef(KnlJpegWaitSem);
		tKNL_JpegSigProc.osWaitSem = osSemaphoreCreate(osSemaphore(KnlJpegWaitSem), 1);
		tKNL_JpegSigProc.ubProcFlag = FALSE;

        osMessageQDef(KNL_JPGMONITOR, KNL_JPEG_QUEUE_NUM, JPEG_CODEC_INFO_t);
        KNL_QueueJpegMonit = osMessageCreate(osMessageQ(KNL_JPGMONITOR), NULL);

        osThreadDef(JpegMonitThread, KNL_JpegMonitThread, THREAD_PRIO_JPEG_MONIT, 1, THREAD_STACK_JPEG_MONIT);
        osThreadCreate(osThread(JpegMonitThread), NULL);

		ubKNL_InitJpegFlg = 1;
	}	
#if ((USBD_UVC_MJ_FMT == USBD_UVC_FMT) && USBD_ENABLE)
	#ifdef OP_AP
	else if((DISPLAY_1T1R == DISPLAY_MODE) && ((USBD_UVC_MODE == tUSBD_GetClassMode()) || (TRUE == ubUSBD_ChkCompUvcClass())))
	#else
	else if((KNL_TUNINGMODE_OFF == KNL_GetTuningToolMode()) && ((USBD_UVC_MODE == tUSBD_GetClassMode()) || (TRUE == ubUSBD_ChkCompUvcClass())))
	#endif
		JPEG_Init();
#endif
	else
		JPEG_FuncDisable;
	//KNL_UpdateJpgHeader();	
	KNL_UpdateJpgHeader(1280,720);	
	
	//For LCD
	KNL_LcdBlockSetup();
	
	//For Sensor
	//=======================================================================	
    if(ubKNL_ChkExistNode(KNL_NODE_SEN) && (!ubKNL_GetPlayBackIngFlg()))
	{
#if (defined(OP_STA) || (defined(OP_AP) && defined(BSP_DVR_SDK)))	
		uint8_t ubSrcNum = KNL_SRC_NONE;
		SEN_RegisterEventQueue(KNL_VdoInProcQueue);
		SEN_RegisterEventNode(KNL_NODE_SEN_YUV_BUF);
		SEN_SetIspFinishCbFunc(KNL_ImgStabNotifyFunc);
		SEN_SetAhdCamResCbFunc(KNL_AhdCamInSetResFunc);
		SEN_SetAhdCamBufCbFunc(KNL_AhdCamInSetBufFunc);
		#ifdef S2019A
		SEN_RegIsrProcCbFunc(SEN_VSYNC_PROC,  NULL);
		SEN_RegIsrProcCbFunc(SEN_ISPOUT_PROC, NULL);
		#endif
        IQ_IqBinAddrCbFunc(ulSEN_IQBinAddr);

		if(ubKNL_GetIspEnable())
			SEN_LoadIQData();

        if(ubSEN_InitProcess())
        {    
            ubSrcNum = ubSEN_GetPathSrc(SENSOR_PATH1);
            if(KNL_SRC_NONE != ubSrcNum)
                KNL_SenStart(ubSrcNum);

            ubSrcNum = ubSEN_GetPathSrc(SENSOR_PATH2);
            if(KNL_SRC_NONE != ubSrcNum)
                KNL_SenStart(ubSrcNum);

#ifdef BIO_BU
            ubSrcNum = ubSEN_GetPathSrc(SENSOR_PATH3);
            if((ubKNL_GetRole() <= KNL_STA4) && (KNL_SRC_NONE != ubSrcNum))
                KNL_SenStart(ubSrcNum);
#endif
        }		
		
#endif
	}	
	//======================================================================================
	//======================================================================================
	//DVR(End)	

	
	//VBM/BUC(Start)
	//======================================================================================
	//======================================================================================
#else	
	//For Sensor
	//=======================================================================
	if(ubKNL_ChkExistNode(KNL_NODE_SEN))
	{
#ifdef OP_STA
		uint8_t ubSrcNum = KNL_SRC_NONE;
        SEN_RegisterEventQueue(KNL_VdoInProcQueue);
        SEN_RegisterEventNode(KNL_NODE_SEN_YUV_BUF);
        SEN_SetIspFinishCbFunc(KNL_ImgStabNotifyFunc);
		SEN_SetAhdCamResCbFunc(KNL_AhdCamInSetResFunc);
		SEN_SetAhdCamBufCbFunc(KNL_AhdCamInSetBufFunc);
		#ifdef S2019A
		SEN_RegIsrProcCbFunc(SEN_VSYNC_PROC,  ulKNL_SenVsyncIsrProc);
		SEN_RegIsrProcCbFunc(SEN_ISPOUT_PROC, ulKNL_IspOutIsrProc);
		#endif
        IQ_IqBinAddrCbFunc(ulSEN_IQBinAddr);
#ifndef BSP_DVR_SDK         
		if(ubKNL_GetSenThenEncEnable())		
            SEN_SetHwEndIsrCbFunc(SENSOR_PATH1, KNL_SenHwEndProcess);
#endif

		if(ubKNL_GetIspEnable())
		{
            //printf("Load IQ !!!!\r\n");
			SEN_LoadIQData();
		}	
        if(ubSEN_InitProcess())
        {
        #if (APP_SEN_HORIZONTAL_MIRROR_ENABLE == 1)
			//printf("Set Horizontal Mirror\r\n");		
			SEN_SetMirrorFlip(1,0);	//Horizontal Mirror
		#endif
					
			ubSrcNum = ubSEN_GetPathSrc(SENSOR_PATH1);
            if((ubKNL_GetRole() <= KNL_STA4) && (KNL_SRC_NONE != ubSrcNum))
                KNL_SenStart(ubSrcNum);

#if (defined(VDO_SUBPATH_ENABLE)&&(VDO_SUBPATH_ENABLE!=0))			
            ubSrcNum = ubSEN_GetPathSrc(SENSOR_PATH2);
            if(KNL_SRC_NONE != ubSrcNum)
                KNL_SenStart(ubSrcNum);
#endif
			
#ifdef BIO_BU
            ubSrcNum = ubSEN_GetPathSrc(SENSOR_PATH3);
            if((ubKNL_GetRole() <= KNL_STA4) && (KNL_SRC_NONE != ubSrcNum))
                KNL_SenStart(ubSrcNum);
#endif   			
        }
#endif
	}
#endif
	else
		ISP_FuncDisable;

//For BB
	ubNodeExist = ubKNL_ChkExistNode(KNL_NODE_COMM_TX_VDO)|ubKNL_ChkExistNode(KNL_NODE_COMM_RX_VDO)|ubKNL_ChkExistNode(KNL_NODE_COMM_TX_ADO)|ubKNL_ChkExistNode(KNL_NODE_COMM_RX_ADO);		
#if defined(RTC676x)
    if((USBD_UVC_MODE == tUSBD_GetClassMode()) && (16 == (ulDDR_GetCapacity() >> 20)))
    {
        ubNodeExist = 0;
    }
#endif
#if (APP_UVC_CAM_ENABLE == 1)
	ubNodeExist = 0;
#endif
	if(ubNodeExist && (ubKNL_InitBBFlg == 0))
	{
	#ifdef RTC676x		
		SPI_Setup_t tSpiSetup;
	
		osDelay(KNL_STABLE_TIME);	//For Stable
		
		tSpiSetup.ubSPI_CPOL    = 0;
		tSpiSetup.ubSPI_CPHA    = 0;
		tSpiSetup.tSPI_Mode     = SPI_MASTER;			
		//tSpiSetup.uwClkDiv      = 1;            //SPI_CLK = 0->24MHz,1->12MHz	
		tSpiSetup.uwClkDiv      = 0;            //SPI_CLK = 0->24MHz,1->12MHz		
		RTC676x_SPI_Init(&tSpiSetup);
	#endif	
			
		SET_SLOT_MODE tKNL_BbSlotMode;

	#if (!defined(BIO_CU) && !defined(BIO_BU))
		uint8_t ubKNL_PsValue = 0;		
	#endif
		tKNL_BbSlotMode = tKNL_BbSlotMode;	//Avoid Warning

	#ifdef A7130
		if((VDO_MAIN_H_SIZE(KNL_DISP_SINGLE) <= HD_WIDTH) && (VDO_MAIN_V_SIZE(KNL_DISP_SINGLE) <= HD_HEIGHT))
		{
			
			BB_SetVideoAudioBufSize(ulKNL_GetRfBigBufSize(),ulKNL_GetRfSmallBufSize(),((8)*1024));
		}
		else 
		{
#if ((defined(BSP_VBM_SDK)||defined(BSP_RVCS_SDK)) && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
			
			BB_SetVideoAudioBufSize(ulKNL_GetRfBigBufSize(),ulKNL_GetRfSmallBufSize(),((8)*1024));
#else
			
			BB_SetVideoAudioBufSize(ulKNL_GetRfBigBufSize(),ulKNL_GetRfSmallBufSize(),((8)*1024));
#endif
		}
		BB_VariableInit(ulBUF_GetBlkBufAddr(0,BUF_BB_IP));
	#endif

		for(i=0;i<6;i++)
		{
#if (defined(OP_AP) && defined(BSP_DVR_SDK))
            if(i != KNL_STA2)
		#endif
		
		#if (defined(OP_AP)&& (APP_DUAL_HOST_ENABLE == 1))
			if((i == KNL_STA1)||(i == KNL_STA4))	//STA2/STA3 for Local
		#endif
            {      
            	ubKNL_LinkStatus[i] = BB_LOST_LINK;
            	ubKNL_RtLinkStatus[i] = BB_LOST_LINK;
            }
		}		
		
	#ifdef RTC676x
		//Packet's Ack Status -> 50% Ack Ok
		for(i=0;i<KNL_ACK_STATIC_NUM;i++)
		{
			if(i%2)
			{
				ubPkt_AckStatus[i] = KNL_ACK_OK;
			}
			else
			{
				ubPkt_AckStatus[i] = KNL_ACK_FAIL;
			}
		}
	#if OP_STA
		//ubKNL_LinkActiveTime = KNL_LINK_ACTIVE_TIME;
		ubKNL_AccessLinkActiveTime(KNL_OPERATION_SET,KNL_LINK_ACTIVE_TIME);		
	#endif
	#endif

		switch(tKNL_Info.ubOpMode)
		{
			case KNL_OPMODE_VBM_4T:
			case KNL_OPMODE_BUC_4T:
				tKNL_BbSlotMode = BB_SLOT_4;			
				KNL_SetTXRSlotNum(4);			
				break;
			case KNL_OPMODE_VBM_2T:
			case KNL_OPMODE_BUC_2T_1L1R:
			case KNL_OPMODE_BUC_2T_1T1B:
				tKNL_BbSlotMode = BB_SLOT_2;
				KNL_SetTXRSlotNum(2);
				break;
			default:
				tKNL_BbSlotMode = BB_SLOT_1;
				KNL_SetTXRSlotNum(1);
				break;
		}
		
	#if defined(BSP_DVR_SDK)
		tKNL_BbSlotMode = BB_SLOT_1;
		KNL_SetTXRSlotNum(1);	
		#ifdef S2019A
		#if OP_AP
		DDR_ImprovePriority(SYS_PERMODE7);
		#endif
		#endif
		#ifdef A7130
		#if OP_AP
		DDR_ImprovePriority(SYS_PERMODE5);	
		#endif
		BB_SetTRxTime(400);		
        BB_SetDvrMode(1);
		#endif
	#else
		#ifdef A7130
			if(BB_SLOT_1 == tKNL_BbSlotMode)
				BB_SetTRxTime(0);
			else
                BB_SetTRxTime(350);
		#endif
	#endif	
			
	#if (APP_DUAL_HOST_ENABLE == 1)
		tKNL_BbSlotMode = BB_SLOT_1;
		KNL_SetTXRSlotNum(1);		
		BB_SetTRxTime(0);
	#endif

	#if (APP_BB_SPECIAL_TIMING_ENABLE == 1)
		#if OP_AP		
			DDR_ImprovePriority(SYS_PERMODE5);
			BB_SetTRxTime(400);			
			BB_SetDvrMode(1);
		#endif
		#if OP_STA
			BB_SetTRxTime(400);			
			BB_SetDvrMode(1);
		#endif
	#endif
		
    #if (defined(BSP_SNCC72_AHD_RN6752M_TX_V1)||defined(BSP_SNCC72_AHD_TP9950_TX_V2)||defined(BSP_D_SNCC72_TX_V1))
		#ifdef A7130
			BB_SetRfPinMode(2); 
		#endif
	#else
		#ifdef A7130
			BB_SetRfPinMode(1); 
		#endif
	#endif
	
	#if (!defined(BIO_CU) && !defined(BIO_BU))
		ubKNL_PsValue  = wRTC_ReadUserRam(RTC_RECORD_PWRSTS_ADDR);
		ubKNL_PsValue &= 0xF0;
	#endif
	#ifdef A7130
		BB_SetRFGpioPinNum(RF_CKO_GPIONUM, RF_TXSW_GPIONUM);	//! Set GPIO pin of RF
		BB_SetHopChNumber(APP_RF_HOPPING_CHANNEL_NUMBER);		//! Set RF hopping channel number
		KNL_DisableWORFunc();
		#if (defined(BIO_CU) || defined(BIO_BU))
		if (BSP_CHK_WOR())
		#else
		if((!ubRTC_GetKey()) && (ubKNL_PsValue == RTC_PS_WOR_TAG))
		#endif
		{
#ifdef SU5390	
			BB_Init(tKNL_BbSlotMode, NULL, 0, 0x07, 0x07, 0, 165, APP_BB_TIMING_SET);	
#else
			BB_Init(tKNL_BbSlotMode, NULL, 0, 0x2B, 0x2B, 0, 165, APP_BB_TIMING_SET);		
#endif
			
			
			
			ubKNL_WorSts = BB_ConfirmWakeUpInf();
			#if (defined(BIO_CU) || defined(BIO_BU))
			if (ubKNL_WorSts)
				BSP_SET_POWERON_MODE(BSP_RF_WAKEUP);
			#endif
		}
		else
		{
#ifdef SU5390			
			BB_Init(tKNL_BbSlotMode, NULL, 1, 0x07, 0x07, 0, 165, APP_BB_TIMING_SET);
#else
			BB_Init(tKNL_BbSlotMode, NULL, 1, 0x2B, 0x2B, 0, 165, APP_BB_TIMING_SET);	
#endif
		}
		#ifdef OP_STA
		BB_SetWorMode(tKNL_WorMode);
		#endif

		osMessageQDef(KNL_QueBbFrmOk, 150, uint8_t);
		KNL_QueBbFrmOk = osMessageCreate(osMessageQ(KNL_QueBbFrmOk), NULL);
		BB_FrameOkReqisteredQueue(&KNL_QueBbFrmOk);
		osThreadDef(KNL_BbFrmMonitThread, KNL_BbFrmMonitThread, osPriorityAboveNormal, 1, 512);
		osThreadCreate(osThread(KNL_BbFrmMonitThread), NULL);	
		
		//Step(n+1)
		//=============================================================
		osMessageQDef(KNL_QUETXVDO, 30, uint8_t);
		KNL_QueTxVdo = osMessageCreate(osMessageQ(KNL_QUETXVDO), NULL);	
		osMessageQDef(KNL_QUETXADO, 30, uint8_t);
		KNL_QueTxAdo = osMessageCreate(osMessageQ(KNL_QUETXADO), NULL);
		
		osMessageQDef(KNL_LINKRPT, 30, LINK_REPORT);
		KNL_LinkQ = osMessageCreate(osMessageQ(KNL_LINKRPT), NULL);	

		BB_LinkStatusReqisteredQueue(&KNL_LinkQ);		
		BB_RxDataReqisteredQueue(&KNL_QueRxVdo,BB_DATA_VIDEO);
		BB_RxDataReqisteredQueue(&KNL_QueRxAdo,BB_DATA_AUDIO);		
	#endif
	
		osMessageQDef(KNL_QUERXVDO, 60, RX_DON);
		KNL_QueRxVdo = osMessageCreate(osMessageQ(KNL_QUERXVDO), NULL);
		osMessageQDef(KNL_QUERXADO, 60, RX_DON);
		KNL_QueRxAdo = osMessageCreate(osMessageQ(KNL_QUERXADO), NULL);	
#ifdef S2019A
        osMessageQDef(KNL_LINKRPT, 30, LINK_REPORT);
		KNL_LinkQ = osMessageCreate(osMessageQ(KNL_LINKRPT), NULL);	
#endif
		osThreadDef(CommLinkMonitThread, KNL_CommLinkMonitThread, THREAD_PRIO_LINK_MONIT, 1, THREAD_STACK_LINK_MONIT);
		osThreadCreate(osThread(CommLinkMonitThread), NULL);

		osThreadDef(CommLinkUpdateThread, KNL_CommLinkUpdateThread, THREAD_PRIO_LINK_UPDATE, 1, THREAD_STACK_LINK_UPDATE);
		osThreadCreate(osThread(CommLinkUpdateThread), NULL);
		//=============================================================
		
#ifdef A7130
		#if OP_STA
			BB_SetPacketRetryTime(BB_ADO,BB_TIME_ALWAYS);
			BB_SetPacketRetryTime(BB_VDO,BB_TIME_ALWAYS);
			BB_SetDataPath(BB_TX_ADO_MASTER_AP,BB_RX_ADO_MASTER_AP,BB_PAYLOAD_NONE);
		#endif
		#if OP_AP
			BB_SetPacketRetryTime(BB_ADO,BB_TIME_ALWAYS);
			BB_SetDataPath(BB_TX_ADO_STA1,BB_RX_ADO_ALL_STA,BB_PAYLOAD_NONE);
		#endif

		AFH_Start(AFH_ADA_CH,0,0);
		BB_Start(THREAD_STACK_BB_HANDLER, THREAD_PRIO_BB_HANDLER);
	#if (defined(BIO_CU) || defined(BIO_BU))
		if (BSP_CHK_WOR())
	#else
		if((!ubRTC_GetKey()) && (ubKNL_PsValue == RTC_PS_WOR_TAG))
	#endif
		{
			if(!ubKNL_WorSts)
			{
				printd(DBG_CriticalLvl, "Not to me\n");
				KNL_EnableWORFunc();
				return;
			}
		}
		EN_Start(THREAD_STACK_EN_HANDLER, THREAD_PRIO_EN_HANDLER);
#endif		

#ifdef A7130
	#if OP_STA		
		BB_SetDataPath(BB_TX_ADO_MASTER_AP,BB_RX_ADO_MASTER_AP,BB_PAYLOAD_NONE);
	#endif
	#if OP_AP		
		BB_SetDataPath(BB_TX_ADO_STA1,BB_RX_ADO_ALL_STA,BB_PAYLOAD_NONE);
	#endif
#endif

#if OP_AP	
		osThreadDef(CommVdoRxMonitThread, KNL_CommVdoRxMonitThread, THREAD_PRIO_COMM_RX_VDO, 1, THREAD_STACK_COMM_RX_VDO);
		osThreadCreate(osThread(CommVdoRxMonitThread), NULL);
#endif

		osThreadDef(CommAdoRxMonitThread, KNL_CommAdoRxMonitThread, THREAD_PRIO_COMM_RX_ADO, 1, THREAD_STACK_COMM_RX_ADO);
		osThreadCreate(osThread(CommAdoRxMonitThread), NULL);
		
		if(tTWC_RegTransCbFunc(TWC_RESEND_I_EXT,KNL_TwcResult,KNL_ResendIActionExt) == TWC_FAIL)
		{
			printd(DBG_ErrorLvl, "Register RESEND_I(EXT) TWC Fail !!!\r\n");
		}
		if(tTWC_RegTransCbFunc(TWC_RESEND_I_INT,KNL_TwcResult,KNL_ResendIActionInt) == TWC_FAIL)
		{
			printd(DBG_ErrorLvl, "Register RESEND_I(INT) TWC Fail !!!\r\n");
		}
		
#if (KNL_DYNAMIC_SLOT == 1)
		if(tTwcIf_RegTransCbFunc(TWC_IF_STA_ON_LINE,KNL_TwcIfResult,KNL_StaOnLineAction) == TWC_IF_FAIL)
		{
			printd(DBG_ErrorLvl, "Register STA_ON_LINE TWC Fail !!!\r\n");
		}			
#endif

		if(tTWC_RegTransCbFunc(TWC_VDORES_SETTING,KNL_TwcResult,KNL_VdoResSetting) == TWC_FAIL)
		{
			printd(DBG_ErrorLvl, "Register Video Resolution TWC Fail !!!\r\n");
		}		
		
#if APP_TIMESTAMP_FUNC_ENABLE        
		if(tTWC_RegTransCbFunc(TWC_SYNC_TIMESTAMP,KNL_TwcResult,KNL_TimeStampSync) == TWC_FAIL)
		{
			printd(DBG_ErrorLvl, "Register Sync RTC TWC Fail !!!\r\n");
		}
#endif        
		if(tTWC_RegTransCbFunc(TWC_SYNC_GOP,KNL_TwcResult,KNL_SyncGOPAction) == TWC_FAIL)
		{
			printd(DBG_ErrorLvl, "Register Sync RTC TWC Fail !!!\r\n");
		}
		if(tTWC_RegTransCbFunc(TWC_SYNC_FRAME,KNL_TwcResult,KNL_SyncFrameAction) == TWC_FAIL)
		{
			printd(DBG_ErrorLvl, "Register Sync TEST TWC Fail !!!\r\n");
		}
	#ifdef RTC676x
	#if APP_RTC676X_BRIDGE_COEXISTENCE_ENABLE		
		if(tTWC_RegTransCbFunc(TWC_FREQ_TABLE,KNL_TwcResult,KNL_FreqTableAction) == TWC_FAIL)
		{
			printd(DBG_ErrorLvl, "Register Freq_Table TWC Fail !!!\r\n");
		}		
	#endif
		
	#if APP_RTC676X_FOTA_ENABLE
		if(tTWC_RegTransCbFunc(TWC_FOTA_RPT,KNL_TwcResult,KNL_FotaAction) == TWC_FAIL)
		{
			printd(DBG_ErrorLvl, "Register FOTA_Report TWC Fail !!!\r\n");
		}		
	#ifdef OP_AP
		osThreadDef(KNLFotaThread, KNL_FotaThread, THREAD_PRIO_FOTA, 1, THREAD_STACK_FOTA);
		osThreadCreate(osThread(KNLFotaThread), NULL);
	#endif
		
	#ifdef OP_STA		
		KNL_RegisterFotaEventAtTx(KNL_FotaEventAtTx);		
	#endif		
	#endif		
		
		//Richwave Setting
		RTC676x_Init();	
		
		//Transmit(Video Data)
		if(ubKNL_GetAdjBufEnable())
			ubTemp = BUF_NUM_VDO_PACKETIZE_ADJ;
		else
			ubTemp = BUF_NUM_VDO_PACKETIZE;
		osMessageQDef(KNL_VDOPACKETIZEPROCESS, ubTemp, KNL_PROCESS);							//Queue Number = BS Buf Number		
		KNL_VdoPacketizeQue = osMessageCreate(osMessageQ(KNL_VDOPACKETIZEPROCESS), NULL);		
		osThreadDef(KNLVdoPacketizeProcThread, KNL_VdoPacketizeProcThread, osPriorityBelowNormal, 1, 8192);	
		osThreadCreate(osThread(KNLVdoPacketizeProcThread), NULL);
		
		//Transmit(Audio Data)
		osMessageQDef(KNL_ADOPACKETIZEPROCESS, BUF_NUM_ADO_PACKETIZE, KNL_PROCESS);							//Queue Number = BS Buf Number
		KNL_AdoPacketizeQue = osMessageCreate(osMessageQ(KNL_ADOPACKETIZEPROCESS), NULL);		
		osThreadDef(KNLAdoPacketizeProcThread, KNL_AdoPacketizeProcThread, osPriorityBelowNormal, 1, 8192);	
		osThreadCreate(osThread(KNLAdoPacketizeProcThread), NULL);		

		//Receive(Cam1/2/3/4)
	#if defined(OP_AP)
		for(i=0; i<4; i++)
	#else
		for(i=0; i<1; i++)
	#endif
		{
			KNL_PacketQue[i].Def.queue_sz = BUF_NUM_PACKET;
			KNL_PacketQue[i].Def.item_sz  = sizeof(KNL_PROCESS);
			KNL_PacketQue[i].Id = osMessageCreate(&KNL_PacketQue[i].Def, NULL);
			
			tKNL_PacketThRdySem[i].Def.dummy = 0;
			tKNL_PacketThRdySem[i].Id = osSemaphoreCreate(&tKNL_PacketThRdySem[i].Def, 1);
		}
	
		osThreadDef(KNLPacket0ProcThread, KNL_Packet0ProcThread, THREAD_PRIO_RW_PACKET_HANDLER, 1, THREAD_STACK_RW_PACKET_HANDLER);		
		osThreadCreate(osThread(KNLPacket0ProcThread), NULL);
	#if OP_AP
		osThreadDef(KNLPacket1ProcThread, KNL_Packet1ProcThread, THREAD_PRIO_RW_PACKET_HANDLER, 1, THREAD_STACK_RW_PACKET_HANDLER);
		osThreadCreate(osThread(KNLPacket1ProcThread), NULL);
		osThreadDef(KNLPacket2ProcThread, KNL_Packet2ProcThread, THREAD_PRIO_RW_PACKET_HANDLER, 1, THREAD_STACK_RW_PACKET_HANDLER);
		osThreadCreate(osThread(KNLPacket2ProcThread), NULL);
		osThreadDef(KNLPacket3ProcThread, KNL_Packet3ProcThread, THREAD_PRIO_RW_PACKET_HANDLER, 1, THREAD_STACK_RW_PACKET_HANDLER);
		osThreadCreate(osThread(KNLPacket3ProcThread), NULL);
	#endif		

		//Wait Packet0/1/2/3 Thread ready
	#if defined(OP_AP)
		for(i=0; i<4; i++)
	#else
		for(i=0; i<1; i++)
	#endif
		{
			osSemaphoreWait(tKNL_PacketThRdySem[i].Id, osWaitForever);
		}
		
	#if defined(OP_AP)	
		osThreadDef(RTC676xVdoThread, RTC676x_VdoThread, THREAD_PRIO_RW_RX_HANDLER, 1, THREAD_STACK_RW_RX_HANDLER);		
		osThreadCreate(osThread(RTC676xVdoThread), NULL);
	#endif
		
		osThreadDef(RTC676xAdoThread, RTC676x_AdoThread, THREAD_PRIO_RW_RX_HANDLER, 1, THREAD_STACK_RW_RX_HANDLER);		
		osThreadCreate(osThread(RTC676xAdoThread), NULL);

		osThreadDef(RTC676xCmdThread, RTC676x_CmdThread, THREAD_PRIO_RW_RX_HANDLER, 1, THREAD_STACK_RW_RX_HANDLER);
		osThreadCreate(osThread(RTC676xCmdThread), NULL);

		#if TRXBW_RPT_EN
		if(tTWC_RegTransCbFunc(TWC_TRXBW_RPT, KNL_TwcResult, KNL_TrxBwRptFunc) == TWC_FAIL)
		{
			printd(DBG_ErrorLvl, "Register Sync TEST TWC Fail !!!\r\n");
		}
		#endif
		
		KNL_RfModeSwInit();
	#endif

		ubKNL_InitBBFlg = 1;
	}
	else
	{		
	#if (APP_UVC_CAM_ENABLE == 1)
		//printf("BB_DummyInit\r\n");
		BB_DummyInit();
	#endif
	}	
	
	ubNodeExist = ubKNL_ChkExistNode(KNL_NODE_H264_ENC)|ubKNL_ChkExistNode(KNL_NODE_H264_DEC)|ubKNL_ChkExistNode(KNL_NODE_IMG_MERGE_BUF)|ubKNL_ChkExistNode(KNL_NODE_IMG_MERGE_H);
	if(ubNodeExist && (ubKNL_InitImgFlg==0))
	{
		#ifdef OP_STA
            #if (defined(VDO_SUBPATH_ENABLE)&&(VDO_SUBPATH_ENABLE!=0))
            GLB->H264_RATE = 1;
    		GLB->IMG_RATE  = 3;
            #else
   		    uint16_t uwHSize = 0, uwVSize = 0;
    		uwHSize = VDO_MAIN_H_SIZE(VDO_DISP_TYPE);
    		uwVSize = VDO_MAIN_V_SIZE(VDO_DISP_TYPE);
    		SetH264Rate(uwHSize, uwVSize, VDO_FRAME_RATE(uwHSize, uwVSize));
			
			if(ubKNL_GetSenThenEncEnable())
			{		
				GLB->H264_RATE = 1;	
				GLB->IMG_RATE  = 3;
			}
		
            #endif
		#endif

		#ifdef OP_AP
		GLB->H264_RATE = 1;    //1//RX-16MB 6
		GLB->IMG_RATE  = 3;    //3//RX-16MB 15
		#endif

		IMG_Init();
		H264_Reset();

		IMG_SetCodecFinishCbFunc(KNL_ImgMonitorFunc);
//		osThreadDef(ImgMonitThread, KNL_ImgMonitThread, THREAD_PRIO_IMG_MONIT, 1, THREAD_STACK_IMG_MONIT);
//		osThreadCreate(osThread(ImgMonitThread), NULL);

		ubKNL_InitImgFlg = 1;
	}	
	
#if (defined(OP_STA) || (defined(OP_AP) && defined(BSP_DVR_SDK)))	
	RC_VariableInit();	
	//For Rate-Control
	for(i=0;i<4;i++)
	{
		if(ubRC_GetFlg(i))
		{
			RC_Init(i);
		}
	}
	//Rate-Control for IQ-Tuning
	RC_EngModeSet(0,KNL_RC_BITRATE,KNL_RC_FPS);	//CodecIdx:0,Target BitRate:150KB,FPS:15
#endif	
	
	//For H264 Encode
	//=======================================================================
	ubKNL_InitH264EncFlg[0] = 0;
	ubKNL_InitH264EncFlg[1] = 0;
	ubKNL_InitH264EncFlg[2] = 0;
	ubKNL_InitH264EncFlg[3] = 0;
	
	//Main
	for(i=0;i<4;i++)
	{
		if(ubKNL_ExistNode(KNL_SRC_1_MAIN+i,KNL_NODE_H264_ENC))
		{
			tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_MAIN+i,KNL_NODE_H264_ENC);
			if(tNodeInfo.ubCodecIdx == ENCODE_0)
			{
				KNL_ImgEncInit(ENCODE_0,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
				ubKNL_InitH264EncFlg[0] = 1;
			}
			else if(tNodeInfo.ubCodecIdx == ENCODE_1)
			{
				KNL_ImgEncInit(ENCODE_1,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
				ubKNL_InitH264EncFlg[1] = 1;
			}
			else if(tNodeInfo.ubCodecIdx == ENCODE_2)
			{
				KNL_ImgEncInit(ENCODE_2,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
				ubKNL_InitH264EncFlg[2] = 1;
			}
			else if(tNodeInfo.ubCodecIdx == ENCODE_3)
			{
				KNL_ImgEncInit(ENCODE_3,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
				ubKNL_InitH264EncFlg[3] = 1;
			}			
		}
	}
	//Aux
	for(i=0;i<4;i++)
	{
		if(ubKNL_ExistNode(KNL_SRC_1_AUX+i,KNL_NODE_H264_ENC))
		{
			tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_AUX+i,KNL_NODE_H264_ENC);
			if(tNodeInfo.ubCodecIdx == ENCODE_0)
			{
				KNL_ImgEncInit(ENCODE_0,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
				ubKNL_InitH264EncFlg[0] = 1;
			}
			else if(tNodeInfo.ubCodecIdx == ENCODE_1)
			{
				KNL_ImgEncInit(ENCODE_1,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
				ubKNL_InitH264EncFlg[1] = 1;
			}
			else if(tNodeInfo.ubCodecIdx == ENCODE_2)
			{
				KNL_ImgEncInit(ENCODE_2,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
				ubKNL_InitH264EncFlg[2] = 1;
			}
			else if(tNodeInfo.ubCodecIdx == ENCODE_3)
			{
				KNL_ImgEncInit(ENCODE_3,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
				ubKNL_InitH264EncFlg[3] = 1;
			}			
		}
	}	
	//Sub
	for(i=0;i<4;i++)
	{
		if(ubKNL_ExistNode(KNL_SRC_1_SUB+i,KNL_NODE_H264_ENC))
		{
			tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_SUB+i,KNL_NODE_H264_ENC);
			if(tNodeInfo.ubCodecIdx == ENCODE_0)
			{
				KNL_ImgEncInit(ENCODE_0,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
				ubKNL_InitH264EncFlg[0] = 1;
			}
			else if(tNodeInfo.ubCodecIdx == ENCODE_1)
			{
				KNL_ImgEncInit(ENCODE_1,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
				ubKNL_InitH264EncFlg[1] = 1;
			}
			else if(tNodeInfo.ubCodecIdx == ENCODE_2)
			{
				KNL_ImgEncInit(ENCODE_2,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
				ubKNL_InitH264EncFlg[2] = 1;
			}
			else if(tNodeInfo.ubCodecIdx == ENCODE_3)
			{
				KNL_ImgEncInit(ENCODE_3,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
				ubKNL_InitH264EncFlg[3] = 1;
			}			
		}
	}	

#if (defined(OP_AP) && defined(BSP_DVR_SDK))
	if(ubKNL_ExistNode(KNL_SRC_STORAGE_LOCAL,KNL_NODE_H264_ENC))
	{
		tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_STORAGE_LOCAL,KNL_NODE_H264_ENC);
		if(tNodeInfo.ubCodecIdx == ENCODE_0)
		{
			KNL_ImgEncInit(ENCODE_0,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
			ubKNL_InitH264EncFlg[0] = 1;
		}
		else if(tNodeInfo.ubCodecIdx == ENCODE_1)
		{
			KNL_ImgEncInit(ENCODE_1,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
			ubKNL_InitH264EncFlg[1] = 1;
		}
		else if(tNodeInfo.ubCodecIdx == ENCODE_2)
		{
			KNL_ImgEncInit(ENCODE_2,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
			ubKNL_InitH264EncFlg[2] = 1;
		}
		else if(tNodeInfo.ubCodecIdx == ENCODE_3)
		{
			KNL_ImgEncInit(ENCODE_3,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
			ubKNL_InitH264EncFlg[3] = 1;
		}
	}
#endif	
	
	//For H264 Decode
	//=======================================================================
	ubKNL_InitH264DecFlg[0] = 0;
	ubKNL_InitH264DecFlg[1] = 0;
	ubKNL_InitH264DecFlg[2] = 0;
	ubKNL_InitH264DecFlg[3] = 0;
	
	//Main
	for(i=0;i<4;i++)
	{
		if(ubKNL_ExistNode(KNL_SRC_1_MAIN+i,KNL_NODE_H264_DEC))
		{
			tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_MAIN+i,KNL_NODE_H264_DEC);
			if(tNodeInfo.ubCodecIdx == DECODE_0)
			{
				KNL_ImgDecInit(DECODE_0,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
				ubKNL_InitH264DecFlg[0] = 1;
			}
			else if(tNodeInfo.ubCodecIdx == DECODE_1)
			{
				KNL_ImgDecInit(DECODE_1,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
				ubKNL_InitH264DecFlg[1] = 1;
			}
			else if(tNodeInfo.ubCodecIdx == DECODE_2)
			{
				KNL_ImgDecInit(DECODE_2,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
				ubKNL_InitH264DecFlg[2] = 1;
			}
			else if(tNodeInfo.ubCodecIdx == DECODE_3)
			{
				KNL_ImgDecInit(DECODE_3,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
				ubKNL_InitH264DecFlg[3] = 1;
			}
		}
	}
	//Aux
	for(i=0;i<4;i++)
	{
		if(ubKNL_ExistNode(KNL_SRC_1_AUX+i,KNL_NODE_H264_DEC))
		{
			tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_AUX+i,KNL_NODE_H264_DEC);
			if(tNodeInfo.ubCodecIdx == DECODE_0)
			{
				KNL_ImgDecInit(DECODE_0,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
				ubKNL_InitH264DecFlg[0] = 1;
			}
			else if(tNodeInfo.ubCodecIdx == DECODE_1)
			{
				KNL_ImgDecInit(DECODE_1,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
				ubKNL_InitH264DecFlg[1] = 1;
			}
			else if(tNodeInfo.ubCodecIdx == DECODE_2)
			{
				KNL_ImgDecInit(DECODE_2,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
				ubKNL_InitH264DecFlg[2] = 1;
			}
			else if(tNodeInfo.ubCodecIdx == DECODE_3)
			{
				KNL_ImgDecInit(DECODE_3,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
				ubKNL_InitH264DecFlg[3] = 1;
			}
		}
	}
	//Sub
	for(i=0;i<4;i++)
	{
		if(ubKNL_ExistNode(KNL_SRC_1_SUB+i,KNL_NODE_H264_DEC))
		{
			tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_SUB+i,KNL_NODE_H264_DEC);
			if(tNodeInfo.ubCodecIdx == DECODE_0)
			{
				KNL_ImgDecInit(DECODE_0,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
				ubKNL_InitH264DecFlg[0] = 1;
			}
			else if(tNodeInfo.ubCodecIdx == DECODE_1)
			{
				KNL_ImgDecInit(DECODE_1,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
				ubKNL_InitH264DecFlg[1] = 1;
			}
			else if(tNodeInfo.ubCodecIdx == DECODE_2)
			{
				KNL_ImgDecInit(DECODE_2,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
				ubKNL_InitH264DecFlg[2] = 1;
			}
			else if(tNodeInfo.ubCodecIdx == DECODE_3)
			{
				KNL_ImgDecInit(DECODE_3,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
				ubKNL_InitH264DecFlg[3] = 1;
			}
		}
	}	

#if !defined(BSP_DVR_SDK)
	//For LCD
	KNL_LcdBlockSetup();
#endif

	//For Audio
	KNL_AudioBlockSetup();

#if !defined(BSP_DVR_SDK)
	//For JPEG Codec
	//=======================================================================
	if(((APP_PHOTOGRAPH_FUNC_ENABLE || ubKNL_ChkExistNode(KNL_NODE_JPG_ENC) || ubKNL_ChkExistNode(KNL_NODE_JPG_DEC1) || ubKNL_ChkExistNode(KNL_NODE_JPG_DEC2)) ||
	    ((KNL_DISP_H == tKNL_GetDispType()) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0))) && (ubKNL_InitJpegFlg == 0))
	{
		JPEG_Init();
		KNL_SetJpegQp(32);

		osSemaphoreDef(JPEG_CodecSem);
		JPEG_CodecSem = osSemaphoreCreate(osSemaphore(JPEG_CodecSem), 1);
		
		osSemaphoreDef(KnlJpegWaitSem);
		tKNL_JpegSigProc.osWaitSem = osSemaphoreCreate(osSemaphore(KnlJpegWaitSem), 1);
		tKNL_JpegSigProc.ubProcFlag = FALSE;

        osMessageQDef(KNL_JPGMONITOR, KNL_JPEG_QUEUE_NUM, JPEG_CODEC_INFO_t);
        KNL_QueueJpegMonit = osMessageCreate(osMessageQ(KNL_JPGMONITOR), NULL);

        osThreadDef(JpegMonitThread, KNL_JpegMonitThread, THREAD_PRIO_JPEG_MONIT, 1, THREAD_STACK_JPEG_MONIT);
        osThreadCreate(osThread(JpegMonitThread), NULL);

		ubKNL_InitJpegFlg = 1;
	}
#if ((USBD_UVC_MJ_FMT == USBD_UVC_FMT) && USBD_ENABLE)
	#ifdef OP_AP
	else if((DISPLAY_1T1R == DISPLAY_MODE) && ((USBD_UVC_MODE == tUSBD_GetClassMode()) || (TRUE == ubUSBD_ChkCompUvcClass())))
	#else
	else if((KNL_TUNINGMODE_OFF == KNL_GetTuningToolMode()) && ((USBD_UVC_MODE == tUSBD_GetClassMode()) || (TRUE == ubUSBD_ChkCompUvcClass())))
	#endif
		JPEG_Init();
#endif
	else
		JPEG_FuncDisable;
	KNL_UpdateJpgHeader(1280,720);
#endif


	//For REC
	KNL_RecordingBlockSetup();

#if (defined(S2019A) || (defined(OP_AP) && defined(sWIFIBDG)))
    //! For SPRF
    #if ((KNL_USBH_FUNC_ENABLE) && (defined(KNL_USBH_SPRF)))
		#ifdef sPRF_PWR_RST
		sPRF_PWR_RST;
		#endif
		#ifdef OP_STA
		sPRF_Init(sPRF_TX_IF);
		#endif
		#ifdef OP_AP
		#ifdef sWIFIBDG
		sPRF_EnApBridgeMode(sPRF_BDGONLY_EN, KNL_EnStaDtDrvMode);
		#endif
		sPRF_Init(sPRF_RX_IF);
		#endif
		#ifdef S2019A
		sPRF_SetVdoGop(uwVdoGop);
		tsPRF_CbFunc.pvPwrCtrl  = KNL_sPRFDevPwrCtrl;
		tsPRF_CbFunc.pvRstGop   = KNL_ResetVdoGop;
		tsPRF_CbFunc.pvLinkRpt  = KNL_sPRFLinkReportFunc;
		tsPRF_CbFunc.pvGetRxBuf = ulKNL_GetSPRFRxBufAddr;
		tsPRF_CbFunc.pvRxProc   = ubKNL_sPRFRxProcess;
		tsPRF_CbFunc.pvGetTrxBufNum = ubKNL_GetSPRFDataBufNum;
		tsPRF_CbFunc.pvStpTxProc	= KNL_StopSPRFTxProcess;
		#else
		tsPRF_CbFunc.pvPwrCtrl  = NULL;
		tsPRF_CbFunc.pvRstGop   = NULL;
		tsPRF_CbFunc.pvLinkRpt  = KNL_sPRFLinkReportFunc;
		tsPRF_CbFunc.pvGetRxBuf = NULL;
		tsPRF_CbFunc.pvRxProc   = NULL;
		tsPRF_CbFunc.pvGetTrxBufNum = NULL;
		tsPRF_CbFunc.pvStpTxProc	= NULL;
		#endif
		tsPRF_CbFunc.pvDrvMdStp     = NULL;
		tsPRF_CbFunc.pvSwDrvProc	= NULL;
		#if (defined(RVCS_APP) || defined(sWIFIBDG))
		tsPRF_CbFunc.pvSwDrvProc	= KNL_DrvModeSwProc;
		#endif
		sPRF_RegCbFunc(tsPRF_CbFunc);
		for(ubSPRF_InitCnt = 0; ubSPRF_InitCnt < 100; ubSPRF_InitCnt++)
		{
			osDelay(20);
			ubSPRF_InitSts = ulsPRF_GetInitSts();
			if(SUCCESS == ubSPRF_InitSts)
				break;
		}
		#ifdef S2019A
		osMessageQDef(sPRFFrmQue, 150, uint8_t);
		osKNL_sPrfFrmQue = osMessageCreate(osMessageQ(sPRFFrmQue), NULL);
		osThreadDef(sPRFMonitorThd, KNL_sPRFMonitorThread, osPriorityNormal, 1, 512);
		osThreadCreate(osThread(sPRFMonitorThd), NULL);
		#endif
    #else
    	USBH_FuncDisable;	
    #endif
#else
    #if ((KNL_USBH_FUNC_ENABLE) && (KNL_USBH_UVCCLASS_ENABLE) && (!defined(KNL_USBH_SPRF)))    
	
	#if (APP_DUAL_HOST_ENABLE == 1)
        FWU_Disable();     
		USBH_SetFrameInfoCbFunc(KNL_GetFramFromUsbHost);
		USBH_SetUvcRdyInfoCbFunc(KNL_UvcRdyEvent);
		USBH_SetUvcErrInfoCbFunc(KNL_UvcErrEvent);
		USBH_SetUvcChkFlgCbFunc(KNL_SetUvcChkFlg);
		USBH_SetCxToInfoCbFunc(KNL_CxTimeOutEvent);
	#endif
	
		USBH_Init(ulBUF_GetBlkBufAddr(0,BUF_USBH_IP));
    #else
    	USBH_FuncDisable;	
    #endif	
		
//	#if OP_STA			
//		APPXU_GetDataFromUsbCbFunc(USB_HOST,APPXU_GetDataFromUsbHost);
//	#endif
//	#if OP_AP
//		APPXU_GetDataFromUsbCbFunc(USB_UVC_DEVICE1,APPXU_GetDataFromUsbDevice1);
//		APPXU_GetDataFromUsbCbFunc(USB_UVC_DEVICE2,APPXU_GetDataFromUsbDevice2);
//	#endif	
	
	#if (APP_DUAL_HOST_ENABLE == 1)	
	
		#if defined(POWER_UVC1_IO)			
			printf("UVC1 -> Power On\r\n");
			POWER_UVC1_IO = 1;	
			POWER_UVC1_IO_ENABLE = 1;
		#endif

		#if defined(POWER_UVC2_IO)			
			printf("UVC2 -> Power On\r\n");
			POWER_UVC2_IO = 1;	
			POWER_UVC2_IO_ENABLE = 1;			
		#endif
	#endif	
#endif
    
}

#else	//! #ifndef S2019A

void KNL_BlockInit(void)
{
	KNL_NODE_INFO tNodeInfo;
	uint8_t ubNodeExist, i;
	uint8_t ubSPRF_InitSts = UNSUCCESS;
	uint8_t ubSPRF_InitCnt = 0;
	H264_ENCODE_INDEX tEncIdx[4] = {ENCODE_0, ENCODE_1, ENCODE_2, ENCODE_3};
	H264_DECODE_INDEX tDecIdx[4] = {DECODE_0, DECODE_1, DECODE_2, DECODE_3};
	uint16_t uwVdoGop = KNL_TX_GOP;
	sPRF_CbFunc_t tsPRF_CbFunc;

	KNL_1MSCounterInit();
	
	//! For Sensor
	if(ubKNL_ChkExistNode(KNL_NODE_SEN))
	{
#ifdef OP_STA
		uint8_t ubSrcNum = KNL_SRC_NONE;
        SEN_RegisterEventQueue(KNL_VdoInProcQueue);
        SEN_RegisterEventNode(KNL_NODE_SEN_YUV_BUF);
        SEN_SetIspFinishCbFunc(KNL_ImgStabNotifyFunc);
		SEN_SetAhdCamResCbFunc(KNL_AhdCamInSetResFunc);
		SEN_SetAhdCamBufCbFunc(KNL_AhdCamInSetBufFunc);
        IQ_IqBinAddrCbFunc(ulSEN_IQBinAddr);
		SEN_RegIsrProcCbFunc(SEN_VSYNC_PROC,  ulKNL_SenVsyncIsrProc);
		SEN_RegIsrProcCbFunc(SEN_ISPOUT_PROC, ulKNL_IspOutIsrProc);
		if(ubKNL_GetIspEnable())
			SEN_LoadIQData();

        if(ubSEN_InitProcess())
        {
            ubSrcNum = ubSEN_GetPathSrc(SENSOR_PATH1);
            if((ubKNL_GetRole() <= KNL_STA4) && (KNL_SRC_NONE != ubSrcNum))
                KNL_SenStart(ubSrcNum);
#if (defined(VDO_SUBPATH_ENABLE)&&(VDO_SUBPATH_ENABLE!=0))			
            ubSrcNum = ubSEN_GetPathSrc(SENSOR_PATH2);
            if(KNL_SRC_NONE != ubSrcNum)
                KNL_SenStart(ubSrcNum);
#endif            
        }
#endif
	}
	else
		ISP_FuncDisable;

	//! For IMG
	ubNodeExist = ubKNL_ChkExistNode(KNL_NODE_H264_ENC)|ubKNL_ChkExistNode(KNL_NODE_H264_DEC)|ubKNL_ChkExistNode(KNL_NODE_IMG_MERGE_BUF)|ubKNL_ChkExistNode(KNL_NODE_IMG_MERGE_H);
	if(ubNodeExist && (!ubKNL_InitImgFlg))
	{
		#ifdef OP_STA
            #if (defined(VDO_SUBPATH_ENABLE)&&(VDO_SUBPATH_ENABLE!=0))
            GLB->H264_RATE = 1;
    		GLB->IMG_RATE  = 3;
            #else        
    		uint16_t uwHSize = 0, uwVSize = 0;
			uint8_t ubFps = 15;
    		uwHSize = VDO_MAIN_H_SIZE(VDO_DISP_TYPE);
    		uwVSize = VDO_MAIN_V_SIZE(VDO_DISP_TYPE);
			ubFps   = VDO_FRAME_RATE(uwHSize, uwVSize);
			#ifdef RVCS_APP
			ubFps = VDO_FRC_FPS;
			#endif
			if((HD_WIDTH == uwHSize) && (HD_HEIGHT == uwVSize) && (ubFps > 15))
				ubFps = 31;
    		SetH264Rate(uwHSize, uwVSize, ubFps);
            #endif	//! End of #if (defined(VDO_SUBPATH_ENABLE)&&(VDO_SUBPATH_ENABLE!=0))
		#endif
		#ifdef OP_AP
		GLB->H264_RATE = 1;
		GLB->IMG_RATE  = 3;
		#endif
		IMG_Init();
		#if (defined(OP_AP) && (APP_USBD_COMPOSITE_MODE & USBD_MULTI_UVC))
		if((USBD_UVC_MODE == tUSBD_GetClassMode()) || (TRUE == ubUSBD_ChkCompUvcClass()))
		IMG_SetPriority(osPriorityAboveNormal);
		#endif
		H264_Reset();
		IMG_SetCodecFinishCbFunc(KNL_ImgMonitorFunc);
		ubKNL_InitImgFlg = 1;
	}

	//! RC
#if OP_STA
	for(i = 0; i < 4; i++)
	{
		if(ubRC_GetFlg(i))
			RC_Init(i);
	}
	//Rate-Control for IQ-Tuning
	RC_EngModeSet(0, KNL_RC_BITRATE, KNL_RC_FPS);	//! CodecIdx:0,Target BitRate:150KB,FPS:15
#endif

	//! GOP
	#if APP_REC_FUNC_ENABLE
	uwVdoGop = KNL_TX_RECGOP;
	#endif
	KNL_SetVdoGop((uint32_t)uwVdoGop);

	//! For H264 Encoder
	for(i = 0; i < 4; i++)
		ubKNL_InitH264EncFlg[i] = 0;
	//Main
	for(i = 0; i < 4; i++)
	{
		if(ubKNL_ExistNode((KNL_SRC_1_MAIN + i), KNL_NODE_H264_ENC))
		{
			tNodeInfo = tKNL_GetNodeInfo((KNL_SRC_1_MAIN + i), KNL_NODE_H264_ENC);
			if(tNodeInfo.ubCodecIdx > ENCODE_3)
			{
				printd(DBG_ErrorLvl, "[%d]Encode Err @%s\n", i, __func__);
				continue;
			}
			KNL_ImgEncInit(tEncIdx[tNodeInfo.ubCodecIdx], tNodeInfo.uwVdoH, tNodeInfo.uwVdoV);
			ubKNL_InitH264EncFlg[tNodeInfo.ubCodecIdx] = 1;
		}
	}
	//Aux
	for(i = 0; i < 4; i++)
	{
		if(ubKNL_ExistNode((KNL_SRC_1_AUX + i), KNL_NODE_H264_ENC))
		{
			tNodeInfo = tKNL_GetNodeInfo((KNL_SRC_1_AUX + i), KNL_NODE_H264_ENC);
			if(tNodeInfo.ubCodecIdx > ENCODE_3)
			{
				printd(DBG_ErrorLvl, "[%d]Encode Err @%s\n", i, __func__);
				continue;
			}
			KNL_ImgEncInit(tEncIdx[tNodeInfo.ubCodecIdx], tNodeInfo.uwVdoH, tNodeInfo.uwVdoV);
			ubKNL_InitH264EncFlg[tNodeInfo.ubCodecIdx] = 1;
		}
	}
	//Sub
	for(i = 0; i < 4; i++)
	{
		if(ubKNL_ExistNode((KNL_SRC_1_SUB + i), KNL_NODE_H264_ENC))
		{
			tNodeInfo = tKNL_GetNodeInfo((KNL_SRC_1_SUB + i), KNL_NODE_H264_ENC);
			if(tNodeInfo.ubCodecIdx > ENCODE_3)
			{
				printd(DBG_ErrorLvl, "[%d]Encode Err @%s\n", i, __func__);
				continue;
			}
			KNL_ImgEncInit(tEncIdx[tNodeInfo.ubCodecIdx], tNodeInfo.uwVdoH, tNodeInfo.uwVdoV);
			ubKNL_InitH264EncFlg[tNodeInfo.ubCodecIdx] = 1;
		}
	}

	//! For H264 Decoder
	for(i = 0; i < 4; i++)
		ubKNL_InitH264DecFlg[i] = 0;
	//Main
	for(i = 0; i < 4; i++)
	{
		if(ubKNL_ExistNode((KNL_SRC_1_MAIN + i), KNL_NODE_H264_DEC))
		{
			tNodeInfo = tKNL_GetNodeInfo((KNL_SRC_1_MAIN + i), KNL_NODE_H264_DEC);
			if(tNodeInfo.ubCodecIdx > DECODE_3)
			{
				printd(DBG_ErrorLvl, "[%d]Decode Err @%s\n", i, __func__);
				continue;
			}
			KNL_ImgDecInit(tDecIdx[tNodeInfo.ubCodecIdx], tNodeInfo.uwVdoH, tNodeInfo.uwVdoV);
			ubKNL_InitH264DecFlg[tNodeInfo.ubCodecIdx] = 1;
		}
	}
	//Aux
	for(i = 0; i < 4; i++)
	{
		if(ubKNL_ExistNode((KNL_SRC_1_AUX + i), KNL_NODE_H264_DEC))
		{
			tNodeInfo = tKNL_GetNodeInfo((KNL_SRC_1_AUX + i), KNL_NODE_H264_DEC);
			if(tNodeInfo.ubCodecIdx > DECODE_3)
			{
				printd(DBG_ErrorLvl, "[%d]Decode Err @%s\n", i, __func__);
				continue;
			}
			KNL_ImgDecInit(tDecIdx[tNodeInfo.ubCodecIdx], tNodeInfo.uwVdoH, tNodeInfo.uwVdoV);
			ubKNL_InitH264DecFlg[tNodeInfo.ubCodecIdx] = 1;
		}
	}
	//Sub
	for(i = 0; i < 4; i++)
	{
		if(ubKNL_ExistNode((KNL_SRC_1_SUB + i), KNL_NODE_H264_DEC))
		{
			tNodeInfo = tKNL_GetNodeInfo((KNL_SRC_1_SUB + i), KNL_NODE_H264_DEC);
			if(tNodeInfo.ubCodecIdx > DECODE_3)
			{
				printd(DBG_ErrorLvl, "[%d]Decode Err @%s\n", i, __func__);
				continue;
			}
			KNL_ImgDecInit(tDecIdx[tNodeInfo.ubCodecIdx], tNodeInfo.uwVdoH, tNodeInfo.uwVdoV);
			ubKNL_InitH264DecFlg[tNodeInfo.ubCodecIdx] = 1;
		}
	}

	//! For TRX
	ubNodeExist = ubKNL_ChkExistNode(KNL_NODE_COMM_TX_VDO)|ubKNL_ChkExistNode(KNL_NODE_COMM_RX_VDO)|ubKNL_ChkExistNode(KNL_NODE_COMM_TX_ADO)|ubKNL_ChkExistNode(KNL_NODE_COMM_RX_ADO);		
	if(ubNodeExist)
	{

		for(i = 0; i < 6; i++)
		{			
			if(!ubKNL_GetFixDisplayLocateEnable())
			{
				ubKNL_LinkStatus[i] = BB_LOST_LINK;
				ubKNL_RtLinkStatus[i] = BB_LOST_LINK;
			}
			else if((i == 0) || ( i == 3))	//CAM1 and CAM4
			{
				ubKNL_LinkStatus[i] = BB_LOST_LINK;
				ubKNL_RtLinkStatus[i] = BB_LOST_LINK;
			}
		}
		
		
		//Step(n+1)
		//=============================================================
		osMessageQDef(KNL_QUERXVDO, 60, RX_DON);
		KNL_QueRxVdo = osMessageCreate(osMessageQ(KNL_QUERXVDO), NULL);
		osMessageQDef(KNL_QUERXADO, 60, RX_DON);
		KNL_QueRxAdo = osMessageCreate(osMessageQ(KNL_QUERXADO), NULL);
		osMessageQDef(KNL_LINKRPT, 30, LINK_REPORT);
		KNL_LinkQ = osMessageCreate(osMessageQ(KNL_LINKRPT), NULL);	
		osThreadDef(CommLinkMonitThread, KNL_CommLinkMonitThread, THREAD_PRIO_LINK_MONIT, 1, THREAD_STACK_LINK_MONIT);
		osThreadCreate(osThread(CommLinkMonitThread), NULL);
		osThreadDef(CommLinkUpdateThread, KNL_CommLinkUpdateThread, THREAD_PRIO_LINK_UPDATE, 1, THREAD_STACK_LINK_UPDATE);
		osThreadCreate(osThread(CommLinkUpdateThread), NULL);
#ifdef OP_AP	
		osThreadDef(CommVdoRxMonitThread, KNL_CommVdoRxMonitThread, THREAD_PRIO_COMM_RX_VDO, 1, THREAD_STACK_COMM_RX_VDO);
		osThreadCreate(osThread(CommVdoRxMonitThread), NULL);
#endif
#if defined(OP_STA) && (APP_PLYBK_ENABLE == 1) && defined(RVCS_APP)
		osMessageQDef(KNL_DWNLDFILEIDX, 10, uint16_t);
		KNL_QueDwnldMode = osMessageCreate(osMessageQ(KNL_DWNLDFILEIDX), NULL);
		osThreadDef(PLYBK_DownloadThread, KNL_PlyBk_DownloadThread, osPriorityAboveNormal, 1, 4096);
		osThreadCreate(osThread(PLYBK_DownloadThread), NULL);
#endif

		osThreadDef(CommAdoRxMonitThread, KNL_CommAdoRxMonitThread, THREAD_PRIO_COMM_RX_ADO, 1, THREAD_STACK_COMM_RX_ADO);
		osThreadCreate(osThread(CommAdoRxMonitThread), NULL);
		
		if(tTWC_RegTransCbFunc(TWC_RESEND_I_EXT, KNL_TwcResult, KNL_ResendIActionExt) == TWC_FAIL)
		{
			printd(DBG_ErrorLvl, "Register RESEND_I(EXT) TWC Fail !!!\r\n");
		}
		if(tTWC_RegTransCbFunc(TWC_RESEND_I_INT, KNL_TwcResult, KNL_ResendIActionInt) == TWC_FAIL)
		{
			printd(DBG_ErrorLvl, "Register RESEND_I(INT) TWC Fail !!!\r\n");
		}
		if(tTWC_RegTransCbFunc(TWC_VDORES_SETTING, KNL_TwcResult, KNL_VdoResSetting) == TWC_FAIL)
		{
			printd(DBG_ErrorLvl, "Register Video Resolution TWC Fail !!!\r\n");
		}
#if APP_TIMESTAMP_FUNC_ENABLE
		if(tTWC_RegTransCbFunc(TWC_SYNC_TIMESTAMP, KNL_TwcResult, KNL_TimeStampSync) == TWC_FAIL)
		{
			printd(DBG_ErrorLvl, "Register Sync RTC TWC Fail !!!\r\n");
		}
#endif
	}

	//! For LCD
	KNL_LcdBlockSetup();

	//! For Audio
	KNL_AudioBlockSetup();

#if !defined(BSP_DVR_SDK)
	//! For JPEG Codec
	if(((APP_PHOTOGRAPH_FUNC_ENABLE || ubKNL_ChkExistNode(KNL_NODE_JPG_ENC) || ubKNL_ChkExistNode(KNL_NODE_JPG_DEC1) || ubKNL_ChkExistNode(KNL_NODE_JPG_DEC2)) ||
	    ((KNL_DISP_H == tKNL_GetDispType()) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0))) && (ubKNL_InitJpegFlg == 0))
	{
		JPEG_Init();
		KNL_SetJpegQp(32);
		osSemaphoreDef(JPEG_CodecSem);
		JPEG_CodecSem = osSemaphoreCreate(osSemaphore(JPEG_CodecSem), 1);
		osSemaphoreDef(KnlJpegWaitSem);
		tKNL_JpegSigProc.osWaitSem = osSemaphoreCreate(osSemaphore(KnlJpegWaitSem), 1);
		tKNL_JpegSigProc.ubProcFlag = FALSE;		
        osMessageQDef(KNL_JPGMONITOR, KNL_JPEG_QUEUE_NUM, JPEG_CODEC_INFO_t);
        KNL_QueueJpegMonit = osMessageCreate(osMessageQ(KNL_JPGMONITOR), NULL);
        osThreadDef(JpegMonitThread, KNL_JpegMonitThread, THREAD_PRIO_JPEG_MONIT, 1, THREAD_STACK_JPEG_MONIT);
        osThreadCreate(osThread(JpegMonitThread), NULL);
		ubKNL_InitJpegFlg = 1;
	}
#if ((USBD_UVC_MJ_FMT == USBD_UVC_FMT) && USBD_ENABLE)
	#ifdef OP_AP
	else if((DISPLAY_1T1R == DISPLAY_MODE) && ((USBD_UVC_MODE == tUSBD_GetClassMode()) || (TRUE == ubUSBD_ChkCompUvcClass())))
	#else
	else if((KNL_TUNINGMODE_OFF == KNL_GetTuningToolMode()) && ((USBD_UVC_MODE == tUSBD_GetClassMode()) || (TRUE == ubUSBD_ChkCompUvcClass())))
	#endif
		JPEG_Init();
#endif
	else
		JPEG_FuncDisable;
	KNL_UpdateJpgHeader(1280, 720);
	#if (defined(OP_AP) && (APP_USBD_COMPOSITE_MODE & USBD_MULTI_UAC))	
	//DDR_ImprovePriority(SYS_PERMODE6);
	#endif	
#endif	//! End of #if !defined(BSP_DVR_SDK)

	//! For SD
	KNL_SdBlockSetup();
	
	//! For FS
	KNL_FsBlockSetup();

	//! For Recording
	KNL_RecordingBlockSetup();
	
	//! For USBD
	KNL_UsbDevBlockSetup();

	//! For SPRF
#if ((KNL_USBH_FUNC_ENABLE) && (defined(KNL_USBH_SPRF)))
	#ifdef sPRF_PWR_RST
	sPRF_PWR_RST;
	#endif
	#ifdef RVCS_APP
	sPRF_EnStaDtMode(FALSE, KNL_EnStaDtDrvMode);
	#endif
	#ifdef OP_STA
	#ifdef RVCS_APP
	sPRF_ChkDefuDrvMode();
	#endif
	sPRF_Init(sPRF_TX_IF);
	#endif
	#ifdef OP_AP
	#ifdef RVCS_APP
	sPRF_EnApBridgeMode(FALSE, KNL_EnStaDtDrvMode);
	#endif
	sPRF_Init(sPRF_RX_IF);
	#endif
	sPRF_SetVdoGop(uwVdoGop);
	tsPRF_CbFunc.pvPwrCtrl  	= KNL_sPRFDevPwrCtrl;
	tsPRF_CbFunc.pvRstGop 		= KNL_ResetVdoGop;
	tsPRF_CbFunc.pvLinkRpt 		= KNL_sPRFLinkReportFunc;
	tsPRF_CbFunc.pvGetRxBuf 	= ulKNL_GetSPRFRxBufAddr;
	tsPRF_CbFunc.pvRxProc		= ubKNL_sPRFRxProcess;
	tsPRF_CbFunc.pvGetTrxBufNum = ubKNL_GetSPRFDataBufNum;
	tsPRF_CbFunc.pvStpTxProc	= KNL_StopSPRFTxProcess;
	tsPRF_CbFunc.pvDrvMdStp     = NULL;
	tsPRF_CbFunc.pvSwDrvProc	= NULL;
	#ifdef RVCS_APP
	tsPRF_CbFunc.pvDrvMdStp     = KNL_DrvMdSwSetup;
	tsPRF_CbFunc.pvSwDrvProc	= KNL_DrvModeSwProc;
	#endif
	sPRF_RegCbFunc(tsPRF_CbFunc);
	for(ubSPRF_InitCnt = 0; ubSPRF_InitCnt < 100; ubSPRF_InitCnt++)
	{
		osDelay(20);
		ubSPRF_InitSts = ulsPRF_GetInitSts();
		if(SUCCESS == ubSPRF_InitSts)
			break;
	}
	osMessageQDef(sPRFFrmQue, 150, uint8_t);
	osKNL_sPrfFrmQue = osMessageCreate(osMessageQ(sPRFFrmQue), NULL);
	osThreadDef(sPRFMonitorThd, KNL_sPRFMonitorThread, osPriorityNormal, 1, 512);
	osThreadCreate(osThread(sPRFMonitorThd), NULL);
#else
	USBH_FuncDisable;
#endif
}
#endif //! End of #ifndef S2019A

//------------------------------------------------------------------------------
void KNL_SetRole(uint8_t ubRole)
{
	tKNL_Info.ubRole = ubRole;
}

#if APP_REC_FUNC_ENABLE
uint32_t ulKNL_GetRECnPLYMemorySize(REC_MEM_MODE_SEL ubMemMode,KNL_RP_SRC_MODE eMode)
{
    uint32_t ulSize;
    if(ubMemMode == REC_MEM_MODE_COMMON)
    {
        if(eMode == KNL_RP_1FHD)            ulSize = REC_COM_1FHD_MEMSZ;
        else if(eMode == KNL_RP_2FHD)      ulSize = (REC_COM_1FHD_MEMSZ<<1);
        else if(eMode == KNL_RP_1SXGA)      ulSize = REC_COM_1SXGA_MEMSZ;
        else if(eMode == KNL_RP_1HD)        ulSize = REC_COM_1HD_MEMSZ;
        else if(eMode == KNL_RP_1XGA)       ulSize = REC_COM_1XGA_MEMSZ;
        else if(eMode == KNL_RP_1WSVGA)     ulSize = REC_COM_1WSVGA_MEMSZ;
        else if(eMode == KNL_RP_1SVGA)      ulSize = REC_COM_1SVGA_MEMSZ;
        else if(eMode == KNL_RP_1WVGA)      ulSize = REC_COM_1WVGA_MEMSZ;
        else if(eMode == KNL_RP_1VGA)       ulSize = REC_COM_1VGA_MEMSZ;
        else if(eMode == KNL_RP_1HD_1FHD)   ulSize = REC_COM_HD_FHD_MEMSZ;
        else if(eMode == KNL_RP_2HD)        ulSize = REC_COM_2HD_MEMSZ;
        else if(eMode == KNL_RP_4VGA)       ulSize = REC_COM_4VGA_MEMSZ;
        else if(eMode == KNL_RP_2XGA)       ulSize = (REC_COM_1XGA_MEMSZ<<1);
        else if(eMode == KNL_R_1FHD)       ulSize = REC_ONLY_1FHD_MEMSZ;
        else if(eMode == KNL_RP_1HD60FPS)   ulSize = REC_COM_1HD60FPS_MEMSZ;
        else if(eMode == KNL_RP_1VGA60FPS)  ulSize = REC_COM_1VGA60FPS_MEMSZ;
        else if(eMode == KNL_R_1HD60FPS)  ulSize = REC_ONLY_1HD60FPS_MEMSZ;   
        else ulSize = REC_4VGA_MEMSZ;                
    }
    else
    {
        if(eMode == KNL_RP_1FHD)            ulSize = REC_1FHD_MEMSZ;
        else if(eMode == KNL_RP_2FHD)      ulSize = (REC_1FHD_MEMSZ<<1);
        else if(eMode == KNL_RP_1SXGA)      ulSize = REC_1SXGA_MEMSZ;
        else if(eMode == KNL_RP_1HD)        ulSize = REC_1HD_MEMSZ;
        else if(eMode == KNL_RP_1XGA)       ulSize = REC_1XGA_MEMSZ;
        else if(eMode == KNL_RP_1WSVGA)     ulSize = REC_1WSVGA_MEMSZ;
        else if(eMode == KNL_RP_1SVGA)      ulSize = REC_1SVGA_MEMSZ;
        else if(eMode == KNL_RP_1WVGA)      ulSize = REC_1WVGA_MEMSZ;
        else if(eMode == KNL_RP_1VGA)       ulSize = REC_1VGA_MEMSZ;
        else if(eMode == KNL_RP_1HD_1FHD)   ulSize = REC_HD_FHD_MEMSZ;
        else if(eMode == KNL_RP_2HD)        ulSize = REC_2HD_MEMSZ;
        else if(eMode == KNL_RP_4VGA)       ulSize = REC_4VGA_MEMSZ;
        else if(eMode == KNL_RP_2XGA)       ulSize = (REC_1XGA_MEMSZ<<1);
        else if(eMode == KNL_R_1FHD)       ulSize = REC_ONLY_1FHD_MEMSZ;
        else if(eMode == KNL_RP_1HD60FPS)   ulSize = REC_1HD60FPS_MEMSZ;
        else if(eMode == KNL_RP_1VGA60FPS)  ulSize = REC_1VGA60FPS_MEMSZ;
        else if(eMode == KNL_R_1HD60FPS)  ulSize = REC_ONLY_1HD60FPS_MEMSZ; 
        else ulSize = REC_4VGA_MEMSZ;
    }
    return ulSize;
}
void KNL_RECnPLYCBFuncRegistered(void)
{
    REC_EXTFUNC_CTRL sRecExtFunc;
    REC_MEDIAFUNC_CALLBACK sRecMediaExtFunc;
#if ( OP_AP || ( OP_STA && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE ))
    PLY_AUDIO_EXTFUNC_TAB sPlyAdoFunc;
    PLY_TIME_EXTFUNC_TAB sPlyTimeFunc; 
    PLY_H264_EXTFUNC_TAB sPlyH264Func; 
    PLY_EVENT_EXTFUNC_TAB sPlyEventFunc; 
    PLY_MEDIAFUNC_CALLBACK sPlyMediaExtFunc;
#endif
    
    REC_SetLogLvl(REC_DEBUG_LV);
    PLY_SetLogLvl(PLY_DEBUG_LV);

    // REC----------------------------------------
    memset(&sRecExtFunc,0x0,sizeof(REC_EXTFUNC_CTRL));
    sRecExtFunc.ulAdoSkipFrameAdrGet = ulKNL_ADO_GetMemInitValueAdr;
    sRecExtFunc.ulAdoSkipFrameSizeGet = ulKNL_ADO_GetWifiPacketSize;
    sRecExtFunc.Time1msCntGet = KNL_TIMER_Get1ms;
    sRecExtFunc.EventRecOnceEnd = KNL_RecordOnceEnd_SDK;
    sRecExtFunc.KNL_GetPreviewType = ubKNL_GetPlayDispType;
    sRecExtFunc.KNL_GetAPPCfgDispMode = ubKNL_GetAPPCfgDispMode;
    sRecExtFunc.ubKNL_GetDispSrc = ubKNL_SearchSrcByDispLoc;
    sRecExtFunc.KNL_SearchLocationSrc = ubKNL_SearchSrcByDispLoc;
    sRecExtFunc.ubKNL_TwcSend = ubKNL_TwcSend;
    sRecExtFunc.KNL_RecFileCreate = KNL_RecFileCreate;
    sRecExtFunc.ResetH264IPCnt = KNL_ResetH264IPCnt;
    ubREC_ExternFuncInit(&sRecExtFunc);

    memset(&sRecMediaExtFunc,0x0,sizeof(REC_MEDIAFUNC_CALLBACK));
    sRecMediaExtFunc.MediaCreateFile = Media_CreateFile;
    sRecMediaExtFunc.ulMediaWriteInfoData = ulMedia_WriteInfoData;
    sRecMediaExtFunc.slMediaWriteOneFrame = slMedia_WriteOneFrame;
    sRecMediaExtFunc.ubMediaAudioFrameTypeGet = ubMedia_AudioFrameTypeGet;
    sRecMediaExtFunc.MediaClose = Media_Close;
    sRecMediaExtFunc.ulMediaAlignMoveLength = ulMedia_AlignMoveLength;
    sRecMediaExtFunc.uwMediaMovieLength = uwMedia_MovieLength;
    sRecMediaExtFunc.ulMediaGetStrMaxFrmCnt = ulMedia_GetStrMaxFrmCnt;
    sRecMediaExtFunc.MediaSetSourceType = Media_SetSourceType;
    sRecMediaExtFunc.MediaVdo1SetFormat = Media_Vdo1SetFormat;
    sRecMediaExtFunc.MediaAdoSetFormat = Media_AdoSetFormat;
    sRecMediaExtFunc.MediaConfigedSrcNum = Media_ConfigedSrcNum;
    sRecMediaExtFunc.ulMediaGetFixedMemorySize = ulMedia_GetFixedMemorySize;
    sRecMediaExtFunc.MediaSetRecMaxTime = Media_SetRecMaxTime;
    sRecMediaExtFunc.ulMediaGetSkipFrameSize = ulMedia_GetSkipFrameSize;
    sRecMediaExtFunc.ulMediaGet1MINHeadSize = ulMedia_Get1MINHeadSize;
    sRecMediaExtFunc.MediaClearUserDataSize = Media_ClearUserDataSize;
    sRecMediaExtFunc.MediaWriteUserData = Media_WriteUserData;
    ubREC_MediaExternFuncInit(&sRecMediaExtFunc);
#if ( OP_AP || ( OP_STA && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE ))
    // PLY----------------------------------------
    memset(&sPlyAdoFunc,0x0,sizeof(PLY_AUDIO_EXTFUNC_TAB));
	sPlyAdoFunc.ubAdoBuffChk = ubKNL_PLY_ADOBufChk;
    sPlyAdoFunc.AdoBufWrite = KNL_PLY_ADOBufWrite;
	sPlyAdoFunc.AdoMute = KNL_PLY_ADODacMute;
    ubPLY_AudioExtFuncInit(&sPlyAdoFunc);

    memset(&sPlyTimeFunc,0x0,sizeof(PLY_TIME_EXTFUNC_TAB));
    sPlyTimeFunc.Time1msCntGet = KNL_TIMER_Get1ms;
    sPlyTimeFunc.Time1sRTCGet = KNL_TIMER_Get1Sec;
    ubPLY_TimeExtFuncInit(&sPlyTimeFunc);
    
    memset(&sPlyH264Func,0x0,sizeof(PLY_H264_EXTFUNC_TAB));      
    sPlyH264Func.H264DecEntry = KNL_SdVideoPlayBack;
    ubPLY_H264ExtFuncInit(&sPlyH264Func);
    
    memset(&sPlyEventFunc,0x0,sizeof(PLY_EVENT_EXTFUNC_TAB));
    ubPLY_EventExtFuncInit(&sPlyEventFunc);
    
    memset(&sPlyEventFunc,0x0,sizeof(PLY_EVENT_EXTFUNC_TAB));
    sPlyEventFunc.EventTimeBarfresh = KNL_PlayTimeBarEvent_SDK;
    sPlyEventFunc.EventPlayOver = KNL_PlayOverEvent_SDK;
#if ( OP_STA && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE )
    sPlyEventFunc.ubEventTXBufUse = ubKNL_GetBufUse;
#else
    sPlyEventFunc.ubEventTXBufUse = NULL;
#endif
    ubPLY_EventExtFuncInit(&sPlyEventFunc);

    memset(&sPlyMediaExtFunc,0x0,sizeof(PLY_MEDIAFUNC_CALLBACK));
    sPlyMediaExtFunc.ulAVIHeadSize = sizeof(AVISTRUCT);
    sPlyMediaExtFunc.ulAVIChunkSize = sizeof(AVICHUNK);
    sPlyMediaExtFunc.ulAVIThumbnailSize = AVI_THUMBNAIL_SIZE;
    sPlyMediaExtFunc.ulMP4ThumbnailSize = MP4_THUMBNAIL_SIZE;
    
    sPlyMediaExtFunc.LoadAVIHeader = Media_LoadAviHeader;
    sPlyMediaExtFunc.ulParseVdoIFrmTBL = ulMedia_ParseVideoIFrameTable;
    sPlyMediaExtFunc.ulParse1stIFrmTBL = ulMedia_Parse1stIFrameInfo;
    sPlyMediaExtFunc.ulParseAdoFrmTBL = ulMedia_ParseAudioFrameTable;
    sPlyMediaExtFunc.ubGetRes = ubMedia_GetResolution;
    sPlyMediaExtFunc.ulGetMoviLen = ulMedia_GetMoviLength;
    sPlyMediaExtFunc.ulGetMoviFrmCnt = ulMedia_GetMoviFrmCnt;
    sPlyMediaExtFunc.ulGetScale = ulMedia_GetScale;
    sPlyMediaExtFunc.ulGetTotalVdoIFrm = ulMedia_GetTotalVideoIFrame;
    sPlyMediaExtFunc.ulGetAdoSampleRate = ulMedia_GetAdoSampleRate;
    sPlyMediaExtFunc.ubGetAdoCodec = ubMedia_GetAdoCodec;
    sPlyMediaExtFunc.ulGetAdoAvgBytesPerSec = ulMedia_GetAdoAvgBytesPerSec;
    sPlyMediaExtFunc.vGetHeadInfo = vMedia_GetHeadInfo;
    sPlyMediaExtFunc.ParseAdoFmt = Media_ParsingAudioFormat;
    sPlyMediaExtFunc.AssignStruct = Media_AssignmentStructure;
    sPlyMediaExtFunc.ulGetStreamTimeScale = ulMedia_GetStreamTimeScale;
    sPlyMediaExtFunc.ulParseMdatFrameInfo = ulMedia_ParseMdatFrameInfo;
    sPlyMediaExtFunc.ulGetVdoFrmSize = ulMedia_GetVideoFrameSize;
    sPlyMediaExtFunc.ulGetStreamDelayTime = ulMedia_GetStreamDelayTime;
    sPlyMediaExtFunc.ulJumpReload = ulMedia_JumpReload;
    ubPLY_MediaExternFuncInit(&sPlyMediaExtFunc);
#endif
}
#endif
//------------------------------------------------------------------------------
uint8_t ubKNL_GetRole(void)
{
	return tKNL_Info.ubRole;
}
//------------------------------------------------------------------------------
void KNL_SetOpMode(uint8_t ubOpMode)
{
	tKNL_Info.ubOpMode = ubOpMode;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_GetOpMode(void)
{
	return tKNL_Info.ubOpMode;
}
//------------------------------------------------------------------------------
void KNL_SetAuxInfoFunc(uint8_t ubEnable)
{
	tKNL_Info.ubAuxInfoFlg = ubEnable;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_GetAuxInfoFunc(void)
{	
	return tKNL_Info.ubAuxInfoFlg;
}

#if (defined(A7130) || defined(S2019A))
//------------------------------------------------------------------------------
uint32_t ulKNL_AddAuxInfo(KNL_PACKET_TYPE tPktType,uint8_t ubSrcNum,uint32_t ulAddr,uint32_t ulSize,uint32_t ulFrmIdx,uint32_t ulGop,uint8_t ubVdoGroupIdx,uint32_t ulTime)
{
#define KNL_AUX_INFO_LEN		(16 * 3)
#define KNL_INFO_FRMSEQ			(1)
#define KNL_INFO_RES			(2)
#define KNL_INFO_VGOP			(6)
#define KNL_INFO_GOP			(7)
#define KNL_INFO_FRMIDX			(11)
#define KNL_INFO_OPMODE			(15)
#define KNL_INFO_SRCNUM			(16)
#define KNL_INFO_TIMESTP_LSB	(20)	//17~20
#define KNL_INFO_TIMESTP_MSB	(24)	//21~24	
#define KNL_INFO_PADD			(25)	
#define KNL_INFO_HQCAP			(26)
#ifdef S2019A
#define KNL_INFO_TXSFRMTM		(32)	//27~30(31)	//! 32Bytes
#endif
#if (APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
#define KNL_INFO_FS_SZ			(34)
#define KNL_INFO_FS_PAD			(38)
#define KNL_INFO_FS_TP			(39)
#endif
#define KNL_INFO_ADOSIZE		(3)

#define KNL_INFO_AHD_CAM_TYPE	(44)//(40)
	
#define KNL_INFO_FRAME_SZ		(KNL_AUX_INFO_LEN-5)
	
//	uint8_t ubCrc8 = 0;
//	CRC_t tCRC2_Setup;
    uint32_t ulFrameSz=0;
    
	uint32_t ulTemp;
	uint32_t ulRtnSz;
	uint32_t i;
	uint32_t ulDmy0Time = 0;
//	uint32_t ulCrcCalSz;
	uint8_t ubVdoIdx = 0;
    uint8_t *pAuxAddr = NULL;
#if (APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
    uint32_t ulFsInfoSz=0;
    uint32_t ulFsInfoTp=0;
	uint32_t ulDmy1Time = 0;
#endif
	static uint8_t ubKNL_VdoFrameSeq[2] = {0, 0};
	static uint8_t ubKNL_AdoFrameSeq = 0;
	
	osSemaphoreWait(tKNL_AuxAccSem, osWaitForever);		
	//Case (%16) = 0
	//-------------------------------------------
	//|							 				|
	//| Original Size			 				|
	//|							 				|
	//-------------------------------------------
	//|TimeStamp (24)  			 				|
	//--------------------------------------------------
	//|SrcNum(1)|OpMode(1)|FrmIdx(4)|GOP(4)|VGOP(1)|(5)|
	//--------------------------------------------------

	if(!ubKNL_GetAuxInfoFunc())
	{
		osSemaphoreRelease(tKNL_AuxAccSem);
		return ulSize;
	}

	if(tPktType == KNL_VDO_PKT)
	{
		ulTemp = ulSize;
		if((ulTemp % 16) == 0)
		{
			ulRtnSz    = ulTemp + KNL_AUX_INFO_LEN;
//			ulCrcCalSz = ulTemp;
            ulFrameSz = ulTemp;
		}
		else
		{
			ulRtnSz    = ((ulTemp / 16) * 16) + 16 + KNL_AUX_INFO_LEN;
//			ulCrcCalSz = ((ulTemp / 16) * 16) + 16;
			//Padd 0 value
			ulDmy0Time = 16 - (ulTemp % 16);
			for(i = 0; i < ulDmy0Time; i++)
			{
				*((uint8_t *)(ulAddr + ulSize + i)) = 0;
			}
            ulFrameSz = ulRtnSz-KNL_AUX_INFO_LEN;
		}
#if (APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
        // Add fs info
#if (defined(A7130))        
        if(KNL_TxFsSort.ubTrgger && KNL_TxFsSort.ulSize != 0 && tKNL_GetFrameType(ulAddr) == KNL_P_FRAME && ubSrcNum <= KNL_SRC_4_MAIN)
#elif(defined(S2019A))
	  #if (E_RVCS_ALL_I_FRM == 1)
        if(KNL_TxFsSort.ubTrgger && KNL_TxFsSort.ulSize != 0 && tKNL_GetFrameType(ulAddr) == KNL_I_FRAME && ubSrcNum <= KNL_SRC_4_MAIN)
	  #else
        if(KNL_TxFsSort.ubTrgger && KNL_TxFsSort.ulSize != 0 && tKNL_GetFrameType(ulAddr) == KNL_P_FRAME && ubSrcNum <= KNL_SRC_4_MAIN)
	  #endif		
#endif
        {
            printf("Add TX FS Info, fsSrtSz:%d, frmSz:%d\n", KNL_TxFsSort.ulSize, ulFrameSz);
            if (KNL_TxFsSort.ubTrgger > 0)
	            KNL_TxFsSort.ubTrgger--;
            memcpy( (uint8_t *)(ulAddr+ulFrameSz), (uint8_t *)KNL_TxFsSort.ulAdr, KNL_TxFsSort.ulSize);
            ulFsInfoTp = KNL_TxFsSort.ubFSTp;
            ulTemp = KNL_TxFsSort.ulSize;
            if((ulTemp % 16) == 0)
            {
                ulRtnSz += ulTemp;
                ulFsInfoSz = ulTemp;
            }
            else
            {
                ulRtnSz += (((ulTemp / 16) * 16) + 16);
                ulDmy1Time = 16 - (ulTemp % 16);
                for(i = 0; i < ulDmy1Time; i++)
                {
                    *((uint8_t *)(ulAddr + ulFrameSz + ulTemp + i)) = 0;
                }
                ulFsInfoSz = (((ulTemp / 16) * 16) + 16);
            }
            KNL_TxFsSort.ulSize = 0;
        }
        pAuxAddr = (uint8_t *)(ulAddr + ulFrameSz + ulFsInfoSz);
        memset(pAuxAddr, 0, KNL_AUX_INFO_LEN);            
        if(ulFsInfoSz != 0)
        {
            printf("ulFsInfo = %d tp:%d %d infoSz:0x%x\n",ulRtnSz,ulFsInfoTp,ulDmy1Time,ulFsInfoSz);
            *((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_FS_TP))   = ulFsInfoTp;
            *((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_FS_PAD))  = ulDmy1Time;
    		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_FS_SZ+0))) = (uint8_t)((ulFsInfoSz & 0x000000FF)>>0);
    		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_FS_SZ+1))) = (uint8_t)((ulFsInfoSz & 0x0000FF00)>>8);
    		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_FS_SZ+2))) = (uint8_t)((ulFsInfoSz & 0x00FF0000)>>16);
    		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_FS_SZ+3))) = (uint8_t)((ulFsInfoSz & 0xFF000000)>>24);
        }
#else        
        pAuxAddr = (uint8_t *)(ulAddr + ulFrameSz);
        memset(pAuxAddr, 0, KNL_AUX_INFO_LEN);
#endif
	#ifdef S2019A
		*((uint32_t *)(ulAddr+ulRtnSz-KNL_INFO_TXSFRMTM)) = 0;
	#endif
		//CRC-Information
//		if(KNL_AUX_CRC_FUNC)
//		{
//			ulCrcCalSz = ulCrcCalSz;
//			tCRC2_Setup.CRC_INIT_VALUE = INIT_ALL_ZERO;
//			tCRC2_Setup.CRC_FINAL_XOR_VALUE = XOR_ALL_ZERO;
//			tCRC2_Setup.CRC_ORDER = 7;
//			ubCrc8 = (uint8_t)ulCRC2_Calc(tCRC2_Setup, CRC_P_8, ulAddr, ulCrcCalSz);
//			//printd(DBG_Debug3Lvl, "crc2:0x%x\r\n",ubCrc8);
//			//printd(DBG_Debug3Lvl, "ulCrcCalSz:0x%x\r\n",ulCrcCalSz);
//			
//			*((uint32_t *)(ulAddr+ulRtnSz-16-16-16)) = ulCrcCalSz;
//			*((uint32_t *)(ulAddr+ulRtnSz-16-16)) = (uint32_t)ubCrc8;
//		}

		//Aux-Information
		*((uint8_t *)(ulAddr+ulRtnSz-KNL_INFO_FRAME_SZ+0)) 	= (uint8_t)((ulFrameSz & 0x000000FF)>>0);
		*((uint8_t *)(ulAddr+ulRtnSz-KNL_INFO_FRAME_SZ+1)) 	= (uint8_t)((ulFrameSz & 0x0000FF00)>>8);
		*((uint8_t *)(ulAddr+ulRtnSz-KNL_INFO_FRAME_SZ+2)) 	= (uint8_t)((ulFrameSz & 0x00FF0000)>>16);
		*((uint8_t *)(ulAddr+ulRtnSz-KNL_INFO_FRAME_SZ+3)) 	= (uint8_t)((ulFrameSz & 0xFF000000)>>24);

		//Capture
		if((!ulFrmIdx) && (KNL_CAPHQ_EN == tKNL_CapHQImgSte))
			printd(DBG_CriticalLvl, "	HQ:[0x%X, 0x%X, %d]\n", ulTemp, ulFrameSz, ulDmy0Time);
		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_HQCAP))  		 = ((!ulFrmIdx) && (KNL_CAPHQ_EN == tKNL_CapHQImgSte))?tKNL_CapHQImgSte:0;

		//Padd
		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_PADD))  		 = (uint8_t)ulDmy0Time;

		//Time Stamp
		*((uint32_t *)(ulAddr + ulRtnSz - KNL_INFO_TIMESTP_MSB)) = 0;
		*((uint32_t *)(ulAddr + ulRtnSz - KNL_INFO_TIMESTP_LSB)) = ulTime;
		
		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_SRCNUM)) 		 = ubSrcNum;								//SrcNum Information
		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_OPMODE)) 		 = ubKNL_GetOpMode();						//OpMode Information

		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_FRMIDX + 3))) = (uint8_t)(((ulFrmIdx&0x000000FF)>>0));	//Frame Index Information
		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_FRMIDX + 2))) = (uint8_t)(((ulFrmIdx&0x0000FF00)>>8));
		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_FRMIDX + 1))) = (uint8_t)(((ulFrmIdx&0x00FF0000)>>16));
		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_FRMIDX)) 		 = (uint8_t)(((ulFrmIdx&0xFF000000)>>24));

		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_GOP + 3))) 	 = (uint8_t)(((ulGop&0x000000FF)>>0));		//Codec GOP Information
		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_GOP + 2)))  	 = (uint8_t)(((ulGop&0x0000FF00)>>8));
		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_GOP + 1)))  	 = (uint8_t)(((ulGop&0x00FF0000)>>16));
		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_GOP))  		 = (uint8_t)(((ulGop&0xFF000000)>>24));

		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_VGOP))  		 = ubVdoGroupIdx;							//Video Group Information
		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_RES + 3)))  	 = uwKNL_GetVdoH(ubSrcNum) >> 8;
		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_RES + 2)))  	 = uwKNL_GetVdoH(ubSrcNum) & 0xFF;
		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_RES + 1)))  	 = uwKNL_GetVdoV(ubSrcNum) >> 8;
		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_RES))  		 = uwKNL_GetVdoV(ubSrcNum) & 0xFF;
		ubVdoIdx = (ubSrcNum <= KNL_SRC_4_MAIN)?0:1;
		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_FRMSEQ))  	 = ubKNL_VdoFrameSeq[ubVdoIdx]++;		
#if OP_STA
    #if ((defined(BSP_VBM_SDK)||defined(BSP_RVCS_SDK)) &&defined(VDO_SUBPATH_ENABLE)&&(VDO_SUBPATH_ENABLE!=0))
        *((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_AHD_CAM_TYPE)) = 0;
    #else
		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_AHD_CAM_TYPE)) = SEN_GetAhdCamType();
    #endif
#endif	
	}
	else if(tPktType == KNL_ADO_PKT)
	{
		ulTemp = ulSize;
#if defined(A7130)
		if((ulTemp % KNL_ADO_SUB_PKT_LEN) == 0)
		{
			ulRtnSz = ulTemp + KNL_ADO_SUB_PKT_LEN;
		}
		else
		{
			ulRtnSz = ((ulTemp / KNL_ADO_SUB_PKT_LEN) * KNL_ADO_SUB_PKT_LEN) + KNL_ADO_SUB_PKT_LEN + KNL_ADO_SUB_PKT_LEN;
			//Padd 0 value
			ulDmy0Time = KNL_ADO_SUB_PKT_LEN - (ulTemp % KNL_ADO_SUB_PKT_LEN);
			for(i = 0; i < ulDmy0Time; i++)
			{
				*((uint8_t *)(ulAddr + ulSize + i)) = 0;
			}
		}
#endif
#if defined(S2019A)
		if((ulTemp % 16) == 0)
		{
			ulRtnSz = ulTemp + KNL_ADO_SUB_PKT_LEN;
		}
		else
		{
			ulRtnSz = ((ulTemp / 16) * 16) + 16 + KNL_ADO_SUB_PKT_LEN;
			//Padd 0 value
			ulDmy0Time = 16 - (ulTemp % 16);
			for(i = 0; i < ulDmy0Time; i++)
			{
				*((uint8_t *)(ulAddr + ulSize + i)) = 0;
			}
		}
#endif
		//Aux-Information
		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_SRCNUM)) = ubSrcNum;					//SrcNum Information

		//Time Stamp
		*((uint32_t *)(ulAddr + ulRtnSz - KNL_INFO_TIMESTP_MSB))   = 0;
		*((uint32_t *)(ulAddr + ulRtnSz - KNL_INFO_TIMESTP_LSB))   = ulTime;
		

		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_ADOSIZE + 3)))  = (uint8_t)(((ulSize&0x000000FF)>>0));		//Real-Size Information
		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_ADOSIZE + 2)))  = (uint8_t)(((ulSize&0x0000FF00)>>8));
		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_ADOSIZE + 1)))  = (uint8_t)(((ulSize&0x00FF0000)>>16));
		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_ADOSIZE))   	   = (uint8_t)(((ulSize&0xFF000000)>>24));
		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_FRMSEQ))  	   = ubKNL_AdoFrameSeq++;
	}
	osSemaphoreRelease(tKNL_AuxAccSem);
	return ulRtnSz;
}
#endif

#ifdef RTC676x
uint32_t ulKNL_AddAuxInfo(KNL_PACKET_TYPE tPktType,uint8_t ubSrcNum,uint32_t ulAddr,uint32_t ulSize,uint32_t ulFrmIdx,uint32_t ulGop,uint8_t ubVdoGroupIdx,uint32_t ulTime)
{
#define KNL_AUX_INFO_LEN		(16 * 3)
#define KNL_INFO_FRMSEQ			(1)
#define KNL_INFO_RES			(2)
#define KNL_INFO_VGOP			(6)
#define KNL_INFO_GOP			(7)
#define KNL_INFO_FRMIDX			(11)
#define KNL_INFO_OPMODE			(15)
#define KNL_INFO_SRCNUM			(16)
#define KNL_INFO_TIMESTP_LSB	(20)
#define KNL_INFO_TIMESTP_MSB	(24)
#define KNL_INFO_PADD			(25)
#define KNL_INFO_HQCAP			(26)
	
#define KNL_INFO_AHD_CAM_TYPE	(31)	
	
#define KNL_INFO_CRC8			(KNL_AUX_INFO_LEN)	
#define KNL_INFO_CRC_SZ			(KNL_AUX_INFO_LEN-1)

#define KNL_INFO_FRAME_SZ		(KNL_AUX_INFO_LEN-5)
	
#define KNL_INFO_ADOSIZE		(3)
    uint32_t ulFrameSz=0;
	uint8_t ubCrc8 = 0;
	uint32_t ulTemp;
	uint32_t ulRtnSz;
	uint32_t i;
	uint32_t ulDmy0Time = 0;
	uint32_t ulCrcCalSz;
	uint8_t ubVdoIdx = 0;
	static uint8_t ubKNL_VdoFrameSeq[2] = {0, 0};
	static uint8_t ubKNL_AdoFrameSeq = 0;
	
	osSemaphoreWait(tKNL_AuxAccSem, osWaitForever);	
	//Case (%16) = 0
	//-------------------------------------------
	//|							 				|
	//| Original Size			 				|
	//|							 				|
	//-------------------------------------------
	//|TimeStamp (24)  			 				|
	//--------------------------------------------------
	//|SrcNum(1)|OpMode(1)|FrmIdx(4)|GOP(4)|VGOP(1)|(5)|
	//--------------------------------------------------

	if(!ubKNL_GetAuxInfoFunc())
	{
		osSemaphoreRelease(tKNL_AuxAccSem);
		return ulSize;
	}

	if(tPktType == KNL_VDO_PKT)
	{
		ulTemp = ulSize;
		if((ulTemp % 16) == 0)
		{
			ulRtnSz    = ulTemp + KNL_AUX_INFO_LEN;
			ulCrcCalSz = ulTemp;
            ulFrameSz = ulTemp;
		}
		else
		{
			ulRtnSz    = ((ulTemp / 16) * 16) + 16 + KNL_AUX_INFO_LEN;
			ulCrcCalSz = ((ulTemp / 16) * 16) + 16;
			//Padd 0 value
			ulDmy0Time = 16 - (ulTemp % 16);
			for(i = 0; i < ulDmy0Time; i++)
			{
				*((uint8_t *)(ulAddr + ulSize + i)) = 0;
			}
             ulFrameSz = ulRtnSz-KNL_AUX_INFO_LEN;
		}

		//CRC-Information
		if(KNL_AUX_CRC_FUNC)
		{
			ulCrcCalSz = ulCrcCalSz;
			ubCrc8 = ubKNL_TransmitCRC8(ulAddr, ulCrcCalSz);
						
			//printd(DBG_Debug3Lvl, "crc2:0x%x\r\n",ubCrc8);
			//printd(DBG_Debug3Lvl, "ulCrcCalSz:0x%x\r\n",ulCrcCalSz);			
			
			*((uint8_t *)(ulAddr+ulRtnSz-KNL_INFO_CRC8))		= ubCrc8;
			
			*((uint8_t *)(ulAddr+ulRtnSz-KNL_INFO_CRC_SZ+0)) 	= (uint8_t)((ulCrcCalSz & 0x000000FF)>>0);
			*((uint8_t *)(ulAddr+ulRtnSz-KNL_INFO_CRC_SZ+1)) 	= (uint8_t)((ulCrcCalSz & 0x0000FF00)>>8);
			*((uint8_t *)(ulAddr+ulRtnSz-KNL_INFO_CRC_SZ+2)) 	= (uint8_t)((ulCrcCalSz & 0x00FF0000)>>16);
			*((uint8_t *)(ulAddr+ulRtnSz-KNL_INFO_CRC_SZ+3)) 	= (uint8_t)((ulCrcCalSz & 0xFF000000)>>24);
		}

		//Aux-Information
		*((uint8_t *)(ulAddr+ulRtnSz-KNL_INFO_FRAME_SZ+0)) 	= (uint8_t)((ulFrameSz & 0x000000FF)>>0);
		*((uint8_t *)(ulAddr+ulRtnSz-KNL_INFO_FRAME_SZ+1)) 	= (uint8_t)((ulFrameSz & 0x0000FF00)>>8);
		*((uint8_t *)(ulAddr+ulRtnSz-KNL_INFO_FRAME_SZ+2)) 	= (uint8_t)((ulFrameSz & 0x00FF0000)>>16);
		*((uint8_t *)(ulAddr+ulRtnSz-KNL_INFO_FRAME_SZ+3)) 	= (uint8_t)((ulFrameSz & 0xFF000000)>>24);

		//Capture
		if((!ulFrmIdx) && (KNL_CAPHQ_EN == tKNL_CapHQImgSte))
			printd(DBG_CriticalLvl, "	HQ Image: [0x%X, 0x%X, %d]\n", ulTemp, ulFrameSz, ulDmy0Time);
		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_HQCAP))  		 = ((!ulFrmIdx) && (KNL_CAPHQ_EN == tKNL_CapHQImgSte))?tKNL_CapHQImgSte:0;

		//Padd
		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_PADD))  		 = (uint8_t)ulDmy0Time;

		//Time Stamp
		*((uint32_t *)(ulAddr + ulRtnSz - KNL_INFO_TIMESTP_MSB)) = 0;
		*((uint32_t *)(ulAddr + ulRtnSz - KNL_INFO_TIMESTP_LSB)) = ulTime;
		
		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_SRCNUM)) 		 = ubSrcNum;								//SrcNum Information
		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_OPMODE)) 		 = ubKNL_GetOpMode();						//OpMode Information

		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_FRMIDX + 3))) = (uint8_t)(((ulFrmIdx&0x000000FF)>>0));	//Frame Index Information
		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_FRMIDX + 2))) = (uint8_t)(((ulFrmIdx&0x0000FF00)>>8));
		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_FRMIDX + 1))) = (uint8_t)(((ulFrmIdx&0x00FF0000)>>16));
		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_FRMIDX)) 		 = (uint8_t)(((ulFrmIdx&0xFF000000)>>24));

		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_GOP + 3))) 	 = (uint8_t)(((ulGop&0x000000FF)>>0));		//Codec GOP Information
		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_GOP + 2)))  	 = (uint8_t)(((ulGop&0x0000FF00)>>8));
		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_GOP + 1)))  	 = (uint8_t)(((ulGop&0x00FF0000)>>16));
		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_GOP))  		 = (uint8_t)(((ulGop&0xFF000000)>>24));

		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_VGOP))  		 = ubVdoGroupIdx;							//Video Group Information
		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_RES + 3)))  	 = uwKNL_GetVdoH(ubSrcNum) >> 8;
		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_RES + 2)))  	 = uwKNL_GetVdoH(ubSrcNum) & 0xFF;
		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_RES + 1)))  	 = uwKNL_GetVdoV(ubSrcNum) >> 8;
		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_RES))  		 = uwKNL_GetVdoV(ubSrcNum) & 0xFF;
		ubVdoIdx = (ubSrcNum <= KNL_SRC_4_MAIN)?0:1;
		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_FRMSEQ))  	 = ubKNL_VdoFrameSeq[ubVdoIdx]++;		
		#if OP_STA		
    #if ((defined(BSP_VBM_SDK)||defined(BSP_RVCS_SDK)) &&defined(VDO_SUBPATH_ENABLE)&&(VDO_SUBPATH_ENABLE!=0))
        *((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_AHD_CAM_TYPE)) = 0;
    #else
    	*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_AHD_CAM_TYPE)) = SEN_GetAhdCamType();
    #endif
        #endif	
	}
	else if(tPktType == KNL_ADO_PKT)
	{
		ulTemp = ulSize;
		if((ulTemp % 16) == 0)
		{
			ulRtnSz    = ulTemp + KNL_AUX_INFO_LEN;
			ulCrcCalSz = ulTemp;
		}
		else
		{
			ulRtnSz    = ((ulTemp / 16) * 16) + 16 + KNL_AUX_INFO_LEN;
			ulCrcCalSz = ((ulTemp / 16) * 16) + 16;
			//Padd 0 value
			ulDmy0Time = 16 - (ulTemp % 16);
			for(i = 0; i < ulDmy0Time; i++)
			{
				*((uint8_t *)(ulAddr + ulSize + i)) = 0;
			}
		}

		//CRC-Information
		if(KNL_AUX_CRC_FUNC)
		{
			ulCrcCalSz = ulCrcCalSz;
			ubCrc8 = ubKNL_TransmitCRC8(ulAddr, ulCrcCalSz);
			
			//printd(DBG_Debug3Lvl, "crc2:0x%x\r\n",ubCrc8);
			//printd(DBG_Debug3Lvl, "ulCrcCalSz:0x%x\r\n",ulCrcCalSz);			
			
			*((uint8_t *)(ulAddr+ulRtnSz-KNL_INFO_CRC8))		= ubCrc8;
			
			*((uint8_t *)(ulAddr+ulRtnSz-KNL_INFO_CRC_SZ+0)) 	= (uint8_t)((ulCrcCalSz & 0x000000FF)>>0);
			*((uint8_t *)(ulAddr+ulRtnSz-KNL_INFO_CRC_SZ+1)) 	= (uint8_t)((ulCrcCalSz & 0x0000FF00)>>8);
			*((uint8_t *)(ulAddr+ulRtnSz-KNL_INFO_CRC_SZ+2)) 	= (uint8_t)((ulCrcCalSz & 0x00FF0000)>>16);
			*((uint8_t *)(ulAddr+ulRtnSz-KNL_INFO_CRC_SZ+3)) 	= (uint8_t)((ulCrcCalSz & 0xFF000000)>>24);
		}		
		
		//Aux-Information
		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_SRCNUM)) = ubSrcNum;					//SrcNum Information

		//Time Stamp
		*((uint32_t *)(ulAddr + ulRtnSz - KNL_INFO_TIMESTP_MSB))   = 0;
		*((uint32_t *)(ulAddr + ulRtnSz - KNL_INFO_TIMESTP_LSB))   = ulTime;
		

		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_ADOSIZE + 3)))  = (uint8_t)(((ulSize&0x000000FF)>>0));		//Real-Size Information
		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_ADOSIZE + 2)))  = (uint8_t)(((ulSize&0x0000FF00)>>8));
		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_ADOSIZE + 1)))  = (uint8_t)(((ulSize&0x00FF0000)>>16));
		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_ADOSIZE))   	   = (uint8_t)(((ulSize&0xFF000000)>>24));
		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_FRMSEQ))  	   = ubKNL_AdoFrameSeq++;
	}	
	
	//[FOTA]
	else if(tPktType == KNL_FOTA_PKT)
	{
		ulTemp = ulSize;
		if((ulTemp % 16) == 0)
		{
			ulRtnSz    = ulTemp + KNL_AUX_INFO_LEN;
			ulCrcCalSz = ulTemp;
		}
		else
		{
			ulRtnSz    = ((ulTemp / 16) * 16) + 16 + KNL_AUX_INFO_LEN;
			ulCrcCalSz = ((ulTemp / 16) * 16) + 16;
			//Padd 0 value
			ulDmy0Time = 16 - (ulTemp % 16);
			for(i = 0; i < ulDmy0Time; i++)
			{
				*((uint8_t *)(ulAddr + ulSize + i)) = 0;
			}
		}

		//CRC-Information
		if(KNL_AUX_CRC_FUNC)
		{
			ulCrcCalSz = ulCrcCalSz;
			ubCrc8 = ubKNL_TransmitCRC8(ulAddr, ulCrcCalSz);
			
			//printd(DBG_Debug3Lvl, "crc2:0x%x\r\n",ubCrc8);
			//printd(DBG_Debug3Lvl, "ulCrcCalSz:0x%x\r\n",ulCrcCalSz);			
			
			*((uint8_t *)(ulAddr+ulRtnSz-KNL_INFO_CRC8))		= ubCrc8;
			
			*((uint8_t *)(ulAddr+ulRtnSz-KNL_INFO_CRC_SZ+0)) 	= (uint8_t)((ulCrcCalSz & 0x000000FF)>>0);
			*((uint8_t *)(ulAddr+ulRtnSz-KNL_INFO_CRC_SZ+1)) 	= (uint8_t)((ulCrcCalSz & 0x0000FF00)>>8);
			*((uint8_t *)(ulAddr+ulRtnSz-KNL_INFO_CRC_SZ+2)) 	= (uint8_t)((ulCrcCalSz & 0x00FF0000)>>16);
			*((uint8_t *)(ulAddr+ulRtnSz-KNL_INFO_CRC_SZ+3)) 	= (uint8_t)((ulCrcCalSz & 0xFF000000)>>24);
		}		
		
		//Aux-Information
		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_SRCNUM)) = ubSrcNum;					//SrcNum Information

		//Time Stamp
		*((uint32_t *)(ulAddr + ulRtnSz - KNL_INFO_TIMESTP_MSB))   = 0;
		*((uint32_t *)(ulAddr + ulRtnSz - KNL_INFO_TIMESTP_LSB))   = ulTime;
		

		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_ADOSIZE + 3)))  = (uint8_t)(((ulSize&0x000000FF)>>0));		//Real-Size Information
		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_ADOSIZE + 2)))  = (uint8_t)(((ulSize&0x0000FF00)>>8));
		*((uint8_t *)(ulAddr + ulRtnSz - (KNL_INFO_ADOSIZE + 1)))  = (uint8_t)(((ulSize&0x00FF0000)>>16));
		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_ADOSIZE))   	   = (uint8_t)(((ulSize&0xFF000000)>>24));
		*((uint8_t *)(ulAddr + ulRtnSz - KNL_INFO_FRMSEQ))  	   = ubKNL_AdoFrameSeq++;
	}
	osSemaphoreRelease(tKNL_AuxAccSem);
	return ulRtnSz;
}
#endif
//------------------------------------------------------------------------------
void KNL_SetJpegQp(uint8_t ubQp)
{
	tKNL_Info.ubJpegCodecQp = ubQp;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_GetJpegQp(void)
{
	return tKNL_Info.ubJpegCodecQp;
}

//------------------------------------------------------------------------------
void KNL_SetNodeState(uint8_t ubSrcNum,uint8_t ubNode,uint8_t ubState)
{
	tKNL_NodeState[ubSrcNum][ubNode] = (KNL_NODE_STATE)ubState;
}
//------------------------------------------------------------------------------
void KNL_TwcResult(TWC_TAG GetSta,TWC_STATUS ubStatus)
{
	if(ubStatus == TWC_SUCCESS)
	{
		ubKNL_TwcResult = TWC_SUCCESS;
	}
	else if(ubStatus == TWC_FAIL)
	{
		ubKNL_TwcResult = TWC_FAIL;
	}
	ubKNL_TwcEndFlg = 1;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_TwcSend(uint8_t ubRole,TWC_OPC Opc,uint8_t *Data,uint8_t ubLen,uint8_t ubRetry)
{	
#define KNL_TWC_RETRY_MAX	50
	TWC_TAG Tag;
	TWC_STATUS tKNL_TwcSts = TWC_SUCCESS;

	osSemaphoreWait(tKNL_TwcSem, osWaitForever);

	if(ubRole == KNL_STA1)
	{
		Tag = TWC_STA1; 
	}
	else if(ubRole == KNL_STA2)
	{
		Tag = TWC_STA2;
	}
	else if(ubRole == KNL_STA3)
	{
		Tag = TWC_STA3;
	}
	else if(ubRole == KNL_STA4)
	{
		Tag = TWC_STA4;
	}
	else if(ubRole == KNL_SLAVE_AP)
	{
		Tag = TWC_AP_SLAVE;
	}
	else if(ubRole == KNL_MASTER_AP)
	{
		Tag = TWC_AP_MASTER;
	}

	if(!ubKNL_GetCommLinkStatus(ubRole))
	{
		osSemaphoreRelease(tKNL_TwcSem);
		return TWC_FAIL;
	}

	ubKNL_TwcEndFlg = 0;
	tKNL_TwcSts = tTWC_Send(Tag,Opc,Data,ubLen,ubRetry);
	if(tKNL_TwcSts != TWC_SUCCESS)
	{
		ubKNL_TwcEndFlg = 1;
	}
	else
	{

	#if defined(A7130) || defined(S2019A) || defined(RTC676x)
		uint8_t ubTwcRtyCnt = 0;
		while(ubKNL_TwcEndFlg == 0)
		{
			osDelay(10);
			if(++ubTwcRtyCnt >= KNL_TWC_RETRY_MAX)
			{
				ubKNL_TwcResult = TWC_FAIL;
				break;
			}
		}
	#endif
		tKNL_TwcSts = (TWC_STATUS)ubKNL_TwcResult;
		tTWC_StopTwcSend(Tag, Opc);
	}
	if(TWC_FAIL == tKNL_TwcSts)
	{
		switch(Opc)
		{
			case TWC_RESEND_I_EXT:
				ubKNL_VdoResendITwcFlg[ubRole] = FALSE;
				ubKNL_AppResendIFrmFlg[ubRole] = FALSE;
				break;
			case TWC_VDORES_SETTING:
				ubKNL_VdoResChgTwcFlg[ubRole]  = FALSE;
				break;
			default:
				break;
		}
	}

	osSemaphoreRelease(tKNL_TwcSem);

	return (uint8_t)tKNL_TwcSts;
}

//------------------------------------------------------------------------------
void KNL_NodeStateReset(void)
{
	uint16_t i,j;
	
	for(j=0;j<KNL_SRC_NUM;j++)
	{
		for(i=0;i<256;i++)
		{
			tKNL_NodeState[j][i] = KNL_NODE_STOP;	
		}
	}
}
//------------------------------------------------------------------------------
void KNL_VdoReset(void)
{
	uint8_t i;

	for(i=0;i<KNL_SRC_NUM;i++)
	{
		ubKNL_VdoFlowActiveFlg[i] = 0;
		ubKNL_RcvFirstIFrame[i] = 0;

		ulKNL_OutVdoFpsCnt[i] = 0;
		ulKNL_OutVdoFpsCntTemp[i] = 0;

		ulKNL_InVdoFpsCnt[i] = 0;
		ulKNL_InVdoFpsCntTemp[i] = 0;
	}
	for(i=0;i<KNL_MAX_ROLE;i++)
	{
		ulKNL_FrmTRxNum[i] = 0;
		ulKNL_FrmTRxNumTemp[i] = 0;
	}

	//Reset Status Report
	ulKNL_VdoOutAccCnt[0] = 0;		//Bit-Rate
	ulKNL_VdoOutAccCnt[1] = 0;		//Bit-Rate
	ulKNL_VdoOutAccCnt[2] = 0;		//Bit-Rate
	ulKNL_VdoOutAccCnt[3] = 0;		//Bit-Rate
	
	ulKNL_VdoOutAccCntTemp[0] = 0;	//Bit-Rate
	ulKNL_VdoOutAccCntTemp[1] = 0;	//Bit-Rate
	ulKNL_VdoOutAccCntTemp[2] = 0;	//Bit-Rate
	ulKNL_VdoOutAccCntTemp[3] = 0;	//Bit-Rate
	
	ulKNL_AdoOutAccCnt = 0;		//Bit-Rate
	ulKNL_AdoOutAccCntTemp = 0;	//Bit-Rate
}
//------------------------------------------------------------------------------
void KNL_SetMultiOutNode(uint8_t ubNode,uint8_t ubEnable,uint8_t ubInSrc,uint8_t ubOutSrc1,uint8_t ubOutSrc2)
{
	tKNL_Info.ubMultiOutFlg[ubNode]		= ubEnable;
	tKNL_Info.ubMultiInSrc[ubNode] 		= ubInSrc;
	tKNL_Info.ubMultiOutSrc1[ubNode] 	= ubOutSrc1;
	tKNL_Info.ubMultiOutSrc2[ubNode] 	= ubOutSrc2;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_ChkMultiOutNode(uint8_t ubNode)
{
	return tKNL_Info.ubMultiOutFlg[ubNode];
}
//------------------------------------------------------------------------------
uint8_t ubKNL_GetMultiInSrc(uint8_t ubNode)
{
	return tKNL_Info.ubMultiInSrc[ubNode];
}
//------------------------------------------------------------------------------
uint8_t ubKNL_GetMultiOutSrc(uint8_t ubNode,uint8_t ubOutSrc)
{
	if(ubOutSrc == 0)
	{
		return tKNL_Info.ubMultiOutSrc1[ubNode];
	}
	else if(ubOutSrc == 1)
	{
		return tKNL_Info.ubMultiOutSrc2[ubNode];
	}
	else
	{
		printd(DBG_ErrorLvl, "Err @ubKNL_GetMultiOutSrc\r\n");
		return 0;
	}
}
//------------------------------------------------------------------------------
void KNL_SetLcdDmyImgH(uint16_t uwH)
{
	tKNL_Info.uwLcdDmyImgH = uwH;
}
//------------------------------------------------------------------------------
uint16_t uwKNL_GetLcdDmyImgH(void)
{
	return tKNL_Info.uwLcdDmyImgH;
}
//------------------------------------------------------------------------------
uint32_t ulKNL_GetImgMergeBufSz(void)
{
	KNL_DISP_TYPE tDispType = KNL_DISP_QUAD;
	uint32_t ulBufSz1,ulBufSz2,ulBufSz3;
	uint32_t ulBufSz;		
	uint8_t ubDisp1Src,ubDisp2Src,ubDisp3Src,ubDisp4Src;

	ulBufSz1 	= ulBufSz1;
	ulBufSz2 	= ulBufSz2;
	ulBufSz3 	= ulBufSz3;
	ulBufSz		= ulBufSz;
	ubDisp1Src	= ubDisp1Src;
	ubDisp2Src	= ubDisp2Src;
	ubDisp3Src	= ubDisp3Src;
	ubDisp4Src	= ubDisp4Src;

	ubDisp1Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
	ubDisp2Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION2);
	ubDisp3Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION3);
	ubDisp4Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION4);

	tDispType = tKNL_GetDispType();
	//H-View
	if(KNL_DISP_H == tDispType)
	{
		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
		{
			uint8_t ubScaleDmy1Param = 0, ubScaleDmy2Param = 0;

			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src = KNL_SRC_1_MAIN;
				ubScaleDmy1Param = (uwKNL_GetVdoH(ubDisp1Src) > 1024)?2:1;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) > 1024)?KNL_SCALE_X0P25:KNL_SCALE_X0P5));
				ubScaleDmy1Param = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}
			if(KNL_SRC_NONE == ubDisp4Src)
			{
				ubDisp4Src = KNL_SRC_4_MAIN;
				ubScaleDmy2Param = (uwKNL_GetVdoH(ubDisp4Src) > 1024)?2:1;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp4Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp4Src) > 1024)?KNL_SCALE_X0P25:KNL_SCALE_X0P5));
				ubScaleDmy2Param = ubKNL_GetVdoScaleParam(ubDisp4Src);
			}
			ulBufSz1   = (((uint32_t)uwKNL_GetVdoH(ubDisp1Src) >> ubScaleDmy1Param) * ((uint32_t)uwKNL_GetVdoV(ubDisp1Src) >> ubScaleDmy1Param) * 3) >> 1;					//L Image
			ulBufSz2   = ((uint32_t)uwKNL_GetLcdDmyImgH() * ((uint32_t)uwKNL_GetVdoV(ubDisp1Src) >> ubScaleDmy1Param) * 3) >> 1;											//Dummy Image
			ulBufSz3   = (((uint32_t)uwKNL_GetVdoH(ubDisp4Src) >> ubScaleDmy2Param) * ((uint32_t)uwKNL_GetVdoV(ubDisp4Src) >> ubScaleDmy2Param) * 3) >> 1;					//R Image
			ulBufSz    = ulBufSz1 + ulBufSz2 + ulBufSz3;
			return ulBufSz;
		}
		else if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)
		{
			uint8_t ubScaleParam = 0;

			ubDisp2Src   = (KNL_SRC_NONE == ubDisp2Src)?KNL_SRC_2_MAIN:ubDisp2Src;
			ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			ulBufSz1     = (((uint32_t)uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam)*((uint32_t)uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam) * 3) >> 1;
			ubDisp3Src   = (KNL_SRC_NONE == ubDisp3Src)?KNL_SRC_3_MAIN:ubDisp3Src;
			ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp3Src);
			ulBufSz2     = (((uint32_t)uwKNL_GetVdoH(ubDisp3Src) >> ubScaleParam)*((uint32_t)uwKNL_GetVdoV(ubDisp3Src) >> ubScaleParam) * 3) >> 1;
			ulBufSz      = ulBufSz1 + ulBufSz2;
			return ulBufSz;
		}
	}
	else if((((KNL_DISP_3T_2L1R == tKNL_GetDispType()) || (KNL_DISP_3T_1L2R == tKNL_GetDispType())) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)) ||
		    (((KNL_DISP_3T_2T1B == tKNL_GetDispType()) || (KNL_DISP_3T_1T2B == tKNL_GetDispType())) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0))  ||
	         ((KNL_DISP_3T_3COL == tKNL_GetDispType()) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)))
	{
		uint8_t ubScaleParam = 0;
		ubDisp2Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[1]:ubDisp2Src;
		ubDisp2Src = (KNL_SRC_NONE == ubDisp2Src)?KNL_SRC_2_MAIN:ubDisp2Src;
		ubDisp3Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[2]:ubDisp3Src;
		ubDisp3Src = (KNL_SRC_NONE == ubDisp3Src)?KNL_SRC_3_MAIN:ubDisp3Src;
		ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
		ulBufSz1 = (((uint32_t)uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam)*((uint32_t)uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam) * 3) >> 1;
		ulBufSz2 = (((uint32_t)uwKNL_GetVdoH(ubDisp3Src) >> ubScaleParam)*((uint32_t)uwKNL_GetVdoV(ubDisp3Src) >> ubScaleParam) * 3) >> 1;
		ulBufSz  = ulBufSz1 + ulBufSz2;
		return ulBufSz;
	}
	printd(DBG_ErrorLvl, "Err @ulKNL_GetImgMergeBufSz\r\n");
	return 0;
}

//------------------------------------------------------------------------------
void KNL_SetDispRotate(KNL_DISP_ROTATE tRotateType)
{
	tKNL_Info.tDispRotate = tRotateType;
}
//------------------------------------------------------------------------------
KNL_DISP_ROTATE tKNL_GetDispRotate(void)
{
	return tKNL_Info.tDispRotate;
}
//------------------------------------------------------------------------------
void KNL_SetDispHV(uint16_t uwDispH,uint16_t uwDispV)
{
	tKNL_Info.uwDispH = uwDispH;
	tKNL_Info.uwDispV = uwDispV;
}
//------------------------------------------------------------------------------
void KNL_SetDispType(KNL_DISP_TYPE tDispType)
{
	tKNL_Info.tDispType	= tDispType;
}
//------------------------------------------------------------------------------
KNL_DISP_TYPE tKNL_GetDispType(void)
{
	return tKNL_Info.tDispType;
}
uint8_t ubKNL_GetAPPCfgDispMode(void)
{
    return DISPLAY_MODE;
}
//------------------------------------------------------------------------------
KNL_DISP_LOCATION tKNL_SearchSrcLocation(uint8_t ubSrcNum)
{
	KNL_DISP_LOCATION tDispLocate;
	uint8_t i;
	i = i;	//Avoid Warning
#if !defined(BSP_DVR_SDK)
	if(TRUE == KNL_SwDispInfo.ubSetupFlag)
	{
		for(i = 0; i < 4; i++)
		{
			if(KNL_SwDispInfo.tSrcNum[i] == ubSrcNum)
				return KNL_SwDispInfo.tSrcLocate[i];
		}
		return KNL_DISP_LOCATION_ERR;
	}
#endif
	tDispLocate = tKNL_GetDispLocation(ubSrcNum);
	return tDispLocate;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_SearchSrcByDispLoc(uint8_t ubDispLoc)
{
	uint8_t ubSrcNum = 0, ubMaxSlotNum;

	ubMaxSlotNum = ubKNL_GetTRXSlotNum();
	if((FALSE == ubKNL_BbPathAct) && (TRUE == KNL_SwDispInfo.ubSetupFlag))
	{
		uint8_t ubSrcIdx;
		for(ubSrcIdx = 0; ubSrcIdx < 4; ubSrcIdx++)
		{
			if(ubDispLoc == KNL_SwDispInfo.tSrcLocate[ubSrcIdx])
				return (uint8_t)KNL_SwDispInfo.tSrcNum[ubSrcIdx];
		}
	}
	else if((ubMaxSlotNum != DISPLAY_MODE) && (ubMaxSlotNum == 2))
		return (KNL_DISP_LOCATION1 == ubDispLoc)?KNL_SRC_1_MAIN:KNL_SRC_2_MAIN;
	ubSrcNum = ubKNL_GetDispSrc((KNL_DISP_LOCATION)ubDispLoc);
	return ubSrcNum;
}
//------------------------------------------------------------------------------
void KNL_ModifyDispType(KNL_DISP_TYPE tDispType, KNL_SrcLocateMap_t tSrcLocate)
{
#if KNL_LCD_FUNC_ENABLE
	LCD_INFOR_TYP sLcdInfor;
	uint8_t ubDisp1Src;
	uint8_t ubDisp2Src;
	uint8_t ubDisp3Src;
	uint8_t ubDisp4Src;
	static uint8_t ubKNL_LcdDispChgFlag = FALSE;
	static uint8_t ubDualDectFlag = FALSE;

	osSemaphoreWait(osKNL_LcdDispInfoSem, osWaitForever);

	//Step1
	ubKNL_DispCh0ActiveFlg = 0;
	ubKNL_DispCh1ActiveFlg = 0;
	ubKNL_DispCh2ActiveFlg = 0;
	ubKNL_DispCh3ActiveFlg = 0;

	//Step2
#if !defined(BSP_DVR_SDK)
	if(((tKNL_GetDispType() != tDispType) && (LCD_JPEG_DISABLE == tLCD_GetJpegDecoderStatus())) ||
	   (TRUE == tSrcLocate.ubDispBufChgFlag))
	{
		ubKNL_LcdDispChgFlag = TRUE;
		if((tKNL_GetDispType() != tDispType) || (FALSE == tSrcLocate.ubFixDispChFlag))
			KNL_ResetLcdChannel();
	}
#else
	KNL_SetDispType(tDispType);
	ulKNL_CalLcdBufSz();
	LCD_SetLcdBufAddr(ulBUF_GetBlkBufAddr(0, BUF_LCD_IP));
    osSemaphoreWait(JPEG_CodecSem, 200);
    osSemaphoreWait(tKNL_JpegSigProc.osWaitSem, 200);
	if(TRUE == tSrcLocate.ubDispBufChgFlag)    
		ubKNL_LcdDispChgFlag = TRUE;
    KNL_ResetLcdChannel();
    ubKNL_ModifyDPCnt = 100;
    if(tDispType == KNL_DISP_SINGLE)
    {
        osSemaphoreRelease(tKNL_JpegSigProc.osWaitSem);
    	osSemaphoreRelease(JPEG_CodecSem);    
	}
#endif
#if (APP_DUAL_HOST_ENABLE == 1)
	KNL_ResetLcdChannel();
#endif
	
	//Get Correspond Source
	ubDisp1Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
	ubDisp2Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION2);
	ubDisp3Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION3);
	ubDisp4Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION4);
#if !defined(BSP_DVR_SDK)
	KNL_SetDispType(tDispType);
#endif
	memcpy(&KNL_SwDispInfo, &tSrcLocate, sizeof(KNL_SrcLocateMap_t));

	if(tDispType == KNL_DISP_SINGLE)
	{
		sLcdInfor.tDispType = LCD_DISP_1T;
		sLcdInfor.ubChNum = 1;

		KNL_SwDispInfo.ubSetupFlag = TRUE;
#if (defined(OP_AP) && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)		
		if(tKNL_RecordAct.tSimFolder == KNL_SIM_FLD && tKNL_GetRecordFunc() == KNL_VIDEO_PLAY)
		    ubDisp1Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
		else
#endif
		    ubDisp1Src = KNL_SwDispInfo.tSrcNum[0];
		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
		{
			sLcdInfor.uwLcdOutputHsize = tKNL_Info.uwDispH;
			sLcdInfor.uwLcdOutputVsize = tKNL_Info.uwDispV;
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoH(ubDisp1Src);
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoV(ubDisp1Src);
			sLcdInfor.tChRes[0].uwCropHstart = 0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;
			sLcdInfor.tChRes[0].uwCropHsize = uwKNL_GetVdoH(ubDisp1Src);
			sLcdInfor.tChRes[0].uwCropVsize = uwKNL_GetVdoV(ubDisp1Src);
		}
		else
		{
			sLcdInfor.uwLcdOutputHsize = tKNL_Info.uwDispV;
			sLcdInfor.uwLcdOutputVsize = tKNL_Info.uwDispH;
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoV(ubDisp1Src);
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoH(ubDisp1Src);
			sLcdInfor.tChRes[0].uwCropHstart = 0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;
			sLcdInfor.tChRes[0].uwCropHsize = uwKNL_GetVdoV(ubDisp1Src);
			sLcdInfor.tChRes[0].uwCropVsize = uwKNL_GetVdoH(ubDisp1Src);
		}
#if (defined(OP_AP) && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
		if(!(tKNL_RecordAct.tSimFolder == KNL_SIM_FLD && tKNL_GetRecordFunc() == KNL_VIDEO_PLAY))
#endif
		{
    		KNL_SwDispInfo.tSrcNum[1] = KNL_SwDispInfo.tSrcNum[2] = KNL_SwDispInfo.tSrcNum[3] = KNL_SRC_NONE;
    		KNL_SwDispInfo.tSrcLocate[1] = KNL_SwDispInfo.tSrcLocate[2] = KNL_SwDispInfo.tSrcLocate[3] = KNL_DISP_LOCATION_ERR;
		}
	}
	else if(tKNL_GetDispType() == KNL_DISP_DUAL_U)
	{
		uint8_t ubScaleParam = 0;
		sLcdInfor.tDispType = LCD_DISP_2T_H;
		sLcdInfor.ubChNum = 2;

		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
		{
			sLcdInfor.uwLcdOutputHsize = tKNL_Info.uwDispH;
			sLcdInfor.uwLcdOutputVsize = tKNL_Info.uwDispV;

			ubDisp1Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[0]:ubDisp1Src;
			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src   = KNL_SRC_1_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) >= 1920)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) >= 1920)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropHstart = 0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;
			sLcdInfor.tChRes[0].uwCropHsize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropVsize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;

			ubDisp2Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[1]:ubDisp2Src;
			if(KNL_SRC_NONE == ubDisp2Src)
			{
				ubDisp2Src   = KNL_SRC_2_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp2Src) >= 1920)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp2Src) >= 1920)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			}
			sLcdInfor.tChRes[1].uwChInputHsize = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;	
			sLcdInfor.tChRes[1].uwChInputVsize = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;	
			sLcdInfor.tChRes[1].uwCropHstart = 0;
			sLcdInfor.tChRes[1].uwCropVstart = 0;
			sLcdInfor.tChRes[1].uwCropHsize = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwCropVsize = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
		}
		else
		{
			sLcdInfor.uwLcdOutputHsize = tKNL_Info.uwDispV;
			sLcdInfor.uwLcdOutputVsize = tKNL_Info.uwDispH;

			ubDisp1Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[0]:ubDisp1Src;
			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src   = KNL_SRC_1_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) >= 1920)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) >= 1920)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropHstart = 0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;
			sLcdInfor.tChRes[0].uwCropHsize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropVsize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;

			ubDisp2Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[1]:ubDisp2Src;
			if(KNL_SRC_NONE == ubDisp2Src)
			{
				ubDisp2Src   = KNL_SRC_2_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp2Src) >= 1920)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp2Src) >= 1920)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			}
			sLcdInfor.tChRes[1].uwChInputHsize = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwChInputVsize = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwCropHstart = 0;
			sLcdInfor.tChRes[1].uwCropVstart = 0;
			sLcdInfor.tChRes[1].uwCropHsize = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwCropVsize = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;
		}
		if(TRUE == KNL_SwDispInfo.ubSetupFlag)
		{
			LCD_CH_TYP tCh;
			uint8_t ubRole[2], ubIdx;

			if(TRUE == ubDualDectFlag)
			{
				for(ubIdx = 0; ubIdx < 2; ubIdx++)
				{
#if defined(BSP_DVR_SDK)
				    if(ubKNL_GetSrcNumPosition(KNL_SwDispInfo.tSrcNum[ubIdx]) == KNL_REMOTE)
                        continue;
#endif						
					ubRole[ubIdx] = ubKNL_SrcNumMap(KNL_SwDispInfo.tSrcNum[ubIdx]);
				#ifdef RTC676x
					if(FALSE == tSrcLocate.ubFixDispChFlag)
				#endif
					{
						if(ubKNL_GetCommLinkStatus(ubRole[ubIdx]) == BB_LOST_LINK)
						{
							tCh = (KNL_DISP_LOCATION1 == KNL_SwDispInfo.tSrcLocate[ubIdx])?LCD_CH0:LCD_CH1;
							LCD_ChDisable(tCh);
						}
					}
				}
			}
			else
				ubDualDectFlag = TRUE;
		}
		else
			KNL_SwDispInfo.tSrcNum[0] = KNL_SwDispInfo.tSrcNum[1] = KNL_SRC_NONE;
		KNL_SwDispInfo.tSrcNum[2] = KNL_SwDispInfo.tSrcNum[3] = KNL_SRC_NONE;
		KNL_SwDispInfo.tSrcLocate[2] = KNL_SwDispInfo.tSrcLocate[3] = KNL_DISP_LOCATION_ERR;
	}
	else if(tKNL_GetDispType() == KNL_DISP_QUAD)
	{
		sLcdInfor.tDispType = LCD_DISP_4T;
		sLcdInfor.ubChNum = 4;

		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
		{
			uint8_t ubScaleParam = 0;

			sLcdInfor.uwLcdOutputHsize = tKNL_Info.uwDispH;
			sLcdInfor.uwLcdOutputVsize = tKNL_Info.uwDispV;

			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src   = KNL_SRC_1_MAIN;
			
			#if (APP_DUAL_HOST_ENABLE == 1)
				ubScaleParam = 0;
			#else
				ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) >= 1024)?1:0;
			#endif
			}
			else
			{				
			#if (APP_DUAL_HOST_ENABLE == 1)
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, KNL_SCALE_X1);				
			#else
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
			#endif
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropHstart = 0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;
			sLcdInfor.tChRes[0].uwCropHsize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropVsize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;

			if(KNL_SRC_NONE == ubDisp2Src)
			{
				ubDisp2Src   = KNL_SRC_2_MAIN;			
			#if (APP_DUAL_HOST_ENABLE == 1)
				ubScaleParam = 0;
			#else
				ubScaleParam = (uwKNL_GetVdoH(ubDisp2Src) >= 1024)?1:0;
			#endif
			}
			else
			{				
			#if (APP_DUAL_HOST_ENABLE == 1)
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC,KNL_SCALE_X1);				
			#else
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp2Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
			#endif
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			}
			sLcdInfor.tChRes[1].uwChInputHsize = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwChInputVsize = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwCropHstart = 0;
			sLcdInfor.tChRes[1].uwCropVstart = 0;
			sLcdInfor.tChRes[1].uwCropHsize = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwCropVsize = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;

			if(KNL_SRC_NONE == ubDisp3Src)
			{
				ubDisp3Src   = KNL_SRC_3_MAIN;			
			#if (APP_DUAL_HOST_ENABLE == 1)
				ubScaleParam = 0;
			#else
				ubScaleParam = (uwKNL_GetVdoH(ubDisp3Src) >= 1024)?1:0;
			#endif
			}
			else
			{					
			#if (APP_DUAL_HOST_ENABLE == 1)
				KNL_SetVdoScaleParam(ubDisp3Src, KNL_NODE_H264_DEC, KNL_SCALE_X1);				
			#else
				KNL_SetVdoScaleParam(ubDisp3Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp3Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
			#endif
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp3Src);
			}
			sLcdInfor.tChRes[2].uwChInputHsize = uwKNL_GetVdoH(ubDisp3Src) >> ubScaleParam;
			sLcdInfor.tChRes[2].uwChInputVsize = uwKNL_GetVdoV(ubDisp3Src) >> ubScaleParam;
			sLcdInfor.tChRes[2].uwCropHstart = 0;
			sLcdInfor.tChRes[2].uwCropVstart = 0;
			sLcdInfor.tChRes[2].uwCropHsize = uwKNL_GetVdoH(ubDisp3Src) >> ubScaleParam;
			sLcdInfor.tChRes[2].uwCropVsize = uwKNL_GetVdoV(ubDisp3Src) >> ubScaleParam;

			if(KNL_SRC_NONE == ubDisp4Src)
			{
				ubDisp4Src   = KNL_SRC_4_MAIN;
			
			#if (APP_DUAL_HOST_ENABLE == 1)
				ubScaleParam = 0;
			#else
				ubScaleParam = (uwKNL_GetVdoH(ubDisp4Src) >= 1024)?1:0;
			#endif
			}
			else
			{			
			#if (APP_DUAL_HOST_ENABLE == 1)
				KNL_SetVdoScaleParam(ubDisp4Src, KNL_NODE_H264_DEC, KNL_SCALE_X1);				
			#else
				KNL_SetVdoScaleParam(ubDisp4Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp4Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
			#endif			
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp4Src);
			}
			sLcdInfor.tChRes[3].uwChInputHsize = uwKNL_GetVdoH(ubDisp4Src) >> ubScaleParam;
			sLcdInfor.tChRes[3].uwChInputVsize = uwKNL_GetVdoV(ubDisp4Src) >> ubScaleParam;
			sLcdInfor.tChRes[3].uwCropHstart = 0;
			sLcdInfor.tChRes[3].uwCropVstart = 0;
			sLcdInfor.tChRes[3].uwCropHsize = uwKNL_GetVdoH(ubDisp4Src) >> ubScaleParam;
			sLcdInfor.tChRes[3].uwCropVsize = uwKNL_GetVdoV(ubDisp4Src) >> ubScaleParam;
		}
		else
		{
			sLcdInfor.uwLcdOutputHsize = tKNL_Info.uwDispV;
			sLcdInfor.uwLcdOutputVsize = tKNL_Info.uwDispH;

			ubDisp1Src = (KNL_SRC_NONE == ubDisp1Src)?KNL_SRC_1_MAIN:ubDisp1Src;
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoV(ubDisp1Src);
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoH(ubDisp1Src);
			sLcdInfor.tChRes[0].uwCropHstart = 0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;
			sLcdInfor.tChRes[0].uwCropHsize = uwKNL_GetVdoV(ubDisp1Src);
			sLcdInfor.tChRes[0].uwCropVsize = uwKNL_GetVdoH(ubDisp1Src);

			ubDisp2Src = (KNL_SRC_NONE == ubDisp2Src)?KNL_SRC_2_MAIN:ubDisp2Src;
			sLcdInfor.tChRes[1].uwChInputHsize = uwKNL_GetVdoV(ubDisp2Src);
			sLcdInfor.tChRes[1].uwChInputVsize = uwKNL_GetVdoH(ubDisp2Src);
			sLcdInfor.tChRes[1].uwCropHstart = 0;
			sLcdInfor.tChRes[1].uwCropVstart = 0;
			sLcdInfor.tChRes[1].uwCropHsize = uwKNL_GetVdoV(ubDisp2Src);
			sLcdInfor.tChRes[1].uwCropVsize = uwKNL_GetVdoH(ubDisp2Src);

			ubDisp3Src = (KNL_SRC_NONE == ubDisp3Src)?KNL_SRC_3_MAIN:ubDisp3Src;
			sLcdInfor.tChRes[2].uwChInputHsize = uwKNL_GetVdoV(ubDisp3Src);
			sLcdInfor.tChRes[2].uwChInputVsize = uwKNL_GetVdoH(ubDisp3Src);
			sLcdInfor.tChRes[2].uwCropHstart = 0;
			sLcdInfor.tChRes[2].uwCropVstart = 0;
			sLcdInfor.tChRes[2].uwCropHsize = uwKNL_GetVdoV(ubDisp3Src);
			sLcdInfor.tChRes[2].uwCropVsize = uwKNL_GetVdoH(ubDisp3Src);

			ubDisp4Src = (KNL_SRC_NONE == ubDisp4Src)?KNL_SRC_4_MAIN:ubDisp4Src;
			sLcdInfor.tChRes[3].uwChInputHsize = uwKNL_GetVdoV(ubDisp4Src);
			sLcdInfor.tChRes[3].uwChInputVsize = uwKNL_GetVdoH(ubDisp4Src);
			sLcdInfor.tChRes[3].uwCropHstart = 0;
			sLcdInfor.tChRes[3].uwCropVstart = 0;
			sLcdInfor.tChRes[3].uwCropHsize = uwKNL_GetVdoV(ubDisp4Src);
			sLcdInfor.tChRes[3].uwCropVsize = uwKNL_GetVdoH(ubDisp4Src);
		}		
	}
	else if(tKNL_GetDispType() == KNL_DISP_DUAL_C)
	{
		uint8_t ubScaleParam = 0;
		sLcdInfor.tDispType = LCD_DISP_2T_V;
		sLcdInfor.ubChNum = 2;

		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
		{
			sLcdInfor.uwLcdOutputHsize = tKNL_Info.uwDispH;
			sLcdInfor.uwLcdOutputVsize = tKNL_Info.uwDispV;

			//Source[0]
			ubDisp1Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[0]:ubDisp1Src;
			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src   = KNL_SRC_1_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) >= 1920)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) >= 1920)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropHstart   = 0;	//! (uwKNL_GetVdoH(ubDisp1Src) == 1280)?210:0;
			sLcdInfor.tChRes[0].uwCropVstart   = 0;
			sLcdInfor.tChRes[0].uwCropHsize    = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;	//! (uwKNL_GetVdoH(ubDisp1Src) == 1280)?860:uwKNL_GetVdoH(ubDisp1Src);
			sLcdInfor.tChRes[0].uwCropVsize    = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;

			//Source[1]
			ubDisp2Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[1]:ubDisp2Src;
			if(KNL_SRC_NONE == ubDisp2Src)
			{
				ubDisp2Src   = KNL_SRC_2_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp2Src) >= 1920)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp2Src) >= 1920)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			}
			sLcdInfor.tChRes[1].uwChInputHsize = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwChInputVsize = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwCropHstart   = 0;	//! (uwKNL_GetVdoH(ubDisp2Src) == 1280)?210:0;
			sLcdInfor.tChRes[1].uwCropVstart   = 0;
			sLcdInfor.tChRes[1].uwCropHsize    = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;	//! (uwKNL_GetVdoH(ubDisp2Src) == 1280)?860:uwKNL_GetVdoH(ubDisp2Src);
			sLcdInfor.tChRes[1].uwCropVsize    = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
		}
		else if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)
		{
			sLcdInfor.uwLcdOutputHsize = tKNL_Info.uwDispV;
			sLcdInfor.uwLcdOutputVsize = tKNL_Info.uwDispH;

			//Source[0]
			ubDisp1Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[0]:ubDisp1Src;
			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src   = KNL_SRC_1_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) >= 1920)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) >= 1920)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropHstart = 0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;	//! (uwKNL_GetVdoH(ubDisp1Src) == 1280)?210:0;
			sLcdInfor.tChRes[0].uwCropHsize  = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropVsize  = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;	//! (uwKNL_GetVdoH(ubDisp1Src) == 1280)?860:uwKNL_GetVdoH(ubDisp1Src);

			//Source[1]
			ubDisp2Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[1]:ubDisp2Src;
			if(KNL_SRC_NONE == ubDisp2Src)
			{
				ubDisp2Src   = KNL_SRC_2_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp2Src) >= 1920)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp2Src) >= 1920)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			}
			sLcdInfor.tChRes[1].uwChInputHsize = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwChInputVsize = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwCropHstart = 0;
			sLcdInfor.tChRes[1].uwCropVstart = 0;	//! (uwKNL_GetVdoH(ubDisp2Src) == 1280)?210:0;
			sLcdInfor.tChRes[1].uwCropHsize  = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwCropVsize  = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;	//! (uwKNL_GetVdoH(ubDisp2Src) == 1280)?860:uwKNL_GetVdoH(ubDisp2Src);
		}
		if(TRUE == KNL_SwDispInfo.ubSetupFlag)
		{
			LCD_CH_TYP tCh;
			uint8_t ubRole[2], ubIdx;

			if(TRUE == ubDualDectFlag)
			{
				for(ubIdx = 0; ubIdx < 2; ubIdx++)
				{
#if defined(BSP_DVR_SDK)
				    if(ubKNL_GetSrcNumPosition(KNL_SwDispInfo.tSrcNum[ubIdx]) == KNL_REMOTE)
                        continue;
#endif
					ubRole[ubIdx] = ubKNL_SrcNumMap(KNL_SwDispInfo.tSrcNum[ubIdx]);
				#ifdef RTC676x
					if(FALSE == tSrcLocate.ubFixDispChFlag)
				#endif
					{
						if(ubKNL_GetCommLinkStatus(ubRole[ubIdx]) == BB_LOST_LINK)
						{
							tCh = (KNL_DISP_LOCATION1 == KNL_SwDispInfo.tSrcLocate[ubIdx])?LCD_CH0:LCD_CH1;
							LCD_ChDisable(tCh);
						}
					}
				}
			}
			else
				ubDualDectFlag = TRUE;
		}
		else
			KNL_SwDispInfo.tSrcNum[0] = KNL_SwDispInfo.tSrcNum[1] = KNL_SRC_NONE;
		KNL_SwDispInfo.tSrcNum[2] = KNL_SwDispInfo.tSrcNum[3] = KNL_SRC_NONE;
		KNL_SwDispInfo.tSrcLocate[2] = KNL_SwDispInfo.tSrcLocate[3] = KNL_DISP_LOCATION_ERR;
#if defined(BSP_DVR_SDK)
		KNL_SwDispInfo.ubSetupFlag = FALSE;
#endif
	}
	else if(tKNL_GetDispType() == KNL_DISP_3T_3C)
	{		
		//sLcdInfor.tDispType = LCD_DISP_3TC;
		sLcdInfor.tDispType = LCD_DISP_3TC_SHOW_111;
		
		sLcdInfor.ubChNum = 3;
		sLcdInfor.uwLcdOutputHsize = uwLCD_GetLcdHoSize();
		sLcdInfor.uwLcdOutputVsize = uwLCD_GetLcdVoSize();	
	
		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)
		{
			//90 rotation
			//Get Correspond Source
			ubDisp1Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
			ubDisp2Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION2);
			ubDisp3Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION3);
			ubDisp4Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION4);						
				
			//Source[0]
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoV(ubDisp1Src)/2;
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoH(ubDisp1Src)/2;			
			sLcdInfor.tChRes[0].uwCropHstart = 0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;		
			sLcdInfor.tChRes[0].uwCropHsize = uwKNL_GetVdoV(ubDisp1Src)/2;
			sLcdInfor.tChRes[0].uwCropVsize = uwKNL_GetVdoH(ubDisp1Src)/2;

			//Source[1]
			sLcdInfor.tChRes[1].uwChInputHsize = uwKNL_GetVdoV(ubDisp2Src)/2;
			sLcdInfor.tChRes[1].uwChInputVsize = uwKNL_GetVdoH(ubDisp2Src)/2;			
			sLcdInfor.tChRes[1].uwCropHstart = 0;
			sLcdInfor.tChRes[1].uwCropVstart = 0;		
			sLcdInfor.tChRes[1].uwCropHsize = uwKNL_GetVdoV(ubDisp2Src)/2;
			sLcdInfor.tChRes[1].uwCropVsize = uwKNL_GetVdoH(ubDisp2Src)/2;	

			//Source[2]
			sLcdInfor.tChRes[2].uwChInputHsize = uwKNL_GetVdoV(ubDisp3Src)/2;
			sLcdInfor.tChRes[2].uwChInputVsize = uwKNL_GetVdoH(ubDisp3Src)/2;			
			sLcdInfor.tChRes[2].uwCropHstart = 0;
			sLcdInfor.tChRes[2].uwCropVstart = 0;		
			sLcdInfor.tChRes[2].uwCropHsize = uwKNL_GetVdoV(ubDisp3Src)/2;
			sLcdInfor.tChRes[2].uwCropVsize = uwKNL_GetVdoH(ubDisp3Src)/2;
		
			KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, KNL_SCALE_X0P5);
			KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, KNL_SCALE_X0P5);
			KNL_SetVdoScaleParam(ubDisp3Src, KNL_NODE_H264_DEC, KNL_SCALE_X0P5);			
			
		}				
	}	
	else if(tKNL_GetDispType() == KNL_DISP_H)
	{
		uint8_t ubScaleParam = 0;

		sLcdInfor.ubChNum = 3;
		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
		{
			uint8_t ubScaleDmy1Param = 0, ubScaleDmy2Param = 0;

			sLcdInfor.tDispType = LCD_DISP_3T_2PIP;
			sLcdInfor.uwLcdOutputHsize = tKNL_Info.uwDispH;
			sLcdInfor.uwLcdOutputVsize = tKNL_Info.uwDispV;

			//Source[0]
			if(KNL_SRC_NONE == ubDisp2Src)
			{
				ubDisp2Src   = KNL_SRC_2_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp2Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp2Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			}
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropHstart = 0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;
			sLcdInfor.tChRes[0].uwCropHsize = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropVsize = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;

			//Source[1]
			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src = KNL_SRC_1_MAIN;
				ubScaleDmy1Param = (uwKNL_GetVdoH(ubDisp1Src) > 1024)?2:1;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) > 1024)?KNL_SCALE_X0P25:KNL_SCALE_X0P5));
				ubScaleDmy1Param = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}
			if(KNL_SRC_NONE == ubDisp4Src)
			{
				ubDisp4Src = KNL_SRC_4_MAIN;
				ubScaleDmy2Param = (uwKNL_GetVdoH(ubDisp4Src) > 1024)?2:1;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp4Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp4Src) > 1024)?KNL_SCALE_X0P25:KNL_SCALE_X0P5));
				ubScaleDmy2Param = ubKNL_GetVdoScaleParam(ubDisp4Src);
			}
			KNL_SetLcdDmyImgH((uwKNL_GetVdoH(ubDisp1Src) >> ubScaleDmy1Param) * 2);
			sLcdInfor.tChRes[1].uwChInputHsize = (uwKNL_GetVdoH(ubDisp1Src) >> ubScaleDmy1Param) + uwKNL_GetLcdDmyImgH() + (uwKNL_GetVdoH(ubDisp4Src) >> ubScaleDmy2Param);
			sLcdInfor.tChRes[1].uwChInputVsize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleDmy1Param;
			sLcdInfor.tChRes[1].uwCropHstart = 0;
			sLcdInfor.tChRes[1].uwCropVstart = 0;
			sLcdInfor.tChRes[1].uwCropHsize = (uwKNL_GetVdoH(ubDisp1Src) >> ubScaleDmy1Param) + uwKNL_GetLcdDmyImgH() + (uwKNL_GetVdoH(ubDisp4Src) >> ubScaleDmy2Param);
			sLcdInfor.tChRes[1].uwCropVsize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleDmy1Param;

			//Source[2]
			if(KNL_SRC_NONE == ubDisp3Src)
			{
				ubDisp3Src   = KNL_SRC_3_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp3Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp3Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp3Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp3Src);
			}
			sLcdInfor.tChRes[2].uwChInputHsize = uwKNL_GetVdoH(ubDisp3Src) >> ubScaleParam;
			sLcdInfor.tChRes[2].uwChInputVsize = uwKNL_GetVdoV(ubDisp3Src) >> ubScaleParam;
			sLcdInfor.tChRes[2].uwCropHstart = 0;
			sLcdInfor.tChRes[2].uwCropVstart = 0;
			sLcdInfor.tChRes[2].uwCropHsize = uwKNL_GetVdoH(ubDisp3Src) >> ubScaleParam;
			sLcdInfor.tChRes[2].uwCropVsize = uwKNL_GetVdoV(ubDisp3Src) >> ubScaleParam;
		}
		else if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)
		{
			//sLcdInfor.tDispType = LCD_DISP_3TC;
			sLcdInfor.tDispType = LCD_DISP_3TC_SHOW_121;
			sLcdInfor.uwLcdOutputHsize = tKNL_Info.uwDispV;
			sLcdInfor.uwLcdOutputVsize = tKNL_Info.uwDispH;

			//Source[0]
			ubDisp1Src   = (KNL_SRC_NONE == ubDisp1Src)?KNL_SRC_1_MAIN:ubDisp1Src;
			ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropHstart = 0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;
			sLcdInfor.tChRes[0].uwCropHsize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropVsize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;

			//Source[1]
			ubDisp2Src   = (KNL_SRC_NONE == ubDisp2Src)?KNL_SRC_2_MAIN:ubDisp2Src;			
			ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			sLcdInfor.tChRes[1].uwChInputHsize = uwKNL_GetVdoV(ubDisp2Src) * (2 >> ubScaleParam);
			sLcdInfor.tChRes[1].uwChInputVsize = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwCropHstart = 0;
			sLcdInfor.tChRes[1].uwCropVstart = 0;
			sLcdInfor.tChRes[1].uwCropHsize = uwKNL_GetVdoV(ubDisp2Src) * (2 >> ubScaleParam);
			sLcdInfor.tChRes[1].uwCropVsize = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;

			//Source[2]
			ubDisp4Src   = (KNL_SRC_NONE == ubDisp4Src)?KNL_SRC_4_MAIN:ubDisp4Src;
			ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp4Src);
			sLcdInfor.tChRes[2].uwChInputHsize = uwKNL_GetVdoV(ubDisp4Src) >> ubScaleParam;
			sLcdInfor.tChRes[2].uwChInputVsize = uwKNL_GetVdoH(ubDisp4Src) >> ubScaleParam;
			sLcdInfor.tChRes[2].uwCropHstart = 0;
			sLcdInfor.tChRes[2].uwCropVstart = 0;
			sLcdInfor.tChRes[2].uwCropHsize = uwKNL_GetVdoV(ubDisp4Src) >> ubScaleParam;
			sLcdInfor.tChRes[2].uwCropVsize = uwKNL_GetVdoH(ubDisp4Src) >> ubScaleParam;
		}
	}
	else if((tDispType == KNL_DISP_3T_2L1R) || (tDispType == KNL_DISP_3T_1L2R) ||
		    (tDispType == KNL_DISP_3T_2T1B) || (tDispType == KNL_DISP_3T_1T2B))
	{
		KNL_DISP_ROTATE tDispRot = KNL_DISP_ROTATE_0;
		uint8_t ubScaleParam = 0;

		tDispRot = tKNL_GetDispRotate();
		sLcdInfor.uwLcdOutputHsize = (tDispRot == KNL_DISP_ROTATE_90)?tKNL_Info.uwDispV:tKNL_Info.uwDispH;
		sLcdInfor.uwLcdOutputVsize = (tDispRot == KNL_DISP_ROTATE_90)?tKNL_Info.uwDispH:tKNL_Info.uwDispV;
		if((((tDispType == KNL_DISP_3T_2L1R) || (tDispType == KNL_DISP_3T_1L2R)) && (tDispRot == KNL_DISP_ROTATE_0)) ||
		   (((tDispType == KNL_DISP_3T_2T1B) || (tDispType == KNL_DISP_3T_1T2B)) && (tDispRot == KNL_DISP_ROTATE_90)))
		{
			sLcdInfor.ubChNum = 3;
			sLcdInfor.tDispType = (tDispRot == KNL_DISP_ROTATE_90)?(KNL_DISP_3T_2T1B == tDispType)?LCD_DISP_3T_2L1R:LCD_DISP_3T_1L2R:
													               (KNL_DISP_3T_2L1R == tDispType)?LCD_DISP_3T_2L1R:LCD_DISP_3T_1L2R;
			//! CH0
			ubDisp1Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[0]:ubDisp1Src;
			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src   = KNL_SRC_1_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}
			sLcdInfor.tChRes[0].uwChInputHsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoV(ubDisp1Src):uwKNL_GetVdoH(ubDisp1Src)) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwChInputVsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoH(ubDisp1Src):uwKNL_GetVdoV(ubDisp1Src)) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropHstart = 0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;
			sLcdInfor.tChRes[0].uwCropHsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoV(ubDisp1Src):uwKNL_GetVdoH(ubDisp1Src)) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropVsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoH(ubDisp1Src):uwKNL_GetVdoV(ubDisp1Src)) >> ubScaleParam;
			//! CH2
			ubDisp2Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[1]:ubDisp2Src;
			if(KNL_SRC_NONE == ubDisp2Src)
			{
				ubDisp2Src   = KNL_SRC_2_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp2Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp2Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			}
			sLcdInfor.tChRes[2].uwChInputHsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoV(ubDisp2Src):uwKNL_GetVdoH(ubDisp2Src)) >> ubScaleParam;
			sLcdInfor.tChRes[2].uwChInputVsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoH(ubDisp2Src):uwKNL_GetVdoV(ubDisp2Src)) >> ubScaleParam;
			sLcdInfor.tChRes[2].uwCropHstart = 0;
			sLcdInfor.tChRes[2].uwCropVstart = 0;
			sLcdInfor.tChRes[2].uwCropHsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoV(ubDisp2Src):uwKNL_GetVdoH(ubDisp2Src)) >> ubScaleParam;
			sLcdInfor.tChRes[2].uwCropVsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoH(ubDisp2Src):uwKNL_GetVdoV(ubDisp2Src)) >> ubScaleParam;
			//! CH1
			ubDisp3Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[2]:ubDisp3Src;
			if(KNL_SRC_NONE == ubDisp3Src)
			{
				ubDisp3Src   = KNL_SRC_3_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp3Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp3Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp3Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp3Src);
			}
			sLcdInfor.tChRes[1].uwChInputHsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoV(ubDisp3Src):uwKNL_GetVdoH(ubDisp3Src)) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwChInputVsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoH(ubDisp3Src):uwKNL_GetVdoV(ubDisp3Src)) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwCropHstart = 0;
			sLcdInfor.tChRes[1].uwCropVstart = 0;
			sLcdInfor.tChRes[1].uwCropHsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoV(ubDisp3Src):uwKNL_GetVdoH(ubDisp3Src)) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwCropVsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoH(ubDisp3Src):uwKNL_GetVdoV(ubDisp3Src)) >> ubScaleParam;
		}
		else
		{
			uint8_t ubLcdCh = 0;
			sLcdInfor.ubChNum = 2;
			sLcdInfor.tDispType = LCD_DISP_2T_V;
			//! CH0/1
			ubDisp1Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[0]:ubDisp1Src;
			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src   = KNL_SRC_1_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}
			ubLcdCh = ((KNL_DISP_3T_1L2R == tDispType) || (KNL_DISP_3T_2T1B == tDispType))?1:0;
			sLcdInfor.tChRes[ubLcdCh].uwChInputHsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoV(ubDisp1Src):uwKNL_GetVdoH(ubDisp1Src)) >> ubScaleParam;
			sLcdInfor.tChRes[ubLcdCh].uwChInputVsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoH(ubDisp1Src):uwKNL_GetVdoV(ubDisp1Src)) >> ubScaleParam;
			sLcdInfor.tChRes[ubLcdCh].uwCropHstart = 0;
			sLcdInfor.tChRes[ubLcdCh].uwCropVstart = 0;		
			sLcdInfor.tChRes[ubLcdCh].uwCropHsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoV(ubDisp1Src):uwKNL_GetVdoH(ubDisp1Src)) >> ubScaleParam;
			sLcdInfor.tChRes[ubLcdCh].uwCropVsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoH(ubDisp1Src):uwKNL_GetVdoV(ubDisp1Src)) >> ubScaleParam;
			//! CH1/0
			ubDisp2Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[1]:ubDisp2Src;
			if(KNL_SRC_NONE == ubDisp2Src)
			{
				ubDisp2Src   = KNL_SRC_2_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp2Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp2Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			}
			ubDisp3Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[2]:ubDisp3Src;
			if(KNL_SRC_NONE == ubDisp3Src)
				ubDisp3Src   = KNL_SRC_3_MAIN;
			else
				KNL_SetVdoScaleParam(ubDisp3Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp3Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
			ubLcdCh = ((KNL_DISP_3T_1L2R == tDispType) || (KNL_DISP_3T_2T1B == tDispType))?0:1;
			sLcdInfor.tChRes[ubLcdCh].uwChInputHsize = (tDispRot == KNL_DISP_ROTATE_90)?(uwKNL_GetVdoV(ubDisp2Src) * (2 >> ubScaleParam)):(uwKNL_GetVdoH(ubDisp2Src) * (2 >> ubScaleParam));
			sLcdInfor.tChRes[ubLcdCh].uwChInputVsize = (tDispRot == KNL_DISP_ROTATE_90)?(uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam):(uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam);
			sLcdInfor.tChRes[ubLcdCh].uwCropHstart   = 0;
			sLcdInfor.tChRes[ubLcdCh].uwCropVstart   = 0;
			sLcdInfor.tChRes[ubLcdCh].uwCropHsize    = (tDispRot == KNL_DISP_ROTATE_90)?(uwKNL_GetVdoV(ubDisp2Src) * (2 >> ubScaleParam)):(uwKNL_GetVdoH(ubDisp2Src) * (2 >> ubScaleParam));
			sLcdInfor.tChRes[ubLcdCh].uwCropVsize    = (tDispRot == KNL_DISP_ROTATE_90)?(uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam):(uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam);
		}
		KNL_SwDispInfo.tSrcNum[3] = KNL_SRC_NONE;
		KNL_SwDispInfo.tSrcLocate[3] = KNL_DISP_LOCATION_ERR;
	}
	else if(tDispType == KNL_DISP_3T_3COL)
	{
		KNL_DISP_ROTATE tDispRot = KNL_DISP_ROTATE_0;
		uint8_t ubScaleParam = 0;

		tDispRot = tKNL_GetDispRotate();
		if(KNL_DISP_ROTATE_0 == tDispRot)
		{
			sLcdInfor.ubChNum = 2;
			sLcdInfor.tDispType = LCD_DISP_2T_H12;
			sLcdInfor.uwLcdOutputHsize = tKNL_Info.uwDispH;
			sLcdInfor.uwLcdOutputVsize = tKNL_Info.uwDispV;
			//! CH0
			ubDisp1Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[0]:ubDisp1Src;
			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src   = KNL_SRC_1_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropHstart = 0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;		
			sLcdInfor.tChRes[0].uwCropHsize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropVsize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			//! CH1
			ubDisp2Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[1]:ubDisp2Src;
			if(KNL_SRC_NONE == ubDisp2Src)
			{
				ubDisp2Src   = KNL_SRC_2_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp2Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp2Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			}
			ubDisp3Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[2]:ubDisp3Src;
			if(KNL_SRC_NONE == ubDisp3Src)
				ubDisp3Src   = KNL_SRC_3_MAIN;
			else
				KNL_SetVdoScaleParam(ubDisp3Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp3Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
			sLcdInfor.tChRes[1].uwChInputHsize = uwKNL_GetVdoH(ubDisp2Src) * (2 >> ubScaleParam);
			sLcdInfor.tChRes[1].uwChInputVsize = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwCropHstart   = 0;
			sLcdInfor.tChRes[1].uwCropVstart   = 0;
			sLcdInfor.tChRes[1].uwCropHsize    = uwKNL_GetVdoH(ubDisp2Src) * (2 >> ubScaleParam);
			sLcdInfor.tChRes[1].uwCropVsize    = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
		}
		else if(KNL_DISP_ROTATE_90 == tDispRot)
		{
			sLcdInfor.ubChNum = 3;
			sLcdInfor.tDispType = LCD_DISP_3TC_SHOW_111;
			sLcdInfor.uwLcdOutputHsize = tKNL_Info.uwDispV;
			sLcdInfor.uwLcdOutputVsize = tKNL_Info.uwDispH;
			//! CH0
			ubDisp3Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[2]:ubDisp3Src;
			if(KNL_SRC_NONE == ubDisp3Src)
			{
				ubDisp3Src   = KNL_SRC_3_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp3Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp3Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp3Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp3Src);
			}
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoV(ubDisp3Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoH(ubDisp3Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropHstart   = 0;
			sLcdInfor.tChRes[0].uwCropVstart   = 0;
			sLcdInfor.tChRes[0].uwCropHsize    = uwKNL_GetVdoV(ubDisp3Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropVsize    = uwKNL_GetVdoH(ubDisp3Src) >> ubScaleParam;
			//! CH1
			ubDisp2Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[1]:ubDisp2Src;
			if(KNL_SRC_NONE == ubDisp2Src)
			{
				ubDisp2Src   = KNL_SRC_2_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp2Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp2Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			}
			sLcdInfor.tChRes[1].uwChInputHsize = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwChInputVsize = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwCropHstart   = 0;
			sLcdInfor.tChRes[1].uwCropVstart   = 0;
			sLcdInfor.tChRes[1].uwCropHsize    = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwCropVsize    = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;
			//! CH2
			ubDisp1Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[0]:ubDisp1Src;
			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src   = KNL_SRC_1_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}
			sLcdInfor.tChRes[2].uwChInputHsize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[2].uwChInputVsize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[2].uwCropHstart   = 0;
			sLcdInfor.tChRes[2].uwCropVstart   = 0;
			sLcdInfor.tChRes[2].uwCropHsize    = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[2].uwCropVsize    = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
		}
		KNL_SwDispInfo.tSrcNum[3] = KNL_SRC_NONE;
		KNL_SwDispInfo.tSrcLocate[3] = KNL_DISP_LOCATION_ERR;
	}

	if(NULL == pLcdCropScaleParam)
		pLcdCropScaleParam = (LCD_INFOR_TYP *)(&sLcdInfor);
	else
		memcpy(pLcdCropScaleParam, &sLcdInfor, sizeof(LCD_INFOR_TYP));

	if(TRUE == ubKNL_LcdDispChgFlag)
	{
#if (defined(BUC_CU) && (!defined(S2019A)))
	    KNL_VdoCodecProcOff();
#endif
		BUF_ResetFreeAddr();
		KNL_BufInit();
		ubKNL_LcdDispChgFlag = FALSE;
#if (defined(BUC_CU) && (!defined(S2019A)))
        KNL_VdoCodecProcOn();
#endif
	}

	ubKNL_LcdDispParamActiveFlg = 1;
	//Step3
	ubKNL_DispCh0ActiveFlg = 1;
	ubKNL_DispCh1ActiveFlg = 1;
	ubKNL_DispCh2ActiveFlg = 1;
	ubKNL_DispCh3ActiveFlg = 1;

	osSemaphoreRelease(osKNL_LcdDispInfoSem);
#endif
}
//------------------------------------------------------------------------------
uint32_t ulKNL_CalLcdBufSz(void)
{
#if KNL_LCD_FUNC_ENABLE
	LCD_CALBUF_TYP	sInfor;
	KNL_DISP_TYPE tDispType;
	uint8_t ubDisp1Src;
	uint8_t ubDisp2Src;
	uint8_t ubDisp3Src;
	uint8_t ubDisp4Src;		

	sInfor.uwLcdHSize = tKNL_Info.uwDispH;	//Target H of LCD
	sInfor.uwLcdVSize = tKNL_Info.uwDispV;	//Target V of LCD

	//Get Correspond Source
	ubDisp1Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
	ubDisp2Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION2);
	ubDisp3Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION3);
	ubDisp4Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION4);

	tDispType = tKNL_GetDispType();
	if(tDispType == KNL_DISP_SINGLE)
	{
		sInfor.ubChMax = 1;

		//For 0
		if(ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)
		{
			sInfor.tInput[0].bJpegEn = FALSE;
		}
		else
		{
			sInfor.tInput[0].bJpegEn = TRUE;
		}
#if (defined(OP_AP) && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
		if(!(tKNL_RecordAct.tSimFolder == KNL_SIM_FLD && tKNL_GetRecordFunc() == KNL_VIDEO_PLAY))
#endif
		    ubDisp1Src = (KNL_SRC_NONE != KNL_SwDispInfo.tSrcNum[0])?KNL_SwDispInfo.tSrcNum[0]:(KNL_SRC_NONE != ubDisp1Src)?ubDisp1Src:KNL_SRC_1_MAIN;
		sInfor.tInput[0].uwHSize = (KNL_SRC_NONE == ubDisp1Src)?sInfor.uwLcdHSize:uwKNL_GetVdoH(ubDisp1Src);
		sInfor.tInput[0].uwVSize = (KNL_SRC_NONE == ubDisp1Src)?sInfor.uwLcdVSize:uwKNL_GetVdoV(ubDisp1Src);
	}
	else if(tDispType == KNL_DISP_DUAL_U)
	{
		sInfor.ubChMax = 2;
		
		//For 0
		if(ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)
		{
			sInfor.tInput[0].bJpegEn = FALSE;
		}
		else
		{
			sInfor.tInput[0].bJpegEn = TRUE;
		}
		ubDisp1Src = (KNL_SRC_NONE != KNL_SwDispInfo.tSrcNum[0])?KNL_SwDispInfo.tSrcNum[0]:(KNL_SRC_NONE != ubDisp1Src)?ubDisp1Src:KNL_SRC_1_MAIN;
		sInfor.tInput[0].uwHSize = (KNL_SRC_NONE == ubDisp1Src)?sInfor.uwLcdHSize:uwKNL_GetVdoH(ubDisp1Src);
		sInfor.tInput[0].uwVSize = (KNL_SRC_NONE == ubDisp1Src)?sInfor.uwLcdVSize:uwKNL_GetVdoV(ubDisp1Src);
		
		//For 1
		if(ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)
		{
			sInfor.tInput[1].bJpegEn = FALSE;
		}
		else
		{
			sInfor.tInput[1].bJpegEn = TRUE;
		}
		ubDisp2Src = (KNL_SRC_NONE != KNL_SwDispInfo.tSrcNum[1])?KNL_SwDispInfo.tSrcNum[1]:(KNL_SRC_NONE != ubDisp2Src)?ubDisp2Src:KNL_SRC_2_MAIN;
		sInfor.tInput[1].uwHSize = (KNL_SRC_NONE == ubDisp2Src)?sInfor.uwLcdHSize:uwKNL_GetVdoH(ubDisp2Src);
		sInfor.tInput[1].uwVSize = (KNL_SRC_NONE == ubDisp2Src)?sInfor.uwLcdVSize:uwKNL_GetVdoV(ubDisp2Src);
	}
	else if(tDispType == KNL_DISP_QUAD)
	{
		uint8_t ubScaleParam = 0;

		sInfor.ubChMax = 4;
		
		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
		{			
			//For 0
			if(ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)
			{
				sInfor.tInput[0].bJpegEn = FALSE;
			}
			else
			{
				sInfor.tInput[0].bJpegEn = TRUE;
			}
			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src   = KNL_SRC_1_MAIN;
			
			#if (APP_DUAL_HOST_ENABLE == 1)
				ubScaleParam = 0;
			#else		
				ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) >= 1024)?1:0;
			#endif
			}
			else
			{			
			#if (APP_DUAL_HOST_ENABLE == 1)
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, KNL_SCALE_X1);			
			#else
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
			#endif
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}
			sInfor.tInput[0].uwHSize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
			sInfor.tInput[0].uwVSize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			
			//For 1
			if(ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)
			{
				sInfor.tInput[1].bJpegEn = FALSE;
			}
			else
			{
				sInfor.tInput[1].bJpegEn = TRUE;
			}
			if(KNL_SRC_NONE == ubDisp2Src)
			{
				ubDisp2Src   = KNL_SRC_2_MAIN;
			
			#if (APP_DUAL_HOST_ENABLE == 1)
				ubScaleParam = 0;
			#else
				ubScaleParam = (uwKNL_GetVdoH(ubDisp2Src) >= 1024)?1:0;
			#endif
			}
			else
			{
			
			#if (APP_DUAL_HOST_ENABLE == 1)
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, KNL_SCALE_X1);
			#else
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp2Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
			#endif
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			}
			sInfor.tInput[1].uwHSize = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;
			sInfor.tInput[1].uwVSize = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
			
			//For 2
			if(ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)
			{
				sInfor.tInput[2].bJpegEn = FALSE;
			}
			else
			{
				sInfor.tInput[2].bJpegEn = TRUE;
			}
			if(KNL_SRC_NONE == ubDisp3Src)
			{
				ubDisp3Src   = KNL_SRC_3_MAIN;
			
			#if (APP_DUAL_HOST_ENABLE == 1)
				ubScaleParam = 0;
			#else
				ubScaleParam = (uwKNL_GetVdoH(ubDisp3Src) >= 1024)?1:0;
			#endif
			}
			else
			{
					
			#if (APP_DUAL_HOST_ENABLE == 1)
				KNL_SetVdoScaleParam(ubDisp3Src, KNL_NODE_H264_DEC, KNL_SCALE_X1);
			#else
				KNL_SetVdoScaleParam(ubDisp3Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp3Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
			#endif
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp3Src);
			}
			sInfor.tInput[2].uwHSize = uwKNL_GetVdoH(ubDisp3Src) >> ubScaleParam;
			sInfor.tInput[2].uwVSize = uwKNL_GetVdoV(ubDisp3Src) >> ubScaleParam;
			
			//For 3
			if(ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)
			{
				sInfor.tInput[3].bJpegEn = FALSE;
			}
			else
			{
				sInfor.tInput[3].bJpegEn = TRUE;
			}
			if(KNL_SRC_NONE == ubDisp4Src)
			{
				ubDisp4Src   = KNL_SRC_4_MAIN;
			
			#if (APP_DUAL_HOST_ENABLE == 1)
				ubScaleParam = 0;
			#else
				ubScaleParam = (uwKNL_GetVdoH(ubDisp4Src) >= 1024)?1:0;
			#endif
			}
			else
			{
			
			#if (APP_DUAL_HOST_ENABLE == 1)
				KNL_SetVdoScaleParam(ubDisp4Src, KNL_NODE_H264_DEC, KNL_SCALE_X1);			
			#else
				KNL_SetVdoScaleParam(ubDisp4Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp4Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
			#endif
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp4Src);
			}
			sInfor.tInput[3].uwHSize = uwKNL_GetVdoH(ubDisp4Src) >> ubScaleParam;
			sInfor.tInput[3].uwVSize = uwKNL_GetVdoV(ubDisp4Src) >> ubScaleParam;
		}
		else
		{
			//For 0
			if(ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)
			{
				sInfor.tInput[0].bJpegEn = FALSE;
			}
			else
			{
				sInfor.tInput[0].bJpegEn = TRUE;
			}
			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src   = KNL_SRC_1_MAIN;
			
			#if (APP_DUAL_HOST_ENABLE == 1)
				ubScaleParam = 0;
			#else		
				ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) >= 1024)?1:0;
			#endif
			}
			else
			{
			
			#if (APP_DUAL_HOST_ENABLE == 1)
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, KNL_SCALE_X1);			
			#else
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
			#endif
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}			
			sInfor.tInput[0].uwHSize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			sInfor.tInput[0].uwVSize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
			
			//For 1
			if(ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)
			{
				sInfor.tInput[1].bJpegEn = FALSE;
			}
			else
			{
				sInfor.tInput[1].bJpegEn = TRUE;
			}
			if(KNL_SRC_NONE == ubDisp2Src)
			{
				ubDisp2Src   = KNL_SRC_2_MAIN;
			
			#if (APP_DUAL_HOST_ENABLE == 1)
				ubScaleParam = 0;
			#else
				ubScaleParam = (uwKNL_GetVdoH(ubDisp2Src) >= 1024)?1:0;
			#endif
			}
			else
			{
			
			#if (APP_DUAL_HOST_ENABLE == 1)
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, KNL_SCALE_X1);
			#else
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp2Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
			#endif
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			}			
			sInfor.tInput[1].uwHSize = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
			sInfor.tInput[1].uwVSize = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;
			
			//For 2
			if(ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)
			{
				sInfor.tInput[2].bJpegEn = FALSE;
			}
			else
			{
				sInfor.tInput[2].bJpegEn = TRUE;
			}
			if(KNL_SRC_NONE == ubDisp3Src)
			{
				ubDisp3Src   = KNL_SRC_3_MAIN;
			
			#if (APP_DUAL_HOST_ENABLE == 1)
				ubScaleParam = 0;
			#else
				ubScaleParam = (uwKNL_GetVdoH(ubDisp3Src) >= 1024)?1:0;
			#endif
			}
			else
			{
				
			#if (APP_DUAL_HOST_ENABLE == 1)
				KNL_SetVdoScaleParam(ubDisp3Src, KNL_NODE_H264_DEC, KNL_SCALE_X1);
			#else
				KNL_SetVdoScaleParam(ubDisp3Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp3Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
			#endif
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp3Src);
			}			
			sInfor.tInput[2].uwHSize = uwKNL_GetVdoV(ubDisp3Src) >> ubScaleParam;
			sInfor.tInput[2].uwVSize = uwKNL_GetVdoH(ubDisp3Src) >> ubScaleParam;
			
			//For 3
			if(ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)
			{
				sInfor.tInput[3].bJpegEn = FALSE;
			}
			else
			{
				sInfor.tInput[3].bJpegEn = TRUE;
			}
			if(KNL_SRC_NONE == ubDisp4Src)
			{
				ubDisp4Src   = KNL_SRC_4_MAIN;
		
			#if (APP_DUAL_HOST_ENABLE == 1)
				ubScaleParam = 0;
			#else
				ubScaleParam = (uwKNL_GetVdoH(ubDisp4Src) >= 1024)?1:0;
			#endif
			}
			else
			{
			
			#if (APP_DUAL_HOST_ENABLE == 1)
				KNL_SetVdoScaleParam(ubDisp4Src, KNL_NODE_H264_DEC, KNL_SCALE_X1);			
			#else
				KNL_SetVdoScaleParam(ubDisp4Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp4Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
			#endif
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp4Src);
			}			
			sInfor.tInput[3].uwHSize = uwKNL_GetVdoV(ubDisp4Src) >> ubScaleParam;
			sInfor.tInput[3].uwVSize = uwKNL_GetVdoH(ubDisp4Src) >> ubScaleParam;
		}
	}
	else if(tDispType == KNL_DISP_H)
	{
		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
		{
			uint8_t ubScaleDmy1Param = 0, ubScaleDmy2Param = 0, ubScaleParam = 0;

			sInfor.ubChMax = 3;

			//For 0
			if(ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)
			{
				sInfor.tInput[0].bJpegEn = FALSE;
			}
			else
			{
				sInfor.tInput[0].bJpegEn = TRUE;
			}
			if(KNL_SRC_NONE == ubDisp2Src)
			{
				ubDisp2Src   = KNL_SRC_2_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp2Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp2Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			}
			sInfor.tInput[0].uwHSize = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;
			sInfor.tInput[0].uwVSize = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;

			//For 1
			if(ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)
			{
				sInfor.tInput[1].bJpegEn = FALSE;
			}
			else
			{
				sInfor.tInput[1].bJpegEn = TRUE;
			}
			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src   = KNL_SRC_1_MAIN;
				ubScaleDmy1Param = (uwKNL_GetVdoH(ubDisp1Src) > 1024)?2:1;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) > 1024)?KNL_SCALE_X0P25:KNL_SCALE_X0P5));
				ubScaleDmy1Param = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}
			if(KNL_SRC_NONE == ubDisp4Src)
			{
				ubDisp4Src   = KNL_SRC_4_MAIN;
				ubScaleDmy2Param = (uwKNL_GetVdoH(ubDisp4Src) > 1024)?2:1;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp4Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp4Src) > 1024)?KNL_SCALE_X0P25:KNL_SCALE_X0P5));
				ubScaleDmy2Param = ubKNL_GetVdoScaleParam(ubDisp4Src);
			}
			KNL_SetLcdDmyImgH((uwKNL_GetVdoH(ubDisp1Src) >> ubScaleDmy1Param) * 2);
			sInfor.tInput[1].uwHSize = (uwKNL_GetVdoH(ubDisp1Src) >> ubScaleDmy1Param) + uwKNL_GetLcdDmyImgH() + (uwKNL_GetVdoH(ubDisp4Src) >> ubScaleDmy2Param);
			sInfor.tInput[1].uwVSize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleDmy1Param;

			//For 2
			if(ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)
			{
				sInfor.tInput[2].bJpegEn = FALSE;
			}
			else
			{
				sInfor.tInput[2].bJpegEn = TRUE;
			}
			if(KNL_SRC_NONE == ubDisp3Src)
			{
				ubDisp3Src   = KNL_SRC_3_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp3Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp3Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp3Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp3Src);
			}
			sInfor.tInput[2].uwHSize = uwKNL_GetVdoH(ubDisp3Src) >> ubScaleParam;
			sInfor.tInput[2].uwVSize = uwKNL_GetVdoV(ubDisp3Src) >> ubScaleParam;
		}
		else if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)
		{
			uint8_t ubScaleParam = 0;

			// For LCD IP	
			// -----------------
			// | 	           |
			// |	  CH0      |
			// | 	           |
			// |---------------|
			// |               |
			// |	  CH1      |
			// |	           |
			// -----------------			
			// |               |
			// |	  CH2      |
			// |	           |
			// -----------------
			sInfor.ubChMax = 3;

			ubDisp1Src = (KNL_SRC_NONE == ubDisp1Src)?KNL_SRC_1_MAIN:ubDisp1Src;
			ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
			sInfor.tInput[0].bJpegEn = FALSE;
			sInfor.tInput[0].uwHSize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			sInfor.tInput[0].uwVSize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
			ubDisp2Src = (KNL_SRC_NONE == ubDisp2Src)?KNL_SRC_2_MAIN:ubDisp2Src;
			ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			sInfor.tInput[1].bJpegEn = FALSE;
			sInfor.tInput[1].uwHSize = uwKNL_GetVdoV(ubDisp2Src) * (2 >> ubScaleParam);
			sInfor.tInput[1].uwVSize = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;
			ubDisp4Src = (KNL_SRC_NONE == ubDisp4Src)?KNL_SRC_4_MAIN:ubDisp4Src;
			ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp4Src);
			sInfor.tInput[2].bJpegEn = FALSE;
			sInfor.tInput[2].uwHSize = uwKNL_GetVdoV(ubDisp4Src) >> ubScaleParam;
			sInfor.tInput[2].uwVSize = uwKNL_GetVdoH(ubDisp4Src) >> ubScaleParam;
		}
	}
	else if((tDispType == KNL_DISP_3T_2L1R) || (tDispType == KNL_DISP_3T_1L2R) ||
		    (tDispType == KNL_DISP_3T_2T1B) || (tDispType == KNL_DISP_3T_1T2B))
	{
		uint8_t ubScaleParam = 0;
		if((((tDispType == KNL_DISP_3T_2L1R) || (tDispType == KNL_DISP_3T_1L2R)) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)) ||
		   (((tDispType == KNL_DISP_3T_2T1B) || (tDispType == KNL_DISP_3T_1T2B)) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)))
		{
			// For LCD IP
			// -----------------
			// |  CH0  |	   |
			// | 	   |       |
			// |-------|  CH1  |
			// |       |       |
			// |  CH2  |	   |
			// -----------------
			// -----------------
			// |       |  CH0  |
			// | 	   |       |
			// |  CH1  |-------|
			// |       |       |
			// |       |  CH2  |
			// -----------------
			sInfor.ubChMax = 3;
			//For CH0 -> Location 1
			ubDisp1Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[0]:ubDisp1Src;
			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src   = KNL_SRC_1_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}
			sInfor.tInput[0].uwHSize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
			sInfor.tInput[0].uwVSize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			sInfor.tInput[0].bJpegEn = (ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)?FALSE:TRUE;
			//For CH1 -> Location 3
			ubDisp3Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[2]:ubDisp3Src;
			if(KNL_SRC_NONE == ubDisp3Src)
			{
				ubDisp3Src   = KNL_SRC_3_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp3Src) >= 1024)?1:0;
			}
			else
			{			
				KNL_SetVdoScaleParam(ubDisp3Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp3Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp3Src);
			}
			sInfor.tInput[1].uwHSize = uwKNL_GetVdoH(ubDisp3Src) >> ubScaleParam;
			sInfor.tInput[1].uwVSize = uwKNL_GetVdoV(ubDisp3Src) >> ubScaleParam;
			sInfor.tInput[1].bJpegEn = (ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)?FALSE:TRUE;
			//For CH2 -> Location 2
			ubDisp2Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[1]:ubDisp2Src;
			if(KNL_SRC_NONE == ubDisp2Src)
			{
				ubDisp2Src   = KNL_SRC_2_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp2Src) >= 1024)?1:0;
			}
			else
			{			
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp2Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			}
			sInfor.tInput[2].uwHSize = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;
			sInfor.tInput[2].uwVSize = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
			sInfor.tInput[2].bJpegEn = (ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)?FALSE:TRUE;
		}
		else
		{
			// For LCD IP	
			// -----------------		-----------------
			// | 	           |		| 	            |
			// |	  CH0      |		|	   CH1      |
			// | 	           |		| 	            |
			// |---------------|		|---------------|
			// |               |		|               |
			// |	  CH1      |		|	   CH0      |
			// |	           |		|	            |
			// -----------------		-----------------
			uint8_t ubLcdCh = 0;
			sInfor.ubChMax = 2;
			//! For CH0/1
			ubDisp1Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[0]:ubDisp1Src;
			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src   = KNL_SRC_1_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}
			ubLcdCh = ((KNL_DISP_3T_1L2R == tDispType) || (KNL_DISP_3T_2T1B == tDispType))?1:0;
			sInfor.tInput[ubLcdCh].uwHSize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
			sInfor.tInput[ubLcdCh].uwVSize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			sInfor.tInput[ubLcdCh].bJpegEn = (ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)?FALSE:TRUE;
			//! For CH1/0
			ubDisp2Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[1]:ubDisp2Src;
			ubDisp3Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[2]:ubDisp3Src;
			if(KNL_SRC_NONE == ubDisp2Src)
			{
				ubDisp2Src   = KNL_SRC_2_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp2Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			}
			if(KNL_SRC_NONE == ubDisp3Src)
				ubDisp3Src   = KNL_SRC_3_MAIN;
			else
				KNL_SetVdoScaleParam(ubDisp3Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp3Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
			ubLcdCh = ((KNL_DISP_3T_1L2R == tDispType) || (KNL_DISP_3T_2T1B == tDispType))?0:1;
			sInfor.tInput[ubLcdCh].uwHSize = (tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)?(uwKNL_GetVdoV(ubDisp2Src) * (2 >> ubScaleParam)):(uwKNL_GetVdoH(ubDisp2Src) * (2 >> ubScaleParam));
			sInfor.tInput[ubLcdCh].uwVSize = ((tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)?uwKNL_GetVdoH(ubDisp2Src):uwKNL_GetVdoV(ubDisp2Src)) >> ubScaleParam;
			sInfor.tInput[ubLcdCh].bJpegEn = (ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)?FALSE:TRUE;
		}
	}
	else if(tDispType == KNL_DISP_3T_3COL)
	{
		uint8_t ubScaleParam = 0;
		
		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
		{
			sInfor.ubChMax = 2;
			//! For CH0
			ubDisp1Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[0]:ubDisp1Src;
			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src   = KNL_SRC_1_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}
			sInfor.tInput[0].uwHSize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
			sInfor.tInput[0].uwVSize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			sInfor.tInput[0].bJpegEn = (ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)?FALSE:TRUE;
			//! For CH1
			ubDisp2Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[1]:ubDisp2Src;
			ubDisp3Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[2]:ubDisp3Src;
			if(KNL_SRC_NONE == ubDisp2Src)
			{
				ubDisp2Src   = KNL_SRC_2_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp2Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			}
			if(KNL_SRC_NONE == ubDisp3Src)
				ubDisp3Src   = KNL_SRC_3_MAIN;
			else
				KNL_SetVdoScaleParam(ubDisp3Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp3Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
			sInfor.tInput[1].uwHSize = uwKNL_GetVdoH(ubDisp2Src) * (2 >> ubScaleParam);
			sInfor.tInput[1].uwVSize = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
			sInfor.tInput[1].bJpegEn = (ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)?FALSE:TRUE;
		}
		else
		{
			sInfor.ubChMax = 3;
			//For CH0 -> Location 1
			ubDisp3Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[2]:ubDisp3Src;
			if(KNL_SRC_NONE == ubDisp3Src)
			{
				ubDisp3Src   = KNL_SRC_3_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp3Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp3Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp3Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp3Src);
			}
			sInfor.tInput[0].uwHSize = uwKNL_GetVdoH(ubDisp3Src) >> ubScaleParam;
			sInfor.tInput[0].uwVSize = uwKNL_GetVdoV(ubDisp3Src) >> ubScaleParam;
			sInfor.tInput[0].bJpegEn = (ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)?FALSE:TRUE;
			//For CH1 -> Location 2
			ubDisp2Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[1]:ubDisp2Src;
			if(KNL_SRC_NONE == ubDisp2Src)
			{
				ubDisp2Src   = KNL_SRC_2_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp2Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp2Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			}
			sInfor.tInput[1].uwHSize = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;
			sInfor.tInput[1].uwVSize = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
			sInfor.tInput[1].bJpegEn = (ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)?FALSE:TRUE;
			//For CH2 -> Location 3
			ubDisp1Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[0]:ubDisp1Src;
			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src   = KNL_SRC_1_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}
			sInfor.tInput[2].uwHSize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
			sInfor.tInput[2].uwVSize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			sInfor.tInput[2].bJpegEn = (ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)?FALSE:TRUE;
		}
	}
	else if(tDispType == KNL_DISP_3T_3C)
	{
		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)
		{				
			sInfor.ubChMax = 3;
			
			//For 0
			if(ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)
			{
				sInfor.tInput[0].bJpegEn = FALSE;
			}
			else
			{
				sInfor.tInput[0].bJpegEn = TRUE;
			}		
			sInfor.tInput[0].uwHSize = uwKNL_GetVdoV(ubDisp1Src);
			sInfor.tInput[0].uwVSize = uwKNL_GetVdoH(ubDisp1Src);		

			//For 1
			if(ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)
			{
				sInfor.tInput[1].bJpegEn = FALSE;
			}
			else
			{
				sInfor.tInput[1].bJpegEn = TRUE;
			}		
			sInfor.tInput[1].uwHSize = uwKNL_GetVdoV(ubDisp2Src);
			sInfor.tInput[1].uwVSize = uwKNL_GetVdoH(ubDisp2Src);	
			
			//For 2
			if(ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)
			{
				sInfor.tInput[2].bJpegEn = FALSE;
			}
			else
			{
				sInfor.tInput[2].bJpegEn = TRUE;
			}		
			sInfor.tInput[2].uwHSize = uwKNL_GetVdoV(ubDisp3Src);
			sInfor.tInput[2].uwVSize = uwKNL_GetVdoH(ubDisp3Src);						
		}
	}
	
	else if(tDispType == KNL_DISP_DUAL_C)
	{
		// For Kernel	
		// -----------------
		// |   	 Disp1     |
		// | 	  F(2)     |
		// |---------------|
		// |      B(3)     |
		// |   	 Disp2     |
		// -----------------
		
		// For LCD IP	
		// -----------------
		// |	  CH0      |
		// | 	           |
		// |---------------|
		// |               |
		// |	  CH1      |
		// -----------------
		uint8_t ubScaleParam = 0;
		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
		{			
			sInfor.ubChMax = 2;
			//For 0
			if(ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)
			{
				sInfor.tInput[0].bJpegEn = FALSE;
			}
			else
			{
				sInfor.tInput[0].bJpegEn = TRUE;
			}
			ubDisp1Src = (KNL_SRC_NONE != KNL_SwDispInfo.tSrcNum[0])?KNL_SwDispInfo.tSrcNum[0]:(KNL_SRC_NONE != ubDisp1Src)?ubDisp1Src:KNL_SRC_1_MAIN;
			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src   = KNL_SRC_1_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) >= 1920)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) >= 1920)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}
			sInfor.tInput[0].uwHSize = ((KNL_SRC_NONE == ubDisp1Src)?sInfor.uwLcdHSize:uwKNL_GetVdoH(ubDisp1Src)) >> ubScaleParam;
			sInfor.tInput[0].uwVSize = ((KNL_SRC_NONE == ubDisp1Src)?sInfor.uwLcdVSize:uwKNL_GetVdoV(ubDisp1Src)) >> ubScaleParam;
			//For 1
			if(ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)
			{
				sInfor.tInput[1].bJpegEn = FALSE;
			}
			else
			{
				sInfor.tInput[1].bJpegEn = TRUE;
			}	
#if defined(BSP_DVR_SDK)
			ubDisp2Src = (KNL_SRC_NONE != KNL_SwDispInfo.tSrcNum[1])?KNL_SwDispInfo.tSrcNum[1]:(KNL_SRC_NONE != ubDisp2Src)?ubDisp2Src:KNL_SRC_1_MAIN;
#else
			ubDisp2Src = (KNL_SRC_NONE != KNL_SwDispInfo.tSrcNum[1])?KNL_SwDispInfo.tSrcNum[1]:(KNL_SRC_NONE != ubDisp2Src)?ubDisp2Src:KNL_SRC_2_MAIN;
#endif
			if(KNL_SRC_NONE == ubDisp2Src)
			{
				ubDisp2Src   = KNL_SRC_2_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp2Src) >= 1920)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp2Src) >= 1920)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			}
			sInfor.tInput[1].uwHSize = ((KNL_SRC_NONE == ubDisp2Src)?sInfor.uwLcdHSize:uwKNL_GetVdoH(ubDisp2Src)) >> ubScaleParam;
			sInfor.tInput[1].uwVSize = ((KNL_SRC_NONE == ubDisp2Src)?sInfor.uwLcdVSize:uwKNL_GetVdoV(ubDisp2Src)) >> ubScaleParam;
		}
		else if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)
		{
			sInfor.ubChMax = 2;
			//For 0
			if(ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)
			{
				sInfor.tInput[0].bJpegEn = FALSE;
			}
			else
			{
				sInfor.tInput[0].bJpegEn = TRUE;
			}
			ubDisp1Src = (KNL_SRC_NONE != KNL_SwDispInfo.tSrcNum[0])?KNL_SwDispInfo.tSrcNum[0]:(KNL_SRC_NONE != ubDisp1Src)?ubDisp1Src:KNL_SRC_1_MAIN;
			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src   = KNL_SRC_1_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) >= 1920)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) >= 1920)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}
#if defined(BSP_DVR_SDK)			
			sInfor.tInput[0].uwHSize = 816;	// Enlage LCD memory szie to play FHD photo.
			sInfor.tInput[0].uwVSize = 1280;
#else
			sInfor.tInput[0].uwHSize = ((KNL_SRC_NONE == ubDisp1Src)?sInfor.uwLcdVSize:uwKNL_GetVdoV(ubDisp1Src)) >> ubScaleParam;
			sInfor.tInput[0].uwVSize = ((KNL_SRC_NONE == ubDisp1Src)?sInfor.uwLcdHSize:uwKNL_GetVdoH(ubDisp1Src)) >> ubScaleParam;
#endif			
			//For 1
			if(ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)
			{
				sInfor.tInput[1].bJpegEn = FALSE;
			}
			else
			{
				sInfor.tInput[1].bJpegEn = TRUE;
			}
			ubDisp2Src = (KNL_SRC_NONE != KNL_SwDispInfo.tSrcNum[1])?KNL_SwDispInfo.tSrcNum[1]:(KNL_SRC_NONE != ubDisp2Src)?ubDisp2Src:KNL_SRC_2_MAIN;
			if(KNL_SRC_NONE == ubDisp2Src)
			{
				ubDisp2Src   = KNL_SRC_2_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp2Src) >= 1920)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp2Src) >= 1920)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			}
#if defined(BSP_DVR_SDK)
			sInfor.tInput[1].uwHSize = 816;	// Enlage LCD memory szie to play FHD photo.
			sInfor.tInput[1].uwVSize = 1280;
#else
			sInfor.tInput[1].uwHSize = ((KNL_SRC_NONE == ubDisp2Src)?sInfor.uwLcdVSize:uwKNL_GetVdoV(ubDisp2Src)) >> ubScaleParam;
			sInfor.tInput[1].uwVSize = ((KNL_SRC_NONE == ubDisp2Src)?sInfor.uwLcdHSize:uwKNL_GetVdoH(ubDisp2Src)) >> ubScaleParam;
#endif			
		}
	}
#if defined(BSP_DVR_SDK)
	//justin 2019.07.22
	else if(tDispType == KNL_DISP_PIP_0)
	{	
		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
		{			
			sInfor.ubChMax = 2;
			//For 0
			if(ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)
			{
				sInfor.tInput[0].bJpegEn = FALSE;
			}
			else
			{
				sInfor.tInput[0].bJpegEn = TRUE;
			}
			ubDisp1Src = (KNL_SRC_NONE != KNL_SwDispInfo.tSrcNum[0])?KNL_SwDispInfo.tSrcNum[0]:(KNL_SRC_NONE != ubDisp1Src)?ubDisp1Src:KNL_SRC_1_MAIN;
			sInfor.tInput[0].uwHSize = (KNL_SRC_NONE == ubDisp1Src)?sInfor.uwLcdHSize:uwKNL_GetVdoH(ubDisp1Src);
			sInfor.tInput[0].uwVSize = (KNL_SRC_NONE == ubDisp1Src)?sInfor.uwLcdVSize:uwKNL_GetVdoV(ubDisp1Src);		
			//For 1
			if(ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)
			{
				sInfor.tInput[1].bJpegEn = FALSE;
			}
			else
			{
				sInfor.tInput[1].bJpegEn = TRUE;
			}	
			ubDisp2Src = (KNL_SRC_NONE != KNL_SwDispInfo.tSrcNum[1])?KNL_SwDispInfo.tSrcNum[1]:(KNL_SRC_NONE != ubDisp2Src)?ubDisp2Src:KNL_SRC_2_MAIN;
			sInfor.tInput[1].uwHSize = (KNL_SRC_NONE == ubDisp2Src)?sInfor.uwLcdHSize:uwKNL_GetVdoH(ubDisp2Src);
			sInfor.tInput[1].uwVSize = (KNL_SRC_NONE == ubDisp2Src)?sInfor.uwLcdVSize:uwKNL_GetVdoV(ubDisp2Src);	
		}
		else if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)
		{
			sInfor.ubChMax = 2;
			//For 0
			if(ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)
			{
				sInfor.tInput[0].bJpegEn = FALSE;
			}
			else
			{
				sInfor.tInput[0].bJpegEn = TRUE;
			}
			ubDisp1Src = (KNL_SRC_NONE != KNL_SwDispInfo.tSrcNum[0])?KNL_SwDispInfo.tSrcNum[0]:(KNL_SRC_NONE != ubDisp1Src)?ubDisp1Src:KNL_SRC_1_MAIN;
			sInfor.tInput[0].uwHSize = (KNL_SRC_NONE == ubDisp1Src)?sInfor.uwLcdVSize:uwKNL_GetVdoV(ubDisp1Src);
			sInfor.tInput[0].uwVSize = (KNL_SRC_NONE == ubDisp1Src)?sInfor.uwLcdHSize:uwKNL_GetVdoH(ubDisp1Src);
			//For 1
			if(ubKNL_GetVdoCodec() == KNL_VDO_CODEC_H264)
			{
				sInfor.tInput[1].bJpegEn = FALSE;
			}
			else
			{
				sInfor.tInput[1].bJpegEn = TRUE;
			}
			ubDisp2Src = (KNL_SRC_NONE != KNL_SwDispInfo.tSrcNum[1])?KNL_SwDispInfo.tSrcNum[1]:(KNL_SRC_NONE != ubDisp2Src)?ubDisp2Src:KNL_SRC_2_MAIN;
			sInfor.tInput[1].uwHSize = (KNL_SRC_NONE == ubDisp2Src)?sInfor.uwLcdVSize:uwKNL_GetVdoV(ubDisp2Src);
			sInfor.tInput[1].uwVSize = (KNL_SRC_NONE == ubDisp2Src)?sInfor.uwLcdHSize:uwKNL_GetVdoH(ubDisp2Src);
		}
	}
#endif
	sInfor.tAlign = LCD_BUF_1024BYTES_ALIG;
	return ulLCD_CalLcdBufSize(&sInfor);
#else
	return 0;
#endif	
}
//------------------------------------------------------------------------------
uint8_t ubKNL_SetDispCropScaleParam(void)
{
	//printf("(1)@%s\r\n",__func__);
	
#if KNL_LCD_FUNC_ENABLE
	static LCD_INFOR_TYP sLcdInfor;
	uint8_t ubDisp1Src;
	uint8_t ubDisp2Src;
	uint8_t ubDisp3Src;
	uint8_t ubDisp4Src;
	
	if(tKNL_GetDispType() == KNL_DISP_SINGLE)
	{
		sLcdInfor.tDispType = LCD_DISP_1T;
		sLcdInfor.ubChNum = 1;

		//Get Correspond Source
		ubDisp1Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
		ubDisp2Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION2);
		ubDisp3Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION3);
		ubDisp4Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION4);		
	
		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
		{
			sLcdInfor.uwLcdOutputHsize = tKNL_Info.uwDispH;
			sLcdInfor.uwLcdOutputVsize = tKNL_Info.uwDispV;

			ubDisp1Src = (KNL_SRC_NONE == ubDisp1Src)?KNL_SRC_1_MAIN:ubDisp1Src;
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoH(ubDisp1Src);
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoV(ubDisp1Src);
			sLcdInfor.tChRes[0].uwCropHstart = 0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;
			sLcdInfor.tChRes[0].uwCropHsize = uwKNL_GetVdoH(ubDisp1Src);
			sLcdInfor.tChRes[0].uwCropVsize = uwKNL_GetVdoV(ubDisp1Src);
		}
		else
		{
			sLcdInfor.uwLcdOutputHsize = tKNL_Info.uwDispV;
			sLcdInfor.uwLcdOutputVsize = tKNL_Info.uwDispH;

			ubDisp1Src = (KNL_SRC_NONE == ubDisp1Src)?KNL_SRC_1_MAIN:ubDisp1Src;
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoV(ubDisp1Src);
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoH(ubDisp1Src);
			sLcdInfor.tChRes[0].uwCropHstart = 0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;
			sLcdInfor.tChRes[0].uwCropHsize = uwKNL_GetVdoV(ubDisp1Src);
			sLcdInfor.tChRes[0].uwCropVsize = uwKNL_GetVdoH(ubDisp1Src);
		}
		pLcdCropScaleParam = (LCD_INFOR_TYP *)(&sLcdInfor);
	}
	
#if defined(BSP_DVR_SDK)
	//justin 2019.07.08
	//=================================================================================================
	if(tKNL_GetDispType() == KNL_DISP_PIP_0)
	{
		//printf("(2)@%s\r\n",__func__);	
		sLcdInfor.tDispType = LCD_DISP_2T_PIP_0;
		sLcdInfor.ubChNum = 2;

		//Get Correspond Source
		ubDisp1Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
		ubDisp2Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION2);
//		ubDisp3Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION3);
//		ubDisp4Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION4);		
		
		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
		{
			sLcdInfor.uwLcdOutputHsize = tKNL_Info.uwDispH;
			sLcdInfor.uwLcdOutputVsize = tKNL_Info.uwDispV;

			//justin 2019.07.08			
			//Source[0]
//			ubDisp1Src = (KNL_SRC_NONE == ubDisp1Src)?KNL_SRC_1_MAIN:ubDisp1Src;
//			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoH(ubDisp1Src)/2;
//			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoV(ubDisp1Src)/2;			
//			sLcdInfor.tChRes[0].uwCropHstart = 0;
//			sLcdInfor.tChRes[0].uwCropVstart = 0;		
//			sLcdInfor.tChRes[0].uwCropHsize = uwKNL_GetVdoH(ubDisp1Src)/2;
//			sLcdInfor.tChRes[0].uwCropVsize = uwKNL_GetVdoV(ubDisp1Src)/2;

			ubDisp1Src = (KNL_SRC_NONE == ubDisp1Src)?KNL_SRC_1_MAIN:ubDisp1Src;
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoH(ubDisp1Src)/1;
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoV(ubDisp1Src)/1;			
			sLcdInfor.tChRes[0].uwCropHstart = 0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;		
			sLcdInfor.tChRes[0].uwCropHsize = uwKNL_GetVdoH(ubDisp1Src)/1;
			sLcdInfor.tChRes[0].uwCropVsize = uwKNL_GetVdoV(ubDisp1Src)/1;
			
		
			//Source[1]
			ubDisp2Src = (KNL_SRC_NONE == ubDisp2Src)?KNL_SRC_2_MAIN:ubDisp2Src;
			sLcdInfor.tChRes[1].uwChInputHsize = uwKNL_GetVdoH(ubDisp2Src);
			sLcdInfor.tChRes[1].uwChInputVsize = uwKNL_GetVdoV(ubDisp2Src);		
			sLcdInfor.tChRes[1].uwCropHstart = 0;
			sLcdInfor.tChRes[1].uwCropVstart = 0;		
			sLcdInfor.tChRes[1].uwCropHsize = uwKNL_GetVdoH(ubDisp2Src);
			sLcdInfor.tChRes[1].uwCropVsize = uwKNL_GetVdoV(ubDisp2Src);			
		}
		else if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)
		{
			//printf("(3)@%s\r\n",__func__);
#if 0	//Sensor Test
			sLcdInfor.uwLcdOutputHsize = tKNL_Info.uwDispV;
			sLcdInfor.uwLcdOutputVsize = tKNL_Info.uwDispH;

			//Source[0]
			ubDisp1Src = (KNL_SRC_NONE == ubDisp1Src)?KNL_SRC_1_MAIN:ubDisp1Src;
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoV(ubDisp1Src);
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoH(ubDisp1Src);
			sLcdInfor.tChRes[0].uwCropHstart = 0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;				
			sLcdInfor.tChRes[0].uwCropHsize = uwKNL_GetVdoV(ubDisp1Src);
			sLcdInfor.tChRes[0].uwCropVsize = uwKNL_GetVdoH(ubDisp1Src);
			
			//Source[1]
			ubDisp2Src = (KNL_SRC_NONE == ubDisp2Src)?KNL_SRC_2_MAIN:ubDisp2Src;
			sLcdInfor.tChRes[1].uwChInputHsize = uwKNL_GetVdoV(ubDisp2Src);
			sLcdInfor.tChRes[1].uwChInputVsize = uwKNL_GetVdoH(ubDisp2Src);			
			sLcdInfor.tChRes[1].uwCropHstart = 0;
			sLcdInfor.tChRes[1].uwCropVstart = 0;			
			sLcdInfor.tChRes[1].uwCropHsize = uwKNL_GetVdoV(ubDisp2Src);
			sLcdInfor.tChRes[1].uwCropVsize = uwKNL_GetVdoH(ubDisp2Src);				
#endif
			
#if 1 //For RF
			sLcdInfor.uwLcdOutputHsize = tKNL_Info.uwDispV;
			sLcdInfor.uwLcdOutputVsize = tKNL_Info.uwDispH;

			//Source[0]
			ubDisp1Src = (KNL_SRC_NONE == ubDisp1Src)?KNL_SRC_1_MAIN:ubDisp1Src;
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoV(ubDisp1Src)/2;
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoH(ubDisp1Src)/2;
			sLcdInfor.tChRes[0].uwCropHstart = 0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;				
			sLcdInfor.tChRes[0].uwCropHsize = uwKNL_GetVdoV(ubDisp1Src)/2;
			sLcdInfor.tChRes[0].uwCropVsize = uwKNL_GetVdoH(ubDisp1Src)/2;
	
			ubDisp2Src = (KNL_SRC_NONE == ubDisp2Src)?KNL_SRC_2_MAIN:ubDisp2Src;
			sLcdInfor.tChRes[1].uwChInputHsize = uwKNL_GetVdoV(ubDisp2Src)/2;
			sLcdInfor.tChRes[1].uwChInputVsize = uwKNL_GetVdoH(ubDisp2Src)/2;			
			sLcdInfor.tChRes[1].uwCropHstart = 0;
			sLcdInfor.tChRes[1].uwCropVstart = 0;			
			sLcdInfor.tChRes[1].uwCropHsize = uwKNL_GetVdoV(ubDisp2Src)/2;
			sLcdInfor.tChRes[1].uwCropVsize = uwKNL_GetVdoH(ubDisp2Src)/2;
#endif

		}
		pLcdCropScaleParam = (LCD_INFOR_TYP *)(&sLcdInfor);
	}
	//=================================================================================================
#endif
	if(tKNL_GetDispType() == KNL_DISP_DUAL_U)
	{
		sLcdInfor.tDispType = LCD_DISP_2T_H;
		sLcdInfor.ubChNum = 2;

		//Get Correspond Source
		ubDisp1Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
		ubDisp2Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION2);
		ubDisp3Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION3);
		ubDisp4Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION4);		
		
		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
		{
			sLcdInfor.uwLcdOutputHsize = tKNL_Info.uwDispH;
			sLcdInfor.uwLcdOutputVsize = tKNL_Info.uwDispV;

			//Source[0]
			ubDisp1Src = (KNL_SRC_NONE == ubDisp1Src)?KNL_SRC_1_MAIN:ubDisp1Src;
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoH(ubDisp1Src);
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoV(ubDisp1Src);			
			sLcdInfor.tChRes[0].uwCropHstart = 0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;		
			sLcdInfor.tChRes[0].uwCropHsize = uwKNL_GetVdoH(ubDisp1Src);
			sLcdInfor.tChRes[0].uwCropVsize = uwKNL_GetVdoV(ubDisp1Src);		
		
			//Source[1]
			ubDisp2Src = (KNL_SRC_NONE == ubDisp2Src)?KNL_SRC_2_MAIN:ubDisp2Src;
			sLcdInfor.tChRes[1].uwChInputHsize = uwKNL_GetVdoH(ubDisp2Src);
			sLcdInfor.tChRes[1].uwChInputVsize = uwKNL_GetVdoV(ubDisp2Src);		
			sLcdInfor.tChRes[1].uwCropHstart = 0;
			sLcdInfor.tChRes[1].uwCropVstart = 0;		
			sLcdInfor.tChRes[1].uwCropHsize = uwKNL_GetVdoH(ubDisp2Src);
			sLcdInfor.tChRes[1].uwCropVsize = uwKNL_GetVdoV(ubDisp2Src);			
		}
		else if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)
		{			
			sLcdInfor.uwLcdOutputHsize = tKNL_Info.uwDispV;
			sLcdInfor.uwLcdOutputVsize = tKNL_Info.uwDispH;

			//Source[0]
			ubDisp1Src = (KNL_SRC_NONE == ubDisp1Src)?KNL_SRC_1_MAIN:ubDisp1Src;
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoV(ubDisp1Src);
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoH(ubDisp1Src);
			sLcdInfor.tChRes[0].uwCropHstart = 0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;				
			sLcdInfor.tChRes[0].uwCropHsize = uwKNL_GetVdoV(ubDisp1Src);
			sLcdInfor.tChRes[0].uwCropVsize = uwKNL_GetVdoH(ubDisp1Src);			
			
			//Source[1]
			ubDisp2Src = (KNL_SRC_NONE == ubDisp2Src)?KNL_SRC_2_MAIN:ubDisp2Src;
			sLcdInfor.tChRes[1].uwChInputHsize = uwKNL_GetVdoV(ubDisp2Src);
			sLcdInfor.tChRes[1].uwChInputVsize = uwKNL_GetVdoH(ubDisp2Src);			
			sLcdInfor.tChRes[1].uwCropHstart = 0;
			sLcdInfor.tChRes[1].uwCropVstart = 0;			
			sLcdInfor.tChRes[1].uwCropHsize = uwKNL_GetVdoV(ubDisp2Src);
			sLcdInfor.tChRes[1].uwCropVsize = uwKNL_GetVdoH(ubDisp2Src);				
		}
		pLcdCropScaleParam = (LCD_INFOR_TYP *)(&sLcdInfor);
	}
	
	if(tKNL_GetDispType() == KNL_DISP_QUAD)
	{
		sLcdInfor.tDispType = LCD_DISP_4T;
		sLcdInfor.ubChNum = 4;

		//Get Correspond Source
		ubDisp1Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
		ubDisp2Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION2);
		ubDisp3Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION3);
		ubDisp4Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION4);		
		
		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
		{
			uint8_t ubScaleParam = 0;

			sLcdInfor.uwLcdOutputHsize = tKNL_Info.uwDispH;
			sLcdInfor.uwLcdOutputVsize = tKNL_Info.uwDispV;

			//Source[0]
			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src   = KNL_SRC_1_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropHstart = 0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;
			sLcdInfor.tChRes[0].uwCropHsize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropVsize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;

			//Source[1]
			if(KNL_SRC_NONE == ubDisp2Src)
			{
				ubDisp2Src   = KNL_SRC_2_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp2Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp2Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			}
			sLcdInfor.tChRes[1].uwChInputHsize = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwChInputVsize = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwCropHstart = 0;
			sLcdInfor.tChRes[1].uwCropVstart = 0;
			sLcdInfor.tChRes[1].uwCropHsize = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwCropVsize = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;

			//Source[2]
			if(KNL_SRC_NONE == ubDisp3Src)
			{
				ubDisp3Src   = KNL_SRC_3_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp3Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp3Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp3Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp3Src);
			}
			sLcdInfor.tChRes[2].uwChInputHsize = uwKNL_GetVdoH(ubDisp3Src) >> ubScaleParam;
			sLcdInfor.tChRes[2].uwChInputVsize = uwKNL_GetVdoV(ubDisp3Src) >> ubScaleParam;
			sLcdInfor.tChRes[2].uwCropHstart = 0;
			sLcdInfor.tChRes[2].uwCropVstart = 0;
			sLcdInfor.tChRes[2].uwCropHsize = uwKNL_GetVdoH(ubDisp3Src) >> ubScaleParam;
			sLcdInfor.tChRes[2].uwCropVsize = uwKNL_GetVdoV(ubDisp3Src) >> ubScaleParam;

			//Source[3]
			if(KNL_SRC_NONE == ubDisp4Src)
			{
				ubDisp4Src   = KNL_SRC_4_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp4Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp4Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp4Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp4Src);
			}
			sLcdInfor.tChRes[3].uwChInputHsize = uwKNL_GetVdoH(ubDisp4Src) >> ubScaleParam;
			sLcdInfor.tChRes[3].uwChInputVsize = uwKNL_GetVdoV(ubDisp4Src) >> ubScaleParam;
			sLcdInfor.tChRes[3].uwCropHstart = 0;
			sLcdInfor.tChRes[3].uwCropVstart = 0;
			sLcdInfor.tChRes[3].uwCropHsize = uwKNL_GetVdoH(ubDisp4Src) >> ubScaleParam;
			sLcdInfor.tChRes[3].uwCropVsize = uwKNL_GetVdoV(ubDisp4Src) >> ubScaleParam;
		}
		else if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)
		{
			sLcdInfor.uwLcdOutputHsize = tKNL_Info.uwDispV;
			sLcdInfor.uwLcdOutputVsize = tKNL_Info.uwDispH;

			//Source[0]
			ubDisp1Src = (KNL_SRC_NONE == ubDisp1Src)?KNL_SRC_1_MAIN:ubDisp1Src;
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoV(ubDisp1Src);
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoH(ubDisp1Src);
			sLcdInfor.tChRes[0].uwCropHstart = 0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;
			sLcdInfor.tChRes[0].uwCropHsize = uwKNL_GetVdoV(ubDisp1Src);
			sLcdInfor.tChRes[0].uwCropVsize = uwKNL_GetVdoH(ubDisp1Src);

			//Source[1]
			ubDisp2Src = (KNL_SRC_NONE == ubDisp2Src)?KNL_SRC_2_MAIN:ubDisp2Src;
			sLcdInfor.tChRes[1].uwChInputHsize = uwKNL_GetVdoV(ubDisp2Src);
			sLcdInfor.tChRes[1].uwChInputVsize = uwKNL_GetVdoH(ubDisp2Src);
			sLcdInfor.tChRes[1].uwCropHstart = 0;
			sLcdInfor.tChRes[1].uwCropVstart = 0;
			sLcdInfor.tChRes[1].uwCropHsize = uwKNL_GetVdoV(ubDisp2Src);
			sLcdInfor.tChRes[1].uwCropVsize = uwKNL_GetVdoH(ubDisp2Src);

			//Source[2]
			ubDisp3Src = (KNL_SRC_NONE == ubDisp3Src)?KNL_SRC_3_MAIN:ubDisp3Src;
			sLcdInfor.tChRes[2].uwChInputHsize = uwKNL_GetVdoV(ubDisp3Src);
			sLcdInfor.tChRes[2].uwChInputVsize = uwKNL_GetVdoH(ubDisp3Src);
			sLcdInfor.tChRes[2].uwCropHstart = 0;
			sLcdInfor.tChRes[2].uwCropVstart = 0;
			sLcdInfor.tChRes[2].uwCropHsize = uwKNL_GetVdoV(ubDisp3Src);
			sLcdInfor.tChRes[2].uwCropVsize = uwKNL_GetVdoH(ubDisp3Src);

			//Source[3]
			ubDisp4Src = (KNL_SRC_NONE == ubDisp4Src)?KNL_SRC_4_MAIN:ubDisp4Src;
			sLcdInfor.tChRes[3].uwChInputHsize = uwKNL_GetVdoV(ubDisp4Src);
			sLcdInfor.tChRes[3].uwChInputVsize = uwKNL_GetVdoH(ubDisp4Src);
			sLcdInfor.tChRes[3].uwCropHstart = 0;
			sLcdInfor.tChRes[3].uwCropVstart = 0;
			sLcdInfor.tChRes[3].uwCropHsize = uwKNL_GetVdoV(ubDisp4Src);
			sLcdInfor.tChRes[3].uwCropVsize = uwKNL_GetVdoH(ubDisp4Src);
		}
		pLcdCropScaleParam = (LCD_INFOR_TYP *)(&sLcdInfor);
	}
	if(tKNL_GetDispType() == KNL_DISP_H)
	{
		uint8_t ubScaleParam = 0;

		//Get Correspond Source
		ubDisp1Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
		ubDisp2Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION2);
		ubDisp3Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION3);
		ubDisp4Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION4);

		sLcdInfor.ubChNum = 3;
		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
		{
			uint8_t ubScaleDmy1Param = 0, ubScaleDmy2Param = 0;

			sLcdInfor.tDispType = LCD_DISP_3T_2PIP;
			sLcdInfor.uwLcdOutputHsize = tKNL_Info.uwDispH;
			sLcdInfor.uwLcdOutputVsize = tKNL_Info.uwDispV;

			//Source[0]
			if(KNL_SRC_NONE == ubDisp2Src)
			{
				ubDisp2Src   = KNL_SRC_2_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp2Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp2Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			}
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropHstart = 0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;
			sLcdInfor.tChRes[0].uwCropHsize = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropVsize = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;

			//Source[1]
			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src   = KNL_SRC_1_MAIN;
				ubScaleDmy1Param = (uwKNL_GetVdoH(ubDisp1Src) > 1024)?2:1;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) > 1024)?KNL_SCALE_X0P25:KNL_SCALE_X0P5));
				ubScaleDmy1Param = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}
			if(KNL_SRC_NONE == ubDisp4Src)
			{
				ubDisp4Src   = KNL_SRC_4_MAIN;
				ubScaleDmy2Param = (uwKNL_GetVdoH(ubDisp4Src) > 1024)?2:1;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp4Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp4Src) > 1024)?KNL_SCALE_X0P25:KNL_SCALE_X0P5));
				ubScaleDmy2Param = ubKNL_GetVdoScaleParam(ubDisp4Src);
			}
			sLcdInfor.tChRes[1].uwChInputHsize = (uwKNL_GetVdoH(ubDisp1Src) >> ubScaleDmy1Param) + uwKNL_GetLcdDmyImgH() + (uwKNL_GetVdoH(ubDisp4Src) >> ubScaleDmy2Param);
			sLcdInfor.tChRes[1].uwChInputVsize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleDmy1Param;
			sLcdInfor.tChRes[1].uwCropHstart = 0;
			sLcdInfor.tChRes[1].uwCropVstart = 0;
			sLcdInfor.tChRes[1].uwCropHsize = (uwKNL_GetVdoH(ubDisp1Src) >> ubScaleDmy1Param) + uwKNL_GetLcdDmyImgH() + (uwKNL_GetVdoH(ubDisp4Src) >> ubScaleDmy2Param);
			sLcdInfor.tChRes[1].uwCropVsize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleDmy1Param;

			//Source[2]
			if(KNL_SRC_NONE == ubDisp3Src)
			{
				ubDisp3Src   = KNL_SRC_2_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp3Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp3Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp3Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp3Src);
			}
			sLcdInfor.tChRes[2].uwChInputHsize = uwKNL_GetVdoH(ubDisp3Src) >> ubScaleParam;
			sLcdInfor.tChRes[2].uwChInputVsize = uwKNL_GetVdoV(ubDisp3Src) >> ubScaleParam;
			sLcdInfor.tChRes[2].uwCropHstart = 0;
			sLcdInfor.tChRes[2].uwCropVstart = 0;
			sLcdInfor.tChRes[2].uwCropHsize = uwKNL_GetVdoH(ubDisp3Src) >> ubScaleParam;
			sLcdInfor.tChRes[2].uwCropVsize = uwKNL_GetVdoV(ubDisp3Src) >> ubScaleParam;
		}	
		else if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)
		{
			//sLcdInfor.tDispType = LCD_DISP_3TC;
			sLcdInfor.tDispType = LCD_DISP_3TC_SHOW_121;
			sLcdInfor.uwLcdOutputHsize = tKNL_Info.uwDispV;
			sLcdInfor.uwLcdOutputVsize = tKNL_Info.uwDispH;

			//Source[0]
			ubDisp1Src = (KNL_SRC_NONE == ubDisp1Src)?KNL_SRC_1_MAIN:ubDisp1Src;
			ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropHstart = 0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;
			sLcdInfor.tChRes[0].uwCropHsize = (uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam);
			sLcdInfor.tChRes[0].uwCropVsize = (uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam);

			//Source[1]
			ubDisp2Src = (KNL_SRC_NONE == ubDisp2Src)?KNL_SRC_2_MAIN:ubDisp2Src;
			ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			sLcdInfor.tChRes[1].uwChInputHsize = uwKNL_GetVdoV(ubDisp2Src) * (2 >> ubScaleParam);
			sLcdInfor.tChRes[1].uwChInputVsize = (uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam);
			sLcdInfor.tChRes[1].uwCropHstart = 0;
			sLcdInfor.tChRes[1].uwCropVstart = 0;
			sLcdInfor.tChRes[1].uwCropHsize = uwKNL_GetVdoV(ubDisp2Src) * (2 >> ubScaleParam);
			sLcdInfor.tChRes[1].uwCropVsize = (uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam);

			//Source[2]
			ubDisp4Src = (KNL_SRC_NONE == ubDisp4Src)?KNL_SRC_4_MAIN:ubDisp4Src;
			ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp4Src);
			sLcdInfor.tChRes[2].uwChInputHsize = (uwKNL_GetVdoV(ubDisp4Src) >> ubScaleParam);
			sLcdInfor.tChRes[2].uwChInputVsize = (uwKNL_GetVdoH(ubDisp4Src) >> ubScaleParam);
			sLcdInfor.tChRes[2].uwCropHstart = 0;
			sLcdInfor.tChRes[2].uwCropVstart = 0;
			sLcdInfor.tChRes[2].uwCropHsize = (uwKNL_GetVdoV(ubDisp4Src) >> ubScaleParam);
			sLcdInfor.tChRes[2].uwCropVsize = (uwKNL_GetVdoH(ubDisp4Src) >> ubScaleParam);
		}
		pLcdCropScaleParam = (LCD_INFOR_TYP *)(&sLcdInfor);
	}

	if((tKNL_GetDispType() == KNL_DISP_3T_2L1R) || (tKNL_GetDispType() == KNL_DISP_3T_1L2R) ||
	   (tKNL_GetDispType() == KNL_DISP_3T_2T1B) || (tKNL_GetDispType() == KNL_DISP_3T_1T2B))
	{
		KNL_DISP_TYPE tDispType = KNL_DISP_3T_2L1R;
		KNL_DISP_ROTATE tDispRot = KNL_DISP_ROTATE_0;
		uint8_t ubScaleParam = 0;

		tDispType = tKNL_GetDispType();
		tDispRot  = tKNL_GetDispRotate();
		ubDisp1Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
		ubDisp2Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION2);
		ubDisp3Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION3);
		ubDisp4Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION4);
		sLcdInfor.uwLcdOutputHsize = (tDispRot == KNL_DISP_ROTATE_90)?tKNL_Info.uwDispV:tKNL_Info.uwDispH;
		sLcdInfor.uwLcdOutputVsize = (tDispRot == KNL_DISP_ROTATE_90)?tKNL_Info.uwDispH:tKNL_Info.uwDispV;
		if((((tDispType == KNL_DISP_3T_2L1R) || (tDispType == KNL_DISP_3T_1L2R)) && (tDispRot == KNL_DISP_ROTATE_0)) ||
		   (((tDispType == KNL_DISP_3T_2T1B) || (tDispType == KNL_DISP_3T_1T2B)) && (tDispRot == KNL_DISP_ROTATE_90)))
		{
			// For Kernel
			// -----------------			 -----------------
			// | Disp1 |       |			 |   	 | Disp1 |
			// |  F(2) |       |			 | 	     |  F(2) |
			// |-------| Disp3 |			 |  L(1) |-------|
			// | Disp2 |  R(4) |			 | Disp3 | Disp2 |
			// |  B(3) |	   |			 |   	 |  B(3) |
			// -----------------			 -----------------
			// For LCD IP
			// -----------------			 -----------------
			// |  CH0  |       |			 |       |  CH0  |
			// | 	   |       |			 | 	     |       |
			// |-------|  CH1  |			 |  CH1  |-------|
			// |       |       |			 |       |       |
			// |  CH2  |	   |			 |       |  CH2  |
			// -----------------			 -----------------
			// For Kernel
			// -----------------			 -----------------
			// |     Disp3     |			 | Disp1 | Disp2 |
			// |               |			 |       |       |
			// |---------------|			 |---------------|
			// | Disp1 | Disp2 |			 | 	   Disp3     |
			// |       |	   |			 |   	         |
			// -----------------			 -----------------
			// For LCD IP
			// -----------------			 -----------------
			// |      CH1      |			 |  CH0  |  CH2  |
			// |               |			 |       |       |
			// |---------------|			 |---------------|
			// |  CH0  |  CH2  |			 |      CH1      |
			// |       |	   |			 |   	         |
			// -----------------			 -----------------
			sLcdInfor.ubChNum = 3;
			sLcdInfor.tDispType = (tDispRot == KNL_DISP_ROTATE_90)?(KNL_DISP_3T_2T1B == tDispType)?LCD_DISP_3T_2L1R:LCD_DISP_3T_1L2R:
													               (KNL_DISP_3T_2L1R == tDispType)?LCD_DISP_3T_2L1R:LCD_DISP_3T_1L2R;
			//! CH0
			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src   = KNL_SRC_1_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}
			sLcdInfor.tChRes[0].uwChInputHsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoV(ubDisp1Src):uwKNL_GetVdoH(ubDisp1Src)) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwChInputVsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoH(ubDisp1Src):uwKNL_GetVdoV(ubDisp1Src)) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropHstart = 0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;
			sLcdInfor.tChRes[0].uwCropHsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoV(ubDisp1Src):uwKNL_GetVdoH(ubDisp1Src)) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropVsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoH(ubDisp1Src):uwKNL_GetVdoV(ubDisp1Src)) >> ubScaleParam;
			//! CH1
			if(KNL_SRC_NONE == ubDisp3Src)
			{
				ubDisp3Src   = KNL_SRC_3_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp3Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp3Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp3Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp3Src);
			}
			sLcdInfor.tChRes[1].uwChInputHsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoV(ubDisp3Src):uwKNL_GetVdoH(ubDisp3Src)) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwChInputVsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoH(ubDisp3Src):uwKNL_GetVdoV(ubDisp3Src)) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwCropHstart = 0;
			sLcdInfor.tChRes[1].uwCropVstart = 0;
			sLcdInfor.tChRes[1].uwCropHsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoV(ubDisp3Src):uwKNL_GetVdoH(ubDisp3Src)) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwCropVsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoH(ubDisp3Src):uwKNL_GetVdoV(ubDisp3Src)) >> ubScaleParam;
			//! CH2
			if(KNL_SRC_NONE == ubDisp2Src)
			{
				ubDisp2Src   = KNL_SRC_2_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp2Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp2Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			}
			sLcdInfor.tChRes[2].uwChInputHsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoV(ubDisp2Src):uwKNL_GetVdoH(ubDisp2Src)) >> ubScaleParam;
			sLcdInfor.tChRes[2].uwChInputVsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoH(ubDisp2Src):uwKNL_GetVdoV(ubDisp2Src)) >> ubScaleParam;
			sLcdInfor.tChRes[2].uwCropHstart = 0;
			sLcdInfor.tChRes[2].uwCropVstart = 0;
			sLcdInfor.tChRes[2].uwCropHsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoV(ubDisp2Src):uwKNL_GetVdoH(ubDisp2Src)) >> ubScaleParam;
			sLcdInfor.tChRes[2].uwCropVsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoH(ubDisp2Src):uwKNL_GetVdoV(ubDisp2Src)) >> ubScaleParam;
		}
		else
		{
			uint8_t ubLcdCh = 0;
			sLcdInfor.ubChNum = 2;
			sLcdInfor.tDispType = LCD_DISP_2T_V;
			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src   = KNL_SRC_1_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}
			//! CH0/1
			ubLcdCh = ((KNL_DISP_3T_1L2R == tDispType) || (KNL_DISP_3T_2T1B == tDispType))?1:0;
			sLcdInfor.tChRes[ubLcdCh].uwChInputHsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoV(ubDisp1Src):uwKNL_GetVdoH(ubDisp1Src)) >> ubScaleParam;
			sLcdInfor.tChRes[ubLcdCh].uwChInputVsize = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoH(ubDisp1Src):uwKNL_GetVdoV(ubDisp1Src)) >> ubScaleParam;
			sLcdInfor.tChRes[ubLcdCh].uwCropHstart   = 0;
			sLcdInfor.tChRes[ubLcdCh].uwCropVstart   = 0;		
			sLcdInfor.tChRes[ubLcdCh].uwCropHsize    = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoV(ubDisp1Src):uwKNL_GetVdoH(ubDisp1Src)) >> ubScaleParam;
			sLcdInfor.tChRes[ubLcdCh].uwCropVsize    = ((tDispRot == KNL_DISP_ROTATE_90)?uwKNL_GetVdoH(ubDisp1Src):uwKNL_GetVdoV(ubDisp1Src)) >> ubScaleParam;
			if(KNL_SRC_NONE == ubDisp2Src)
			{
				ubDisp2Src   = KNL_SRC_2_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp2Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			}
			if(KNL_SRC_NONE == ubDisp3Src)
				ubDisp3Src   = KNL_SRC_3_MAIN;
			else
				KNL_SetVdoScaleParam(ubDisp3Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp3Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
			//! CH1/0
			ubLcdCh = ((KNL_DISP_3T_1L2R == tDispType) || (KNL_DISP_3T_2T1B == tDispType))?0:1;
			sLcdInfor.tChRes[ubLcdCh].uwChInputHsize = (tDispRot == KNL_DISP_ROTATE_90)?(uwKNL_GetVdoV(ubDisp2Src) * (2 >> ubScaleParam)):(uwKNL_GetVdoH(ubDisp2Src) * (2 >> ubScaleParam));
			sLcdInfor.tChRes[ubLcdCh].uwChInputVsize = (tDispRot == KNL_DISP_ROTATE_90)?((uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam)):((uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam));
			sLcdInfor.tChRes[ubLcdCh].uwCropHstart   = 0;
			sLcdInfor.tChRes[ubLcdCh].uwCropVstart   = 0;
			sLcdInfor.tChRes[ubLcdCh].uwCropHsize    = (tDispRot == KNL_DISP_ROTATE_90)?(uwKNL_GetVdoV(ubDisp2Src) * (2 >> ubScaleParam)):(uwKNL_GetVdoH(ubDisp2Src) * (2 >> ubScaleParam));
			sLcdInfor.tChRes[ubLcdCh].uwCropVsize    = (tDispRot == KNL_DISP_ROTATE_90)?((uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam)):((uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam));
		}
		pLcdCropScaleParam = (LCD_INFOR_TYP *)(&sLcdInfor);
	}

	if(tKNL_GetDispType() == KNL_DISP_3T_3COL)
	{
		KNL_DISP_ROTATE tDispRot = KNL_DISP_ROTATE_0;
		uint8_t ubScaleParam = 0;

		tDispRot = tKNL_GetDispRotate();
		ubDisp1Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
		ubDisp2Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION2);
		ubDisp3Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION3);
		ubDisp4Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION4);
		if(KNL_DISP_ROTATE_0 == tDispRot)
		{
			sLcdInfor.ubChNum = 2;
			sLcdInfor.tDispType = LCD_DISP_2T_H12;
			sLcdInfor.uwLcdOutputHsize = tKNL_Info.uwDispH;
			sLcdInfor.uwLcdOutputVsize = tKNL_Info.uwDispV;
			//! CH0
			ubDisp1Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[0]:ubDisp1Src;
			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src   = KNL_SRC_1_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropHstart = 0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;
			sLcdInfor.tChRes[0].uwCropHsize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropVsize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			//! CH1
			ubDisp2Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[1]:ubDisp2Src;
			if(KNL_SRC_NONE == ubDisp2Src)
			{
				ubDisp2Src   = KNL_SRC_2_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp2Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp2Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			}
			ubDisp3Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[2]:ubDisp3Src;
			if(KNL_SRC_NONE == ubDisp3Src)
				ubDisp3Src   = KNL_SRC_3_MAIN;
			else
				KNL_SetVdoScaleParam(ubDisp3Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp3Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
			sLcdInfor.tChRes[1].uwChInputHsize = uwKNL_GetVdoH(ubDisp2Src) * (2 >> ubScaleParam);
			sLcdInfor.tChRes[1].uwChInputVsize = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwCropHstart   = 0;
			sLcdInfor.tChRes[1].uwCropVstart   = 0;
			sLcdInfor.tChRes[1].uwCropHsize    = uwKNL_GetVdoH(ubDisp2Src) * (2 >> ubScaleParam);
			sLcdInfor.tChRes[1].uwCropVsize    = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
		}
		else if(KNL_DISP_ROTATE_90 == tDispRot)
		{
			sLcdInfor.ubChNum = 3;
			sLcdInfor.tDispType = LCD_DISP_3TC_SHOW_111;
			sLcdInfor.uwLcdOutputHsize = tKNL_Info.uwDispV;
			sLcdInfor.uwLcdOutputVsize = tKNL_Info.uwDispH;
			//! CH0
			ubDisp3Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[2]:ubDisp3Src;
			if(KNL_SRC_NONE == ubDisp3Src)
			{
				ubDisp3Src   = KNL_SRC_3_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp3Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp3Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp3Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp3Src);
			}
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoV(ubDisp3Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoH(ubDisp3Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropHstart   = 0;
			sLcdInfor.tChRes[0].uwCropVstart   = 0;
			sLcdInfor.tChRes[0].uwCropHsize    = uwKNL_GetVdoV(ubDisp3Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropVsize    = uwKNL_GetVdoH(ubDisp3Src) >> ubScaleParam;
			//! CH1
			ubDisp2Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[1]:ubDisp2Src;
			if(KNL_SRC_NONE == ubDisp2Src)
			{
				ubDisp2Src   = KNL_SRC_2_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp2Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp2Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			}
			sLcdInfor.tChRes[1].uwChInputHsize = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwChInputVsize = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwCropHstart   = 0;
			sLcdInfor.tChRes[1].uwCropVstart   = 0;
			sLcdInfor.tChRes[1].uwCropHsize    = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwCropVsize    = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;
			//! CH2
			ubDisp1Src = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[0]:ubDisp1Src;
			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src   = KNL_SRC_1_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) >= 1024)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}
			sLcdInfor.tChRes[2].uwChInputHsize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[2].uwChInputVsize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[2].uwCropHstart   = 0;
			sLcdInfor.tChRes[2].uwCropVstart   = 0;
			sLcdInfor.tChRes[2].uwCropHsize    = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[2].uwCropVsize    = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
		}
		pLcdCropScaleParam = (LCD_INFOR_TYP *)(&sLcdInfor);
	}

	//justin 2020.03.02
	if(tKNL_GetDispType() == KNL_DISP_3T_3C)
	{		
		//sLcdInfor.tDispType = LCD_DISP_3TC;
		sLcdInfor.tDispType = LCD_DISP_3TC_SHOW_111;
		
		sLcdInfor.ubChNum = 3;
		sLcdInfor.uwLcdOutputHsize = uwLCD_GetLcdHoSize();
		sLcdInfor.uwLcdOutputVsize = uwLCD_GetLcdVoSize();	
	
		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)
		{
			//90 rotation
			//Get Correspond Source
			ubDisp1Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
			ubDisp2Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION2);
			ubDisp3Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION3);
			ubDisp4Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION4);						
				
			//Source[0]
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoV(ubDisp1Src)/2;
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoH(ubDisp1Src)/2;			
			sLcdInfor.tChRes[0].uwCropHstart = 0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;		
			sLcdInfor.tChRes[0].uwCropHsize = uwKNL_GetVdoV(ubDisp1Src)/2;
			sLcdInfor.tChRes[0].uwCropVsize = uwKNL_GetVdoH(ubDisp1Src)/2;

			//Source[1]
			sLcdInfor.tChRes[1].uwChInputHsize = uwKNL_GetVdoV(ubDisp2Src)/2;
			sLcdInfor.tChRes[1].uwChInputVsize = uwKNL_GetVdoH(ubDisp2Src)/2;			
			sLcdInfor.tChRes[1].uwCropHstart = 0;
			sLcdInfor.tChRes[1].uwCropVstart = 0;		
			sLcdInfor.tChRes[1].uwCropHsize = uwKNL_GetVdoV(ubDisp2Src)/2;
			sLcdInfor.tChRes[1].uwCropVsize = uwKNL_GetVdoH(ubDisp2Src)/2;	

			//Source[2]
			sLcdInfor.tChRes[2].uwChInputHsize = uwKNL_GetVdoV(ubDisp3Src)/2;
			sLcdInfor.tChRes[2].uwChInputVsize = uwKNL_GetVdoH(ubDisp3Src)/2;			
			sLcdInfor.tChRes[2].uwCropHstart = 0;
			sLcdInfor.tChRes[2].uwCropVstart = 0;		
			sLcdInfor.tChRes[2].uwCropHsize = uwKNL_GetVdoV(ubDisp3Src)/2;
			sLcdInfor.tChRes[2].uwCropVsize = uwKNL_GetVdoH(ubDisp3Src)/2;
		}		
		pLcdCropScaleParam = (LCD_INFOR_TYP *)(&sLcdInfor);
	}	
	
	if(tKNL_GetDispType() == KNL_DISP_DUAL_C)
	{
		uint8_t ubScaleParam = 0;
		sLcdInfor.tDispType = LCD_DISP_2T_V;
		sLcdInfor.ubChNum = 2;
//		sLcdInfor.uwLcdOutputHsize = uwLCD_GetLcdHoSize();
//		sLcdInfor.uwLcdOutputVsize = uwLCD_GetLcdVoSize();		
		
		//Get Correspond Source
		ubDisp1Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
		ubDisp2Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION2);
		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
		{	
			// For Kernel	
			// -----------------
			// |   	 Disp1     |
			// | 	  F(2)     |
			// |---------------|
			// |      B(3)     |
			// |   	 Disp2     |
			// -----------------
			
			// For LCD IP	
			// -----------------
			// |	   CH0     |
			// | 	           |
			// |---------------|
			// |               |
			// |	   CH1     |
			// -----------------			
			
			sLcdInfor.uwLcdOutputHsize = tKNL_Info.uwDispH;
			sLcdInfor.uwLcdOutputVsize = tKNL_Info.uwDispV;

			//Source[0]
			ubDisp1Src = (KNL_SRC_NONE == ubDisp1Src)?KNL_SRC_1_MAIN:ubDisp1Src;
			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src   = KNL_SRC_1_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) >= 1920)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) >= 1920)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropHstart = 0;	//! sLcdInfor.tChRes[0].uwCropHstart = (uwKNL_GetVdoH(ubDisp1Src) == 1280)?210:0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;
			sLcdInfor.tChRes[0].uwCropHsize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;	//! sLcdInfor.tChRes[0].uwCropHsize = (uwKNL_GetVdoH(ubDisp1Src) == 1280)?860:uwKNL_GetVdoH(ubDisp1Src);
			sLcdInfor.tChRes[0].uwCropVsize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;

			//Source[1]
			ubDisp2Src = (KNL_SRC_NONE == ubDisp2Src)?KNL_SRC_2_MAIN:ubDisp2Src;
			if(KNL_SRC_NONE == ubDisp2Src)
			{
				ubDisp2Src   = KNL_SRC_2_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp2Src) >= 1920)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp2Src) >= 1920)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			}
			sLcdInfor.tChRes[1].uwChInputHsize = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwChInputVsize = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwCropHstart = 0;	//! sLcdInfor.tChRes[1].uwCropHstart = (uwKNL_GetVdoH(ubDisp2Src) == 1280)?210:0;
			sLcdInfor.tChRes[1].uwCropVstart = 0;
			sLcdInfor.tChRes[1].uwCropHsize = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;	//! sLcdInfor.tChRes[1].uwCropHsize = (uwKNL_GetVdoH(ubDisp2Src) == 1280)?860:uwKNL_GetVdoH(ubDisp2Src);
			sLcdInfor.tChRes[1].uwCropVsize = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
		}
		else if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)
		{
			sLcdInfor.uwLcdOutputHsize = tKNL_Info.uwDispV;
			sLcdInfor.uwLcdOutputVsize = tKNL_Info.uwDispH;

			//Source[0]
			ubDisp1Src = (KNL_SRC_NONE == ubDisp1Src)?KNL_SRC_1_MAIN:ubDisp1Src;
			if(KNL_SRC_NONE == ubDisp1Src)
			{
				ubDisp1Src   = KNL_SRC_1_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) >= 1920)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp1Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp1Src) >= 1920)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
			}
			sLcdInfor.tChRes[0].uwChInputHsize = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwChInputVsize = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropHstart = 0;
			sLcdInfor.tChRes[0].uwCropVstart = 0;		//! sLcdInfor.tChRes[0].uwCropVstart = (uwKNL_GetVdoH(ubDisp1Src) == 1280)?210:0;
			sLcdInfor.tChRes[0].uwCropHsize  = uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam;
			sLcdInfor.tChRes[0].uwCropVsize  = uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam;	//! sLcdInfor.tChRes[0].uwCropVsize  = (uwKNL_GetVdoH(ubDisp1Src) == 1280)?860:uwKNL_GetVdoH(ubDisp1Src);

			//Source[1]
#if defined(BSP_DVR_SDK)
			ubDisp2Src = (KNL_SRC_NONE == ubDisp2Src)?KNL_SRC_1_MAIN:ubDisp2Src;
#else
			ubDisp2Src = (KNL_SRC_NONE == ubDisp2Src)?KNL_SRC_2_MAIN:ubDisp2Src;
#endif
			if(KNL_SRC_NONE == ubDisp2Src)
			{
				ubDisp2Src   = KNL_SRC_2_MAIN;
				ubScaleParam = (uwKNL_GetVdoH(ubDisp2Src) >= 1920)?1:0;
			}
			else
			{
				KNL_SetVdoScaleParam(ubDisp2Src, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(ubDisp2Src) >= 1920)?KNL_SCALE_X0P5:KNL_SCALE_X1));
				ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			}
			sLcdInfor.tChRes[1].uwChInputHsize = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwChInputVsize = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwCropHstart = 0;
			sLcdInfor.tChRes[1].uwCropVstart = 0;	//! sLcdInfor.tChRes[1].uwCropVstart = (uwKNL_GetVdoH(ubDisp2Src) == 1280)?210:0;
			sLcdInfor.tChRes[1].uwCropHsize  = uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam;
			sLcdInfor.tChRes[1].uwCropVsize  = uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam;	//! sLcdInfor.tChRes[1].uwCropVsize  = (uwKNL_GetVdoH(ubDisp2Src) == 1280)?860:uwKNL_GetVdoH(ubDisp2Src);			
		}
		pLcdCropScaleParam = (LCD_INFOR_TYP *)(&sLcdInfor);
	}	

	if(NULL == pLcdCropScaleParam)
		return 0;

	ubKNL_LcdDispParamActiveFlg = 1;
	return 1;
#else
	return 0;
#endif
}
//------------------------------------------------------------------------------
uint8_t KNL_ChkLcdDispLocation(uint8_t ubSrcNum)
{
#if KNL_LCD_FUNC_ENABLE
	KNL_DISP_LOCATION tDispLocate;

	tDispLocate = tKNL_GetDispLocation(ubSrcNum);
	return (tDispLocate > KNL_DISP_LOCATION4)?0:1;
#else
	return 0;
#endif
}
//------------------------------------------------------------------------------
void KNL_LcdDisplaySetting(void)
{
#if KNL_LCD_FUNC_ENABLE
	LCD_RESULT tKNL_LcdJpegDisRet;

#if (APP_DOORPHONE_ENABLE==1)
    if(ubKNK_VideoOnOffFg[KNL_STA1]!=1&&ubKNK_VideoOnOffFg[KNL_STA2]!=1&&ubKNK_VideoOnOffFg[KNL_STA3]!=1&&ubKNK_VideoOnOffFg[KNL_STA4]!=1)
        return;
#endif
	tKNL_LcdJpegDisRet = tLCD_JpegDecodeDisable();
	if((NULL == pLcdCropScaleParam) || ((!ubKNL_LcdDispParamActiveFlg) && (LCD_JPEG_DECDIS_FAIL == tKNL_LcdJpegDisRet)))
	{
		osSemaphoreRelease(osKNL_LcdDispInfoSem);
		return;
	}
	LCD_SetLcdBufAddr(ulBUF_GetBlkBufAddr(0, BUF_LCD_IP));
	if (LCD_OK != tLCD_CropScale(pLcdCropScaleParam))
	{
		printd(DBG_ErrorLvl, "Set LCD Crop & Scale Fail !!!\r\n");
		osSemaphoreRelease(osKNL_LcdDispInfoSem);
		return;
	}
	ubKNL_LcdDispParamActiveFlg = 0;

#if (APP_DUAL_HOST_ENABLE == 1)
	if((VDO_DISP_TYPE == KNL_DISP_QUAD) && (KNL_DISP_ROTATE_SETTING == KNL_DISP_ROTATE_0))
		tLCD_WinSft(LCD_CH2, LCD->LCD_HO_SIZE/4, 0);
#endif
	
#endif
}
//------------------------------------------------------------------------------
void KNL_ResetLcdChannel(void)
{
#if KNL_LCD_FUNC_ENABLE
	LCD_ChDisable(LCD_CH0);
	LCD_ChDisable(LCD_CH1);
	LCD_ChDisable(LCD_CH2);
	LCD_ChDisable(LCD_CH3);
#endif
}
//------------------------------------------------------------------------------
void KNL_ResetDispSrc(uint8_t ubSrcNum)
{
	if(tKNL_Info.ubDisp1SrcNum == ubSrcNum)
	{
		tKNL_Info.ubDisp1SrcNum = KNL_SRC_NONE;
		if((KNL_DISP_H == tKNL_GetDispType()) && (KNL_DISP_ROTATE_0 == tKNL_GetDispRotate()))
			tKNL_delMergeHSrc = (KNL_SRC)ubSrcNum;
	}
	else if(tKNL_Info.ubDisp2SrcNum == ubSrcNum)
	{
		tKNL_Info.ubDisp2SrcNum = KNL_SRC_NONE;
		if(((KNL_DISP_H == tKNL_GetDispType()) && (KNL_DISP_ROTATE_90 == tKNL_GetDispRotate())) ||
		   (((KNL_DISP_3T_2L1R == tKNL_GetDispType()) || (KNL_DISP_3T_1L2R == tKNL_GetDispType())) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)) ||
		   (((KNL_DISP_3T_2T1B == tKNL_GetDispType()) || (KNL_DISP_3T_1T2B == tKNL_GetDispType())) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0))  ||
		   (( KNL_DISP_3T_3COL == tKNL_GetDispType()) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)))
			tKNL_delMergeHSrc = (KNL_SRC)ubSrcNum;
	}
	else if(tKNL_Info.ubDisp3SrcNum == ubSrcNum)
	{
		tKNL_Info.ubDisp3SrcNum = KNL_SRC_NONE;
		if(((KNL_DISP_H == tKNL_GetDispType()) && (KNL_DISP_ROTATE_90 == tKNL_GetDispRotate())) ||
		   (((KNL_DISP_3T_2L1R == tKNL_GetDispType()) || (KNL_DISP_3T_1L2R == tKNL_GetDispType())) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)) ||
		   (((KNL_DISP_3T_2T1B == tKNL_GetDispType()) || (KNL_DISP_3T_1T2B == tKNL_GetDispType())) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0))  ||
		   (( KNL_DISP_3T_3COL == tKNL_GetDispType()) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)))
			tKNL_delMergeHSrc = (KNL_SRC)ubSrcNum;
	}
	else if(tKNL_Info.ubDisp4SrcNum == ubSrcNum)
	{
		tKNL_Info.ubDisp4SrcNum = KNL_SRC_NONE;
		if((KNL_DISP_H == tKNL_GetDispType()) && (KNL_DISP_ROTATE_0 == tKNL_GetDispRotate()))
			tKNL_delMergeHSrc = (KNL_SRC)ubSrcNum;
	}
}
//------------------------------------------------------------------------------
void KNL_SetDispSrc(KNL_DISP_LOCATION tDispLocation,uint8_t ubDispSrcNum)
{
#ifndef S2019A
	if(tDispLocation == KNL_DISP_LOCATION1)
		//printf("DispLocat1:%d @%s\r\n",ubDispSrcNum,__func__);
		printf("DispL1:%d @%s\r\n",ubDispSrcNum,__func__);
	if(tDispLocation == KNL_DISP_LOCATION2)
		//printf("DispLocat2:%d @%s\r\n",ubDispSrcNum,__func__);
		printf("DispL2:%d @%s\r\n",ubDispSrcNum,__func__);
	if(tDispLocation == KNL_DISP_LOCATION3)
		//printf("DispLocat3:%d @%s\r\n",ubDispSrcNum,__func__);
		printf("DispL3:%d @%s\r\n",ubDispSrcNum,__func__);
	if(tDispLocation == KNL_DISP_LOCATION4)
		//printf("DispLocat4:%d @%s\r\n",ubDispSrcNum,__func__);
		printf("DispL:%d @%s\r\n",ubDispSrcNum,__func__);
#endif
	
	KNL_ResetDispSrc(ubDispSrcNum);
	if(tDispLocation == KNL_DISP_LOCATION1)
	{
		tKNL_Info.ubDisp1SrcNum = ubDispSrcNum;
	}
	if(tDispLocation == KNL_DISP_LOCATION2)
	{
		tKNL_Info.ubDisp2SrcNum = ubDispSrcNum;
		if((KNL_DISP_H == tKNL_GetDispType()) && (KNL_DISP_ROTATE_0 == tKNL_GetDispRotate()))
			KNL_SetVdoScaleParam(tKNL_Info.ubDisp2SrcNum, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(tKNL_Info.ubDisp2SrcNum) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
	}
	if(tDispLocation == KNL_DISP_LOCATION3)
	{
		tKNL_Info.ubDisp3SrcNum = ubDispSrcNum;
		if((KNL_DISP_H == tKNL_GetDispType()) && (KNL_DISP_ROTATE_0 == tKNL_GetDispRotate()))
			KNL_SetVdoScaleParam(tKNL_Info.ubDisp3SrcNum, KNL_NODE_H264_DEC, ((uwKNL_GetVdoH(tKNL_Info.ubDisp3SrcNum) >= 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1));
	}
	if(tDispLocation == KNL_DISP_LOCATION4)
	{
		tKNL_Info.ubDisp4SrcNum = ubDispSrcNum;
	}
}
//------------------------------------------------------------------------------
uint8_t ubKNL_GetDispSrc(KNL_DISP_LOCATION tDispLocation)
{
	if(tDispLocation == KNL_DISP_LOCATION1)
	{
		return tKNL_Info.ubDisp1SrcNum;
	}
	else if(tDispLocation == KNL_DISP_LOCATION2)
	{
		return tKNL_Info.ubDisp2SrcNum;
	}
	else if(tDispLocation == KNL_DISP_LOCATION3)
	{
		return tKNL_Info.ubDisp3SrcNum;
	}
	else if(tDispLocation == KNL_DISP_LOCATION4)
	{
		return tKNL_Info.ubDisp4SrcNum;
	}
	else
	{
		return KNL_SRC_NONE;
	}
}
//------------------------------------------------------------------------------
KNL_DISP_LOCATION tKNL_GetDispLocation(uint8_t ubSrcNum)
{
	if(tKNL_Info.ubDisp1SrcNum == ubSrcNum)
	{
		return KNL_DISP_LOCATION1;
	}
	else if(tKNL_Info.ubDisp2SrcNum == ubSrcNum)
	{
		return KNL_DISP_LOCATION2;
	}
	else if(tKNL_Info.ubDisp3SrcNum == ubSrcNum)
	{
		return KNL_DISP_LOCATION3;
	}
	else if(tKNL_Info.ubDisp4SrcNum == ubSrcNum)
	{
		return KNL_DISP_LOCATION4;
	}
	else
	{
		printd(DBG_ErrorLvl, "Err DispLocation !!!!\r\n");
		return KNL_DISP_LOCATION_ERR;
	}
}
//------------------------------------------------------------------------------
#define IS_NALU_SC(data) ((data[0] == 0x0) && (data[1] == 0x0) && (data[2] == 0x0) && (data[3] == 0x01))
KNL_FRAME_TYPE tKNL_GetFrameType(uint32_t ulAddr)
{
#define NAL_UNIT_VPS	32
	uint8_t *pNalu, ubNalUnit = 0;
	pNalu     = (uint8_t *)ulAddr;
	ubNalUnit = *((uint8_t *)(ulAddr+4));
	if((*((uint8_t *)(ulAddr+4))) == 0x67)
	{
		return KNL_I_FRAME;
	}
	else if(IS_NALU_SC(pNalu) && !(ubNalUnit & 0x1) && ((ubNalUnit >> 1) == NAL_UNIT_VPS))	//! VPS
	{
		return (USBD_UVC_H265_FMT == USBD_UVC_FMT)?KNL_I_FRAME:KNL_ERR_FRAME;
	}
	else
	{
		return KNL_P_FRAME;
	}
}
//------------------------------------------------------------------------------
void KNL_DacStopCase(void)
{
	ulKNL_DacStartToPlayCnt = 0;
	ubKNL_DacStartToPlayFlg = 0;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_ChkImgRdy(void)
{
	return ubKNL_ImgRdy;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_ChkVdoFlowAct(uint8_t ubSrcNum)
{
	if(KNL_VIDEO_PLAY == tKNL_GetRecordFunc() || KNL_PHOTO_PLAY == tKNL_GetRecordFunc())
		return TRUE;
	return ubKNL_VdoFlowActiveFlg[ubSrcNum];
}
//------------------------------------------------------------------------------
uint8_t ubKNL_ChkAdoFlowAct(uint8_t ubSrcNum)
{
	if(ubKNL_ExistNode(ubSrcNum,KNL_NODE_ADC))
	{
		return ubKNL_AdcFlowActiveFlg;
	}
	if(ubKNL_ExistNode(ubSrcNum,KNL_NODE_DAC)||ubKNL_ExistNode(ubSrcNum,KNL_NODE_DAC_BUF)||ubKNL_ExistNode(ubSrcNum,KNL_NODE_COMM_RX_ADO))
	{
		return ubKNL_DacFlowActiveFlg[ubSrcNum];
	}
	printd(DBG_ErrorLvl, "Err[%d] @ubKNL_ChkAdoFlowAct\r\n", ubSrcNum);
	return 0;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_ChkDacFlowAct(uint8_t ubSrcNum)
{
	return ubKNL_DacFlowActiveFlg[ubSrcNum];
}

H264_ENCODE_INDEX tKNL_GetEncIdx(void)
{
	return tKNL_Info.tEncIdx;
}
//------------------------------------------------------------------------------
uint32_t ulKNL_WithSenDataRate = 0;
void KNL_ImgEncInit(H264_ENCODE_INDEX CodecIdx,uint16_t uwVdoH,uint16_t uwVdoV)
{
	H264_MROI_SETUP MROISetup;	
	
	if(CodecIdx == ENCODE_0)
	{
		ulKNL_CurFrmIdx[0] = 0;
	}
	else if(CodecIdx == ENCODE_1)
	{
		ulKNL_CurFrmIdx[1] = 0;
	}
	else if(CodecIdx == ENCODE_2)
	{
		ulKNL_CurFrmIdx[2] = 0;
	}
	else if(CodecIdx == ENCODE_3)
	{
		ulKNL_CurFrmIdx[3] = 0;
	}
	else
	{
		printd(DBG_ErrorLvl, "Encode Index Err !\n");
		return;
	}
	
	if(CodecIdx == ENCODE_0)
	{
	#if (defined(OP_AP) && defined(BSP_DVR_SDK))
		H264_EncodeInit(CodecIdx,uwVdoH,uwVdoV,ulBUF_GetBlkBufAddr(0,BUF_IMG_ENC),ubKNL_GetVdoFps(),30);//DECODE[0]
	#else
		H264_EncodeInit(CodecIdx,uwVdoH,uwVdoV,ulBUF_GetBlkBufAddr(0,BUF_IMG_ENC),ubKNL_GetVdoFps(),ulKNL_GetVdoGop());//DECODE[0]
	#endif
		tKNL_Info.tEncIdx = ENCODE_0;
	}
	if(CodecIdx == ENCODE_1)
	{
	#if (defined(OP_AP) && defined(BSP_DVR_SDK))
		H264_EncodeInit(CodecIdx,uwVdoH,uwVdoV,ulBUF_GetBlkBufAddr(1,BUF_IMG_ENC),ubKNL_GetVdoFps(),30);//DECODE[0]
	#else
		H264_EncodeInit(CodecIdx,uwVdoH,uwVdoV,ulBUF_GetBlkBufAddr(1,BUF_IMG_ENC),ubKNL_GetVdoFps(),ulKNL_GetVdoGop());//DECODE[1]
	#endif
		tKNL_Info.tEncIdx = ENCODE_1;
	}
	if(CodecIdx == ENCODE_2)
	{
	#if (defined(OP_AP) && defined(BSP_DVR_SDK))
		H264_EncodeInit(CodecIdx,uwVdoH,uwVdoV,ulBUF_GetBlkBufAddr(2,BUF_IMG_ENC),ubKNL_GetVdoFps(),30);//DECODE[0]
	#else
		H264_EncodeInit(CodecIdx,uwVdoH,uwVdoV,ulBUF_GetBlkBufAddr(2,BUF_IMG_ENC),ubKNL_GetVdoFps(),ulKNL_GetVdoGop());//DECODE[2]
	#endif		
		tKNL_Info.tEncIdx = ENCODE_2;
	}
	if(CodecIdx == ENCODE_3)
	{
	#if (defined(OP_AP) && defined(BSP_DVR_SDK))
		H264_EncodeInit(CodecIdx,uwVdoH,uwVdoV,ulBUF_GetBlkBufAddr(3,BUF_IMG_ENC),ubKNL_GetVdoFps(),30);//DECODE[0]
	#else
		H264_EncodeInit(CodecIdx,uwVdoH,uwVdoV,ulBUF_GetBlkBufAddr(3,BUF_IMG_ENC),ubKNL_GetVdoFps(),ulKNL_GetVdoGop());//DECODE[3]
	#endif
		tKNL_Info.tEncIdx = ENCODE_3;
	}	
	
	#if (defined(BUC_CU) && defined(BSP_DVR_SDK))
	H264_SetGOP(CodecIdx,30);
	#else
	H264_SetGOP(CodecIdx,ulKNL_GetVdoGop());
	#endif	

#if VBM_BU
	H264_SetAROIEN(CodecIdx,H264_ENABLE,MROI,MV_OR_SKIN);		
	H264_SetCondensedMode(CodecIdx,H264_ENABLE,7);
#endif

#if BUC_CAM	
	H264_SetAROIEN(CodecIdx,H264_DISABLE,MROI,MV_OR_SKIN);	
	H264_SetCondensedMode(CodecIdx,H264_DISABLE,7);
#endif
	
	MROISetup.Num = MROI_0;	
	MROISetup.ENABLE = H264_DISABLE;	
	MROISetup.ubWeight =1;
	MROISetup.uwQP_Value =-1;
	MROISetup.ulPosX = 3;
	MROISetup.ulWidth = 3;
	MROISetup.ulPosY = 1;
	MROISetup.ulHeight = 4;
	MROISetup.ExtSize =SIZE_0;	
	H264_SetMROI(CodecIdx,MROISetup);
	
	MROISetup.Num = MROI_1;	
	MROISetup.ENABLE = H264_DISABLE;	
	MROISetup.ubWeight =7;
	MROISetup.uwQP_Value =-2;
	MROISetup.ulPosX = 1;
	MROISetup.ulWidth = 4;
	MROISetup.ulPosY = 3;
	MROISetup.ulHeight = 3;
	MROISetup.ExtSize =SIZE_0;	
	H264_SetMROI(CodecIdx,MROISetup);

	MROISetup.Num = MROI_2;
	MROISetup.ENABLE = H264_DISABLE;	
	MROISetup.ubWeight =5;
	MROISetup.uwQP_Value =9;
	MROISetup.ulPosX = 2;
	MROISetup.ulWidth = 3;
	MROISetup.ulPosY = 4;
	MROISetup.ulHeight = 2;
	MROISetup.ExtSize =SIZE_0;	
	H264_SetMROI(CodecIdx,MROISetup);

	MROISetup.Num = MROI_7;	
	MROISetup.ENABLE = H264_DISABLE;	
	MROISetup.ubWeight =1;
	MROISetup.uwQP_Value =6;
	MROISetup.ulPosX = 2;
	MROISetup.ulWidth = 3;
	MROISetup.ulPosY = 1;
	MROISetup.ulHeight = 1;
	MROISetup.ExtSize =SIZE_0;	
	H264_SetMROI(CodecIdx,MROISetup);
		
	H264_SetMROIModeEnable(CodecIdx,H264_DISABLE);	
	H264_SetSkinMode(CodecIdx,H264_DISABLE);		

	if(ubRC_GetFlg(CodecIdx))
	{
		H264_SetMaxQP(CodecIdx,ubRC_GetMaxQp(CodecIdx));
		H264_SetMinQP(CodecIdx,ubRC_GetMinQp(CodecIdx));
		H264_RcSetEN(CodecIdx,H264_ENABLE,CBR,ulRC_GetInitBitRate(CodecIdx));
	}
	else
	{
#if (defined(OP_STA)&&defined(VDO_SUBPATH_ENABLE)&&(VDO_SUBPATH_ENABLE!=0))
        H264_SetMaxQP(CodecIdx,50);
        H264_SetMinQP(CodecIdx,20);
#if defined(BSP_VBM_SDK)
        H264_RcSetEN(CodecIdx,H264_ENABLE,CBR,(1024*800L));
		ulKNL_WithSenDataRate = 1024*800;
#else
        H264_RcSetEN(CodecIdx,H264_ENABLE,CBR,(1024*8192L));     
		ulKNL_WithSenDataRate = 1024*8192;		
#endif
#else        
        H264_SetQp(CodecIdx,ubRC_GetTargetQp(CodecIdx),ubRC_GetTargetQp(CodecIdx));
				//printf("   +++++++-----H264_SetQp 1----++++++\n");	//xxx
        H264_RcSetEN(CodecIdx,H264_DISABLE,CBR,0x0A0000L);
		ulKNL_WithSenDataRate = 0x0A0000L;
#endif
	}
#if (defined(OP_AP) && defined(BSP_DVR_SDK))
	H264_SetMaxQP(CodecIdx,50);
	H264_SetMinQP(CodecIdx,28);
	H264_RcSetEN(CodecIdx,H264_ENABLE,CBR,(KNL_CU_STORAGE_DATARATE*8192));
	ulKNL_WithSenDataRate = KNL_CU_STORAGE_DATARATE*8192;
#endif
}
//------------------------------------------------------------------------------
void KNL_ImgDecInit(H264_DECODE_INDEX CodecIdx,uint16_t uwVdoH,uint16_t uwVdoV)
{
	//printf("(H264D[%d]:%d,%d)\r\n",CodecIdx,uwVdoH,uwVdoV);
	if(CodecIdx == DECODE_0)
	{
		H264_DecoderInit(CodecIdx,uwVdoH,uwVdoV,ulBUF_GetBlkBufAddr(0,BUF_IMG_DEC));
	}
	if(CodecIdx == DECODE_1)
	{
		H264_DecoderInit(CodecIdx,uwVdoH,uwVdoV,ulBUF_GetBlkBufAddr(1,BUF_IMG_DEC));
	}
	if(CodecIdx == DECODE_2)
	{
		H264_DecoderInit(CodecIdx,uwVdoH,uwVdoV,ulBUF_GetBlkBufAddr(2,BUF_IMG_DEC));
	}
	if(CodecIdx == DECODE_3)
	{
		H264_DecoderInit(CodecIdx,uwVdoH,uwVdoV,ulBUF_GetBlkBufAddr(3,BUF_IMG_DEC));
	}
	if(CodecIdx > DECODE_3)
	{
		printd(DBG_ErrorLvl, "Decode Index Err\n");
	}
}
//------------------------------------------------------------------------------
void KNL_ImageDecodeSetup(uint8_t ubSrcNum)
{
	KNL_NODE_INFO tNodeInfo;

	if(ubKNL_ExistNode(ubSrcNum, KNL_NODE_H264_DEC))
	{
		H264_Reset();
		tNodeInfo = tKNL_GetNodeInfo(ubSrcNum, KNL_NODE_H264_DEC);
		KNL_ImgDecInit((H264_DECODE_INDEX)tNodeInfo.ubCodecIdx, uwKNL_GetVdoH(ubSrcNum), uwKNL_GetVdoV(ubSrcNum));
		ubKNL_InitH264DecFlg[(H264_DECODE_INDEX)tNodeInfo.ubCodecIdx]= 1;
	}
	ubKNL_RcvFirstIFrame[ubSrcNum] = 0;
}
//------------------------------------------------------------------------------
void KNL_ImageEncodeSetup(uint8_t ubSrcNum)
{
	KNL_NODE_INFO tNodeInfo;

	if(ubKNL_ExistNode(ubSrcNum, KNL_NODE_H264_ENC))
	{
		tNodeInfo = tKNL_GetNodeInfo(ubSrcNum, KNL_NODE_H264_ENC);
		KNL_ImgEncInit((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx, tNodeInfo.uwVdoH, tNodeInfo.uwVdoV);
	}
}
//------------------------------------------------------------------------------
uint8_t ubKNL_ImgEnc(H264_ENCODE_INDEX CodecIdx,uint32_t ulYuvAddr,uint32_t ulBsAddr)
{
	IMG_IMAGE_TASK ImageTask;
	struct H264_TASK H264Task;

	//Pre-Process
	//ubKNL_ImgRdy = 0;
	osSemaphoreWait(tKNL_ImgSem, osWaitForever);

	//printd(DBG_Debug1Lvl, "H->ET_Y:0x%x_B:0x%x\r\n",ulYuvAddr,ulBsAddr);
	//printd(DBG_Debug1Lvl, "H->ET\n");

#if (defined(OP_STA) || (defined(OP_AP) && defined(BSP_DVR_SDK)))
	#if ISP_DS_EN
	KNL_IspDsFunc();
	#endif
	#if IMG_DS_EN
	KNL_ImgCtrlDsFunc();
	#endif
#endif

	H264Task.DesAddr 		= ulBsAddr;
	H264Task.EncodeStream 	= CodecIdx;
	H264Task.Type			= H264_ENCODE;	
	ImageTask.InputSrcAddr 	= ulYuvAddr;
	ImageTask.H264_Task 	= &H264Task;
	ImageTask.JPEGEnable	= IMG_DISABLE;
	ImageTask.ScalingEnable = IMG_DISABLE;	
	
	IMG_StartUp(ImageTask);	
	
	return 1;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_ImgDec(H264_DECODE_INDEX CodecIdx,uint32_t ulYuvAddr,uint32_t ulBsAddr)
{	
	IMG_IMAGE_TASK ImageTask;	
	struct H264_TASK H264Task;
	IMG_MERGE_SETUP MergeSetup;	
	IMG_BOOL_RESULT RESULT;

	//Pre-Process
	//ubKNL_ImgRdy = 0;
	osSemaphoreWait(tKNL_ImgSem, osWaitForever);
	//printd(DBG_Debug3Lvl, "H->DT\r\n");

	H264Task.Type 			= H264_DECODE;
	H264Task.DecodeStream 	= CodecIdx;	
	H264Task.DesAddr 		= ulYuvAddr;
	ImageTask.InputSrcAddr 	= ulBsAddr;
	ImageTask.H264_Task 	= &H264Task;
	ImageTask.JPEGEnable	= IMG_DISABLE;
	ImageTask.ScalingEnable = IMG_ENABLE;

	MergeSetup.STATUS = IMG_DISABLE;	
	RESULT = IMG_MergeSetup(&MergeSetup);
	if(RESULT == IMG_FAIL)
	{
		printd(DBG_ErrorLvl, "Merge Setup Fail2 \n");
		return 0;
	}

	IMG_StartUp(ImageTask);

	return 1;
}

void KNL_H264DecFlgReset(void)
{
    KNL_NODE_INFO tNodeInfo;
    uint8_t i;
    //For H264 Decode
    //=======================================================================
    ubKNL_InitH264DecFlg[0] = 0;
    ubKNL_InitH264DecFlg[1] = 0;
    ubKNL_InitH264DecFlg[2] = 0;
    ubKNL_InitH264DecFlg[3] = 0;

    //Main
    for(i=0;i<4;i++)
    {
        if(ubKNL_ExistNode(KNL_SRC_1_MAIN+i,KNL_NODE_H264_DEC))
        {
            tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_MAIN+i,KNL_NODE_H264_DEC);
            if(tNodeInfo.ubCodecIdx == DECODE_0)
                ubKNL_InitH264DecFlg[0] = 1;
            else if(tNodeInfo.ubCodecIdx == DECODE_1)
                ubKNL_InitH264DecFlg[1] = 1;
            else if(tNodeInfo.ubCodecIdx == DECODE_2)
                ubKNL_InitH264DecFlg[2] = 1;
            else if(tNodeInfo.ubCodecIdx == DECODE_3)
                ubKNL_InitH264DecFlg[3] = 1;
        }
    }
    //Aux
    for(i=0;i<4;i++)
    {
        if(ubKNL_ExistNode(KNL_SRC_1_AUX+i,KNL_NODE_H264_DEC))
        {
            tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_AUX+i,KNL_NODE_H264_DEC);
            if(tNodeInfo.ubCodecIdx == DECODE_0)
                ubKNL_InitH264DecFlg[0] = 1;
            else if(tNodeInfo.ubCodecIdx == DECODE_1)
                ubKNL_InitH264DecFlg[1] = 1;
            else if(tNodeInfo.ubCodecIdx == DECODE_2)
                ubKNL_InitH264DecFlg[2] = 1;
            else if(tNodeInfo.ubCodecIdx == DECODE_3)
                ubKNL_InitH264DecFlg[3] = 1;
        }
    }
    //Sub
    for(i=0;i<4;i++)
    {
        if(ubKNL_ExistNode(KNL_SRC_1_SUB+i,KNL_NODE_H264_DEC))
        {
            tNodeInfo = tKNL_GetNodeInfo(KNL_SRC_1_SUB+i,KNL_NODE_H264_DEC);
            if(tNodeInfo.ubCodecIdx == DECODE_0)
                ubKNL_InitH264DecFlg[0] = 1;
            else if(tNodeInfo.ubCodecIdx == DECODE_1)
                ubKNL_InitH264DecFlg[1] = 1;
            else if(tNodeInfo.ubCodecIdx == DECODE_2)
                ubKNL_InitH264DecFlg[2] = 1;
            else if(tNodeInfo.ubCodecIdx == DECODE_3)
                ubKNL_InitH264DecFlg[3] = 1;
        }
    }   
}

//------------------------------------------------------------------------------
#if (defined(OP_STA) || defined(BSP_DVR_SDK))
uint8_t ubKNL_UpdateUvcImage(KNL_PROCESS tProc, KNL_NODE tCurNode)
{
	uint8_t ubUvcPathMode;
	KNL_NODE_INFO tNodeInfo;
	uint16_t uwVdoHSize, uwVdoVSize;
	static uint8_t ubKNL_UvcChgResFlag = FALSE;
	static uint16_t uwKNL_ImgHSize = 0, uwKNL_ImgVSize = 0;
    static bool bYuvChgFlag = FALSE;
    
	tNodeInfo = tKNL_GetNodeInfo(tProc.ubSrcNum, tCurNode);
	ubUvcPathMode = UVC_GetVdoFormat();
	uwVdoHSize = uwKNL_GetVdoH(tProc.ubSrcNum);
	uwVdoVSize = uwKNL_GetVdoV(tProc.ubSrcNum);
	if(KNL_TUNINGMODE_ON == KNL_GetTuningToolMode())
	{
		if((USB_UVC_VS_FORMAT_UNDEFINED != ubUvcPathMode) && (0xFF != ubKNL_SrcNumMap(tProc.ubSrcNum)))
		{
			switch(ubUvcPathMode)
			{
				case USB_UVC_VS_FORMAT_FRAME_BASED:		
				#if defined(OP_STA)				
					if(KNL_NODE_VDO_BS_BUF1 != tCurNode)
						return FALSE;
				#endif					
				#if (defined(OP_AP) && defined(BSP_DVR_SDK)) 
					if(KNL_NODE_H264_ENC != tCurNode)
						return FALSE;					
				#endif					
					if(TRUE == ubUVC_CheckResolution(uwVdoHSize, uwVdoVSize))
					{
						SEN_SetUvcPathFlag(1);
						if(FALSE == uvc_update_image((uint32_t *)tProc.ulDramAddr2, (uint32_t)tProc.ulSize))
						{
							if(tNodeInfo.ubPreNode == KNL_NODE_H264_ENC)
							{
								ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_ENC, tProc.ubSrcNum, tProc.ulDramAddr2);
								return FALSE;
							}
						}
					}
					else
					{
						uint8_t ubResData[8];

						uwKNL_ImgHSize 	= uwVdoHSize;
						uwKNL_ImgVSize 	= uwVdoVSize;
						uwVdoHSize   	= UVC_GetVdoWidth();
						uwVdoVSize   	= UVC_GetVdoHeight();
						ubResData[0] 	= (uwVdoHSize & 0xFF00) >> 8;
						ubResData[1] 	= (uwVdoHSize & 0xFF);
						ubResData[2] 	= (uwVdoVSize & 0xFF00) >> 8;
						ubResData[3] 	= (uwVdoVSize & 0xFF);
						ubResData[4] 	= tProc.ubSrcNum;
                        ubResData[5]    = 1;
						KNL_VdoResSetting((TWC_TAG)TWC_STA1, ubResData);
						printd(DBG_InfoLvl, "	->UVC Res: %d x %d\n", uwVdoHSize, uwVdoVSize);
						ubKNL_UvcChgResFlag = TRUE;
					}
					break;
				case USB_UVC_VS_FORMAT_UNCOMPRESSED:
					if(KNL_NODE_SEN_YUV_BUF != tCurNode)
						return TRUE;
				#ifndef S2019A
                    uwVdoHSize = UVC_GetVdoWidth();
                    uwVdoVSize = UVC_GetVdoHeight();
				#endif
					if(TRUE == ubUVC_CheckResolution(uwVdoHSize, uwVdoVSize) && bYuvChgFlag)
					{
						if(ubSEN_GetPathSrc(SENSOR_PATH1) == tProc.ubSrcNum)
							SEN_SetUvcPathFlag(1);
						uvc_update_image((uint32_t *)tProc.ulDramAddr1, (uint32_t)(uwVdoHSize*uwVdoVSize*2));	//! (uint32_t)(YUY2_WIDTH*YUY2_HEIGHT*2)
					}
                    else
					{
						uint8_t ubResData[8];
                        
						uwKNL_ImgHSize 	= uwVdoHSize;
						uwKNL_ImgVSize 	= uwVdoVSize;
						uwVdoHSize   	= UVC_GetVdoWidth();
						uwVdoVSize   	= UVC_GetVdoHeight();
						ubResData[0] 	= (uwVdoHSize & 0xFF00) >> 8;
						ubResData[1] 	= (uwVdoHSize & 0xFF);
						ubResData[2] 	= (uwVdoVSize & 0xFF00) >> 8;
						ubResData[3] 	= (uwVdoVSize & 0xFF);
						ubResData[4] 	= tProc.ubSrcNum;
                        ubResData[5]    = 1;
						KNL_VdoResSetting((TWC_TAG)TWC_STA1, ubResData);
						printd(DBG_InfoLvl, "	->UVC Res: %d x %d\n", uwVdoHSize, uwVdoVSize);
						ubKNL_UvcChgResFlag = TRUE;
                        bYuvChgFlag = TRUE;
					}
                    
                    if(uwKNL_ImgHSize != uwVdoHSize)
                        bYuvChgFlag = FALSE;
					break;
				default:
					return TRUE;
			}
			if(tNodeInfo.ubPreNode == KNL_NODE_H264_ENC)
			{
				if(ubRC_GetFlg(tNodeInfo.ubCodecIdx))
					ubRC_SetFlg(tNodeInfo.ubCodecIdx, FALSE);
				if((KNL_OPMODE_VBM_1T != ubKNL_GetOpMode()) && (KNL_OPMODE_BUC_1T != ubKNL_GetOpMode()))
				{
					ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_ENC, tProc.ubSrcNum, tProc.ulDramAddr2);
					return FALSE;
				}
			}
		}
		else
		{
			SEN_SetUvcPathFlag(0);
			if(tNodeInfo.ubPreNode == KNL_NODE_H264_ENC)
			{
				if(TRUE == ubKNL_UvcChgResFlag)
				{
					uint8_t ubResData[8];

					ubResData[0] = (uwKNL_ImgHSize & 0xFF00) >> 8;
					ubResData[1] = (uwKNL_ImgHSize & 0xFF);
					ubResData[2] = (uwKNL_ImgVSize & 0xFF00) >> 8;
					ubResData[3] = (uwKNL_ImgVSize & 0xFF);
					ubResData[4] = tProc.ubSrcNum;
                    ubResData[5] = 1;    
					KNL_VdoResSetting((TWC_TAG)TWC_STA1, ubResData);
					printd(DBG_InfoLvl, "	<-Img Res: %d x %d\n", uwKNL_ImgHSize, uwKNL_ImgVSize);
					ubKNL_UvcChgResFlag = FALSE;
				}
				if(!ubRC_GetFlg(tNodeInfo.ubCodecIdx))
				{
					H264_SetGOP((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx, ulKNL_GetVdoGop());
					ubRC_SetFlg(tNodeInfo.ubCodecIdx, TRUE);
				}
			}
		}
		return TRUE;
	}
	else
	{
		uint32_t ulBsAddr;
		uint32_t ulBsSize = 0;
		DMAC_RESULT tDmaResult = DMAC_OK;
		static uint8_t ubKNL_EnYuvPathFlag = FALSE;

		if((DISPLAY_1T1R != DISPLAY_MODE) ||
		   (KNL_TUNINGMODE_ON == KNL_GetTuningToolMode()))
			return TRUE;
		if(KNL_NODE_SEN_YUV_BUF == tCurNode)
		{
			if(USB_UVC_VS_FORMAT_UNCOMPRESSED != ubUvcPathMode)
			{
				SEN_SetUvcPathFlag(0);
				ubKNL_EnYuvPathFlag = FALSE;
				return TRUE;
			}
			if(FALSE == ubKNL_EnYuvPathFlag)
			{
				if(ubSEN_GetPathSrc(SENSOR_PATH1) == tProc.ubSrcNum)
					SEN_SetUvcPathFlag(1);
				ubKNL_EnYuvPathFlag = TRUE;
				return TRUE;
			}
		}
		else if(USB_UVC_VS_FORMAT_FRAME_BASED != ubUvcPathMode)
		{
			if(!ubRC_GetFlg(tNodeInfo.ubCodecIdx))
			{
				RC_EnUvcPresetMode(FALSE, tNodeInfo.ubCodecIdx);
				SetH264Rate(uwKNL_ImgHSize, uwKNL_ImgVSize, ubKNL_GetVdoFps());
			}
			if(TRUE == ubKNL_UvcChgResFlag)
			{
				uint8_t ubResData[8];

				ubResData[0] = (uwKNL_ImgHSize & 0xFF00) >> 8;
				ubResData[1] = (uwKNL_ImgHSize & 0xFF);
				ubResData[2] = (uwKNL_ImgVSize & 0xFF00) >> 8;
				ubResData[3] = (uwKNL_ImgVSize & 0xFF);
				ubResData[4] = tProc.ubSrcNum;
                ubResData[5] = 0;
				KNL_VdoResSetting((TWC_TAG)TWC_STA1, ubResData);
				printd(DBG_InfoLvl, "\n   >-Img Res: [%dx%d]\n", uwKNL_ImgHSize, uwKNL_ImgVSize);
				ubKNL_UvcChgResFlag = FALSE;
			}
			return TRUE;
		}
		else
		{
			if(ubRC_GetFlg(tNodeInfo.ubCodecIdx))
				RC_EnUvcPresetMode(TRUE, tNodeInfo.ubCodecIdx);
			if(FALSE == ubKNL_UvcChgResFlag)
			{
				uint8_t ubResData[8];

				uwKNL_ImgHSize = uwVdoHSize;
				uwKNL_ImgVSize = uwVdoVSize;
				ubResData[0] = (ISP_WIDTH & 0xFF00) >> 8;
				ubResData[1] = (ISP_WIDTH & 0xFF);
				ubResData[2] = (ISP_HEIGHT & 0xFF00) >> 8;
				ubResData[3] = (ISP_HEIGHT & 0xFF);
				ubResData[4] = tProc.ubSrcNum;
                ubResData[5] = 0; 
				KNL_VdoResSetting((TWC_TAG)TWC_STA1, ubResData);
				printd(DBG_InfoLvl, "\n   <-Img Res: [%dx%d]\n", ISP_WIDTH, ISP_HEIGHT);
				ubKNL_UvcChgResFlag = TRUE;
				goto UPD_UVC_END;
			}
		}
		if(FALSE == ubUVC_CheckResolution(uwVdoHSize, uwVdoVSize))
			goto UPD_UVC_END;
		ulBsAddr = ulBUF_GetVdoUsbdFreeBuf();
		if(BUF_FAIL == ulBsAddr)
			goto UPD_UVC_END;

		ulBsSize   = (KNL_NODE_SEN_YUV_BUF == tCurNode)?(uwVdoHSize * uwVdoVSize * 2):(uint32_t)tProc.ulSize;
	#if defined(OP_STA)	
	#if APP_UVC_CAM_ENABLE
		ulBsSize = ulKNL_ChkExtraData(tProc.ulDramAddr2,ulBsSize);
	#endif
	#endif
        if((USBD_COMPOSITE_MODE == tUSBD_GetClassMode()) && (TRUE == ubUSBD_ChkCompMscClass()))
        {
            tDmaResult = tDMAC_MemCopy(((KNL_NODE_SEN_YUV_BUF == tCurNode)?tProc.ulDramAddr1:tProc.ulDramAddr2), ulBsAddr + USBD_UVC_HEADER_LEN, ulBsSize, NULL);
            ulBsSize -= USBD_UVC_DUMMY_SZ;
        }
		else
        {
            ulBsAddr += USBD_UVC_HEADER_LEN;
            tDmaResult = tDMAC_MemCopy(((KNL_NODE_SEN_YUV_BUF == tCurNode)?tProc.ulDramAddr1:tProc.ulDramAddr2), ulBsAddr , ulBsSize, NULL);
        }

		if((DMAC_OK != tDmaResult) || (FALSE == uvc_update_image((uint32_t *)ulBsAddr, ulBsSize)))
		{
            if((USBD_COMPOSITE_MODE == tUSBD_GetClassMode()) && (TRUE == ubUSBD_ChkCompMscClass()))
                KNL_ReleaseUsbdBuf(ulBsAddr);
            else
                KNL_ReleaseUsbdBuf((ulBsAddr - USBD_UVC_HEADER_LEN));
			printd(DBG_ErrorLvl, "UVC Update Fail !\n");
		}
UPD_UVC_END:
		if(tNodeInfo.ubPreNode == KNL_NODE_H264_ENC)
			ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_ENC, tProc.ubSrcNum, tProc.ulDramAddr2);
		return FALSE;
	}
}
#endif
//------------------------------------------------------------------------------
void KNL_VdoPathReset(void)
{
	uint8_t i,j;

	for(j=0;j<KNL_SRC_NUM;j++)
	{
		for(i=0;i<KNL_MAX_NODE_NUM;i++)
		{				
			tKNL_VdoNodeInfo[j][i].ubPreNode  = KNL_NODE_NONE;
			tKNL_VdoNodeInfo[j][i].ubCurNode  = KNL_NODE_NONE;
			tKNL_VdoNodeInfo[j][i].ubNextNode = KNL_NODE_NONE;
		}
	}
}
//------------------------------------------------------------------------------
void KNL_AdoPathReset(void)
{
	uint8_t i;
	uint8_t j;
	
	for(j=0;j<KNL_SRC_NUM;j++)
	{
		for(i=0;i<KNL_MAX_NODE_NUM;i++)
		{				
			tKNL_AdoNodeInfo[j][i].ubPreNode 	= KNL_NODE_NONE;
			tKNL_AdoNodeInfo[j][i].ubCurNode 	= KNL_NODE_NONE;
			tKNL_AdoNodeInfo[j][i].ubNextNode	= KNL_NODE_NONE;
		}
	}
}
//------------------------------------------------------------------------------
uint8_t ubKNL_SetVdoPathNode(uint8_t ubSrcNum,uint8_t ubNodeIdx,KNL_NODE_INFO tNodeInfo)
{	
	if((ubNodeIdx > KNL_MAX_NODE_NUM)||(ubSrcNum > KNL_SRC_NUM))
	{
		return 0;
	}
	
	tKNL_VdoNodeInfo[ubSrcNum][ubNodeIdx].ubPreNode 	= tNodeInfo.ubPreNode;
	tKNL_VdoNodeInfo[ubSrcNum][ubNodeIdx].ubCurNode		= tNodeInfo.ubCurNode;
	tKNL_VdoNodeInfo[ubSrcNum][ubNodeIdx].ubNextNode	= tNodeInfo.ubNextNode;
	tKNL_VdoNodeInfo[ubSrcNum][ubNodeIdx].uwVdoH		= tNodeInfo.uwVdoH;	
	tKNL_VdoNodeInfo[ubSrcNum][ubNodeIdx].uwVdoV		= tNodeInfo.uwVdoV;	
	tKNL_VdoNodeInfo[ubSrcNum][ubNodeIdx].ubHMirror		= tNodeInfo.ubHMirror;
	tKNL_VdoNodeInfo[ubSrcNum][ubNodeIdx].ubVMirror		= tNodeInfo.ubVMirror;
	tKNL_VdoNodeInfo[ubSrcNum][ubNodeIdx].ubRotate		= tNodeInfo.ubRotate;
	tKNL_VdoNodeInfo[ubSrcNum][ubNodeIdx].ubHScale		= tNodeInfo.ubHScale;
	tKNL_VdoNodeInfo[ubSrcNum][ubNodeIdx].ubVScale		= tNodeInfo.ubVScale;	
	tKNL_VdoNodeInfo[ubSrcNum][ubNodeIdx].ubMergeSrc1 	= tNodeInfo.ubMergeSrc1;
	tKNL_VdoNodeInfo[ubSrcNum][ubNodeIdx].ubMergeSrc2 	= tNodeInfo.ubMergeSrc2;
	tKNL_VdoNodeInfo[ubSrcNum][ubNodeIdx].ubMergeDest 	= tNodeInfo.ubMergeDest;
	tKNL_VdoNodeInfo[ubSrcNum][ubNodeIdx].uwMergeH		= tNodeInfo.uwMergeH;
	tKNL_VdoNodeInfo[ubSrcNum][ubNodeIdx].uwMergeV		= tNodeInfo.uwMergeV;
	tKNL_VdoNodeInfo[ubSrcNum][ubNodeIdx].ubCodecIdx  	= tNodeInfo.ubCodecIdx;	
	
	return 1;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_SetAdoPathNode(uint8_t ubSrcNum,uint8_t ubNodeIdx,KNL_NODE_INFO tNodeInfo)
{	
	if(ubNodeIdx > KNL_MAX_NODE_NUM)
	{
		return 0;
	}
	
	tKNL_AdoNodeInfo[ubSrcNum][ubNodeIdx].ubPreNode 	= tNodeInfo.ubPreNode;
	tKNL_AdoNodeInfo[ubSrcNum][ubNodeIdx].ubCurNode		= tNodeInfo.ubCurNode;
	tKNL_AdoNodeInfo[ubSrcNum][ubNodeIdx].ubNextNode	= tNodeInfo.ubNextNode;	
	
	return 1;
}
//------------------------------------------------------------------------------
void KNL_VdoPathNodeReset(uint8_t ubSrcNum)
{
#if KNL_LCD_FUNC_ENABLE
	if(LCD_JPEG_ENABLE == tLCD_GetJpegDecoderStatus())
		return;

	if(ubKNL_ExistNode(ubSrcNum,KNL_NODE_LCD))
	{
		KNL_DISP_LOCATION tDispLocate;

		if(tKNL_GetDispType() == KNL_DISP_H)
		{
			tDispLocate = tKNL_GetDispLocation(ubSrcNum);
			if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
			{
				if(tDispLocate == KNL_DISP_LOCATION2)
				{
					LCD_ChDisable(LCD_CH0);
				}
				else if(tDispLocate == KNL_DISP_LOCATION3)
				{
					LCD_ChDisable(LCD_CH2);
				}
				else if((tDispLocate == KNL_DISP_LOCATION1) || (tDispLocate == KNL_DISP_LOCATION4))
				{
					LCD_ChDisable(LCD_CH1);
					tKNL_delMergeHSrc = (KNL_SRC)ubSrcNum;
				}
			}
			else if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)
			{
				if(tDispLocate == KNL_DISP_LOCATION1)
				{
					LCD_ChDisable(LCD_CH0);
				}
				else if((tDispLocate == KNL_DISP_LOCATION2) || (tDispLocate == KNL_DISP_LOCATION3))
				{
					LCD_ChDisable(LCD_CH1);
					tKNL_delMergeHSrc = (KNL_SRC)ubSrcNum;
				}
				else if(tDispLocate == KNL_DISP_LOCATION4)
				{
					LCD_ChDisable(LCD_CH2);
				}
			}
//			KNL_ResetDispSrc(ubSrcNum);
		}
		else if(tKNL_GetDispType() == KNL_DISP_SINGLE)
		{
			LCD_ChDisable(LCD_CH0);
		}
		else if((tKNL_GetDispType() == KNL_DISP_DUAL_U)||(tKNL_GetDispType() == KNL_DISP_QUAD))
		{
			tDispLocate = tKNL_SearchSrcLocation(ubSrcNum);
			if(tDispLocate == KNL_DISP_LOCATION1)
			{
				LCD_ChDisable(LCD_CH0);
			}
			else if(tDispLocate == KNL_DISP_LOCATION2)
			{
				LCD_ChDisable(LCD_CH1);
			}
			else if(tDispLocate == KNL_DISP_LOCATION3)
			{
				LCD_ChDisable(LCD_CH2);
			}
			else if(tDispLocate == KNL_DISP_LOCATION4)
			{
				LCD_ChDisable(LCD_CH3);
			}
		}
		else if(((tKNL_GetDispType() == KNL_DISP_3T_2L1R) || (tKNL_GetDispType() == KNL_DISP_3T_1L2R)) || 
		        ((tKNL_GetDispType() == KNL_DISP_3T_2T1B) || (tKNL_GetDispType() == KNL_DISP_3T_1T2B)))
		{
			tDispLocate = tKNL_SearchSrcLocation(ubSrcNum);
			if((((tKNL_GetDispType() == KNL_DISP_3T_2L1R) || (tKNL_GetDispType() == KNL_DISP_3T_1L2R)) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)) ||
			   (((tKNL_GetDispType() == KNL_DISP_3T_2T1B) || (tKNL_GetDispType() == KNL_DISP_3T_1T2B)) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)))
			{
				if(tDispLocate == KNL_DISP_LOCATION1)
				{
					LCD_ChDisable(LCD_CH0);
				}
				else if(tDispLocate == KNL_DISP_LOCATION2)
				{
					LCD_ChDisable(LCD_CH2);
				}		
				else if(tDispLocate == KNL_DISP_LOCATION3)
				{
					LCD_ChDisable(LCD_CH1);
				}
			}
			else
			{
				LCD_CH_TYP tDisLcdCh = LCD_CH0;
				if(tDispLocate == KNL_DISP_LOCATION1)
				{
					tDisLcdCh = ((tKNL_GetDispType() == KNL_DISP_3T_1L2R) || (tKNL_GetDispType() == KNL_DISP_3T_2T1B))?LCD_CH1:LCD_CH0;
					LCD_ChDisable(tDisLcdCh);
				}
				else if((tDispLocate == KNL_DISP_LOCATION2) || (tDispLocate == KNL_DISP_LOCATION3))
				{
					tDisLcdCh = ((tKNL_GetDispType() == KNL_DISP_3T_1L2R) || (tKNL_GetDispType() == KNL_DISP_3T_2T1B))?LCD_CH0:LCD_CH1;
					LCD_ChDisable(tDisLcdCh);
					tKNL_delMergeHSrc = (KNL_SRC)ubSrcNum;
				}
			}
		}
		else if(tKNL_GetDispType() == KNL_DISP_3T_3COL)
		{
			tDispLocate = tKNL_SearchSrcLocation(ubSrcNum);
			if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
			{
				if(tDispLocate == KNL_DISP_LOCATION1)
				{
					LCD_ChDisable(LCD_CH0);
				}
				else if((tDispLocate == KNL_DISP_LOCATION2) || (tDispLocate == KNL_DISP_LOCATION3))
				{
					LCD_ChDisable(LCD_CH1);
					tKNL_delMergeHSrc = (KNL_SRC)ubSrcNum;
				}
			}
			else
			{
				if(tDispLocate == KNL_DISP_LOCATION1)
				{
					LCD_ChDisable(LCD_CH2);
				}
				else if(tDispLocate == KNL_DISP_LOCATION2)
				{
					LCD_ChDisable(LCD_CH1);
				}		
				else if(tDispLocate == KNL_DISP_LOCATION3)
				{
					LCD_ChDisable(LCD_CH0);
				}
			}
		}
		else if(tKNL_GetDispType() == KNL_DISP_DUAL_C)
		{
			// For Kernel	
			// -----------------
			// |   	 Disp1     |
			// | 	  F(2)     |
			// |---------------|
			// |      B(3)     |
			// |   	 Disp2     |
			// -----------------
			
			// For LCD IP	
			// -----------------
			// |	  CH0      |
			// | 	           |
			// |---------------|
			// |               |
			// |	  CH1	   |
			// -----------------
			tDispLocate = tKNL_SearchSrcLocation(ubSrcNum);
			if(tDispLocate == KNL_DISP_LOCATION1)
			{
				LCD_ChDisable(LCD_CH0);
			}
			else if(tDispLocate == KNL_DISP_LOCATION2)
			{
				LCD_ChDisable(LCD_CH1);
			}
		}
	}
#endif
}
//------------------------------------------------------------------------------
uint8_t ubKNL_GetNextNode(uint8_t ubSrcNum,uint8_t ubNode)
{	
	uint8_t ubNodeIdx;	
	uint8_t ubIsAdoPath;	//0->Video Path, 1->Audio Path
	
	ubIsAdoPath = 0;	
	if((ubNode==KNL_NODE_ADC)||(ubNode==KNL_NODE_DAC)||(ubNode==KNL_NODE_ADC_BUF)||(ubNode==KNL_NODE_DAC_BUF)||(ubNode==KNL_NODE_COMM_TX_ADO)||(ubNode==KNL_NODE_COMM_RX_ADO))
	{
		ubIsAdoPath = 1;
	}	
	ubNodeIdx = ubKNL_GetNodeIdx(ubSrcNum,ubNode);		
	
	if(ubIsAdoPath == 0)
	{
		return tKNL_VdoNodeInfo[ubSrcNum][ubNodeIdx].ubNextNode;
	}	
	else	
	{
		return tKNL_AdoNodeInfo[ubSrcNum][ubNodeIdx].ubNextNode;
	}		
}
//------------------------------------------------------------------------------
uint8_t ubKNL_GetPreNode(uint8_t ubSrcNum,uint8_t ubNode)
{
	uint8_t ubNodeIdx;	
	uint8_t ubIsAdoPath;	//0->Video Path, 1->Audio Path
	
	ubIsAdoPath = 0;	
	if((ubNode==KNL_NODE_ADC)||(ubNode==KNL_NODE_DAC)||(ubNode==KNL_NODE_ADC_BUF)||(ubNode==KNL_NODE_DAC_BUF)||(ubNode==KNL_NODE_COMM_TX_ADO)||(ubNode==KNL_NODE_COMM_RX_ADO))
	{
		ubIsAdoPath = 1;
	}		
	
	ubNodeIdx = ubKNL_GetNodeIdx(ubSrcNum,ubNode);	
	if(ubIsAdoPath == 0)
	{
		return tKNL_VdoNodeInfo[ubSrcNum][ubNodeIdx].ubPreNode;	
	}
	else
	{
		return tKNL_AdoNodeInfo[ubSrcNum][ubNodeIdx].ubPreNode;	
	}
}
//------------------------------------------------------------------------------
uint8_t ubKNL_GetNodeIdx(uint8_t ubSrcNum,uint8_t ubNode)
{
	uint8_t i;
	uint8_t ubIsAdoPath;	//0->Video Path, 1->Audio Path
	
	ubIsAdoPath = 0;	
	if((ubNode==KNL_NODE_ADC)||(ubNode==KNL_NODE_DAC)||(ubNode==KNL_NODE_ADC_BUF)||(ubNode==KNL_NODE_DAC_BUF)||(ubNode==KNL_NODE_COMM_TX_ADO)||(ubNode==KNL_NODE_COMM_RX_ADO))
	{
		ubIsAdoPath = 1;
	}
	
	for(i=0;i<KNL_MAX_NODE_NUM;i++)
	{
		if(ubIsAdoPath == 0)
		{
			if(tKNL_VdoNodeInfo[ubSrcNum][i].ubCurNode == ubNode)
			{
				return i;
			}
		}
		if(ubIsAdoPath == 1)
		{
			if(tKNL_AdoNodeInfo[ubSrcNum][i].ubCurNode == ubNode)
			{
				return i;
			}
		}
	}
	return 0xFF;
}
//------------------------------------------------------------------------------
KNL_NODE_INFO tKNL_GetNodeInfo(uint8_t ubSrcNum, uint8_t ubNode)
{
	uint8_t i;
	KNL_NODE_INFO tNodeInfo;
	
	//Video node Only
	tNodeInfo.ubPreNode		= KNL_NODE_NONE;
	tNodeInfo.ubCurNode 	= KNL_NODE_NONE;
	tNodeInfo.ubNextNode	= KNL_NODE_NONE;
	tNodeInfo.uwVdoH		= 0;
	tNodeInfo.uwVdoV		= 0;
	tNodeInfo.ubHMirror		= 0;
	tNodeInfo.ubVMirror		= 0;
	tNodeInfo.ubRotate		= 0;
	tNodeInfo.ubHScale		= KNL_SCALE_X1;
	tNodeInfo.ubVScale		= KNL_SCALE_X1;	
	for(i=0;i<KNL_MAX_NODE_NUM;i++)
	{
		if(tKNL_VdoNodeInfo[ubSrcNum][i].ubCurNode == ubNode)
		{
			return tKNL_VdoNodeInfo[ubSrcNum][i];
		}
	}
	printd(DBG_ErrorLvl, "Err @tKNL_GetNodeInfo %d %d\r\n",ubSrcNum,ubNode);
	return tNodeInfo;
}
//------------------------------------------------------------------------------
void KNL_ShowVdoPathNode(uint8_t ubSrcNum)
{
	uint8_t i;
	uint8_t ubCurNode;	
	
	printd(DBG_Debug3Lvl, "**********************************************************************\r\n");
	printd(DBG_Debug3Lvl, "****************     Video Path Information(%d)     ******************\r\n",ubSrcNum);
	printd(DBG_Debug3Lvl, "**********************************************************************\r\n");	
	
	for(i=0;i<KNL_MAX_NODE_NUM;i++)
	{		
		ubCurNode = tKNL_VdoNodeInfo[ubSrcNum][i].ubCurNode;	
		
		//Current
		if(ubCurNode == KNL_NODE_SEN)
		{
			printd(DBG_Debug3Lvl, "{SEN}->");
		}
		else if(ubCurNode == KNL_NODE_SEN_YUV_BUF)
		{
			printd(DBG_Debug3Lvl, "{SEN_YUV_BUF}->");
		}
		else if(ubCurNode == KNL_NODE_H264_ENC)
		{
			printd(DBG_Debug3Lvl, "{H264_ENC}->");
		}
		else if(ubCurNode == KNL_NODE_VDO_BS_BUF1)
		{
			printd(DBG_Debug3Lvl, "{VDO_BS_BUF1}->");
		}
		else if(ubCurNode == KNL_NODE_VDO_BS_BUF2)
		{
			printd(DBG_Debug3Lvl, "{VDO_BS_BUF2}->");
		}		
		else if(ubCurNode == KNL_NODE_COMM_TX_VDO)
		{
			printd(DBG_Debug3Lvl, "{COMM_TX_VDO}->");
		}
		else if(ubCurNode == KNL_NODE_COMM_RX_VDO)
		{
			printd(DBG_Debug3Lvl, "{COMM_RX_VDO}->");
		}
		else if(ubCurNode == KNL_NODE_H264_DEC)
		{
			printd(DBG_Debug3Lvl, "{H264_DEC}->");
		}
		else if(ubCurNode == KNL_NODE_IMG_MERGE_BUF)
		{
			printd(DBG_Debug3Lvl, "{IMG_MERGE_BUF}->");
		}
		else if(ubCurNode == KNL_NODE_IMG_MERGE_H)
		{
			printd(DBG_Debug3Lvl, "{IMG_MERGE_H}->");
		}		
		else if(ubCurNode == KNL_NODE_LCD)
		{
			printd(DBG_Debug3Lvl, "{LCD}->");
		}
		else if(ubCurNode == KNL_NODE_VDO_REC)
		{
			printd(DBG_Debug3Lvl, "{VDO_REC}->");
		}
		else if(ubCurNode == KNL_NODE_JPG_ENC)
		{
			printd(DBG_Debug3Lvl, "{JPG_ENC}->");
		}				
		else if(ubCurNode == KNL_NODE_JPG_DEC1)
		{
			printd(DBG_Debug3Lvl, "{JPG_DEC1}->");
		}
		else if(ubCurNode == KNL_NODE_JPG_DEC2)
		{
			printd(DBG_Debug3Lvl, "{JPG_DEC2}->");
		}
		else if(ubCurNode == KNL_NODE_UVC_MAIN)
		{
			printd(DBG_Debug3Lvl, "{UVC_MAIN}->");
		}
		else if(ubCurNode == KNL_NODE_UVC_SUB)
		{
			printd(DBG_Debug3Lvl, "{UVC_SUB}->");
		}
        else if(ubCurNode == KNL_NODE_UVC_MJPG)
		{
			printd(DBG_Debug3Lvl, "{KNL_NODE_UVC_MJPG}->");
		}
		else if(ubCurNode == KNL_NODE_END)
		{
			printd(DBG_Debug3Lvl, "{END}\r\n");
			printd(DBG_Debug3Lvl, "\r\n");
		}		
	}	
}
//------------------------------------------------------------------------------
void KNL_ShowAdoPathNode(uint8_t ubSrcNum)
{
	uint8_t i;	
	uint8_t ubCurNode;	
	
	printd(DBG_Debug3Lvl, "r\n");
	printd(DBG_Debug3Lvl, "****     Audio Path Information(%d)    ******\r\n",ubSrcNum);
	printd(DBG_Debug3Lvl, "******************************************\r\n");	
	
	for(i=0;i<KNL_MAX_NODE_NUM;i++)
	{	
		ubCurNode = tKNL_AdoNodeInfo[ubSrcNum][i].ubCurNode;			
		
		//Current
		if(ubCurNode == KNL_NODE_ADC)
		{
			printd(DBG_Debug3Lvl, "{ADC}->");
		}		
		else if(ubCurNode == KNL_NODE_ADC_BUF)
		{
			printd(DBG_Debug3Lvl, "{ADC_BUF}->");
		}
		else if(ubCurNode == KNL_NODE_DAC_BUF)
		{
			printd(DBG_Debug3Lvl, "{DAC_BUF}->");
		}
		else if(ubCurNode == KNL_NODE_DAC)
		{
			printd(DBG_Debug3Lvl, "{DAC}->");
		}
		else if(ubCurNode == KNL_NODE_COMM_TX_ADO)
		{
			printd(DBG_Debug3Lvl, "{COMM_TX_ADO}->");
		}
		else if(ubCurNode == KNL_NODE_COMM_RX_ADO)
		{
			printd(DBG_Debug3Lvl, "{COMM_RX_ADO}->");			
		}
		else if(ubCurNode == KNL_NODE_END)
		{
			printd(DBG_Debug3Lvl, "{END}\r\n");
			printd(DBG_Debug3Lvl, "\r\n");
		}		
	}	
}
//------------------------------------------------------------------------------
uint8_t ubKNL_ExistNode(uint8_t ubSrcNum,uint8_t ubNode)
{
	uint8_t i;
	
	//For Video Node
	for(i=0;i<KNL_MAX_NODE_NUM;i++)
	{
		if(tKNL_VdoNodeInfo[ubSrcNum][i].ubCurNode == ubNode)
		{
			return 1;
		}
	}	
	
	//For Audio Node
	for(i=0;i<KNL_MAX_NODE_NUM;i++)
	{
		if(tKNL_AdoNodeInfo[ubSrcNum][i].ubCurNode == ubNode)
		{
			return 1;
		}
	}
	
	return 0;	
}
//------------------------------------------------------------------------------
uint8_t ubKNL_ChkExistNode(uint8_t ubNode)
{
	uint8_t i,j;
	
	//For Video Node
	for(j=0;j<KNL_SRC_NUM;j++)
	{
		for(i=0;i<KNL_MAX_NODE_NUM;i++)
		{
			if(tKNL_VdoNodeInfo[j][i].ubCurNode == ubNode)
			{
				return 1;
			}
		}
	}	
	
	//For Audio Node
	for(j=0;j<KNL_SRC_NUM;j++)
	{
		for(i=0;i<KNL_MAX_NODE_NUM;i++)
		{
			if(tKNL_AdoNodeInfo[j][i].ubCurNode == ubNode)
			{
				return 1;
			}
		}
	}
	
	return 0;	
}
//------------------------------------------------------------------------------
uint32_t ulKNL_GetLcdDispAddr(uint8_t ubSrcNum)
{
	uint32_t ulAddr = 0;
#if KNL_LCD_FUNC_ENABLE
	KNL_DISP_LOCATION tDispLocate;

	if(tKNL_GetDispType() == KNL_DISP_H)
	{
		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
		{
			tDispLocate = tKNL_GetDispLocation(ubSrcNum);
			if(tDispLocate == KNL_DISP_LOCATION2)
			{
				pLcdCh0Buf = pLCD_GetLcdChBufInfor(LCD_CH0);
				ulAddr = pLcdCh0Buf->ulBufAddr;			
			}
			else if(tDispLocate == KNL_DISP_LOCATION3)
			{
				pLcdCh2Buf = pLCD_GetLcdChBufInfor(LCD_CH2);
				ulAddr = pLcdCh2Buf->ulBufAddr;	
			}
			else if((tDispLocate == KNL_DISP_LOCATION1) || (tDispLocate == KNL_DISP_LOCATION4))
			{
				pLcdCh1Buf = pLCD_GetLcdChBufInfor(LCD_CH1);
				ulAddr = pLcdCh1Buf->ulBufAddr;			
			}
		}
		else if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)
		{
			tDispLocate = tKNL_GetDispLocation(ubSrcNum);
			if(tDispLocate == KNL_DISP_LOCATION1)
			{
				pLcdCh0Buf = pLCD_GetLcdChBufInfor(LCD_CH0);
				ulAddr = pLcdCh0Buf->ulBufAddr;			
			}
			else if((tDispLocate == KNL_DISP_LOCATION2) || (tDispLocate == KNL_DISP_LOCATION3))
			{
				pLcdCh1Buf = pLCD_GetLcdChBufInfor(LCD_CH1);
				ulAddr = pLcdCh1Buf->ulBufAddr;			
			}
			else if(tDispLocate == KNL_DISP_LOCATION4)
			{
				pLcdCh2Buf = pLCD_GetLcdChBufInfor(LCD_CH2);
				ulAddr = pLcdCh2Buf->ulBufAddr;
			}
		}
	}
	else if(tKNL_GetDispType() == KNL_DISP_SINGLE)
	{
		pLcdCh0Buf = pLCD_GetLcdChBufInfor(LCD_CH0);
		ulAddr = pLcdCh0Buf->ulBufAddr;
	}
#if defined(BSP_DVR_SDK)
	else if((tKNL_GetDispType() == KNL_DISP_DUAL_U)||(tKNL_GetDispType() == KNL_DISP_QUAD)||(tKNL_GetDispType() == KNL_DISP_PIP_0))
#else	
	//else if((tKNL_GetDispType() == KNL_DISP_DUAL_U)||(tKNL_GetDispType() == KNL_DISP_QUAD))
	else if((tKNL_GetDispType() == KNL_DISP_DUAL_U)||(tKNL_GetDispType() == KNL_DISP_QUAD)||(tKNL_GetDispType() == KNL_DISP_3T_3C))
#endif
	{
		tDispLocate = tKNL_SearchSrcLocation(ubSrcNum);
		if(tDispLocate == KNL_DISP_LOCATION1)
		{
			pLcdCh0Buf = pLCD_GetLcdChBufInfor(LCD_CH0);
			ulAddr = pLcdCh0Buf->ulBufAddr;			
		}
		else if(tDispLocate == KNL_DISP_LOCATION2)
		{
			pLcdCh1Buf = pLCD_GetLcdChBufInfor(LCD_CH1);
			ulAddr = pLcdCh1Buf->ulBufAddr;			
		}
		else if(tDispLocate == KNL_DISP_LOCATION3)
		{
			pLcdCh2Buf = pLCD_GetLcdChBufInfor(LCD_CH2);
			ulAddr = pLcdCh2Buf->ulBufAddr;			
		}
		else if(tDispLocate == KNL_DISP_LOCATION4)
		{
			pLcdCh3Buf = pLCD_GetLcdChBufInfor(LCD_CH3);
			ulAddr = pLcdCh3Buf->ulBufAddr;			
		}		
	}
	else if(((tKNL_GetDispType() == KNL_DISP_3T_2L1R) || (tKNL_GetDispType() == KNL_DISP_3T_1L2R)) || 
		    ((tKNL_GetDispType() == KNL_DISP_3T_2T1B) || (tKNL_GetDispType() == KNL_DISP_3T_1T2B)))
	{
		tDispLocate = tKNL_SearchSrcLocation(ubSrcNum);
		if((((tKNL_GetDispType() == KNL_DISP_3T_2L1R) || (tKNL_GetDispType() == KNL_DISP_3T_1L2R)) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)) ||
		   (((tKNL_GetDispType() == KNL_DISP_3T_2T1B) || (tKNL_GetDispType() == KNL_DISP_3T_1T2B)) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)))
		{
			if(tDispLocate == KNL_DISP_LOCATION1)
			{
				pLcdCh0Buf = pLCD_GetLcdChBufInfor(LCD_CH0);
				ulAddr = pLcdCh0Buf->ulBufAddr;
			}
			else if(tDispLocate == KNL_DISP_LOCATION2)
			{
				pLcdCh2Buf = pLCD_GetLcdChBufInfor(LCD_CH2);
				ulAddr = pLcdCh2Buf->ulBufAddr;
			}		
			else if(tDispLocate == KNL_DISP_LOCATION3)
			{
				pLcdCh1Buf = pLCD_GetLcdChBufInfor(LCD_CH1);
				ulAddr = pLcdCh1Buf->ulBufAddr;
			}
			else
			{
				printd(DBG_ErrorLvl, "Err @ulKNL_GetLcdDispAddr\r\n");
			}
		}
		else
		{
			if(tDispLocate == KNL_DISP_LOCATION1)
			{
				if((tKNL_GetDispType() == KNL_DISP_3T_1L2R) || (tKNL_GetDispType() == KNL_DISP_3T_2T1B))
				{
					pLcdCh1Buf = pLCD_GetLcdChBufInfor(LCD_CH1);
					ulAddr = pLcdCh1Buf->ulBufAddr;
				}
				else
				{
					pLcdCh0Buf = pLCD_GetLcdChBufInfor(LCD_CH0);
					ulAddr = pLcdCh0Buf->ulBufAddr;
				}
			}
			else if((tDispLocate == KNL_DISP_LOCATION2) || (tDispLocate == KNL_DISP_LOCATION3))
			{
				if((tKNL_GetDispType() == KNL_DISP_3T_1L2R) || (tKNL_GetDispType() == KNL_DISP_3T_2T1B))
				{
					pLcdCh0Buf = pLCD_GetLcdChBufInfor(LCD_CH0);
					ulAddr = pLcdCh0Buf->ulBufAddr;
				}
				else
				{
					pLcdCh1Buf = pLCD_GetLcdChBufInfor(LCD_CH1);
					ulAddr = pLcdCh1Buf->ulBufAddr;
				}
			}
			else
			{
				printd(DBG_ErrorLvl, "Err @ulKNL_GetLcdDispAddr\r\n");
			}
		}
	}
	else if(tKNL_GetDispType() ==  KNL_DISP_3T_3COL)
	{
		tDispLocate = tKNL_SearchSrcLocation(ubSrcNum);
		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
		{
			if(tDispLocate == KNL_DISP_LOCATION1)
			{
				pLcdCh0Buf = pLCD_GetLcdChBufInfor(LCD_CH0);
				ulAddr = pLcdCh0Buf->ulBufAddr;
			}
			else if((tDispLocate == KNL_DISP_LOCATION2) || (tDispLocate == KNL_DISP_LOCATION3))
			{
				pLcdCh1Buf = pLCD_GetLcdChBufInfor(LCD_CH1);
				ulAddr = pLcdCh1Buf->ulBufAddr;
			}
			else
			{
				printd(DBG_ErrorLvl, "Err @ulKNL_GetLcdDispAddr\r\n");
			}
		}
		else
		{
			if(tDispLocate == KNL_DISP_LOCATION1)
			{
				pLcdCh2Buf = pLCD_GetLcdChBufInfor(LCD_CH2);
				ulAddr = pLcdCh2Buf->ulBufAddr;
			}
			else if(tDispLocate == KNL_DISP_LOCATION2)
			{
				pLcdCh1Buf = pLCD_GetLcdChBufInfor(LCD_CH1);
				ulAddr = pLcdCh1Buf->ulBufAddr;
			}		
			else if(tDispLocate == KNL_DISP_LOCATION3)
			{
				pLcdCh0Buf = pLCD_GetLcdChBufInfor(LCD_CH0);
				ulAddr = pLcdCh0Buf->ulBufAddr;
			}
			else
			{
				printd(DBG_ErrorLvl, "Err @ulKNL_GetLcdDispAddr\r\n");
			}
		}
	}
	else if(tKNL_GetDispType() == KNL_DISP_DUAL_C)
	{	
		// For Kernel	
		// -----------------
		// |   	 Disp1     |
		// | 	  F(2)     |
		// |---------------|
		// |      B(3)     |
		// |   	 Disp2     |
		// -----------------
		
		// For LCD IP	
		// -----------------
		// |	  CH0      |
		// | 	           |
		// |---------------|
		// |               |
		// |	  CH1      |
		// -----------------
		tDispLocate = tKNL_SearchSrcLocation(ubSrcNum);
		if(tDispLocate == KNL_DISP_LOCATION1)
		{
			pLcdCh0Buf = pLCD_GetLcdChBufInfor(LCD_CH0);
			ulAddr = pLcdCh0Buf->ulBufAddr;			
		}
		else if(tDispLocate == KNL_DISP_LOCATION2)
		{
			pLcdCh1Buf = pLCD_GetLcdChBufInfor(LCD_CH1);
			ulAddr = pLcdCh1Buf->ulBufAddr;			
		}					
		else
		{
			printd(DBG_ErrorLvl, "Err @ulKNL_GetLcdDispAddr\r\n");
		}	
	}
#endif
	return ulAddr;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_ChkLcdDispReady(uint8_t ubSrcNum)
{
#if KNL_LCD_FUNC_ENABLE
	if (KNL_DISP_ROTATE_90 == tKNL_GetDispRotate())
	{
		KNL_DISP_LOCATION tDispLocate;
		
		switch (tKNL_GetDispType())
		{
			case KNL_DISP_H:
				tDispLocate = tKNL_GetDispLocation(ubSrcNum);
				switch (tDispLocate)
				{
					case KNL_DISP_LOCATION1:
						return tLCD_ChkChReady(LCD_CH0);
					case KNL_DISP_LOCATION2:
					case KNL_DISP_LOCATION3:
						return tLCD_ChkChReady(LCD_CH1);
					case KNL_DISP_LOCATION4:
						return tLCD_ChkChReady(LCD_CH2);
					default:
						return 0;
				}
			case KNL_DISP_SINGLE:
				return tLCD_ChkChReady(LCD_CH0);
			case KNL_DISP_DUAL_U:
			case KNL_DISP_QUAD:
				tDispLocate = tKNL_SearchSrcLocation(ubSrcNum);
				switch (tDispLocate)
				{
					case KNL_DISP_LOCATION1:
						return tLCD_ChkChReady(LCD_CH0);
					case KNL_DISP_LOCATION2:
						return tLCD_ChkChReady(LCD_CH1);
					case KNL_DISP_LOCATION3:
						return tLCD_ChkChReady(LCD_CH2);
					case KNL_DISP_LOCATION4:
						return tLCD_ChkChReady(LCD_CH3);
					default:
						return 0;
				}
			case KNL_DISP_3T_2L1R:
			case KNL_DISP_3T_1L2R:
			case KNL_DISP_3T_2T1B:
			case KNL_DISP_3T_1T2B:
				tDispLocate = tKNL_SearchSrcLocation(ubSrcNum);
				if((((tKNL_GetDispType() == KNL_DISP_3T_2L1R) || (tKNL_GetDispType() == KNL_DISP_3T_1L2R)) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)) ||
				   (((tKNL_GetDispType() == KNL_DISP_3T_2T1B) || (tKNL_GetDispType() == KNL_DISP_3T_1T2B)) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)))
				{
					switch (tDispLocate)
					{
						case KNL_DISP_LOCATION1:
							return tLCD_ChkChReady(LCD_CH0);
						case KNL_DISP_LOCATION2:
							return tLCD_ChkChReady(LCD_CH2);
						case KNL_DISP_LOCATION3:
							return tLCD_ChkChReady(LCD_CH1);
						default:
							return 0;
					}
				}
				else
				{
					LCD_CH_TYP tChkLcdCh = LCD_CH0;
					switch (tDispLocate)
					{
						case KNL_DISP_LOCATION1:
							tChkLcdCh = ((tKNL_GetDispType() == KNL_DISP_3T_1L2R) || (tKNL_GetDispType() == KNL_DISP_3T_2T1B))?LCD_CH1:LCD_CH0;
							return tLCD_ChkChReady(tChkLcdCh);
						case KNL_DISP_LOCATION2:
						case KNL_DISP_LOCATION3:
							tChkLcdCh = ((tKNL_GetDispType() == KNL_DISP_3T_1L2R) || (tKNL_GetDispType() == KNL_DISP_3T_2T1B))?LCD_CH0:LCD_CH1;
							return tLCD_ChkChReady(tChkLcdCh);
						default:
							return 0;
					}
				}
			case KNL_DISP_3T_3COL:
				tDispLocate = tKNL_SearchSrcLocation(ubSrcNum);
				if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
				{
					switch (tDispLocate)
					{
						case KNL_DISP_LOCATION1:
							return tLCD_ChkChReady(LCD_CH0);
						case KNL_DISP_LOCATION2:
						case KNL_DISP_LOCATION3:
							return tLCD_ChkChReady(LCD_CH1);
						default:
							return 0;
					}
				}
				else
				{
					switch (tDispLocate)
					{
						case KNL_DISP_LOCATION1:
							return tLCD_ChkChReady(LCD_CH2);
						case KNL_DISP_LOCATION2:
							return tLCD_ChkChReady(LCD_CH1);
						case KNL_DISP_LOCATION3:
							return tLCD_ChkChReady(LCD_CH0);
						default:
							return 0;
					}
				}
			case KNL_DISP_DUAL_C:
				/*// For Kernel	
				// -----------------
				// |   	 Disp1     |
				// | 	  F(2)     |
				// |---------------|
				// |      B(3)     |
				// |   	 Disp2     |
				// -----------------
				
				// For LCD IP	
				// -----------------
				// |	  CH0      |
				// | 	           |
				// |---------------|
				// |               |
				// |	  CH1      |
				// -----------------*/
				tDispLocate = tKNL_SearchSrcLocation(ubSrcNum);
				switch (tDispLocate)
				{
					case KNL_DISP_LOCATION1:
						return tLCD_ChkChReady(LCD_CH0);
					case KNL_DISP_LOCATION2:
						return tLCD_ChkChReady(LCD_CH1);
					default:
						return 0;
				}
			default:
				return 1;
		}
	}
#endif
	return 1;
}
//------------------------------------------------------------------------------
void KNL_ActiveLcdDispBuf(uint8_t ubSrcNum)
{
#if defined(BSP_DVR_SDK)
    if(ubKNL_ModifyDPCnt!=0)
        return;
#endif        
#if KNL_LCD_FUNC_ENABLE
	KNL_DISP_LOCATION tDispLocate;

    if(tKNL_GetRecordFunc() == KNL_PHOTO_PLAY)
        return;

	if(tKNL_GetDispType() == KNL_DISP_H)
	{
		tDispLocate = tKNL_GetDispLocation(ubSrcNum);
		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
		{
			if(tDispLocate == KNL_DISP_LOCATION2)
			{
				if(ubKNL_DispCh0ActiveFlg)
				{
					LCD_SetChBufReady(pLcdCh0Buf);
					LCD_ChEnable(LCD_CH0);
				}
			}
			else if(tDispLocate == KNL_DISP_LOCATION3)
			{
				if(ubKNL_DispCh2ActiveFlg)
				{
					LCD_SetChBufReady(pLcdCh2Buf);
					LCD_ChEnable(LCD_CH2);
				}
			}
			else if((tDispLocate == KNL_DISP_LOCATION1) || (tDispLocate == KNL_DISP_LOCATION4))
			{
				if(ubKNL_DispCh1ActiveFlg)
				{
					LCD_SetChBufReady(pLcdCh1Buf);
					LCD_ChEnable(LCD_CH1);
				}
			}
		}
		else if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)
		{
			if(tDispLocate == KNL_DISP_LOCATION1)
			{
				if(ubKNL_DispCh0ActiveFlg)
				{
					LCD_SetChBufReady(pLcdCh0Buf);
					LCD_ChEnable(LCD_CH0);
				}
			}
			else if((tDispLocate == KNL_DISP_LOCATION2) || (tDispLocate == KNL_DISP_LOCATION3))
			{
				if(ubKNL_DispCh1ActiveFlg)
				{
					LCD_SetChBufReady(pLcdCh1Buf);
					LCD_ChEnable(LCD_CH1);
				}
			}
			else if(tDispLocate == KNL_DISP_LOCATION4)
			{
				if(ubKNL_DispCh2ActiveFlg)
				{
					LCD_SetChBufReady(pLcdCh2Buf);
					LCD_ChEnable(LCD_CH2);
				}
			}
		}
	}
	else if(tKNL_GetDispType() == KNL_DISP_SINGLE)
	{
		if(ubKNL_DispCh0ActiveFlg)
		{
			LCD_SetChBufReady(pLcdCh0Buf);
			LCD_ChEnable(LCD_CH0);
		}
	}
	else if((tKNL_GetDispType() == KNL_DISP_DUAL_U)||(tKNL_GetDispType() == KNL_DISP_QUAD))
	{
		tDispLocate = tKNL_SearchSrcLocation(ubSrcNum);
		if(tDispLocate == KNL_DISP_LOCATION1)
		{			
			if(ubKNL_DispCh0ActiveFlg)
			{
				LCD_SetChBufReady(pLcdCh0Buf);
				LCD_ChEnable(LCD_CH0);
			}
		}
		else if(tDispLocate == KNL_DISP_LOCATION2)
		{
			if(ubKNL_DispCh1ActiveFlg)
			{
				LCD_SetChBufReady(pLcdCh1Buf);
				LCD_ChEnable(LCD_CH1);
			}
		}
		else if(tDispLocate == KNL_DISP_LOCATION3)
		{
			if(ubKNL_DispCh2ActiveFlg)
			{
				LCD_SetChBufReady(pLcdCh2Buf);
				LCD_ChEnable(LCD_CH2);
			}
		}
		else if(tDispLocate == KNL_DISP_LOCATION4)
		{
			if(ubKNL_DispCh3ActiveFlg)
			{
				LCD_SetChBufReady(pLcdCh3Buf);
				LCD_ChEnable(LCD_CH3);
			}
		}		
	}
	else if(((tKNL_GetDispType() == KNL_DISP_3T_2L1R) || (tKNL_GetDispType() == KNL_DISP_3T_1L2R)) || 
		    ((tKNL_GetDispType() == KNL_DISP_3T_2T1B) || (tKNL_GetDispType() == KNL_DISP_3T_1T2B)))
	{	
		tDispLocate = tKNL_SearchSrcLocation(ubSrcNum);
		if((((tKNL_GetDispType() == KNL_DISP_3T_2L1R) || (tKNL_GetDispType() == KNL_DISP_3T_1L2R)) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)) ||
		   (((tKNL_GetDispType() == KNL_DISP_3T_2T1B) || (tKNL_GetDispType() == KNL_DISP_3T_1T2B)) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)))
		{
			if(tDispLocate == KNL_DISP_LOCATION1)
			{
				if(ubKNL_DispCh0ActiveFlg)
				{
					LCD_SetChBufReady(pLcdCh0Buf);
					LCD_ChEnable(LCD_CH0);
				}
			}
			else if(tDispLocate == KNL_DISP_LOCATION2)
			{
				if(ubKNL_DispCh2ActiveFlg)
				{
					LCD_SetChBufReady(pLcdCh2Buf);
					LCD_ChEnable(LCD_CH2);
				}
			}		
			else if(tDispLocate == KNL_DISP_LOCATION3)
			{
				if(ubKNL_DispCh1ActiveFlg)
				{
					LCD_SetChBufReady(pLcdCh1Buf);
					LCD_ChEnable(LCD_CH1);
				}
			}		
			else
			{
				printd(DBG_ErrorLvl, "Err @KNL_ActiveLcdDispBuf\r\n");
			}
		}
		else
		{
			if(tDispLocate == KNL_DISP_LOCATION1)
			{
				if((tKNL_GetDispType() == KNL_DISP_3T_1L2R) || (tKNL_GetDispType() == KNL_DISP_3T_2T1B))
				{
					if(ubKNL_DispCh1ActiveFlg)
					{
						LCD_SetChBufReady(pLcdCh1Buf);
						LCD_ChEnable(LCD_CH1);
					}
				}
				else
				{
					if(ubKNL_DispCh0ActiveFlg)
					{
						LCD_SetChBufReady(pLcdCh0Buf);
						LCD_ChEnable(LCD_CH0);
					}
				}
			}
			else if((tDispLocate == KNL_DISP_LOCATION2) || (tDispLocate == KNL_DISP_LOCATION3))
			{
				if((tKNL_GetDispType() == KNL_DISP_3T_1L2R) || (tKNL_GetDispType() == KNL_DISP_3T_2T1B))
				{
					if(ubKNL_DispCh0ActiveFlg)
					{
						LCD_SetChBufReady(pLcdCh0Buf);
						LCD_ChEnable(LCD_CH0);
					}
				}
				else
				{
					if(ubKNL_DispCh1ActiveFlg)
					{
						LCD_SetChBufReady(pLcdCh1Buf);
						LCD_ChEnable(LCD_CH1);
					}
				}
			}
			else
			{
				printd(DBG_ErrorLvl, "Err @KNL_ActiveLcdDispBuf\r\n");
			}
		}
	}
	else if(tKNL_GetDispType() == KNL_DISP_3T_3COL)
	{
		tDispLocate = tKNL_SearchSrcLocation(ubSrcNum);
		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
		{
			if(tDispLocate == KNL_DISP_LOCATION1)
			{
				if(ubKNL_DispCh0ActiveFlg)
				{
					LCD_SetChBufReady(pLcdCh0Buf);
					LCD_ChEnable(LCD_CH0);
				}
			}
			else if((tDispLocate == KNL_DISP_LOCATION2) || (tDispLocate == KNL_DISP_LOCATION3))
			{
				if(ubKNL_DispCh1ActiveFlg)
				{
					LCD_SetChBufReady(pLcdCh1Buf);
					LCD_ChEnable(LCD_CH1);
				}
			}
			else
			{
				printd(DBG_ErrorLvl, "Err @KNL_ActiveLcdDispBuf\r\n");
			}
		}
		else
		{
			if(tDispLocate == KNL_DISP_LOCATION1)
			{
				if(ubKNL_DispCh2ActiveFlg)
				{
					LCD_SetChBufReady(pLcdCh2Buf);
					LCD_ChEnable(LCD_CH2);
				}
			}		
			else if(tDispLocate == KNL_DISP_LOCATION2)
			{
				if(ubKNL_DispCh1ActiveFlg)
				{
					LCD_SetChBufReady(pLcdCh1Buf);
					LCD_ChEnable(LCD_CH1);
				}
			}
			else if(tDispLocate == KNL_DISP_LOCATION3)
			{
				if(ubKNL_DispCh0ActiveFlg)
				{
					LCD_SetChBufReady(pLcdCh0Buf);
					LCD_ChEnable(LCD_CH0);
				}
			}	
			else
			{
				printd(DBG_ErrorLvl, "Err @KNL_ActiveLcdDispBuf\r\n");
			}
		}
	}
	else if(tKNL_GetDispType() == KNL_DISP_3T_3C)
	{	
		//90
		tDispLocate = tKNL_GetDispLocation(ubSrcNum);
		if(tDispLocate == KNL_DISP_LOCATION1)
		{
			if(ubKNL_DispCh0ActiveFlg)
			{
				LCD_SetChBufReady(pLcdCh0Buf);
				LCD_ChEnable(LCD_CH0);
			}
		}		
		else if(tDispLocate == KNL_DISP_LOCATION2)
		{
			if(ubKNL_DispCh1ActiveFlg)
			{
				LCD_SetChBufReady(pLcdCh1Buf);
				LCD_ChEnable(LCD_CH1);
			}
		}
		else if(tDispLocate == KNL_DISP_LOCATION3)
		{
			if(ubKNL_DispCh2ActiveFlg)
			{
				LCD_SetChBufReady(pLcdCh2Buf);
				LCD_ChEnable(LCD_CH2);
			}
		}	
		else
		{
			printd(DBG_ErrorLvl, "Err @KNL_ActiveLcdDispBuf\r\n");
		}
	}
	
	
#if defined(BSP_DVR_SDK)
	else if((tKNL_GetDispType() == KNL_DISP_DUAL_C) || (tKNL_GetDispType() == KNL_DISP_PIP_0))
#else
	else if(tKNL_GetDispType() == KNL_DISP_DUAL_C)
#endif
	{	
		// For Kernel	
		// -----------------
		// |   	 Disp1     |
		// | 	  F(2)     |
		// |---------------|
		// |      B(3)     |
		// |   	 Disp2     |
		// -----------------
		
		// For LCD IP	
		// -----------------
		// |	  CH0      |
		// | 	           |
		// |---------------|
		// |               |
		// |	  CH1	   |
		// -----------------

		tDispLocate = tKNL_SearchSrcLocation(ubSrcNum);
		if(tDispLocate == KNL_DISP_LOCATION1)
		{
			if(ubKNL_DispCh0ActiveFlg)
			{
				LCD_SetChBufReady(pLcdCh0Buf);
				LCD_ChEnable(LCD_CH0);
			}
		}
		else if(tDispLocate == KNL_DISP_LOCATION2)
		{
			if(ubKNL_DispCh1ActiveFlg)
			{
				LCD_SetChBufReady(pLcdCh1Buf);
				LCD_ChEnable(LCD_CH1);
			}
		}
		else
		{
			printd(DBG_ErrorLvl, "Err @KNL_ActiveLcdDispBuf\r\n");
		}
	}
#endif
}
//------------------------------------------------------------------------------
#if defined(BSP_DVR_SDK)
#define DISP_OFF		0
#define DISP_ON			1
//#define PIP_0_SEL		DISP_ON	
//#define PIP_1_SEL		DISP_ON
#define PIP_0_SEL		DISP_OFF //MAIN1
#define PIP_1_SEL		DISP_ON	 //MAIN2
uint8_t ubTestFlg = 1;
#endif
void KNL_SenYuvBufProcess(KNL_PROCESS tProc)
{
#if OP_STA
#if (A7130 || RTC676x)
	KNL_NODE_INFO tNodeInfo;
	uint8_t ubTotalBufNum,ubUsedBufNum;
#endif
	uint8_t ubBsBufFlg = 0;
	uint8_t ubBbBufFlg = 0;
#endif
	
#if (defined(BSP_DVR_SDK)||(defined(BSP_RVCS_SDK)&&defined(OP_STA)&& APP_PHOTOGRAPH_FUNC_ENABLE))
//	uint32_t ulAddr2;
	DMAC_RESULT tDmaResult = DMAC_OK;
	uint32_t ulTempYuvBufAddr;
	
	uint32_t ulYuvTemp;
//	uint32_t ulJpegTemp;
//	KNL_NODE_INFO tJpgNodeInfo;
#endif
	KNL_PROCESS tKNLInfo;
	uint32_t ulAddr;
	uint8_t ubNextNode;
    uint32_t ulCnt;    
#if (defined(BSP_DVR_SDK)||(defined(BSP_RVCS_SDK)&&defined(OP_STA)&& APP_PHOTOGRAPH_FUNC_ENABLE))
	tDmaResult = tDmaResult;			//Avoid Warning
	ulTempYuvBufAddr = ulTempYuvBufAddr;
	ulYuvTemp = ulYuvTemp;
    JPEG_CODEC_INFO_t JpegInfo;
#endif

#if OP_STA
	ubBsBufFlg = ubBsBufFlg;	//Avoid Warning
	ubBbBufFlg = ubBbBufFlg;	//Avoid Warning
#endif

#ifdef OP_STA
/*
    if(ubSEN_GetScaleUpActiveFlg() == 1)
    {
        printf("Got ScaleUp Img\r\n");
        
		//Snapshot Process
		//========================================================
		// Copy YUV Data for "JPEG_Enc->REC->FS->SD"
		// Copy Address : tProc.ulDramAddr1
		// Copy Size	: 
		//		   		 Case1 : HD  Sensor -> 1280x720*1.5*2*2
		//			 	 Case2 : FHD Sensor -> 1920x1088*1.5*2*2
		//========================================================
        KNL_SetRecordFunc(KNL_PHOTO_CAPTURE);
        ubKNL_JpegPreNode = KNL_NODE_SEN_YUV_BUF;
        ubKNL_JpegSrc 	  = 0;
        ubKNL_JPEGEncode(JPEG_YUV420, JPEG_FN_USE_ISR, YUY2_WIDTH *2,  ((YUY2_HEIGHT == 1080)? 1088:YUY2_HEIGHT)*2, tProc.ulDramAddr1,
                 (ulBUF_GetBlkBufAddr(0, BUF_JPG_BS) + KNL_JPG_HEADER_SIZE));
    }
*/
	#if ((USBD_UVC_MJ_FMT == USBD_UVC_FMT) && USBD_ENABLE)
	if((TRUE == ubKNL_GetHQImgCapEn()) && (KNL_TUNINGMODE_OFF == KNL_GetTuningToolMode()))
	{
		static uint8_t ubKNL_CapHQImgStaFlag = FALSE;
		uint32_t ulResSize = tKNL_CapHQImg.uwHQ_H * tKNL_CapHQImg.uwHQ_V * 1.5;
		uint8_t ubCapRet = 0;
		KNL_UsbdUvcRet_t tUvcRet = KNL_UVCO_OK;

		if(FALSE == ubKNL_CapHQImgStaFlag)
		{
			ubBUF_ReleaseSenYuvBuf(tProc.ulDramAddr1);
			ubKNL_CapHQImgStaFlag = ubKNL_HQImgCapSetup(tProc.ubSrcNum, FALSE, ubCapRet);
			return;
		}
		if(ulResSize != tProc.ulSize)
		{
			ubBUF_ReleaseSenYuvBuf(tProc.ulDramAddr1);
			return;
		}
		USBD_doSnapShotUseStillImageCapture();
		tUvcRet = tKNL_UpdateMjUvcImage(tProc.ulDramAddr1, tProc.ubSrcNum);
		ubBUF_ReleaseSenYuvBuf(tProc.ulDramAddr1);
		if(KNL_UVCO_OK == tUvcRet)
			osMessageGet(osKNL_HQImgUvcQue, &ubCapRet, osWaitForever);
		ubKNL_HQImgCapSetup(tProc.ubSrcNum, TRUE, ubCapRet);
		ubKNL_CapHQImgStaFlag = FALSE;
		return;
	}
	#endif
#endif
	ulKNL_OutVdoFpsCntTemp[tProc.ubSrcNum]++;
#if (defined(OP_AP) && defined(BSP_DVR_SDK))
	if(ubKNL_ChkVdoFlowAct(tProc.ubSrcNum) || ubSEN_CaptureScaleUpGet() == 1 )
#else
	if(ubKNL_ChkVdoFlowAct(tProc.ubSrcNum))
#endif
	{
#if ((defined(OP_STA) || defined(BSP_DVR_SDK)) && USBD_ENABLE)
		if((USBD_UVC_MODE == tUSBD_GetClassMode()) || (TRUE == ubUSBD_ChkCompUvcClass()))
		{
		#if (USBD_UVC_MJ_FMT == USBD_UVC_FMT)
			if(KNL_TUNINGMODE_OFF == KNL_GetTuningToolMode())
				tKNL_UpdateMjUvcImage(tProc.ulDramAddr1, tProc.ubSrcNum);
			else
		#endif
				ubKNL_UpdateUvcImage(tProc, KNL_NODE_SEN_YUV_BUF);
		}
#endif
		ubNextNode = ubKNL_GetNextNode(tProc.ubSrcNum, KNL_NODE_SEN_YUV_BUF);
		if(ubNextNode == KNL_NODE_LCD)
		{
			DMAC_RESULT tDmaResult = DMAC_OK;
			//Get Disp Address
			ulAddr = ulKNL_GetLcdDispAddr(tProc.ubSrcNum);

			//Copy Data to Lcd Buffer
			ulCnt = ((uint32_t)((float)uwKNL_GetVdoH(tProc.ubSrcNum)*(float)uwKNL_GetVdoV(tProc.ubSrcNum)*1.5));
			tDmaResult = tDMAC_MemCopy(tProc.ulDramAddr1,ulAddr,ulCnt,NULL);

			//Release Buffer
			ubBUF_ReleaseSenYuvBuf(tProc.ulDramAddr1);

			//Active Lcd Buffer
			if(DMAC_OK == tDmaResult)
				KNL_ActiveLcdDispBuf(tProc.ubSrcNum);
		}
#if defined(BSP_DVR_SDK)
		else if(ubNextNode == KNL_NODE_JPG_ENC)
		{	
			//if((tUI_GetState() == UI_DISPLAY_STATE) && ubKNL_GetCommLinkStatus(KNL_STA1)&& 
#if defined(OP_AP)
			if(((ubKNL_GetDispSrc(KNL_DISP_LOCATION1) == KNL_SRC_PREVIEW_LOCAL) || (ubKNL_GetDispSrc(KNL_DISP_LOCATION2) == KNL_SRC_PREVIEW_LOCAL)))
#else
			if(ubKNL_GetCommLinkStatus(KNL_STA1)&& 
                ((ubKNL_GetDispSrc(KNL_DISP_LOCATION1) == KNL_SRC_PREVIEW_LOCAL) || (ubKNL_GetDispSrc(KNL_DISP_LOCATION2) == KNL_SRC_PREVIEW_LOCAL)))
#endif
			{
				ulKNL_JpegEncCntTemp[KNL_SRC_PREVIEW_LOCAL]++;
				
				KNL_LcdDisplaySetting();

                if((KNL_PHOTO_CAPTURE != tKNL_GetRecordFunc()) && (KNL_PHOTO_PLAY != tKNL_GetRecordFunc()))
                {
                    if( (tKNL_GetDispType() == KNL_DISP_SINGLE) && (ubKNL_GetDispSrc(KNL_DISP_LOCATION1) != tProc.ubSrcNum) )
                    {
                        ubBUF_ReleaseSenYuvBuf(tProc.ulDramAddr1);
                    }
                    else
                    {        				
        				//===========================================================================================			
        				//(Step 1) Get Sem
						//(Step 2) Get JPEG(BS) Buffer
        				//(Step 3) JPEG Encode(Polling)
        				//(Step 4) Release YUV Buffer
        				//(Step 5) Get YUV Buffer(For JPEG Decode/Display)
						//(Step 6) Get Sem
        				//(Step 7) JPEG Decode(Polling)
        				//(Step 8) Active Display        				
						/*
						osSemaphoreWait(JPEG_CodecSem, osWaitForever);		//(Step 1)							
        				ulJpegTemp	= ulBUF_GetBlkBufAddr(0,BUF_JPG_BS2);	//(Step 2)			 
        				ubKNL_JPEGEncode(JPEG_YUV420, JPEG_FN_USE_POLLING, uwKNL_GetVdoH(KNL_SRC_PREVIEW_LOCAL),uwKNL_GetVdoV(KNL_SRC_PREVIEW_LOCAL),tProc.ulDramAddr1,ulJpegTemp);	//(Step 3)			
        				ubBUF_ReleaseSenYuvBuf(tProc.ulDramAddr1);			//(Step 4)			
        				ulAddr2 = ulKNL_GetLcdDispAddr(tProc.ubSrcNum);		//(Step 5)       				
						osSemaphoreWait(JPEG_CodecSem, osWaitForever);		//(Step 6)
						
						tJpgNodeInfo = tKNL_GetNodeInfo(tProc.ubSrcNum,KNL_NODE_JPG_DEC1);						
						tJpgNodeInfo.ubJpgScale = 0;
        				ubKNL_JPEGDecode(&tJpgNodeInfo, JPEG_YUV420, JPEG_FN_USE_POLLING,uwKNL_GetVdoH(KNL_SRC_PREVIEW_LOCAL),uwKNL_GetVdoV(KNL_SRC_PREVIEW_LOCAL), ulAddr2,ulJpegTemp);//(Step 7)							
        				ulKNL_JpegDecCntTemp[KNL_SRC_PREVIEW_LOCAL]++;			
        				
        				KNL_ActiveLcdDispBuf(tProc.ubSrcNum);				//(Step 8)			
						*/
						if(osSemaphoreWait(JPEG_CodecSem,300) == osOK)		//(Step 1)							
						{
							uint32_t ulAddr2;
							uint32_t ulJpegTemp;
							KNL_NODE_INFO tJpgNodeInfo;

							ulJpegTemp	= ulBUF_GetBlkBufAddr(0,BUF_JPG_BS2);	//(Step 2)			 
							ubKNL_JPEGEncode(JPEG_YUV420, JPEG_FN_USE_POLLING, uwKNL_GetVdoH(KNL_SRC_PREVIEW_LOCAL),uwKNL_GetVdoV(KNL_SRC_PREVIEW_LOCAL),tProc.ulDramAddr1,ulJpegTemp);	//(Step 3)			
							ubBUF_ReleaseSenYuvBuf(tProc.ulDramAddr1);			//(Step 4)			
							ulAddr2 = ulKNL_GetLcdDispAddr(tProc.ubSrcNum);		//(Step 5)       				
							
							if(osSemaphoreWait(JPEG_CodecSem,300) == osOK)		//(Step 6)
							{							
								tJpgNodeInfo = tKNL_GetNodeInfo(tProc.ubSrcNum,KNL_NODE_JPG_DEC1);						
								tJpgNodeInfo.ubJpgScale = 0;
								ubKNL_JPEGDecode(&tJpgNodeInfo, JPEG_YUV420, JPEG_FN_USE_POLLING,uwKNL_GetVdoH(KNL_SRC_PREVIEW_LOCAL),uwKNL_GetVdoV(KNL_SRC_PREVIEW_LOCAL), ulAddr2,ulJpegTemp);//(Step 7)							
								ulKNL_JpegDecCntTemp[KNL_SRC_PREVIEW_LOCAL]++;			
								
								KNL_ActiveLcdDispBuf(tProc.ubSrcNum);				//(Step 8)
							}
							else
							{
								osSemaphoreRelease(JPEG_CodecSem);
							}
						}
						else
						{
							ubBUF_ReleaseSenYuvBuf(tProc.ulDramAddr1);
							osSemaphoreRelease(JPEG_CodecSem);
						}
        				//===========================================================================================
                    }
                }
                else
                {
                    ubBUF_ReleaseSenYuvBuf(tProc.ulDramAddr1);			//(Step 3)
                }
			}
			else
			{
				ubBUF_ReleaseSenYuvBuf(tProc.ulDramAddr1);			//(Step 3)
			}
			
		}
#endif
		else if((ubNextNode == KNL_NODE_NONE) || (ubNextNode == KNL_NODE_END))
		{
			//Release Buffer
#ifdef BIO_BU
			if(tProc.ubSrcNum == ubSEN_GetPathSrc(SENSOR_PATH3))
			{
				QR_Process(&tProc.ulDramAddr1);
                FD_FeedImage(&tProc.ulDramAddr1);
			}
			else
				printd(DBG_ErrorLvl, "Err @KNL_SenYuvBufProcess\r\n");
#endif
			ubBUF_ReleaseSenYuvBuf(tProc.ulDramAddr1);
		}
		else
		{
		#if defined(BSP_DVR_SDK)
			if(tProc.ubSrcNum == KNL_SRC_STORAGE_LOCAL && ubKNL_LocalSnapshotProcFg == 0)
			{
			    uint8_t ubSrcCapSrc;
                ubSrcCapSrc = ubKNL_SearchCapSrcNum(tProc.ubSrcNum);
                if(ubSrcCapSrc) KNL_LocalSnapshotTrig();
				//Check Snapshot @Local
				if(tKNL_LocalSnapshotStatus == KNL_BUSY)
				{
					//Step1 ; Get Sem					
					osSemaphoreWait(JPEG_CodecSem, osWaitForever);					

                    KNL_SetRecordCapSrc(0xFF);
                    ubKNL_JpegSrc = tProc.ubSrcNum;
                    ubKNL_JpegPreNode = KNL_NODE_SEN_YUV_BUF;
#if (defined(OP_AP) && defined(BSP_DVR_SDK))					
                    if(ubSEN_CaptureScaleUpGet() == 1)
                    {
                        KNL_SenStop(KNL_SRC_STORAGE_LOCAL);
                        KNL_UpdateJpgHeader(KNL_SCALE_CAP_WIDTH,KNL_SCALE_CAP_HEIGHT);						
                        ubKNL_JPEGEncode(JPEG_YUV420, JPEG_FN_USE_POLLING, KNL_SCALE_CAP_WIDTH,KNL_SCALE_CAP_HEIGHT,tProc.ulDramAddr1,ulKNL_LocalSnapshotBsAddr+KNL_JPG_HEADER_SIZE);															
                        JpegInfo.tJPEG_CodecMode = JPEG_DECODE;
                        JpegInfo.ulJPEG_YUVAddr = tProc.ulDramAddr1;
                        JpegInfo.ulJPEG_BsAddr = ulKNL_LocalSnapshotBsAddr;
                        JpegInfo.ulJPEG_BsSize = ulKNL_LocalSnapshotSz;
                    }
                    else
#endif
                    {
    					//Step2 : Copy YUV to Temp YUV Buffer					
    					tDMAC_MemCopy(tProc.ulDramAddr1,ulKNL_LocalSnapshotYuvAddr,uwKNL_GetVdoH(KNL_SRC_STORAGE_LOCAL)*uwKNL_GetVdoV(KNL_SRC_STORAGE_LOCAL)*1.5,NULL);
    										
    					//Step3 : JPEG Encode					
    					KNL_UpdateJpgHeader(uwKNL_GetVdoH(KNL_SRC_STORAGE_LOCAL),uwKNL_GetVdoV(KNL_SRC_STORAGE_LOCAL));						
    					ubKNL_JPEGEncode(JPEG_YUV420, JPEG_FN_USE_POLLING, uwKNL_GetVdoH(KNL_SRC_STORAGE_LOCAL),uwKNL_GetVdoV(KNL_SRC_STORAGE_LOCAL),ulKNL_LocalSnapshotYuvAddr,ulKNL_LocalSnapshotBsAddr+KNL_JPG_HEADER_SIZE);															
    					
                        JpegInfo.tJPEG_CodecMode = JPEG_DECODE;
                        JpegInfo.ulJPEG_YUVAddr = ulKNL_LocalSnapshotYuvAddr;
                        JpegInfo.ulJPEG_BsAddr = ulKNL_LocalSnapshotBsAddr;
                        JpegInfo.ulJPEG_BsSize = ulKNL_LocalSnapshotSz;
                    }
                    if(osMessagePut(KNL_QueueJpegMonit, &JpegInfo, 0) != osOK)
                        printd(DBG_ErrorLvl, "JPEG Monit Q ->Full !!!!\r\n");

					//Step4 : Release Status of Snapshot function
					tKNL_LocalSnapshotStatus = KNL_READY;
				}
			}
		#endif

        #if (defined(BSP_RVCS_SDK)&&defined(OP_STA)&& APP_PHOTOGRAPH_FUNC_ENABLE)
            if(ubKNL_SearchCapSrcNum(tProc.ubSrcNum) && ubKNL_LocalSnapshotProcFg == 0)
            {
                printf("SRC=%d\n",tProc.ubSrcNum);
                KNL_LocalSnapshotTrig();
                //Check Snapshot @Local
                if(tKNL_LocalSnapshotStatus == KNL_BUSY)
                {
                    //Step1 ; Get Sem                   
                    osSemaphoreWait(JPEG_CodecSem, osWaitForever);                  

                    KNL_SetRecordCapSrc(0xFF);
                    ubKNL_JpegSrc = tProc.ubSrcNum;
                    ubKNL_JpegPreNode = KNL_NODE_SEN_YUV_BUF;
                    
                    //Step2 : Copy YUV to Temp YUV Buffer                   
					ulKNL_JPGAddr = ulBUF_GetBlkBufAddr(0,BUF_REC);
					KNL_SetLocalSnapshotBsBuf(ulKNL_JPGAddr);
                                        
                    //Step3 : JPEG Encode                   
                    KNL_UpdateJpgHeader(uwKNL_GetVdoH(tProc.ubSrcNum),uwKNL_GetVdoV(tProc.ubSrcNum));                       
					ubKNL_JPEGEncode(JPEG_YUV420, JPEG_FN_USE_POLLING, uwKNL_GetVdoH(tProc.ubSrcNum),uwKNL_GetVdoV(tProc.ubSrcNum),tProc.ulDramAddr1,ulKNL_LocalSnapshotBsAddr+KNL_JPG_HEADER_SIZE);                                                           

                    JpegInfo.tJPEG_CodecMode = JPEG_DECODE;
                    JpegInfo.ulJPEG_YUVAddr = ulKNL_LocalSnapshotYuvAddr;
                    JpegInfo.ulJPEG_BsAddr = ulKNL_LocalSnapshotBsAddr;
                    JpegInfo.ulJPEG_BsSize = ulKNL_LocalSnapshotSz;
                    if(osMessagePut(KNL_QueueJpegMonit, &JpegInfo, 0) != osOK)
                        printd(DBG_ErrorLvl, "JPEG Monit Q ->Full !!!!\r\n");

                    //Step4 : Release Status of Snapshot function
                    tKNL_LocalSnapshotStatus = KNL_READY;
                }
            }
        #endif

		#if (defined(OP_STA	) && !defined(S2019A))
			if(VDO_ENC_METHOD == ENC_I_WHEN_BUSY)
			{
				//Send Q to Next Node
				tKNLInfo.ubSrcNum	 = tProc.ubSrcNum;
				tKNLInfo.ubCurNode 	 = KNL_NODE_SEN_YUV_BUF;
				tKNLInfo.ubNextNode	 = ubKNL_GetNextNode(tProc.ubSrcNum, KNL_NODE_SEN_YUV_BUF);
				tKNLInfo.ulSize		 = tProc.ulSize;
				tKNLInfo.ulDramAddr1 = tProc.ulDramAddr1;
				tKNLInfo.ulDramAddr2 = tProc.ulDramAddr2;
				if(osMessagePut(KNL_VdoCodecProcQueue, &tKNLInfo, 0) != osOK)
				{
					ubBUF_ReleaseSenYuvBuf(tProc.ulDramAddr1);
					printd(DBG_ErrorLvl, "KNL_Q->Full !!!!\r\n");
				}
			}
			else if(VDO_ENC_METHOD == DROP_FRM_WHEN_BUSY)
			{					
				//Check BS-Buffer
				//==========================================================
				if(ubKNL_ExistNode(tProc.ubSrcNum, KNL_NODE_VDO_BS_BUF1))
				{
					if(ubKNL_SrcNumMap(tProc.ubSrcNum) == 0)
					{
						if(uwBUF_GetVdoMainBs0FreeNum())
							ubBsBufFlg = 1;
						else
							ubBsBufFlg = 0;
					}
					else if(ubKNL_SrcNumMap(tProc.ubSrcNum) == 1)
					{
						if(uwBUF_GetVdoMainBs1FreeNum())
							ubBsBufFlg = 1;
						else
							ubBsBufFlg = 0;
					}
					else if(ubKNL_SrcNumMap(tProc.ubSrcNum) == 2)
					{
						if(uwBUF_GetVdoMainBs2FreeNum())
							ubBsBufFlg = 1;
						else
							ubBsBufFlg = 0;
					}
					else if(ubKNL_SrcNumMap(tProc.ubSrcNum) == 3)
					{
						if(uwBUF_GetVdoMainBs3FreeNum())
							ubBsBufFlg = 1;
						else
							ubBsBufFlg = 0;
					}
				}
				else
				{
					ubBsBufFlg = 1;
				}
				
				//Check BB-Buffer
				//==========================================================
				if(ubKNL_ExistNode(tProc.ubSrcNum, KNL_NODE_COMM_TX_VDO))
				{
				#if RTC676x					
					tNodeInfo = tKNL_GetNodeInfo(tProc.ubSrcNum,KNL_NODE_H264_ENC);					
					if(H264_GetPeriod((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx) == 0)
					{
						ubTotalBufNum	= uwBUF_GetVdoPacketizeBigTotalNum();
						ubUsedBufNum 	= ubTotalBufNum-uwBUF_GetVdoPacketizeBigFreeNum();						
						//printf("F[%d]:%d,%d\r\n",H264_GetPeriod((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx),ubTotalBufNum,ubUsedBufNum);
					}
					else
					{						
						ubTotalBufNum	= uwBUF_GetVdoPacketizeSmallTotalNum();
						ubUsedBufNum 	= ubTotalBufNum-uwBUF_GetVdoPacketizeSmallFreeNum();						
						//printf("F[%d]:%d,%d\r\n",H264_GetPeriod((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx),ubTotalBufNum,ubUsedBufNum);
					}										
					
					if((ubTotalBufNum - ubUsedBufNum) >= 1)
						ubBbBufFlg = 1;
					else
						ubBbBufFlg = 0;
				#elif A7130	
					//Check Next Output Frame is I or P -Frame
					//---------------------------------------------------------------------------------
					tNodeInfo = tKNL_GetNodeInfo(tProc.ubSrcNum,KNL_NODE_H264_ENC);
					
					if(H264_GetPeriod((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx) == 0)
					{
						ubTotalBufNum	= ubBB_GetTxTotalBufNum(BB_DATA_VIDEO_BG,BB_TX_MASTER);
						ubUsedBufNum 	= ubBB_GetTxUsedBufNum(BB_DATA_VIDEO_BG,BB_TX_MASTER);
					}
					else
					{						
						ubTotalBufNum	= ubBB_GetTxTotalBufNum(BB_DATA_VIDEO_LT,BB_TX_MASTER);
						ubUsedBufNum 	= ubBB_GetTxUsedBufNum(BB_DATA_VIDEO_LT,BB_TX_MASTER);
					}					
					//=================================================================================						
					if((ubTotalBufNum - ubUsedBufNum) >= 1)
						ubBbBufFlg = 1;								
					else
						ubBbBufFlg = 0;
				#endif
				}
				else
				{
					ubBbBufFlg = 1;
				}	
				
				if(ubBsBufFlg && ubBbBufFlg)
				{
					//Send Q to Next Node
					tKNLInfo.ubSrcNum	 = tProc.ubSrcNum;
					tKNLInfo.ubCurNode 	 = KNL_NODE_SEN_YUV_BUF;
					tKNLInfo.ubNextNode	 = ubKNL_GetNextNode(tProc.ubSrcNum, KNL_NODE_SEN_YUV_BUF);
					tKNLInfo.ulSize		 = tProc.ulSize;
					tKNLInfo.ulDramAddr1 = tProc.ulDramAddr1;
					tKNLInfo.ulDramAddr2 = tProc.ulDramAddr2;
					if(osMessagePut(KNL_VdoCodecProcQueue, &tKNLInfo, 0) != osOK)
					{
						ubBUF_ReleaseSenYuvBuf(tProc.ulDramAddr1);
						printd(DBG_ErrorLvl, "KNL_Q->Full !!!!\r\n");
					}
				}
				else
				{
					//printf("Busy:%d,%d\r\n",uwBUF_GetVdoMainBs0FreeNum(),uwBUF_GetVdoPacketizeFreeNum());
					ubBUF_ReleaseSenYuvBuf(tProc.ulDramAddr1);
				}					
			}
		#else			
			//Send Q to Next Node
			tKNLInfo.ubSrcNum	 = tProc.ubSrcNum;
			tKNLInfo.ubCurNode 	 = KNL_NODE_SEN_YUV_BUF;
			tKNLInfo.ubNextNode	 = ubKNL_GetNextNode(tProc.ubSrcNum, KNL_NODE_SEN_YUV_BUF);
			tKNLInfo.ulSize		 = tProc.ulSize;
			tKNLInfo.ulDramAddr1 = tProc.ulDramAddr1;
			tKNLInfo.ulDramAddr2 = tProc.ulDramAddr2;
			#if (defined(S2019A) && defined(OP_STA) && sPRF_LTYMEAS_EN)
			tKNLInfo.ulsFrmTm = tProc.ulIdx;
			#endif
			if(osMessagePut(KNL_VdoCodecProcQueue, &tKNLInfo, 0) != osOK)
			{
				ubBUF_ReleaseSenYuvBuf(tProc.ulDramAddr1);
				printd(DBG_ErrorLvl, "KNL_Q->Full !!!!\r\n");
			}
		#endif			
		}
	}
	else
	{
		ubBUF_ReleaseSenYuvBuf(tProc.ulDramAddr1);
	}
}

//------------------------------------------------------------------------------
#ifdef OP_STA
void KNL_EnHighQualityImageEnc(uint8_t ubEn, uint8_t ubSrcNum)
{
	KNL_NODE_INFO tNodeInfo;
	uint8_t ubSrcNumMap;

	KNL_ResetVdoProc();
	osMessageReset(KNL_CommTxProcQueue);
#ifdef A7130
	BB_ClearTxBuf(BB_TX_MASTER, BB_DATA_VIDEO);
#endif
//#ifdef S2019A
//	KNL_StopSPRFTxProcess(TRUE);
//#endif
	ubSrcNumMap = ubKNL_SrcNumMap(ubSrcNum);
	BUF_Reset((BUF_VDO_MAIN_BS0 + ubSrcNumMap));
	tNodeInfo = tKNL_GetNodeInfo(ubSrcNum,KNL_NODE_H264_ENC);
	RC_EnHighQualityPresetMode(ubEn, (H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx);
	H264_ResetIPCnt((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx);
	ulKNL_CurFrmIdx[(H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx] = 0;
	printd(DBG_Debug1Lvl, "[%d]HQ Cap mode: %d\n", ubSrcNumMap, ubEn);
}
#endif

//------------------------------------------------------------------------------
#define DEC_IDX		0
#define ENC_IDX 	1

uint8_t ubCodecRetryNum[2] = {0,0};
//uint8_t ubCodecRetryCnt[2] = {18,30};
uint8_t ubCodecRetryCnt[2] = {36,60};

void KNL_H264CodecProcess(KNL_PROCESS tProc)
{	
	uint8_t ubIdx;
	
	if((ubKNL_ChkVdoFlowAct(tProc.ubSrcNum)) && (FALSE == ubKNL_ImgBusyFlg))
	{
		if(tProc.ubNextNode == KNL_NODE_H264_DEC)
		{
			ubIdx = DEC_IDX;
			ubCodecRetryNum[DEC_IDX] = 0;
			ubCodecRetryCnt[DEC_IDX] = 36;
		}
		else if(tProc.ubNextNode == KNL_NODE_H264_ENC)
		{
			ubIdx = ENC_IDX;
			ubCodecRetryNum[ENC_IDX] = 0;
			ubCodecRetryCnt[ENC_IDX] = 60;
		}
#if 1
		if(osSemaphoreWait(osKNL_H264CdcWaitSem, (ubCodecRetryCnt[ubIdx]*10)) != osOK)
		{
			printd(DBG_ErrorLvl, (KNL_NODE_H264_DEC == tProc.ubNextNode)?"H->D NRDY\r\n":"H->E NRDY\r\n");
			if((KNL_NODE_H264_DEC == tProc.ubNextNode) || (KNL_NODE_H264_ENC == tProc.ubNextNode))
				ubKNL_ImgBusyFlg = TRUE;
			ubKNL_CodecFailFlg[0] = 1;	//Codec 0~3
			ubKNL_CodecFailFlg[1] = 1;
			ubKNL_CodecFailFlg[2] = 1;
			ubKNL_CodecFailFlg[3] = 1;
		#if (APP_DUAL_HOST_ENABLE == 1)
			KNL_SetUvcChkFlg(0,1);
			KNL_SetUvcChkFlg(1,1);
		#endif
			goto RELEASE_CODEC_BUF;
		}
#else
		for(;;)
		{
			if(ubKNL_ChkImgRdy())
			{
			#ifdef OP_AP
				osSemaphoreWait(osKNL_LcdDispInfoSem, osWaitForever);
			#endif
				if(TRUE == ubKNL_ImgBusyFlg)
					ubKNL_ImgBusyFlg = FALSE;
			#ifdef OP_AP
				osSemaphoreRelease(osKNL_LcdDispInfoSem);
			#endif
				break;
			}
			if(ubCodecRetryNum[ubIdx]++ >= ubCodecRetryCnt[ubIdx])
			{
				printd(DBG_ErrorLvl, (KNL_NODE_H264_DEC == tProc.ubNextNode)?"H->D NRDY\r\n":"H->E NRDY\r\n");
				if((KNL_NODE_H264_DEC == tProc.ubNextNode) || (KNL_NODE_H264_ENC == tProc.ubNextNode))
					ubKNL_ImgBusyFlg = TRUE;

				ubKNL_CodecFailFlg[0] = 1;	//Codec 0~3
				ubKNL_CodecFailFlg[1] = 1;
				ubKNL_CodecFailFlg[2] = 1;
				ubKNL_CodecFailFlg[3] = 1;				
			
			#if (APP_DUAL_HOST_ENABLE == 1)
				KNL_SetUvcChkFlg(0,1);
				KNL_SetUvcChkFlg(1,1);
			#endif

				goto RELEASE_CODEC_BUF;
			}
			osDelay(10);
		}
#endif
		switch(tProc.ubNextNode)
		{
			case KNL_NODE_H264_ENC:
				KNL_H264EncProcess(tProc);
				break;
			case KNL_NODE_H264_DEC:
				KNL_H264DecProcess(tProc);
				break;
			default:
				break;
		}
		if((ubKNL_ChkImgRdy()) && (osKNL_H264CdcWaitSem))
			osSemaphoreRelease(osKNL_H264CdcWaitSem);
	}
	else
	{
RELEASE_CODEC_BUF:
		switch(tProc.ubNextNode)
		{
			case KNL_NODE_H264_ENC:
				ubBUF_ReleaseSenYuvBuf(tProc.ulDramAddr1);
				break;
			case KNL_NODE_H264_DEC:
				ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_DEC, tProc.ubSrcNum, tProc.ulDramAddr2);
				break;
			default:
				break;
		}
	}
}

//------------------------------------------------------------------------------
void KNL_H264EncProcess(KNL_PROCESS tProc)
{
	uint8_t ubNextNode;
	uint32_t ulTemp = BUF_FAIL;
	KNL_NODE_INFO tNodeInfo;
	uint8_t ubCodecIdx;
#ifdef OP_STA
	static uint8_t ubKNL_HqImgEncFlag = FALSE;
#endif

	tNodeInfo = tKNL_GetNodeInfo(tProc.ubSrcNum,KNL_NODE_H264_ENC);
	ubCodecIdx = tNodeInfo.ubCodecIdx - ENCODE_0;
	
	//if(ubKNL_ChkVdoFlowAct(tProc.ubSrcNum))
	if(ubKNL_ChkVdoFlowAct(tProc.ubSrcNum) && ubKNL_InitImgFlg && ubKNL_InitH264EncFlg[ubCodecIdx])
	{
	    #if !(defined(OP_STA)&&(defined(BSP_VBM_SDK)||defined(BSP_RVCS_SDK))&&defined(VDO_SUBPATH_ENABLE)&&(VDO_SUBPATH_ENABLE!=0))
		if(TRUE == ubKNL_ChgResFlg)
		{
			static uint8_t ubKNL_H264ResetFlg = FALSE;
			uint32_t ulResSize = uwKNL_GetVdoH(tProc.ubSrcNum) * uwKNL_GetVdoV(tProc.ubSrcNum) * 3 / 2;

			if(FALSE == ubKNL_H264ResetFlg)
			{
				uint8_t ubNodeIdx;
				uint8_t ubBufIdx[4] = {[ENCODE_0] = 0, [ENCODE_1] = 1, [ENCODE_2] = 2, [ENCODE_3] = 3};
				uint8_t ubSetFps = 0;
#ifdef OP_STA
                SEN_SetIspOutEn(FALSE);
                SEN_SetDetectVideoState(0);
#endif
				KNL_ResetVdoProc();
				H264_Reset();
				if(ubKNL_ExistNode(tProc.ubSrcNum, KNL_NODE_VDO_BS_BUF1))
				{
					tNodeInfo = tKNL_GetNodeInfo(tProc.ubSrcNum,KNL_NODE_VDO_BS_BUF1);
					tNodeInfo.uwVdoH = uwKNL_GetVdoH(tProc.ubSrcNum);
					tNodeInfo.uwVdoV = uwKNL_GetVdoV(tProc.ubSrcNum);
					ubNodeIdx = ubKNL_GetNodeIdx(tProc.ubSrcNum, KNL_NODE_VDO_BS_BUF1);
					ubKNL_SetVdoPathNode(tProc.ubSrcNum, ubNodeIdx, tNodeInfo);
				}
				tNodeInfo = tKNL_GetNodeInfo(tProc.ubSrcNum,KNL_NODE_H264_ENC);
				tNodeInfo.uwVdoH = uwKNL_GetVdoH(tProc.ubSrcNum);
				tNodeInfo.uwVdoV = uwKNL_GetVdoV(tProc.ubSrcNum);
				ubNodeIdx = ubKNL_GetNodeIdx(tProc.ubSrcNum, KNL_NODE_H264_ENC);
				ubKNL_SetVdoPathNode(tProc.ubSrcNum, ubNodeIdx, tNodeInfo);
				BUF_ResetFreeAddr();
				KNL_BufInit();
				ubSetFps = VDO_FRAME_RATE(tNodeInfo.uwVdoH, tNodeInfo.uwVdoV);
			#ifdef S2019A
				if((1 == ubsPRF_GetAttachedDevNums()) &&
				   ((HD_WIDTH == tNodeInfo.uwVdoH) && (HD_HEIGHT == tNodeInfo.uwVdoV)))
					ubSetFps = HD_RES1T_FPS;
				if(ubKNL_GetSysMaxFps() != ubSetFps)
				{
				#ifdef OP_STA
					RC_UpdateDynaFpsParam(ubSetFps, RC_MIN_FPS);
					tKNL_H264EncInfo[tNodeInfo.ubCodecIdx].ubFrames = 0;
					tKNL_H264EncInfo[tNodeInfo.ubCodecIdx].ulBps    = 0;
					tKNL_H264EncInfo[tNodeInfo.ubCodecIdx].ubFps	= ubSetFps;
					if(ubKNL_GetVdoFps() >= ubSetFps)
					{
						KNL_SetVdoFps(ubSetFps);
						SEN_SetFrameRate(SENSOR_PATH1, ubSetFps);
					}
					printd(DBG_CriticalLvl, "\nFPS: %d\n", ubSetFps);
				#endif
				}
			#else
				if(ubKNL_GetVdoFps() != ubSetFps)
				{
					KNL_SetVdoFps(ubSetFps);
					SEN_SetFrameRate(SENSOR_PATH1, ubSetFps);
					printd(DBG_CriticalLvl, "\nFPS: %d\n", ubSetFps);
				}
			#endif
				KNL_SetSysMaxFps(ubSetFps);
				if(RC_MODE_DYNAMIC_FPS2 == ubRC_GetOpMode((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx))
				{					
					RC_DynamicFpsMode(ubKNL_GetSysMaxFps(),RC_MIN_FPS,RC_SECTION_NUM,1);
				}
			#ifdef S2019A
				if((HD_WIDTH == tNodeInfo.uwVdoH) && (HD_HEIGHT == tNodeInfo.uwVdoV) && (ubSetFps > 15))
					ubSetFps = 31;
			#endif
				SetH264Rate(tNodeInfo.uwVdoH, tNodeInfo.uwVdoV, ubSetFps);
				H264_EncodeInit((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV,ulBUF_GetBlkBufAddr(ubBufIdx[(H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx],BUF_IMG_ENC),ubRC_GetFps(),ulKNL_GetVdoGop());
				H264_SetMaxQP((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,ubRC_GetMaxQp(tNodeInfo.ubCodecIdx));
				H264_SetMinQP((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,ubRC_GetMinQp(tNodeInfo.ubCodecIdx));
				H264_RcSetEN((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,H264_ENABLE,CBR,ulRC_GetInitBitRate(tNodeInfo.ubCodecIdx));
				H264_ResetIPCnt((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx);
				ulKNL_CurFrmIdx[(H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx] = 0;
				ubKNL_H264ResetFlg = TRUE;
				ulResSize = 0;
                
#ifdef OP_STA
                if(ubSEN_GetPathSrc(SENSOR_PATH1) == tProc.ubSrcNum)
				{
                    SEN_SetResChgState(SENSOR_PATH1,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
					SEN_SetPathAddr(SENSOR_PATH1, ulBUF_GetSen1YuvFreeBuf());
				}
                if(ubSEN_GetPathSrc(SENSOR_PATH2) == tProc.ubSrcNum)
				{
					SEN_SetResChgState(SENSOR_PATH2,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);                   
					SEN_SetPathAddr(SENSOR_PATH2, ulBUF_GetSen2YuvFreeBuf());
				}
                if(ubSEN_GetPathSrc(SENSOR_PATH3) == tProc.ubSrcNum)
				{
                    SEN_SetResChgState(SENSOR_PATH3,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
					SEN_SetPathAddr(SENSOR_PATH3, ulBUF_GetSen3YuvFreeBuf());
				}
                
                SEN_SetIspOutEn(TRUE);
                SEN_SetDetectVideoState(1);
				
			#if defined(RTC676x)
				if(ubKNL_StopTrxFlg[0])
					ubKNL_StopTrxFlg[0] = 0;
				if(ubKNL_StopTrxFlg[1])
					ubKNL_StopTrxFlg[1] = 0;
				if(ubKNL_StopTrxFlg[2])
					ubKNL_StopTrxFlg[2] = 0;
			#endif
                return;
#endif
			}
			if(ulResSize != tProc.ulSize)
			{
				ubBUF_ReleaseSenYuvBuf(tProc.ulDramAddr1);
				return;
			}
			ubKNL_ChgResFlg 	= FALSE;
			ubKNL_H264ResetFlg  = FALSE;
			#if defined(OP_STA)
			MD_Switch(ubKNL_MDResChRestore());
			#endif
		}
		#endif

#ifdef OP_STA
		if(KNL_CAPHQ_EN == tKNL_CapHQImgSte)
		{
			if(FALSE == ubKNL_HqImgEncFlag)
			{
				KNL_EnHighQualityImageEnc(TRUE, tProc.ubSrcNum);
				ubKNL_HqImgEncFlag = TRUE;
			}
			else
			{
				ubBUF_ReleaseSenYuvBuf(tProc.ulDramAddr1);
				return;
			}
		}
		else if((KNL_CAPHQ_DIS == tKNL_CapHQImgSte) && (TRUE == ubKNL_HqImgEncFlag))
		{
			KNL_EnHighQualityImageEnc(FALSE, tProc.ubSrcNum);
			ubKNL_HqImgEncFlag = FALSE;
		}
#endif

		tNodeInfo = tKNL_GetNodeInfo(tProc.ubSrcNum, KNL_NODE_H264_ENC);
		if(ubKNL_ResetIFlg[tProc.ubSrcNum])
		{
			//printf("Reset H264 IP Cnt[%d] !!!\r\n",tNodeInfo.ubCodecIdx);
			H264_ResetIPCnt((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx);			
			ubKNL_ResetIFlg[tProc.ubSrcNum] = FALSE;
			if(TRUE == ubKNL_RstVdoGrpFlag)
				ubKNL_RstVdoGrpFlag = FALSE;
		}
		//! (1)Get BS Buffer for Encode
#ifdef S2019A
		if(!ubKNL_H264EncSetup(tNodeInfo.ubCodecIdx))
		{
			ubBUF_ReleaseSenYuvBuf(tProc.ulDramAddr1);
			return;
		}
#endif
		ubNextNode = ubKNL_GetNextNode(tProc.ubSrcNum,KNL_NODE_H264_ENC);
		if(ubNextNode == KNL_NODE_VDO_BS_BUF1)
		{
			ulTemp = ulKNL_GetBsBufAddr(tProc.ubSrcNum);
		}
		else
		{
			printd(DBG_ErrorLvl, "Err @KNL_H264EncProcess\r\n");
		}
		if(ulTemp == BUF_FAIL)
		{
			ubBUF_ReleaseSenYuvBuf(tProc.ulDramAddr1);
#ifndef S2019A
			printd(DBG_ErrorLvl, "BUF_VDO_BS Err !!!\r\n");
#endif
			return;
		}

		//! (2)Get the Resource First
		ubKNL_ImgRdy = 0;
		KNL_SetNodeState(tProc.ubSrcNum,KNL_NODE_H264_ENC,KNL_NODE_START);
#ifdef S2019A
		H264EncParamUpdate(tProc);
#endif
		//! (3)Video Encode
		ubKNL_ImgSrc = tProc.ubSrcNum;	//For ImgMonitTask
		ubKNL_ImgEnc((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,tProc.ulDramAddr1,ulTemp);
	}
	else
	{
		ubBUF_ReleaseSenYuvBuf(tProc.ulDramAddr1);
	}
}

//------------------------------------------------------------------------------
void KNL_H264DecProcess(KNL_PROCESS tProc)
{
	KNL_NODE_INFO tNodeInfo;
	IMG_SCALLING_DOWN_SETUP	tScalingInfo;
	uint32_t ulAddr;
	uint8_t ubNextNode;
	uint8_t ubCodecIdx;

	if((!ubKNL_ImgRdy) || ubKNL_ImgBusyFlg)
		printf("(HD-Err:%d,%d)\r\n",ubKNL_ImgRdy,ubKNL_ImgBusyFlg);

	if(ubKNL_ChkVdoFlowAct(tProc.ubSrcNum))
	{
		//printf("D[%d]:%d\r\n",tProc.ubSrcNum,tProc.ulIdx);
		ubNextNode = ubKNL_GetNextNode(tProc.ubSrcNum,KNL_NODE_H264_DEC);
		tNodeInfo  = tKNL_GetNodeInfo(tProc.ubSrcNum, KNL_NODE_H264_DEC);				
		
		ubCodecIdx = tNodeInfo.ubCodecIdx - DECODE_0;		
		
		//if(ubNextNode == KNL_NODE_LCD)

        if((((ubNextNode == KNL_NODE_LCD)&& ubKNL_InitLcdFlg) || (ubNextNode == KNL_NODE_UVC_MJPG)) && ubKNL_InitImgFlg && ubKNL_InitH264DecFlg[ubCodecIdx] )
		{
            if((ubNextNode == KNL_NODE_LCD) && ubKNL_InitLcdFlg)
		{
			if(!KNL_ChkLcdDispLocation(tProc.ubSrcNum))
			{
				ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_DEC,tProc.ubSrcNum,tProc.ulDramAddr2);
				return;
			}
			if((KNL_PHOTO_PLAY == tKNL_GetRecordFunc()) || (JPG_LCDCH_ENABLE == tKNL_GetJpegLcdChCtrl()))
			{
#if (defined(OP_AP) && defined(BSP_DVR_SDK))		
                ulAddr = pLCD_ForcetoGetLcdChBuf(LCD_CH0,1)->ulBufAddr;
#else
                ulAddr = ulKNL_GetResvDecAddr();
#endif
				printd(DBG_InfoLvl, "		->[%d]Resv DEC: 0x%X\n", tProc.ubSrcNum, ulAddr);
			}
			#if (defined(BUC_CU) && (DISPLAY_MODE != DISPLAY_1T1R))
			else if((TRUE == ubKNL_BbPathAct) && (TRUE == KNL_SwDispInfo.ubSetupFlag))
			{
				uint32_t ulResvAddr = 0;
#if defined(BSP_DVR_SDK)
			#if (LCD_SEL == LCD_REAL)		
				KNL_LcdDisplaySetting();
			#endif
#else
				KNL_LcdDisplaySetting();
#endif
				ulAddr = ulResvAddr = ulKNL_GetResvDecAddr();
				switch(tKNL_GetDispType())
				{
					case KNL_DISP_SINGLE:
						if(KNL_SwDispInfo.tSrcNum[0] == tProc.ubSrcNum)
							ulAddr = ulKNL_GetLcdDispAddr(tProc.ubSrcNum);
						break;
					#if (DISPLAY_MODE == DISPLAY_4T1R)
					case KNL_DISP_3T_2L1R:
					case KNL_DISP_3T_1L2R:
					case KNL_DISP_3T_2T1B:
					case KNL_DISP_3T_1T2B:
					case KNL_DISP_3T_3COL:
						if((KNL_SwDispInfo.tSrcNum[0] == tProc.ubSrcNum) ||
						   (KNL_SwDispInfo.tSrcNum[1] == tProc.ubSrcNum) ||
						   (KNL_SwDispInfo.tSrcNum[2] == tProc.ubSrcNum))
						{
							if((((tKNL_GetDispType() == KNL_DISP_3T_2L1R) || (tKNL_GetDispType() == KNL_DISP_3T_1L2R)) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)) ||
							   (((tKNL_GetDispType() == KNL_DISP_3T_2T1B) || (tKNL_GetDispType() == KNL_DISP_3T_1T2B)) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0))  ||
							   (( tKNL_GetDispType() == KNL_DISP_3T_3COL) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)))
							{
								KNL_DISP_LOCATION tDispLocate;
								tDispLocate = tKNL_SearchSrcLocation(tProc.ubSrcNum);
								if((KNL_DISP_LOCATION2 == tDispLocate) || (KNL_DISP_LOCATION3 == tDispLocate))
									ulAddr = ulKNL_GetImgMergeBufAddr(tProc.ubSrcNum);
							}
							else
								ulAddr = ulKNL_GetLcdDispAddr(tProc.ubSrcNum);
						}
						break;
					#endif
					case KNL_DISP_DUAL_C:
					case KNL_DISP_DUAL_U:
					#if (DISPLAY_MODE == DISPLAY_4T1R)
						if((KNL_SwDispInfo.tSrcNum[0] == tProc.ubSrcNum) || (KNL_SwDispInfo.tSrcNum[1] == tProc.ubSrcNum))
							ulAddr = ulKNL_GetLcdDispAddr(tProc.ubSrcNum);
						break;
					#else
						ulAddr = ulKNL_GetLcdDispAddr(tProc.ubSrcNum);
						ulResvAddr = 0;
					#endif
					default:
						break;
				}
				if(ulAddr == ulResvAddr)
					printd(DBG_InfoLvl, "		<-[%d]Resv DEC: 0x%X\n", tProc.ubSrcNum, ulAddr);
				tNodeInfo.ubHScale = KNL_SCALE_X1;
				tNodeInfo.ubVScale = KNL_SCALE_X1;
			}
			#endif	//! End of #if (defined(BUC_CU) && (DISPLAY_MODE != DISPLAY_1T1R))
			else
			{
#if defined(BSP_DVR_SDK)
			#if (LCD_SEL == LCD_REAL)			
				KNL_LcdDisplaySetting();
			#endif
#else
				KNL_LcdDisplaySetting();
#endif

#if APP_FS_FILE_LIST_STYLE
                if(KNL_ThmShowInfo.ubEnFlg==0 || tKNL_GetRecordFunc()==KNL_VIDEO_PLAY)
                {
                    ulAddr = ulKNL_GetLcdDispAddr(tProc.ubSrcNum);
                    //printf("-->knl lcd addr_0=0x%X\n",ulAddr);
                    KNL_ThmShowInfo.ubLcdDispAddrKeepFlg = 0;
                }
                else if(KNL_ThmShowInfo.ubEnFlg==1)
                {
                    if(KNL_ThmShowInfo.ubLcdDispAddrKeepFlg==0)
                    {
                        KNL_ThmShowInfo.ubLcdDispAddrKeepFlg = 1;
                        ulAddr = ulKNL_GetLcdDispAddr(tProc.ubSrcNum);
                        KNL_ThmShowInfo.ulLcdDispKeepAddr = ulAddr;
                    }
                    else if(KNL_ThmShowInfo.ubLcdDispAddrKeepFlg==1)
                    {
                        ulAddr = KNL_ThmShowInfo.ulLcdDispKeepAddr;
                    }
                }
#else
                ulAddr = ulKNL_GetLcdDispAddr(tProc.ubSrcNum);
#endif
				if(KNL_DISP_H == tKNL_GetDispType())
				{
					if(((tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)  && ((ubKNL_GetDispSrc(KNL_DISP_LOCATION1) == tProc.ubSrcNum) || (ubKNL_GetDispSrc(KNL_DISP_LOCATION4) == tProc.ubSrcNum))) ||
					   ((tKNL_GetDispRotate() == KNL_DISP_ROTATE_90) && ((ubKNL_GetDispSrc(KNL_DISP_LOCATION2) == tProc.ubSrcNum) || (ubKNL_GetDispSrc(KNL_DISP_LOCATION3) == tProc.ubSrcNum))))
					{
						tNodeInfo.ubRotate = 1;
						ulAddr = ulKNL_GetImgMergeBufAddr(tProc.ubSrcNum);
					}
				}
				else if((((tKNL_GetDispType() == KNL_DISP_3T_2L1R) || (tKNL_GetDispType() == KNL_DISP_3T_1L2R)) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)) ||
					    (((tKNL_GetDispType() == KNL_DISP_3T_2T1B) || (tKNL_GetDispType() == KNL_DISP_3T_1T2B)) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0))  ||
				        (( tKNL_GetDispType() == KNL_DISP_3T_3COL) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)))
				{
					KNL_DISP_LOCATION tDispLocate;
					tDispLocate = tKNL_SearchSrcLocation(tProc.ubSrcNum);
					if((KNL_DISP_LOCATION2 == tDispLocate) || (KNL_DISP_LOCATION3 == tDispLocate))
						ulAddr = ulKNL_GetImgMergeBufAddr(tProc.ubSrcNum);
				}
				else
				{					
				#if (APP_DUAL_HOST_ENABLE == 1)
				#else
					if((KNL_DISP_QUAD != tKNL_GetDispType()) && (KNL_DISP_3T_3COL != tKNL_GetDispType()) &&
					   ((KNL_DISP_3T_2L1R != tKNL_GetDispType()) && (KNL_DISP_3T_1L2R != tKNL_GetDispType())) &&
					   ((KNL_DISP_3T_2T1B != tKNL_GetDispType()) && (KNL_DISP_3T_1T2B != tKNL_GetDispType())))
					{
						tNodeInfo.ubHScale = (((KNL_DISP_DUAL_C == tKNL_GetDispType()) || (KNL_DISP_DUAL_U == tKNL_GetDispType())) && (uwKNL_GetVdoH(tProc.ubSrcNum) >= 1920))?KNL_SCALE_X0P5:KNL_SCALE_X1;
						tNodeInfo.ubVScale = (((KNL_DISP_DUAL_C == tKNL_GetDispType()) || (KNL_DISP_DUAL_U == tKNL_GetDispType())) && (uwKNL_GetVdoH(tProc.ubSrcNum) >= 1920))?KNL_SCALE_X0P5:KNL_SCALE_X1;
					}
				#endif
				}
			}
			if (ubKNL_ChkLcdDispReady(tProc.ubSrcNum))
			{
				if(TRUE == ubKNL_SearchCapSrcNum(tProc.ubSrcNum))
				{
					tNodeInfo.ubRotate = 0;
					tNodeInfo.ubHScale = KNL_SCALE_X1;
					tNodeInfo.ubVScale = KNL_SCALE_X1;
#if !defined(BSP_DVR_SDK)
					if((KNL_DISP_H == tKNL_GetDispType()) || (KNL_DISP_QUAD == tKNL_GetDispType()) ||
					   (KNL_DISP_3T_2L1R == tKNL_GetDispType()) || (KNL_DISP_3T_1L2R == tKNL_GetDispType()) ||
				       (KNL_DISP_3T_2T1B == tKNL_GetDispType()) || (KNL_DISP_3T_1T2B == tKNL_GetDispType()) ||
				       (KNL_DISP_3T_3COL == tKNL_GetDispType()))
                        ulAddr = ulKNL_GetResvDecAddr();
#else
                        ulAddr = ulKNL_GetLcdDispAddr(tProc.ubSrcNum);
#endif
				}
			}
		}
		else if(ubNextNode == KNL_NODE_UVC_MJPG)           
			ulAddr = ulBUF_GetBlkBufAddr(0,BUF_DEC_YUV);	
			
			
			
			#if (defined(OP_AP) && (USBD_UVC_MJ_FMT == USBD_UVC_FMT) && USBD_ENABLE)
			if((DISPLAY_1T1R == DISPLAY_MODE) && ((USBD_UVC_MODE == tUSBD_GetClassMode()) || (TRUE == ubUSBD_ChkCompUvcClass())))
			{
				uint8_t ubUvcPathMode;

				ubUvcPathMode = UVC_GetVdoFormat();
				if((USB_UVC_VS_FORMAT_MJPEG == ubUvcPathMode) ||(USB_UVC_VS_FORMAT_UNCOMPRESSED == ubUvcPathMode))
				{
					if(KNL_DISP_ROTATE_90 == tKNL_GetDispRotate())
						tNodeInfo.ubRotate = 0;
					tNodeInfo.ubHScale = KNL_SCALE_X1;
					tNodeInfo.ubVScale = KNL_SCALE_X1;
				}
				if(KNL_CAPHQ_EN == tProc.ubHqCapFlag)
					tKNL_CapHQImgSte = KNL_CAPHQ_RXRDY;
			}
			#endif
			if(ulAddr == 0)
			{
				ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_DEC,tProc.ubSrcNum,tProc.ulDramAddr2);
				return;
			}

			//Lock the Resource First
			ubKNL_ImgRdy = 0;
			KNL_SetNodeState(tProc.ubSrcNum,KNL_NODE_H264_DEC,KNL_NODE_START);

#if APP_FS_FILE_LIST_STYLE
            if(KNL_ThmShowInfo.ubEnFlg==1 && tKNL_GetRecordFunc()!=KNL_VIDEO_PLAY)
            {
                KNL_ThmShowInfo.ulLcdDispCurAddr = ulAddr;
				
				if(tProc.uwHSize>=1920 && tProc.uwVSize>=1080)
				{
					tNodeInfo.ubHScale = KNL_SCALE_X0P25;
					tNodeInfo.ubVScale = KNL_SCALE_X0P25;
				}
				else if(tProc.uwHSize>=1280 && tProc.uwVSize>=720)
				{
					tNodeInfo.ubHScale = KNL_SCALE_X0P25;
					tNodeInfo.ubVScale = KNL_SCALE_X0P25;
				}
				else if(tProc.uwHSize>=640 && tProc.uwVSize>=480)
				{
					tNodeInfo.ubHScale = KNL_SCALE_X0P5;
					tNodeInfo.ubVScale = KNL_SCALE_X0P5;
				}
				else
				{
					tNodeInfo.ubHScale = KNL_SCALE_X1;
					tNodeInfo.ubVScale = KNL_SCALE_X1;
				}
				while(KNL_ThmShowInfo.ulDecYuvBufAddr==0)
					osDelay(10);
                ulAddr = KNL_ThmShowInfo.ulDecYuvBufAddr;
#if VBM_PU
				tNodeInfo.ubRotate = 1;
#endif
            }
#endif
			
			//Rotate	
			if(tNodeInfo.ubRotate == 1)
			{
				H264_SetRotationEn((H264_DECODE_INDEX)tNodeInfo.ubCodecIdx, H264_ENABLE);
			}
			else
			{
				H264_SetRotationEn((H264_DECODE_INDEX)tNodeInfo.ubCodecIdx, H264_DISABLE);
			}

			//Scaling
			tScalingInfo.ulDesAddr	= ulAddr;
			tScalingInfo.ulHeight	= tNodeInfo.uwVdoV;
			tScalingInfo.ulWidth	= tNodeInfo.uwVdoH;
			if((tNodeInfo.ubHScale == KNL_SCALE_X0P25) && (tNodeInfo.ubVScale == KNL_SCALE_X0P25))
			{
				tScalingInfo.RATIO	= SCALING_DOWN_4;	//X0.25
			}
			else if((tNodeInfo.ubHScale == KNL_SCALE_X0P5) && (tNodeInfo.ubVScale == KNL_SCALE_X0P5))
			{
				tScalingInfo.RATIO	= SCALING_DOWN_2;	//X0.5
			}
			else
			{
				tScalingInfo.RATIO	= SCALING_DOWN_1;	//X1.0
			}
			IMG_ScalingDownSetup(&tScalingInfo);

			//H-Mirror(Mirror)
			if(tNodeInfo.ubHMirror)
			{
				H264_SetMirrorEn((H264_DECODE_INDEX)tNodeInfo.ubCodecIdx,H264_ENABLE);
			}
			else
			{
				H264_SetMirrorEn((H264_DECODE_INDEX)tNodeInfo.ubCodecIdx,H264_DISABLE);
			}

			//V-Mirror(Flip)
			if(tNodeInfo.ubVMirror)
			{
				H264_SetFlipEn((H264_DECODE_INDEX)tNodeInfo.ubCodecIdx,H264_ENABLE);
			}
			else
			{
				H264_SetFlipEn((H264_DECODE_INDEX)tNodeInfo.ubCodecIdx,H264_DISABLE);
			}
		#ifdef S2019A
			KNL_H264DecSetup(tProc);
		#endif
			ubKNL_ImgSrc  = tProc.ubSrcNum;
            ulKNL_ImgSize = tProc.ulSize;
            ulKNL_ImgTime = tProc.ulTime;
			if(!ubKNL_ImgDec((H264_DECODE_INDEX)tNodeInfo.ubCodecIdx,ulAddr,tProc.ulDramAddr2))
			{
				ubKNL_ImgRdy = 1;
				KNL_SetNodeState(tProc.ubSrcNum,KNL_NODE_H264_DEC,KNL_NODE_STOP);
			}
			#if (defined(OP_AP) && defined(sWIFIBDG))
			if(sPRF_BRIDGE_MODE == tKNL_sPRFDrvMd)
			{
				if(!ubKNL_ApBdgRxProc(sPRF_VDO_PKT, (KNL_SRC)tProc.ubSrcNum, tProc.ulDramAddr2, tProc.ulSize))
				{
					KNL_PROCESS tKNLInfo;
					uint8_t ubSrcNumMap;
					ubSrcNumMap = ubKNL_SrcNumMap(tProc.ubSrcNum);
					if(ubSrcNumMap <= KNL_STA4)
					{
						ubKNL_RcvFirstIFrame[tProc.ubSrcNum] = 0;
						tKNLInfo.ubSrcNum     = tProc.ubSrcNum;
						tKNLInfo.ubTargetRole = ubSrcNumMap;
						tKNLInfo.ubTwcCmd	  = TWC_RESEND_I_EXT;
						if(FALSE == ubKNL_VdoResendITwcFlg[tKNLInfo.ubTargetRole])
						{
							if(osMessagePut(KNL_TwcMonitQueue, &tKNLInfo, 0) != osOK)
								printd(DBG_ErrorLvl, "KNL_TwcMonitQ->Full !!!!\r\n");
						}
					}
				}
			}
			#endif
		}
		else
		{
			ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_DEC,tProc.ubSrcNum,tProc.ulDramAddr2);
			printd(DBG_ErrorLvl, "Err @KNL_H264DecProcess\r\n");
		}
	}
	else
	{
		ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_DEC,tProc.ubSrcNum,tProc.ulDramAddr2);
	}
}

#ifdef BSP_DVR_SDK
#if ((defined(OP_AP) || (defined(OP_STA) && defined(VDO_SUBPATH_ENABLE) && (VDO_SUBPATH_ENABLE!=0))))
//------------------------------------------------------------------------------
void KNL_LocalDpExec(uint8_t ubSenPath, uint32_t ulYuvAddr, uint32_t ulPathSize)
{
	KNL_LocProcInfo_t tLocProc;

	if((ubSenPath > SENSOR_PATH3) || APP_TUNINGMODE_ON == APP_GetTuningToolMode())	
	{
		ubBUF_ReleaseSenYuvBuf(ulYuvAddr);
		return;
	}
	tLocProc.ubSrcNum  = ubSEN_GetPathSrc(ubSenPath);
	tLocProc.ulSrcAddr = ulYuvAddr;
	tLocProc.ulSrcSize = ulPathSize;
	if((NULL == osKNL_LocProcQue) || (osMessagePut(osKNL_LocProcQue, &tLocProc, 0) != osOK))
	{
		ubBUF_ReleaseSenYuvBuf(ulYuvAddr);
		printd(DBG_ErrorLvl, "osKNL_LocProcQue->Full !!!!\r\n");
	}
}
//------------------------------------------------------------------------------
static void KNL_LocalDpProc(void const *argument)
{
	KNL_LocProcInfo_t tKNL_LocDpInfo;
#ifdef OP_STA
	KNL_PROCESS	tKNL_LocCdcProc;
#endif
#ifdef OP_AP
	uint8_t ubKNL_Loc1Prvw = KNL_SRC_NONE, ubKNL_Loc2Prvw = KNL_SRC_NONE;
#endif
	while(1)
	{
		osMessageGet(osKNL_LocProcQue, &tKNL_LocDpInfo, osWaitForever);
	#ifdef OP_STA
		tKNL_LocCdcProc.ubSrcNum    = tKNL_LocDpInfo.ubSrcNum;
		tKNL_LocCdcProc.ubNextNode  = ubKNL_GetNextNode(tKNL_LocCdcProc.ubSrcNum, KNL_NODE_SEN_YUV_BUF);
		tKNL_LocCdcProc.ulDramAddr1 = tKNL_LocDpInfo.ulSrcAddr;
		tKNL_LocCdcProc.ulSize 		= tKNL_LocDpInfo.ulSrcSize;
		if(KNL_NODE_H264_ENC == tKNL_LocCdcProc.ubNextNode)
			KNL_H264CodecProcess(tKNL_LocCdcProc);
		else
			ubBUF_ReleaseSenYuvBuf(tKNL_LocDpInfo.ulSrcAddr);
	#endif
	#ifdef OP_AP
		ubKNL_Loc1Prvw = ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
		ubKNL_Loc2Prvw = ubKNL_GetDispSrc(KNL_DISP_LOCATION2);
		if(((KNL_SRC_PREVIEW_LOCAL == ubKNL_Loc1Prvw) || (KNL_SRC_PREVIEW_LOCAL == ubKNL_Loc2Prvw)) &&
		    (ubKNL_VdoFlowActiveFlg[tKNL_LocDpInfo.ubSrcNum] != 0 ))
		{
			KNL_RecordFunc_t tRecFunc;

			tRecFunc = tKNL_GetRecordFunc();
			if((KNL_PHOTO_CAPTURE != tRecFunc) && (KNL_PHOTO_PLAY != tRecFunc))
			{
				if((tKNL_GetDispType() == KNL_DISP_SINGLE) && (ubKNL_Loc1Prvw != tKNL_LocDpInfo.ubSrcNum))
				{
					ubBUF_ReleaseSenYuvBuf(tKNL_LocDpInfo.ulSrcAddr);
				}
				else
				{
					if(osSemaphoreWait(JPEG_CodecSem, 100) == osOK)
					{
						if(osSemaphoreWait(tKNL_JpegSigProc.osWaitSem, 100) == osOK)
						{
							KNL_NODE_INFO tJpgNodeInfo;
							uint32_t ulLcdDispAddr = 0, ulJpgBs = 0;
							uint16_t uwPrvwH = 0, uwPrvwV = 0;
							uint8_t ubJpgRet = JPEG_CODEC_OK;

							tKNL_JpegSigProc.ubProcFlag = TRUE;
							ulJpgBs = ulBUF_GetBlkBufAddr(0, BUF_JPG_BS2);
							uwPrvwH = uwKNL_GetVdoH(KNL_SRC_PREVIEW_LOCAL);
							uwPrvwV = uwKNL_GetVdoV(KNL_SRC_PREVIEW_LOCAL);
							ubKNL_JPEGEncode(JPEG_YUV420, JPEG_FN_USE_ISR, uwPrvwH, uwPrvwV, tKNL_LocDpInfo.ulSrcAddr, ulJpgBs);
							if(osSemaphoreWait(tKNL_JpegSigProc.osWaitSem, 100) != osOK)
							{
								JPEG_Codec_Disable();
								ubBUF_ReleaseSenYuvBuf(tKNL_LocDpInfo.ulSrcAddr);
								osSemaphoreRelease(tKNL_JpegSigProc.osWaitSem);
								osSemaphoreRelease(JPEG_CodecSem);
								tKNL_JpegSigProc.ubProcFlag = FALSE;
								printd(DBG_ErrorLvl, "JPG Encode Timerout !\n");
								continue;
							}
							ulKNL_JpegEncCntTemp[KNL_SRC_PREVIEW_LOCAL]++;
							ubBUF_ReleaseSenYuvBuf(tKNL_LocDpInfo.ulSrcAddr);
							ubJpgRet = ubJPEG_ReportCodecStatus();
							if(JPEG_CODEC_OK != ubJpgRet)
							{
								osSemaphoreRelease(tKNL_JpegSigProc.osWaitSem);
								osSemaphoreRelease(JPEG_CodecSem);
								tKNL_JpegSigProc.ubProcFlag = FALSE;
								continue;
							}
							ulKNL_JpegEncCntTemp[KNL_SRC_PREVIEW_LOCAL]++;
                            KNL_LcdDisplaySetting();
							ulLcdDispAddr = ulKNL_GetLcdDispAddr(tKNL_LocDpInfo.ubSrcNum);
							tJpgNodeInfo  = tKNL_GetNodeInfo(tKNL_LocDpInfo.ubSrcNum, KNL_NODE_JPG_DEC1);
							tJpgNodeInfo.ubJpgScale = 0;
							ubKNL_JPEGDecode(&tJpgNodeInfo, JPEG_YUV420, JPEG_FN_USE_ISR, uwPrvwH, uwPrvwV, ulLcdDispAddr, ulJpgBs);
							if(osSemaphoreWait(tKNL_JpegSigProc.osWaitSem, 100) != osOK)
							{
								JPEG_Codec_Disable();
								tKNL_JpegSigProc.ubProcFlag = FALSE;
								osSemaphoreRelease(tKNL_JpegSigProc.osWaitSem);
								osSemaphoreRelease(JPEG_CodecSem);
								tKNL_JpegSigProc.ubProcFlag = FALSE;
								printd(DBG_ErrorLvl, "JPG Decode Timerout !\n");
								continue;
							}
							ubJpgRet = ubJPEG_ReportCodecStatus();
							if(JPEG_CODEC_OK == ubJpgRet)
							{
								ulKNL_JpegDecCntTemp[KNL_SRC_PREVIEW_LOCAL]++;
								KNL_LcdDisplaySetting();
								KNL_ActiveLcdDispBuf(tKNL_LocDpInfo.ubSrcNum);
							}
							tKNL_JpegSigProc.ubProcFlag = FALSE;
							osSemaphoreRelease(tKNL_JpegSigProc.osWaitSem);
							osSemaphoreRelease(JPEG_CodecSem);
						}
						else
						{
							ubBUF_ReleaseSenYuvBuf(tKNL_LocDpInfo.ulSrcAddr);
							osSemaphoreRelease(tKNL_JpegSigProc.osWaitSem);
							osSemaphoreRelease(JPEG_CodecSem);
						}
					}
					else
					{
						ubBUF_ReleaseSenYuvBuf(tKNL_LocDpInfo.ulSrcAddr);
						osSemaphoreRelease(JPEG_CodecSem);
					}
				}
			}
			else
				ubBUF_ReleaseSenYuvBuf(tKNL_LocDpInfo.ulSrcAddr);
		}
		else
			ubBUF_ReleaseSenYuvBuf(tKNL_LocDpInfo.ulSrcAddr);
	#endif
	}
}
#endif
#endif

//------------------------------------------------------------------------------
//Img Merge Buffer
uint32_t ulKNL_GetImgMergeBufAddr(uint8_t ubSrcNum)
{
	uint32_t ulAddr = 0;
	uint8_t ubDisp1Src;
	uint8_t ubDisp2Src;
	uint8_t ubDisp3Src;
	uint8_t ubDisp4Src;	
	
	ubDisp1Src = ubDisp1Src;
	ubDisp2Src = ubDisp2Src;
	ubDisp3Src = ubDisp3Src;
	ubDisp4Src = ubDisp4Src;

	if(tKNL_GetDispType() == KNL_DISP_H)
	{
		uint32_t ulYuvOffset = 0;
		uint8_t ubScaleParam = 0;

		if(KNL_SRC_NONE != tKNL_delMergeHSrc)
		{
			KNL_CreateBlackDmyPat(ulBUF_GetBlkBufAddr(0, BUF_IMG_MERGE), (ulKNL_GetImgMergeBufSz()+((tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)?KNL_JPG_BS_SIZE:0)));
			tKNL_delMergeHSrc = KNL_SRC_NONE;
		}
		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
		{
			//BUF(DISP_4)->BUF(DISP_1)
			if(KNL_DISP_LOCATION4 == tKNL_GetDispLocation(ubSrcNum))
			{
				ubDisp1Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
				if(KNL_SRC_NONE == ubDisp1Src)
				{
					ubDisp1Src = (KNL_SRC_1_MAIN == ubSrcNum)?KNL_SRC_4_MAIN:KNL_SRC_1_MAIN;
					ubScaleParam = (uwKNL_GetVdoH(ubDisp1Src) > 1024)?2:1;
				}
				else
				{
					ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp1Src);
				}
				ulYuvOffset  = (((uint32_t)uwKNL_GetVdoH(ubDisp1Src) >> ubScaleParam) * ((uint32_t)uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam) * 3) >> 1;
				ulYuvOffset += (((uint32_t)uwKNL_GetLcdDmyImgH() * ((uint32_t)uwKNL_GetVdoV(ubDisp1Src) >> ubScaleParam) * 3) >> 1);
				ulAddr = ulBUF_GetBlkBufAddr(0, BUF_IMG_MERGE) + ulYuvOffset;
			}
			else if(KNL_DISP_LOCATION1 == tKNL_GetDispLocation(ubSrcNum))
			{
				ulAddr = ulBUF_GetBlkBufAddr(0, BUF_IMG_MERGE);
			}
		}
		else if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)
		{
			if(KNL_SRC_NONE == ubSrcNum)
			{
				ubDisp2Src   = ubKNL_GetDispSrc(KNL_DISP_LOCATION2);
				ubDisp2Src	 = (KNL_SRC_NONE == ubDisp2Src)?KNL_SRC_3_MAIN:ubDisp2Src;
			}
			else
				ubDisp2Src = ubSrcNum;
			ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
			ulYuvOffset  = (ubKNL_GetDispSrc(KNL_DISP_LOCATION3) == ubSrcNum)?(((uint32_t)uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam) * ((uint32_t)uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam) * 3 >> 1):0;
			ulAddr 		 = ulBUF_GetBlkBufAddr(0, BUF_IMG_MERGE) + ulYuvOffset;
		}
	}
	else if((((KNL_DISP_3T_2L1R == tKNL_GetDispType()) || (KNL_DISP_3T_1L2R == tKNL_GetDispType())) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)) ||
		    (((KNL_DISP_3T_2T1B == tKNL_GetDispType()) || (KNL_DISP_3T_1T2B == tKNL_GetDispType())) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0))  ||
	         ((KNL_DISP_3T_3COL == tKNL_GetDispType()) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)))
	{
		KNL_DISP_LOCATION tDispLocate;
		uint32_t ulYuvOffset = 0;
		uint8_t ubScaleParam = 0;
		if(KNL_SRC_NONE != tKNL_delMergeHSrc)
		{
			KNL_CreateBlackDmyPat(ulBUF_GetBlkBufAddr(0, BUF_IMG_MERGE), ulKNL_GetImgMergeBufSz());
			tKNL_delMergeHSrc = KNL_SRC_NONE;
		}
		if(KNL_SRC_NONE == ubSrcNum)
		{
			ubDisp2Src = ubKNL_GetDispSrc(KNL_DISP_LOCATION2);
			ubDisp2Src = (KNL_SRC_NONE == ubDisp2Src)?KNL_SRC_3_MAIN:ubDisp2Src;
		}
		else
			ubDisp2Src = ubSrcNum;
		ubScaleParam = ubKNL_GetVdoScaleParam(ubDisp2Src);
		tDispLocate  = tKNL_SearchSrcLocation(ubDisp2Src);
		ulYuvOffset  = (KNL_DISP_LOCATION3 == tDispLocate)?(((uwKNL_GetVdoH(ubDisp2Src) >> ubScaleParam) * (uwKNL_GetVdoV(ubDisp2Src) >> ubScaleParam) * 3) >> 1):0;
		ulAddr 		 = ulBUF_GetBlkBufAddr(0, BUF_IMG_MERGE) + ulYuvOffset;
	}
	return ulAddr;
}
//------------------------------------------------------------------------------
void KNL_JpegDec1Process(KNL_PROCESS tProc)
{
	uint8_t ubNextNode;
	uint32_t ulYuvAddr;
	KNL_NODE_INFO tNodeInfo;
	uint16_t uwVdoH;
	uint16_t uwVdoV;
	KNL_PROCESS tKNLInfo;	
	
	if(ubKNL_ChkVdoFlowAct(tProc.ubSrcNum))
	{
		if(osSemaphoreWait(JPEG_CodecSem, 0) == osOK)
		{
			//Lock Resource First
			KNL_SetNodeState(tProc.ubSrcNum,KNL_NODE_JPG_DEC1,KNL_NODE_START);
			
			ubNextNode = ubKNL_GetNextNode(tProc.ubSrcNum,KNL_NODE_JPG_DEC1);
			
			if(ubNextNode == KNL_NODE_IMG_MERGE_BUF)
			{				
				ulYuvAddr = ulKNL_GetImgMergeBufAddr(tProc.ubSrcNum);
				tNodeInfo = tKNL_GetNodeInfo(tProc.ubSrcNum,KNL_NODE_JPG_DEC1);
				ubKNL_JpegPreNode = KNL_NODE_JPG_DEC1;
				ubKNL_JpegSrc 	  = tProc.ubSrcNum;
				tNodeInfo.ubJpgScale = 0;
				ubKNL_JPEGDecode(&tNodeInfo, JPEG_YUV420, JPEG_FN_USE_ISR, tNodeInfo.uwVdoH, tNodeInfo.uwVdoV, ulYuvAddr, tProc.ulDramAddr2);
			}
			else if(ubNextNode == KNL_NODE_LCD)
			{
#if defined(BSP_DVR_SDK)
				ulYuvAddr = ulKNL_GetLcdDispAddr(KNL_SRC_2_MAIN);
				tNodeInfo = tKNL_GetNodeInfo(tProc.ubSrcNum,KNL_NODE_JPG_DEC1);
				uwVdoH = 1280;
				uwVdoV = 720;
				tNodeInfo.ubRotate	= 1;	//justin 2019.07.29
#else
				ulYuvAddr = ulKNL_GetLcdDispAddr(tProc.ubSrcNum);
				tNodeInfo = tKNL_GetNodeInfo(tProc.ubSrcNum,KNL_NODE_JPG_DEC1);

				uwVdoH = uwKNL_GetVdoH(tProc.ubSrcNum);
				uwVdoV = uwKNL_GetVdoV(tProc.ubSrcNum);
#endif

				ubKNL_JpegPreNode = KNL_NODE_JPG_DEC1;
				ubKNL_JpegSrc = tProc.ubSrcNum;
				tNodeInfo.ubJpgScale = 0;
				ubKNL_JPEGDecode(&tNodeInfo, JPEG_YUV420, JPEG_FN_USE_ISR, uwVdoH, uwVdoV, ulYuvAddr, tProc.ulDramAddr2);
			}
			else
			{			
				printd(DBG_ErrorLvl, "Err @KNL_JpegDec1Process\r\n");
			}
		}
		else
		{
			printd(DBG_Debug3Lvl, "J->DQ1\r\n");
		#if FPGA
			osDelay(50);
		#endif
		#if ASIC
			osDelay(10);
		#endif
			tKNLInfo.ubSrcNum			= tProc.ubSrcNum;
			tKNLInfo.ubCurNode 			= ubKNL_GetPreNode(tProc.ubSrcNum,KNL_NODE_JPG_DEC1);			
			tKNLInfo.ubNextNode			= KNL_NODE_JPG_DEC1;	
			tKNLInfo.ulDramAddr1		= tProc.ulDramAddr1;
			tKNLInfo.ulDramAddr2		= tProc.ulDramAddr2;
            if(osMessagePutToFront(KNL_VdoCodecProcQueue, &tKNLInfo, 0) == osErrorResource)
			{		
				printd(DBG_ErrorLvl, "KNL_Q->Full !!!!\r\n");
			}		
		}
	}	
}
//------------------------------------------------------------------------------
void KNL_JpegDec2Process(KNL_PROCESS tProc)
{
	uint8_t ubNextNode;
	uint32_t ulOutAddr;
	KNL_NODE_INFO tNodeInfo;	
	KNL_PROCESS tKNLInfo;	

	if(ubKNL_ChkVdoFlowAct(tProc.ubSrcNum))
	{		
		if(osSemaphoreWait(JPEG_CodecSem, 0) == osOK)
		{
			//Lock Resource First
			KNL_SetNodeState(tProc.ubSrcNum,KNL_NODE_JPG_DEC2,KNL_NODE_START);

			ubNextNode = ubKNL_GetNextNode(tProc.ubSrcNum,KNL_NODE_JPG_DEC2);
			
			if(ubNextNode == KNL_NODE_LCD)
			{			
				if((tKNL_GetDispType() == KNL_DISP_H) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0))
				{
					ulOutAddr = ulKNL_GetLcdDispAddr(tProc.ubSrcNum);	
					tNodeInfo = tKNL_GetNodeInfo(tProc.ubSrcNum, KNL_NODE_JPG_DEC2);
					ubKNL_JpegPreNode = KNL_NODE_JPG_DEC2;
					ubKNL_JpegSrc = tProc.ubSrcNum;
					tNodeInfo.ubJpgScale = 0;
					ubKNL_JPEGDecode(&tNodeInfo, JPEG_YUV420, JPEG_FN_USE_ISR, tNodeInfo.uwVdoH, tNodeInfo.uwVdoV, ulOutAddr, tProc.ulDramAddr2);
				}
			}
		}
		else
		{
			printd(DBG_Debug3Lvl, "J->DQ2\r\n");
		#if FPGA
			osDelay(50);
		#endif
		#if ASIC
			osDelay(30);
		#endif
			tKNLInfo.ubSrcNum			= tProc.ubSrcNum;
			tKNLInfo.ubCurNode 			= ubKNL_GetPreNode(tProc.ubSrcNum,KNL_NODE_JPG_DEC2);
			tKNLInfo.ubNextNode			= KNL_NODE_JPG_DEC2;	
			tKNLInfo.ulDramAddr1		= tProc.ulDramAddr1;
			tKNLInfo.ulDramAddr2		= tProc.ulDramAddr2;
            if(osMessagePutToFront(KNL_VdoCodecProcQueue, &tKNLInfo, 0) == osErrorResource)
			{		
				printd(DBG_ErrorLvl, "KNL_Q->Full !!!!\r\n");
			}		
		}
	}
}
//------------------------------------------------------------------------------
void KNL_JpegEncProcess(KNL_PROCESS tProc)
{
	uint8_t ubNextNode;	
	KNL_NODE_INFO tNodeInfo;
	uint32_t ulMergeImgBsAddr;
	uint32_t ulMergeImgYuvAddr;
	KNL_PROCESS tKNLInfo;	

	if(ubKNL_ChkVdoFlowAct(tProc.ubSrcNum))
	{		
		if(osSemaphoreWait(JPEG_CodecSem, 0) == osOK)
		{
			//Lock Resource First
			KNL_SetNodeState(tProc.ubSrcNum,KNL_NODE_JPG_ENC,KNL_NODE_START);
			
			ubNextNode = ubKNL_GetNextNode(tProc.ubSrcNum,KNL_NODE_JPG_ENC);
			tNodeInfo = tKNL_GetNodeInfo(tProc.ubSrcNum,KNL_NODE_JPG_ENC);
			
			if(ubNextNode == KNL_NODE_VDO_BS_BUF2)
			{
				ulMergeImgYuvAddr = ulBUF_GetBlkBufAddr(0,BUF_IMG_MERGE);
				
				if(tProc.ubSrcNum == KNL_SRC_1_SUB)
				{
					ulMergeImgBsAddr	= ulBUF_GetVdoSubBs01FreeBuf();
				}
				else if(tProc.ubSrcNum == KNL_SRC_4_SUB)
				{
					ulMergeImgBsAddr	= ulBUF_GetVdoSubBs31FreeBuf();
				}
				ubKNL_JpegPreNode 	= KNL_NODE_JPG_ENC;
				ubKNL_JpegSrc 		= tProc.ubSrcNum;
				ubKNL_JPEGEncode(JPEG_YUV420, JPEG_FN_USE_ISR, tNodeInfo.uwVdoH,tNodeInfo.uwVdoV,ulMergeImgYuvAddr,ulMergeImgBsAddr);
			}
#if defined(BSP_DVR_SDK)
			else if(ubNextNode == KNL_NODE_JPG_BS)
			{				
				ubKNL_JpegPreNode 	= KNL_NODE_JPG_ENC;
				ubKNL_JpegSrc 		= tProc.ubSrcNum;
				ubKNL_JPEGEncode(JPEG_YUV420, JPEG_FN_USE_ISR, 1280,720,tProc.ulDramAddr1,tProc.ulDramAddr2);
			}
#endif
			else
			{
				printd(DBG_ErrorLvl, "Err @KNL_JpegEnc1Process\r\n");
			}
		}
		else
		{
			printd(DBG_Debug3Lvl, "J->EQ1\r\n");
		#if FPGA
			osDelay(50);
		#endif
		#if ASIC
			osDelay(30);
		#endif
			tKNLInfo.ubSrcNum			= tProc.ubSrcNum;
			tKNLInfo.ubCurNode 			= ubKNL_GetPreNode(tProc.ubSrcNum,KNL_NODE_JPG_ENC);			
			tKNLInfo.ubNextNode			= KNL_NODE_JPG_ENC;	
			tKNLInfo.ulDramAddr1		= tProc.ulDramAddr1;
			tKNLInfo.ulDramAddr2		= tProc.ulDramAddr2;
            if(osMessagePutToFront(KNL_VdoCodecProcQueue, &tKNLInfo, 0) == osErrorResource)
			{		
				printd(DBG_ErrorLvl, "KNL_Q->Full !!!!\r\n");
			}
		}
	}	
}

//------------------------------------------------------------------------------
KNL_Status_t tKNL_ImageMergeFunc(KNL_ImgMergeParam_t tImgMergParam)
{
	IMG_IMAGE_TASK tImgMTask;
	IMG_SCALLING_DOWN_SETUP sScalingSetup;
	IMG_MERGE_SETUP tImgMSetup;
	IMG_BOOL_RESULT tImgMReT;

	sScalingSetup.ulWidth	= tImgMergParam.uwMergeH;
	sScalingSetup.ulHeight	= tImgMergParam.uwMergeV;
	sScalingSetup.RATIO 	= SCALING_DOWN_1;
	sScalingSetup.ulDesAddr = tImgMergParam.ulMergeDestAddr;
	tImgMReT = IMG_ScalingDownSetup(&sScalingSetup);
	if(tImgMReT == IMG_FAIL)
	{
		printd(DBG_ErrorLvl, "Merge Setup Fail \n");
		return KNL_ERR;
	}
	tImgMSetup.STATUS 		= IMG_ENABLE;
	tImgMSetup.LOCATION 	= tImgMergParam.tMergeLoc;
	tImgMSetup.TYPE 		= tImgMergParam.tMergeType;
	tImgMSetup.IMG_1_Addr 	= tImgMergParam.ulMergeAddr2;		//Source2 for Merge
	tImgMSetup.IMG_2_Addr 	= tImgMergParam.ulMergeAddr3;		//Source3 for Merge
	tImgMSetup.Width		= tImgMergParam.uwMergeH;
	tImgMSetup.Height		= tImgMergParam.uwMergeV;
	tImgMReT = IMG_MergeSetup(&tImgMSetup);
	tImgMTask.InputSrcAddr	= tImgMergParam.ulMergeAddr1;		//Source1 for Merge
	tImgMTask.H264_Task 	= NULL;
	tImgMTask.JPEGEnable 	= IMG_DISABLE;
	tImgMTask.ScalingEnable = IMG_ENABLE;
	IMG_StartUp(tImgMTask);

	return KNL_OK;
}
//------------------------------------------------------------------------------
KNL_Status_t tKNL_StartUpImageMergeForTrip(uint8_t ubSrcNum)
{
	KNL_DISP_ROTATE tDispRot = KNL_DISP_ROTATE_0;
	KNL_DISP_TYPE tDispType;

	tDispType = tKNL_GetDispType();
	tDispRot  = tKNL_GetDispRotate();
	if((((KNL_DISP_3T_2L1R == tDispType) || (KNL_DISP_3T_1L2R == tDispType)) && (KNL_DISP_ROTATE_90 == tDispRot)) ||
	   (((KNL_DISP_3T_2T1B == tDispType) || (KNL_DISP_3T_1T2B == tDispType)) && (KNL_DISP_ROTATE_0  == tDispRot)) ||
	   (( KNL_DISP_3T_3COL == tDispType) && (KNL_DISP_ROTATE_0  == tDispRot)))
	{
		KNL_ImgMergeParam_t tImgMerge;
		KNL_DISP_LOCATION tDispLocate;
		KNL_SRC tLocSrc = KNL_SRC_1_MAIN;
		uint8_t ubScaleParam = 0;

		tDispLocate  = tKNL_SearchSrcLocation(ubSrcNum);
		ubScaleParam = ubKNL_GetVdoScaleParam(ubSrcNum);
		tImgMerge.uwMergeH     = ((KNL_DISP_ROTATE_90 == tDispRot)?uwKNL_GetVdoV(ubSrcNum):uwKNL_GetVdoH(ubSrcNum)) >> ubScaleParam;
		tImgMerge.uwMergeV     = ((KNL_DISP_ROTATE_90 == tDispRot)?uwKNL_GetVdoH(ubSrcNum):uwKNL_GetVdoV(ubSrcNum)) >> ubScaleParam;
		tImgMerge.tMergeType   = COMBINE_2_IMAGE;
		tImgMerge.tMergeScale  = SCALING_DOWN_1;
		tImgMerge.ulMergeAddr1 = ulKNL_GetImgMergeBufAddr(ubSrcNum);
		if(KNL_DISP_LOCATION2 == tDispLocate)
		{
			for(tLocSrc = KNL_SRC_1_MAIN; tLocSrc <=  KNL_SRC_4_MAIN; tLocSrc++)
			{
				tDispLocate = tKNL_SearchSrcLocation(tLocSrc);
				if(KNL_DISP_LOCATION3 == tDispLocate)
					break;
			}
			tLocSrc = (tLocSrc > KNL_SRC_4_MAIN)?KNL_SRC_NONE:tLocSrc;
			tImgMerge.ulMergeAddr2 = ulKNL_GetImgMergeBufAddr(tLocSrc);
			tImgMerge.tMergeLoc = ISP_IMAGE_IN_1_LOCATION;
		}
		else
		{
			for(tLocSrc = KNL_SRC_1_MAIN; tLocSrc <=  KNL_SRC_4_MAIN; tLocSrc++)
			{
				tDispLocate = tKNL_SearchSrcLocation(tLocSrc);
				if(KNL_DISP_LOCATION2 == tDispLocate)
					break;
			}
			tLocSrc = (tLocSrc > KNL_SRC_4_MAIN)?KNL_SRC_NONE:tLocSrc;
			tImgMerge.ulMergeAddr2 = ulKNL_GetImgMergeBufAddr(tLocSrc);
			tImgMerge.tMergeLoc = ISP_IMAGE_IN_2_LOCATION;
		}
		tImgMerge.ulMergeAddr3 = 0;
		tImgMerge.ulMergeDestAddr = ulKNL_GetLcdDispAddr(ubSrcNum);
		ubKNL_ImgTrigSrc = ubSrcNum;
		return tKNL_ImageMergeFunc(tImgMerge);
	}
	return KNL_ERR;
}
//------------------------------------------------------------------------------
KNL_Status_t tKNL_StartUpImageMergeForDispH(uint8_t ubSrcNum)
{
	if(tKNL_GetDispType() == KNL_DISP_H)
	{
		if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
		{
			/*	
			KNL_NODE_INFO tJpgNodeInfo;
			uint32_t ulVdoYuvAddr = 0, ulJpgBsAddr;
			uint16_t uwJpgHSize = 0, uwJpgVSize = 0;
			uint8_t ubMergSrcNum, ubScaleDmy1Param = 0, ubScaleDmy2Param = 0;

			ubScaleDmy1Param = ubKNL_GetVdoScaleParam(ubSrcNum);
			ubMergSrcNum = ubKNL_GetDispSrc(((ubKNL_GetDispSrc(KNL_DISP_LOCATION4) == ubSrcNum)?KNL_DISP_LOCATION1:KNL_DISP_LOCATION4));
			if(KNL_SRC_NONE == ubMergSrcNum)
			{
				ubMergSrcNum = (KNL_SRC_1_MAIN == ubSrcNum)?KNL_SRC_4_MAIN:KNL_SRC_1_MAIN;
				ubScaleDmy2Param = (uwKNL_GetVdoH(ubMergSrcNum) > 1024)?2:1;
			}
			else
			{
				ubScaleDmy2Param = ubKNL_GetVdoScaleParam(ubMergSrcNum);
			}
			uwJpgVSize = (uwKNL_GetVdoH(ubSrcNum) >> ubScaleDmy1Param) + uwKNL_GetLcdDmyImgH() + (uwKNL_GetVdoH(ubMergSrcNum) >> ubScaleDmy2Param);
			uwJpgHSize = uwKNL_GetVdoV(ubSrcNum) >> ubScaleDmy1Param;
			ulVdoYuvAddr = ulBUF_GetBlkBufAddr(0, BUF_IMG_MERGE);
			ulJpgBsAddr  = ulVdoYuvAddr + ulKNL_GetImgMergeBufSz();
			if(JPEG_PASS != ubKNL_JPEGEncode(JPEG_YUV422, JPEG_FN_USE_POLLING, uwJpgHSize, uwJpgVSize, ulVdoYuvAddr, ulJpgBsAddr))
			{
				printd(DBG_ErrorLvl, "JPG Encode fail for H View \n");
				return KNL_ERR;
			}
			memset(&tJpgNodeInfo, 0, sizeof(KNL_NODE_INFO));
			tJpgNodeInfo.ubRotate = JPEG_ROT_90Deg;
			tJpgNodeInfo.ubJpgScale = 0;
			ulVdoYuvAddr = ulKNL_GetLcdDispAddr(ubSrcNum);
			if(!ulVdoYuvAddr)
				return KNL_ERR;
			if(JPEG_PASS != ubKNL_JPEGDecode(&tJpgNodeInfo, JPEG_YUV422, JPEG_FN_USE_POLLING, uwJpgHSize, uwJpgVSize, ulVdoYuvAddr, ulJpgBsAddr))
			{
				printd(DBG_ErrorLvl, "JPG Decode fail for H View \n");
				return KNL_ERR;
			}
			*/			
			
			KNL_NODE_INFO tJpgNodeInfo;
			uint32_t ulVdoYuvAddr = 0, ulJpgBsAddr;
			uint16_t uwJpgHSize = 0, uwJpgVSize = 0;
			uint8_t ubMergSrcNum, ubScaleDmy1Param = 0, ubScaleDmy2Param = 0;

			ubScaleDmy1Param = ubKNL_GetVdoScaleParam(ubSrcNum);
			ubMergSrcNum = ubKNL_GetDispSrc(((ubKNL_GetDispSrc(KNL_DISP_LOCATION4) == ubSrcNum)?KNL_DISP_LOCATION1:KNL_DISP_LOCATION4));
			if(KNL_SRC_NONE == ubMergSrcNum)
			{
				ubMergSrcNum = (KNL_SRC_1_MAIN == ubSrcNum)?KNL_SRC_4_MAIN:KNL_SRC_1_MAIN;
				ubScaleDmy2Param = (uwKNL_GetVdoH(ubMergSrcNum) > 1024)?2:1;
			}
			else
			{
				ubScaleDmy2Param = ubKNL_GetVdoScaleParam(ubMergSrcNum);
			}
			if(osSemaphoreWait(JPEG_CodecSem, 100) == osOK)
			{
				uwJpgVSize = (uwKNL_GetVdoH(ubSrcNum) >> ubScaleDmy1Param) + uwKNL_GetLcdDmyImgH() + (uwKNL_GetVdoH(ubMergSrcNum) >> ubScaleDmy2Param);
				uwJpgHSize = uwKNL_GetVdoV(ubSrcNum) >> ubScaleDmy1Param;
				ulVdoYuvAddr = ulBUF_GetBlkBufAddr(0, BUF_IMG_MERGE);
				ulJpgBsAddr  = ulVdoYuvAddr + ulKNL_GetImgMergeBufSz();
				if(osSemaphoreWait(tKNL_JpegSigProc.osWaitSem, 100) == osOK)
				{
					uint8_t ubJpgRet = JPEG_CODEC_OK;

					tKNL_JpegSigProc.ubProcFlag = TRUE;
					if(JPEG_PASS != ubKNL_JPEGEncode(JPEG_YUV422, JPEG_FN_USE_ISR, uwJpgHSize, uwJpgVSize, ulVdoYuvAddr, ulJpgBsAddr))
					{
						tKNL_JpegSigProc.ubProcFlag = FALSE;
						printd(DBG_ErrorLvl, "JPG Encode fail for H View \n");
						return KNL_ERR;
					}
					if(osSemaphoreWait(tKNL_JpegSigProc.osWaitSem, 100) != osOK)
					{
						JPEG_Codec_Disable();
						tKNL_JpegSigProc.ubProcFlag = FALSE;
						osSemaphoreRelease(tKNL_JpegSigProc.osWaitSem);
						osSemaphoreRelease(JPEG_CodecSem);
						printd(DBG_ErrorLvl, "JPG ENC TIMEROUT!\n");
						return KNL_ERR;
					}
					ubJpgRet = ubJPEG_ReportCodecStatus();
					if(JPEG_CODEC_OK != ubJpgRet)
					{
						tKNL_JpegSigProc.ubProcFlag = FALSE;
						osSemaphoreRelease(tKNL_JpegSigProc.osWaitSem);
						osSemaphoreRelease(JPEG_CodecSem);
						return KNL_ERR;
					}
					memset(&tJpgNodeInfo, 0, sizeof(KNL_NODE_INFO));
					tJpgNodeInfo.ubRotate = JPEG_ROT_90Deg;
					tJpgNodeInfo.ubJpgScale = 0;
					ulVdoYuvAddr = ulKNL_GetLcdDispAddr(ubSrcNum);
					if(!ulVdoYuvAddr)
					{
						tKNL_JpegSigProc.ubProcFlag = FALSE;
						osSemaphoreRelease(tKNL_JpegSigProc.osWaitSem);
						osSemaphoreRelease(JPEG_CodecSem);
						printd(DBG_ErrorLvl, "JPG Decode Addr Err!\n");
						return KNL_ERR;
					}
					if(JPEG_PASS != ubKNL_JPEGDecode(&tJpgNodeInfo, JPEG_YUV422, JPEG_FN_USE_ISR, uwJpgHSize, uwJpgVSize, ulVdoYuvAddr, ulJpgBsAddr))
					{
						tKNL_JpegSigProc.ubProcFlag = FALSE;
						osSemaphoreRelease(tKNL_JpegSigProc.osWaitSem);
						osSemaphoreRelease(JPEG_CodecSem);
						printd(DBG_ErrorLvl, "JPG Decode fail for H View \n");
						return KNL_ERR;
					}
					if(osSemaphoreWait(tKNL_JpegSigProc.osWaitSem, 100) != osOK)
					{
						JPEG_Codec_Disable();
						tKNL_JpegSigProc.ubProcFlag = FALSE;
						osSemaphoreRelease(tKNL_JpegSigProc.osWaitSem);
						osSemaphoreRelease(JPEG_CodecSem);
						printd(DBG_ErrorLvl, "JPG DEC TIMEROUT!\n");
						return KNL_ERR;
					}
					ubJpgRet = ubJPEG_ReportCodecStatus();
					tKNL_JpegSigProc.ubProcFlag = FALSE;
					osSemaphoreRelease(tKNL_JpegSigProc.osWaitSem);
					osSemaphoreRelease(JPEG_CodecSem);	
					if(JPEG_CODEC_OK != ubJpgRet)
						return KNL_ERR;
				}
				else
				{
					osSemaphoreRelease(tKNL_JpegSigProc.osWaitSem);
					osSemaphoreRelease(JPEG_CodecSem);
					return KNL_ERR;
				}
			}
			else
				return KNL_ERR;			
		}
		else if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)
		{
			KNL_ImgMergeParam_t tImgMerge;
			uint8_t ubScaleParam = 0;

			ubScaleParam = ubKNL_GetVdoScaleParam(ubSrcNum);
			tImgMerge.uwMergeH     = uwKNL_GetVdoV(ubSrcNum) >> ubScaleParam;
			tImgMerge.uwMergeV     = uwKNL_GetVdoH(ubSrcNum) >> ubScaleParam;
			tImgMerge.tMergeType   = COMBINE_2_IMAGE;
			tImgMerge.tMergeScale  = SCALING_DOWN_1;
			tImgMerge.ulMergeAddr1 = ulKNL_GetImgMergeBufAddr(ubSrcNum);
			if(ubKNL_GetDispSrc(KNL_DISP_LOCATION2) == ubSrcNum)
			{
				tImgMerge.ulMergeAddr2 = ulKNL_GetImgMergeBufAddr(ubKNL_GetDispSrc(KNL_DISP_LOCATION3));
				tImgMerge.tMergeLoc = ISP_IMAGE_IN_1_LOCATION;
			}
			else
			{
				tImgMerge.ulMergeAddr2 = ulKNL_GetImgMergeBufAddr(ubKNL_GetDispSrc(KNL_DISP_LOCATION2));
				tImgMerge.tMergeLoc = ISP_IMAGE_IN_2_LOCATION;
			}
			tImgMerge.ulMergeAddr3 = 0;
			tImgMerge.ulMergeDestAddr = ulKNL_GetLcdDispAddr(ubSrcNum);
			ubKNL_ImgTrigSrc = ubSrcNum;
			return tKNL_ImageMergeFunc(tImgMerge);
		}
	}
	return KNL_OK;
}

//------------------------------------------------------------------------------
void KNL_ImgMergeBufProcess(KNL_PROCESS tProc)
{	
	KNL_PROCESS tMergeProc;

	if(ubKNL_ChkVdoFlowAct(tProc.ubSrcNum))
	{
		tMergeProc.ulDramAddr1	= tProc.ulDramAddr1;
		tMergeProc.ulDramAddr2	= tProc.ulDramAddr2;
		tMergeProc.ubSrcNum		= tProc.ubSrcNum;
		tMergeProc.ubCurNode	= KNL_NODE_IMG_MERGE_BUF;
		tMergeProc.ubNextNode 	= ubKNL_GetNextNode(tProc.ubSrcNum,KNL_NODE_IMG_MERGE_BUF);
		if(osMessagePut(KNL_VdoCodecProcQueue, &tMergeProc, 0) == osErrorResource)
		{
			printd(DBG_ErrorLvl, "KNL_Q->Full !!!!\r\n");
		}
	}
}
//------------------------------------------------------------------------------
void KNL_ImgMergeHProcess(KNL_PROCESS tProc)
{	
	KNL_PROCESS tMergeProc;	
	uint32_t ulAddr1,ulAddr2,ulOutAddr;	
	KNL_NODE_INFO tNodeInfo;	
	IMG_BOOL_RESULT RESULT;	 	
	IMG_IMAGE_TASK ImageTask;		
	IMG_MERGE_SETUP MergeSetup;
	IMG_SCALLING_DOWN_SETUP sScalingSetup;	
	
	if(ubKNL_ChkVdoFlowAct(tProc.ubSrcNum))
	{	
		if(ubKNL_ChkImgRdy())
		{
			//Lock the Resource First
			ubKNL_ImgRdy = 0;
			KNL_SetNodeState(tProc.ubSrcNum,KNL_NODE_IMG_MERGE_H,KNL_NODE_START);

			tNodeInfo = tKNL_GetNodeInfo(tProc.ubSrcNum, KNL_NODE_IMG_MERGE_H);			

			ulAddr1 = ulKNL_GetImgMergeBufAddr(tNodeInfo.ubMergeSrc1);	//IMG Src1		
			ulAddr2 = ulKNL_GetImgMergeBufAddr(tNodeInfo.ubMergeSrc2);	//IMG Src2		
			if(tNodeInfo.ubMergeDest == IMG_MERGE_LCD)									//IMG Dest			
			{				
				ulOutAddr = ulKNL_GetLcdDispAddr(tProc.ubSrcNum);			
			}	
			else
			{
				printd(DBG_ErrorLvl, "Err @KNL_ImgMergeH1Process@\r\n");
			}

			//HW Img Merge
			osSemaphoreWait(tKNL_ImgSem, osWaitForever);

			sScalingSetup.ulWidth	= tNodeInfo.uwMergeH;
			sScalingSetup.ulHeight	= tNodeInfo.uwMergeV;
			sScalingSetup.RATIO = SCALING_DOWN_1;
			sScalingSetup.ulDesAddr = ulOutAddr;
			RESULT = IMG_ScalingDownSetup(&sScalingSetup);	//Merge Output		
			if(RESULT == IMG_FAIL)
			{
				printd(DBG_ErrorLvl, "Merge Setup Fail1 \n");
			}
			MergeSetup.STATUS =IMG_ENABLE;
			MergeSetup.LOCATION = ISP_IMAGE_IN_1_LOCATION;
			MergeSetup.TYPE = COMBINE_2_IMAGE;	
			MergeSetup.IMG_1_Addr = ulAddr2;		//Source2 for Merge		
			RESULT = IMG_MergeSetup(&MergeSetup);
			if(RESULT == IMG_FAIL)
			{
				printd(DBG_ErrorLvl, "Merge Setup Fail2 \n");
			}
			ImageTask.InputSrcAddr	= ulAddr1;	//Source1 for Merge		
			ImageTask.H264_Task = NULL;
			ImageTask.JPEGEnable = IMG_DISABLE;	
			ImageTask.ScalingEnable = IMG_ENABLE;
			ubKNL_ImgTrigSrc	= tProc.ubSrcNum;
			ubKNL_ImgTrigType	= KNL_IMG_MERGE_H;
			IMG_StartUp(ImageTask);
		}
		else
		{
			printd(DBG_Debug3Lvl, "IMH1-Q\r\n");
			tMergeProc.ulDramAddr1	= tProc.ulDramAddr1;
			tMergeProc.ulDramAddr2	= tProc.ulDramAddr2;	
			tMergeProc.ubSrcNum		= tProc.ubSrcNum;			
			tMergeProc.ubCurNode	= ubKNL_GetPreNode(tProc.ubSrcNum,KNL_NODE_IMG_MERGE_H);							
			tMergeProc.ubNextNode 	= KNL_NODE_IMG_MERGE_H;
            if(osMessagePutToFront(KNL_VdoCodecProcQueue, &tMergeProc, 0) == osErrorResource)
			{		
				printd(DBG_ErrorLvl, "KNL_Q->Full !!!!\r\n");
			}
		}
	}
}
//------------------------------------------------------------------------------
#if defined(BUC_CU)
uint8_t ubKNL_VdoDecProcOnOff = 1;
uint8_t ubKNL_ChResIRdy[KNL_SRC_NUM] = {0};
void KNL_VdoCodecProcOff(void)
{
    ubKNL_VdoDecProcOnOff = 0;
    memset(&ubKNL_ChResIRdy[0], 0, KNL_SRC_NUM);
   KNL_ResetVdoProc();
}
void KNL_VdoCodecProcOn(void)
{
    uint8_t i;

    ubKNL_VdoDecProcOnOff = 1;
    for (i = 0; i < 4; i++)
    {
        if(ubKNL_ChkVdoFlowAct(i))  ubKNL_AppResendIFrmFlg[i] = TRUE;
    }
}
#endif

void KNL_VdoBsBuf1Process(KNL_PROCESS tProc)
{
	KNL_PROCESS tKNLInfo;
	KNL_NODE_INFO tNodeInfo;
//#if APP_REC_FUNC_ENABLE
//    REC_INFO RecInfo;
//#endif

#if ((defined(OP_STA) || defined(BSP_DVR_SDK)) && USBD_ENABLE)
	if((USBD_UVC_MODE == tUSBD_GetClassMode()) || (TRUE == ubUSBD_ChkCompUvcClass()))
	{
		if(!ubKNL_UpdateUvcImage(tProc, KNL_NODE_VDO_BS_BUF1))
			return;
	}
#endif	
	
#if (APP_DUAL_HOST_ENABLE == 1)	
	if(tProc.uwExtLen)
	{
		if(tProc.ubDeviceId == USBH_UVC1_DEVICE_ID)
		{			
			if(pKNL_GetDataFromDevice1 != NULL)				
				pKNL_GetDataFromDevice1(tProc.ulExtDataOfs,tProc.uwExtLen);
		}
		else if(tProc.ubDeviceId == USBH_UVC2_DEVICE_ID)
		{
			if(pKNL_GetDataFromDevice2 != NULL)				
				pKNL_GetDataFromDevice2(tProc.ulExtDataOfs,tProc.uwExtLen);
		}
	}
#endif	

	if(tProc.ulSize > 0x2FD000)	
	{
		tNodeInfo = tKNL_GetNodeInfo(tProc.ubSrcNum,KNL_NODE_VDO_BS_BUF1);
		if((tNodeInfo.ubPreNode == KNL_NODE_COMM_RX_VDO) && (tNodeInfo.ubNextNode == KNL_NODE_H264_DEC))
		{
			ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_DEC,tProc.ubSrcNum,tProc.ulDramAddr2);
		}
		else if(tNodeInfo.ubPreNode == KNL_NODE_H264_ENC)
		{
			ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_ENC,tProc.ubSrcNum,tProc.ulDramAddr2);
		}
		printd(DBG_ErrorLvl, "KNL Vdo Bs Buf1 fail->rcv vdo data size error[0x%X]\r\n",tProc.ulSize);
	}
	else if(ubKNL_ChkVdoFlowAct(tProc.ubSrcNum))
	{
		osMessageQId osMsgQId;

		tKNLInfo.ubSrcNum		= tProc.ubSrcNum;
		tKNLInfo.ubCurNode 		= KNL_NODE_VDO_BS_BUF1;
		tKNLInfo.ubNextNode		= ubKNL_GetNextNode(tProc.ubSrcNum,KNL_NODE_VDO_BS_BUF1);
		tKNLInfo.ulDramAddr1	= tProc.ulDramAddr1;
		tKNLInfo.ulDramAddr2	= tProc.ulDramAddr2;
		tKNLInfo.ulSize			= tProc.ulSize;
		tKNLInfo.ulIdx			= tProc.ulIdx;
		tKNLInfo.ulGop			= tProc.ulGop;
		tKNLInfo.ubCodecIdx		= tProc.ubCodecIdx;
		tKNLInfo.ubVdoGop		= tProc.ubVdoGop;
        tKNLInfo.ulTime         = tProc.ulTime;
		tKNLInfo.ubHqCapFlag    = tProc.ubHqCapFlag;
#ifdef S2019A
		tKNLInfo.ulsFrmTm		= tProc.ulsFrmTm;
#endif
#if (OP_STA && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
        tKNLInfo.ubEvent  = tProc.ubEvent;
#endif
#if defined(BUC_CU)
        if((ubKNL_VdoDecProcOnOff == 0) || 
           ((ubKNL_VdoDecProcOnOff == 1) && (tKNL_GetFrameType(tProc.ulDramAddr2) != KNL_I_FRAME) && (ubKNL_ChResIRdy[tProc.ubSrcNum] == 0)))
        {
            tNodeInfo = tKNL_GetNodeInfo(tProc.ubSrcNum, KNL_NODE_VDO_BS_BUF1);
    		if((tNodeInfo.ubPreNode == KNL_NODE_COMM_RX_VDO) && (tNodeInfo.ubNextNode == KNL_NODE_H264_DEC))
    		{
    			ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_DEC,tProc.ubSrcNum,tProc.ulDramAddr2);
                return;
    		}
        }
        if((tKNL_GetFrameType(tProc.ulDramAddr2) == KNL_I_FRAME) && ubKNL_ChResIRdy[tProc.ubSrcNum] == 0 )
            ubKNL_ChResIRdy[tProc.ubSrcNum] = 1;
#endif

#if (defined(OP_AP) && (APP_REC_FUNC_ENABLE))     //by configure source
		if( ubREC_GetRecordMode() != REC_MODE_TIMELAPSE && ubREC_SrcModeGet() == REC_SRCMODE_CFG && ((ubPLY_GetOpMode() == PLY_MODE_R) || (ubPLY_GetOpMode() == PLY_MODE_PR)))
		{
			KNL_StrgRecInfo_t tStrgRecInfo;

			tStrgRecInfo.tRecInfo.ubCh = tProc.ubSrcNum;
            tStrgRecInfo.tRecInfo.ubRestartFg = 0;
            if(tKNL_GetFrameType(tProc.ulDramAddr2) == KNL_I_FRAME)
            {
                tStrgRecInfo.tRecInfo.ubPictureType = REC_I_VFRM;
            }
            else
            {
                tStrgRecInfo.tRecInfo.ubPictureType = REC_P_VFRM;
            }
            tStrgRecInfo.tRecInfo.ulDramAddr = tProc.ulDramAddr2;   
            tStrgRecInfo.tRecInfo.ulSize = ulKNL_GetFrameSz(tProc.ulDramAddr2,tProc.ulSize);
            tStrgRecInfo.tRecInfo.ulTimeStamp = tProc.ulTime;
            tStrgRecInfo.tRecInfo.ubCmd = REC_CMD_VIDEXT;
            if(tStrgRecInfo.tRecInfo.ulTimeStamp < ulPreVdoTimeStamp[tProc.ubSrcNum])
				tStrgRecInfo.tRecInfo.ubRestartFg = 1;
            else
				tStrgRecInfo.tRecInfo.ubRestartFg = 0;
            ulPreVdoTimeStamp[tProc.ubSrcNum] = tStrgRecInfo.tRecInfo.ulTimeStamp;
			tStrgRecInfo.ubSrcNum  = tProc.ubSrcNum;
			tStrgRecInfo.ubNode    = KNL_NODE_H264_ENC;
			tStrgRecInfo.ubRelease = FALSE;
			if(osMessagePut(osKNL_StrgRecQue, &tStrgRecInfo, 0) != osOK)
				printd(DBG_ErrorLvl, "REC_SRCMODE_CFG->Full !!!!\r\n");
		}
#endif	//! End of #if APP_REC_FUNC_ENABLE 
		if(KNL_NODE_VDO_REC == tKNLInfo.ubNextNode)
		{
			ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_ENC,tProc.ubSrcNum,tProc.ulDramAddr2);
			return;
		}
		osMsgQId = (KNL_NODE_COMM_TX_VDO == tKNLInfo.ubNextNode)?KNL_CommTxProcQueue:KNL_VdoCodecProcQueue;
		if(osMessagePut(osMsgQId, &tKNLInfo, 0) != osOK)
		{
			tNodeInfo = tKNL_GetNodeInfo(tProc.ubSrcNum, KNL_NODE_VDO_BS_BUF1);
			if((tNodeInfo.ubPreNode == KNL_NODE_COMM_RX_VDO) && (tNodeInfo.ubNextNode == KNL_NODE_H264_DEC))
			{
				ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_DEC,tProc.ubSrcNum,tProc.ulDramAddr2);
			}
			else if(tNodeInfo.ubPreNode == KNL_NODE_H264_ENC)
			{
				ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_ENC,tProc.ubSrcNum,tProc.ulDramAddr2);
			}
			else if((KNL_NODE_LCD == tKNLInfo.ubNextNode) || (KNL_NODE_END == tKNLInfo.ubNextNode))
			{
				ubKNL_ReleaseBsBufAddr(KNL_NODE_LCD,tProc.ubSrcNum,tProc.ulDramAddr2);
			}
			printd(DBG_ErrorLvl, "KNL_Q->Full !!!!\r\n");
		}
		#if 0
        else
        {
            if(KNL_NODE_VDO_REC == tKNLInfo.ubNextNode)
            {
                ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_ENC,tProc.ubSrcNum,tProc.ulDramAddr2);
            }
        }
		#endif
	}
	else
	{
		tNodeInfo = tKNL_GetNodeInfo(tProc.ubSrcNum,KNL_NODE_VDO_BS_BUF1);
		if((tNodeInfo.ubPreNode == KNL_NODE_COMM_RX_VDO) && (tNodeInfo.ubNextNode == KNL_NODE_H264_DEC))
		{
			ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_DEC,tProc.ubSrcNum,tProc.ulDramAddr2);
		}
		else if(tNodeInfo.ubPreNode == KNL_NODE_H264_ENC)
		{
			ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_ENC,tProc.ubSrcNum,tProc.ulDramAddr2);
		}
	}
}
//------------------------------------------------------------------------------
void KNL_VdoBsBuf2Process(KNL_PROCESS tProc)
{
	KNL_PROCESS tKNLInfo;
	
	if(ubKNL_ChkVdoFlowAct(tProc.ubSrcNum))
	{
		osMessageQId osMsgQId;

		tKNLInfo.ubSrcNum		= tProc.ubSrcNum;
		tKNLInfo.ubCurNode 		= KNL_NODE_VDO_BS_BUF2;
		tKNLInfo.ubNextNode		= ubKNL_GetNextNode(tProc.ubSrcNum,KNL_NODE_VDO_BS_BUF2);
		tKNLInfo.ulDramAddr1	= tProc.ulDramAddr1;
		tKNLInfo.ulDramAddr2	= tProc.ulDramAddr2;
		tKNLInfo.ulSize			= tProc.ulSize;
		tKNLInfo.ulIdx			= tProc.ulIdx;
		tKNLInfo.ulGop			= tProc.ulGop;
		tKNLInfo.ubCodecIdx		= tProc.ubCodecIdx;
		tKNLInfo.ubVdoGop		= tProc.ubVdoGop;
		osMsgQId				= (KNL_NODE_COMM_TX_VDO == tKNLInfo.ubNextNode)?KNL_CommTxProcQueue:KNL_VdoCodecProcQueue;
        if(osMessagePut(osMsgQId, &tKNLInfo, 0) == osErrorResource)
		{
			printd(DBG_ErrorLvl, "KNL_Q->Full !!!!\r\n");
		}
	}
}

//------------------------------------------------------------------------------
#ifdef RTC676x
void KNL_BbTxVdoProcess2(KNL_PROCESS tProc)
{
	uint8_t ubTotalBufNum;
	uint8_t ubUsedBufNum;	
	uint8_t ubSelectSmallBufFlg = 0;
	uint32_t ulOriAddr = 0;	
	uint8_t ubBbLinkFlg	 = 0;
	uint8_t ubBbBufFlg	 = 0;
	
//	uint8_t ubFrameInQue = 0;
	uint32_t ulTemp;
	uint8_t ubTemp;
	uint32_t ulExtSz;

	ulExtSz = ulExtSz;		
	
	ulOriAddr = tProc.ulDramAddr2;
	
	if(ubKNL_ChkVdoFlowAct(tProc.ubSrcNum))
	{	
		//Link
		if(ubTRX_GetLinkStatus(0) == BB_LINK)	//STA->AP, Don't care input parameter
		{
			ubBbLinkFlg	= 1;
		}
		else
		{
			ubBbLinkFlg	= 0;		
		}
		
		//Buffer
		if(ubBbLinkFlg)
		{			
			//------------------------------------------------------------------------
			if((tProc.ulSize + KNL_AUX_INFO_LEN) <= ulKNL_GetRfSmallBufSize())
			{			
				ubSelectSmallBufFlg = 1;				
				ubTotalBufNum =  uwBUF_GetVdoPacketizeSmallTotalNum();
				ubUsedBufNum = ubTotalBufNum - uwBUF_GetVdoPacketizeSmallFreeNum();				
				//printf("(S:%d,%d)\r\n",ubTotalBufNum,ubUsedBufNum);
			}
			else
			{			
				ubSelectSmallBufFlg = 0;				
				ubTotalBufNum =  uwBUF_GetVdoPacketizeBigTotalNum();
				ubUsedBufNum = ubTotalBufNum - uwBUF_GetVdoPacketizeBigFreeNum();
				//printf("(B:%d,%d)\r\n",ubTotalBufNum,ubUsedBufNum);
			}		
			
			if((ubTotalBufNum - ubUsedBufNum) >= 1)
			{
				ubBbBufFlg = 1;
			}
			else
			{
				ubBbBufFlg = 0;
			}
			//========================================================================			
		}	
		
		if(ubBbLinkFlg && ubBbBufFlg)
		{
			ulExtSz = ulKNL_AddAuxInfo(KNL_VDO_PKT,tProc.ubSrcNum,tProc.ulDramAddr2,tProc.ulSize,tProc.ulIdx,tProc.ulGop,tProc.ubVdoGop,KNL_TIMER_Get1ms());
						
			if(ubSelectSmallBufFlg)
			{
				tProc.ubIsBigBuf = 0;
				ulTemp = ulBUF_GetVdoPacketizeSmallFreeBuf();
			}
			else
			{
				tProc.ubIsBigBuf = 1;
				ulTemp = ulBUF_GetVdoPacketizeBigFreeBuf();
			}
			
			
			if(ulTemp != BUF_FAIL)
			{					
				//Copy			
				if(tDMAC_MemCopy(tProc.ulDramAddr2, ulTemp,ulExtSz, NULL) == DMAC_OK)
				{						
					//Next Node					
					tProc.tPktType	 = PKT_MAIN_VDO;				
					tProc.ulDramAddr2 = ulTemp;
					tProc.ulSize	= ulExtSz;
					if(osMessagePut(KNL_VdoPacketizeQue, &tProc, 0) == osErrorResource)
					{					
						printd(DBG_ErrorLvl, "PktQ->F\r\n");
					}				
				}			
			}
			else
			{			
				//New I					
				//H264_ResetIPCnt(ENCODE_0);
				ubKNL_ResetIFlg[tProc.ubSrcNum] = 1;
			}

			ubTemp = ubKNL_ReleaseBsBufAddr(KNL_NODE_COMM_TX_VDO,tProc.ubSrcNum,ulOriAddr);
			if(ubTemp == BUF_OK)
			{
				printd(DBG_Debug3Lvl, "Release BUF_VDO_BS Ok\r\n");
			}
			else
			{
				printd(DBG_ErrorLvl, "Release BUF_VDO_BS Fail\r\n");
			}		
		}
		else
		{		
			//New I					
			//H264_ResetIPCnt(ENCODE_0);
			ubKNL_ResetIFlg[tProc.ubSrcNum] = 1;
			
			ubTemp = ubKNL_ReleaseBsBufAddr(KNL_NODE_COMM_TX_VDO,tProc.ubSrcNum,ulOriAddr);
			if(ubTemp == BUF_OK)
			{
				printd(DBG_Debug3Lvl, "Release BUF_VDO_BS Ok\r\n");
			}
			else
			{
				printd(DBG_ErrorLvl, "Release BUF_VDO_BS Fail\r\n");
			}		
		}
	}
	else
	{		
		ubTemp = ubKNL_ReleaseBsBufAddr(KNL_NODE_COMM_TX_VDO,tProc.ubSrcNum,ulOriAddr);
		if(ubTemp == BUF_OK)
		{
			printd(DBG_Debug3Lvl, "Release BUF_VDO_BS Ok\r\n");
		}
		else
		{
			printd(DBG_ErrorLvl, "Release BUF_VDO_BS Fail\r\n");
		}		
	}
}
#endif
#ifdef A7130
void KNL_BbTxVdoProcess(KNL_PROCESS tProc)
{
	uint8_t ubTemp;
	uint32_t ulExtSz;
	KNL_NODE_INFO tNodeInfo;
	struct H264_ENCODE *codec;
	uint8_t ubTotalBufNum;
	uint8_t ubUsedBufNum;	
	uint8_t ubSelectSmallBufFlg = 0;	
	uint8_t ubFramType = 0;//0->Small Frame, 1->Big Frame
	uint8_t ubBbStartFlg = 0;
	uint8_t ubBbLinkFlg	 = 0;
	uint8_t ubBbBufFlg	 = 0;

	tNodeInfo = tNodeInfo;
	codec = codec;
	if(ubKNL_ChkVdoFlowAct(tProc.ubSrcNum))
	{
RTYSEND_VDO:
		//Check 1
		if(ubBB_GetStartFlg() == BB_TASK_START)
		{
			ubBbStartFlg = 1;
		}
		else
		{
			ubBbStartFlg = 0;
		}

		//Check 2
		if(ubKNL_GetCommLinkStatus(KNL_MASTER_AP) == BB_LINK)
		{
			ubBbLinkFlg	= 1;
		}
		else
		{
			ubBbLinkFlg	= 0;
		}

		//Check 3		
#if (APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
		if((tProc.ulSize + KNL_AUX_INFO_LEN + KNL_TxFsSort.ulSize) <= ulKNL_GetRfSmallBufSize())
#else
		if((tProc.ulSize + KNL_AUX_INFO_LEN) <= ulKNL_GetRfSmallBufSize())
#endif
		{			
			ubSelectSmallBufFlg = 1;			
			ubTotalBufNum = ubBB_GetTxTotalBufNum(BB_DATA_VIDEO_LT,BB_TX_MASTER);
			ubUsedBufNum = ubBB_GetTxUsedBufNum(BB_DATA_VIDEO_LT,BB_TX_MASTER);
		}
		else
		{			
			ubSelectSmallBufFlg = 0;			
			ubTotalBufNum = ubBB_GetTxTotalBufNum(BB_DATA_VIDEO_BG,BB_TX_MASTER);
			ubUsedBufNum = ubBB_GetTxUsedBufNum(BB_DATA_VIDEO_BG,BB_TX_MASTER);
		}		
		
		if((ubTotalBufNum - ubUsedBufNum) >= 1)
		{
			ubBbBufFlg = 1;
		}
		else
		{
			ubBbBufFlg = 0;
		}

		printd(DBG_Debug2Lvl, "BB[%d]: %d_%d_%d(%d)\r\n", tProc.ubSrcNum, ubBbStartFlg, ubBbLinkFlg, ubBbBufFlg, ubKNL_BbRtyFlg);

		//Case 1
		if(ubBbStartFlg && ubBbLinkFlg && ubBbBufFlg)
		{
			ubKNL_BbRtyFlg = 0;
			ulExtSz = ulKNL_AddAuxInfo(KNL_VDO_PKT,tProc.ubSrcNum,tProc.ulDramAddr2,tProc.ulSize,tProc.ulIdx,tProc.ulGop,tProc.ubVdoGop,KNL_TIMER_Get1ms());
			
			if(ubSelectSmallBufFlg)
			{				
				ubFramType = 0;
			}
			else
			{				
				ubFramType = 1;
			}			
			
			if(tBB_SendData(NULL,BB_DATA_VIDEO,(uint8_t *)tProc.ulDramAddr2,ulExtSz,BB_TX_MASTER,ubFramType) != BB_SET_BUF_SUCCESS)
			{
				printd(DBG_ErrorLvl, "BB Busy !\r\n");
			}
			//printd(DBG_Debug3Lvl, "V:0x%x->%d_BW %d KB\r\n",tProc.ulSize,ubUsedBufNum,ulBB_GetBBFlow(BB_GET_TXMAP_VOD_FLOW)/1024);
			//Relase BS Buffer
			ubTemp = ubKNL_ReleaseBsBufAddr(KNL_NODE_COMM_TX_VDO,tProc.ubSrcNum,tProc.ulDramAddr2);
			if(ubTemp == BUF_OK)
			{
				printd(DBG_Debug3Lvl, "Release BUF_VDO_BS Ok\r\n");
			}
			else
			{
				printd(DBG_ErrorLvl, "Release BUF_VDO_BS Fail\r\n");
			}
			if((!tProc.ulIdx) && (KNL_CAPHQ_EN == tKNL_CapHQImgSte))
				tKNL_CapHQImgSte = KNL_CAPHQ_TXRDY;
		}
		//Case 2
		else if(ubBbStartFlg && (!ubBbLinkFlg))
		{
			ubKNL_BbRtyFlg = 0;
			//printd(DBG_Debug3Lvl, "BU(V)\r\n");

			BB_ClearTxBuf(BB_TX_MASTER,BB_DATA_VIDEO);
			//Relase BS Buffer
			ubTemp = ubKNL_ReleaseBsBufAddr(KNL_NODE_COMM_TX_VDO,tProc.ubSrcNum,tProc.ulDramAddr2);
			if(ubTemp == BUF_OK)
			{
				printd(DBG_Debug3Lvl, "Release BUF_VDO_BS Ok\r\n");
			}
			else
			{
				printd(DBG_ErrorLvl, "Release BUF_VDO_BS Fail\r\n");
			}			
			if(ubKNL_ExistNode(tProc.ubSrcNum,KNL_NODE_H264_ENC))
			{
				tNodeInfo = tKNL_GetNodeInfo(tProc.ubSrcNum,KNL_NODE_H264_ENC);
				if((KNL_GetTuningToolMode() == KNL_TUNINGMODE_OFF) ||
				   (USB_UVC_VS_FORMAT_UNDEFINED == UVC_GetVdoFormat()))           	    
					ubKNL_ResetIFlg[tProc.ubSrcNum] = 1;
			}
		}
		//Case 3
		else if(ubBbStartFlg && ubBbLinkFlg && (!ubBbBufFlg) && (!ubKNL_BbRtyFlg))
		{
			//ubKNL_BbRtyFlg = 1;
			printd(DBG_Debug3Lvl, "V->RTY:0x%x\r\n",tProc.ulSize);
			osDelay(20);
			goto RTYSEND_VDO;
		}
		else
		{
			ubKNL_BbRtyFlg = 0;
			printd(DBG_Debug3Lvl, "V->RTY:0x%x->Clr\r\n",tProc.ulSize);
			BB_ClearTxBuf(BB_TX_MASTER,BB_DATA_VIDEO);
			//Relase BS Buffer
			ubTemp = ubKNL_ReleaseBsBufAddr(KNL_NODE_COMM_TX_VDO,tProc.ubSrcNum,tProc.ulDramAddr2);
			if(ubTemp == BUF_OK)
			{
				printd(DBG_Debug3Lvl, "Release BUF_VDO_BS Ok\r\n");
			}
			else
			{
				printd(DBG_ErrorLvl, "Release BUF_VDO_BS Fail\r\n");
			}
			if(ubKNL_ExistNode(tProc.ubSrcNum,KNL_NODE_H264_ENC))
			{
				tNodeInfo = tKNL_GetNodeInfo(tProc.ubSrcNum,KNL_NODE_H264_ENC);
				if((KNL_GetTuningToolMode() == KNL_TUNINGMODE_OFF) ||
				   (USB_UVC_VS_FORMAT_UNDEFINED == UVC_GetVdoFormat()))
					
					ubKNL_ResetIFlg[tProc.ubSrcNum] = 1;
			}
		}
	}
	else
	{
		BB_ClearTxBuf(BB_TX_MASTER,BB_DATA_VIDEO);
		//Relase BS Buffer	
		ubTemp = ubKNL_ReleaseBsBufAddr(KNL_NODE_COMM_TX_VDO,tProc.ubSrcNum,tProc.ulDramAddr2);
		if(ubTemp == BUF_OK)
		{
			printd(DBG_Debug3Lvl, "Release BUF_VDO_BS Ok\r\n");
		}
		else
		{
			printd(DBG_ErrorLvl, "Release BUF_VDO_BS Fail\r\n");
		}
		if(ubKNL_ExistNode(tProc.ubSrcNum,KNL_NODE_H264_ENC))
		{
			tNodeInfo = tKNL_GetNodeInfo(tProc.ubSrcNum,KNL_NODE_H264_ENC);
			if((KNL_GetTuningToolMode() == KNL_TUNINGMODE_OFF) ||
			   (USB_UVC_VS_FORMAT_UNDEFINED == UVC_GetVdoFormat()))
				
				ubKNL_ResetIFlg[tProc.ubSrcNum] = 1;
		}
	}
}
#endif


#ifdef S2019A
//------------------------------------------------------------------------------
void KNL_SetReEncIfrmFlag(uint8_t ubFlag)
{
	osSemaphoreWait(osKNL_EncIfrmSem, osWaitForever);
	ubKNL_EncIfrmFlag = ubFlag;
	osSemaphoreRelease(osKNL_EncIfrmSem);
}
//------------------------------------------------------------------------------v
uint8_t ubKNL_GetReEncIfrmFlag(void)
{
	uint8_t ubEncFlag;

	osSemaphoreWait(osKNL_EncIfrmSem, osWaitForever);
	ubEncFlag = ubKNL_EncIfrmFlag;
	osSemaphoreRelease(osKNL_EncIfrmSem);
	return ubEncFlag;
}
//------------------------------------------------------------------------------
uint32_t ulKNL_IspOutIsrProc(void)
{
	uint32_t ulsFrmTm = 0;
#if (defined(OP_STA) && sPRF_LTYMEAS_EN)
	uint8_t ubTmIdx;
	ulsFrmTm = tKNL_VdoLatency.tLatency[0].ulTxVsyncTm[0];
	for(ubTmIdx = 1; ubTmIdx < SPRF_VSNTM_BUF; ubTmIdx++)
	{
		if(!tKNL_VdoLatency.tLatency[0].ulTxVsyncTm[ubTmIdx])
			break;
		tKNL_VdoLatency.tLatency[0].ulTxVsyncTm[ubTmIdx-1] = tKNL_VdoLatency.tLatency[0].ulTxVsyncTm[ubTmIdx];
		tKNL_VdoLatency.tLatency[0].ulTxVsyncTm[ubTmIdx]   = 0;
	}
	if(tKNL_VdoLatency.tLatency[0].ubvsTmIdx)
		tKNL_VdoLatency.tLatency[0].ubvsTmIdx--;
#endif
	return ulsFrmTm;
}
//------------------------------------------------------------------------------
uint32_t ulKNL_SenVsyncIsrProc(void)
{
	uint32_t ulTmCnt = 0;
#if (defined(OP_STA) && sPRF_LTYMEAS_EN)
	ulTmCnt = ulsPRF_GetIntTmCnt();
	tKNL_VdoLatency.tLatency[0].ulTxVsyncTm[tKNL_VdoLatency.tLatency[0].ubvsTmIdx] = ulTmCnt;
	if(++tKNL_VdoLatency.tLatency[0].ubvsTmIdx >= SPRF_VSNTM_BUF)
		tKNL_VdoLatency.tLatency[0].ubvsTmIdx = SPRF_VSNTM_BUF - 1;
#endif
	return ulTmCnt;
}
//------------------------------------------------------------------------------
void KNL_LcdVsncIsr(void)
{
#if (defined(OP_AP) && sPRF_LTYMEAS_EN)
	uint8_t ubStaNum, ubTmIdx;

	if(FALSE == tKNL_VdoLatency.ubEn)
		return;
	for(ubStaNum = KNL_STA1; ubStaNum <= KNL_STA4; ubStaNum++)
	{
		if(tKNL_VdoLatency.tLatency[ubStaNum].uldFrmTm[0])
		{
			SPRF_LatyInfo_t tLatyData;

			tLatyData.ubStaNum	     = ubStaNum;
			tLatyData.ulRxVsyncTm    = ulsPRF_GetIntTmCnt();
			tLatyData.ulTxVsyncTm[0] = tKNL_VdoLatency.tLatency[ubStaNum].uldFrmTm[0];
			tLatyData.ubDispFlag     = tKNL_VdoLatency.tLatency[ubStaNum].ubDispFlag;
			tLatyData.ubRefhFlag     = tKNL_VdoLatency.tLatency[ubStaNum].ubRefhFlag;
			osMessagePut(osKNL_LatyDataQue, &tLatyData, 0);
			tKNL_VdoLatency.tLatency[ubStaNum].ubUpdFlag  = FALSE;
			tKNL_VdoLatency.tLatency[ubStaNum].ubRefhFlag = FALSE;
			if(TRUE == tKNL_VdoLatency.tLatency[ubStaNum].ubDispFlag)
			{
				if(TRUE == tKNL_VdoLatency.ubDbg)
					sPRF_DBG_PROC(6, 0);
				tKNL_VdoLatency.tLatency[ubStaNum].ubDispFlag = FALSE;
			}
		}
		tKNL_VdoLatency.tLatency[ubStaNum].uldFrmTm[0] = 0;
		for(ubTmIdx = 1; ubTmIdx < LCD_PINGPONG_BUF_MAX; ubTmIdx++)
		{
			if(!tKNL_VdoLatency.tLatency[ubStaNum].uldFrmTm[ubTmIdx])
				break;
			tKNL_VdoLatency.tLatency[ubStaNum].uldFrmTm[ubTmIdx-1] = tKNL_VdoLatency.tLatency[ubStaNum].uldFrmTm[ubTmIdx];
			tKNL_VdoLatency.tLatency[ubStaNum].uldFrmTm[ubTmIdx] = 0;
		}
		if(tKNL_VdoLatency.tLatency[ubStaNum].ubsTmIdx)
			tKNL_VdoLatency.tLatency[ubStaNum].ubsTmIdx--;
	}
#endif
}
//------------------------------------------------------------------------------
#if (defined(OP_AP) && sPRF_LTYMEAS_EN)
static void KNL_CalcLatencyThread(void const *argument)
{
#define KNL_LATY_BUF	15
	SPRF_LatyInfo_t tKNL_LatyData;
	uint16_t uwKNL_LatyTab[KNL_LATY_BUF] = {0};
	uint8_t ubKNL_LatyDispFlag = 0, ubKNL_LatyCnt = 0;

	memset(&uwKNL_LatyTab[0], 0, KNL_LATY_BUF);
	while(1)
	{
		osMessageGet(osKNL_LatyDataQue, &tKNL_LatyData, osWaitForever);
		if((tKNL_LatyData.ubStaNum > KNL_STA4) || (tKNL_LatyData.ulRxVsyncTm < tKNL_LatyData.ulTxVsyncTm[0]))
			continue;
		tKNL_VdoLatency.tLatency[tKNL_LatyData.ubStaNum].fFrmLtcy = (tKNL_LatyData.ulRxVsyncTm - tKNL_LatyData.ulTxVsyncTm[0]) / 10000;
		uwKNL_LatyTab[ubKNL_LatyCnt++] = tKNL_VdoLatency.tLatency[tKNL_LatyData.ubStaNum].fFrmLtcy;
		if(ubKNL_LatyCnt >= KNL_LATY_BUF)
		{
			uint32_t ulLatyData = 0;
			uint8_t ubCnt = 0;
			for(ubCnt = 0; ubCnt < KNL_LATY_BUF; ubCnt++)
				ulLatyData += uwKNL_LatyTab[ubCnt];
			tKNL_VdoLatency.tLatency[tKNL_LatyData.ubStaNum].fAvgLtcy = ulLatyData / KNL_LATY_BUF;
			for(ubCnt = 0; ubCnt < (KNL_LATY_BUF - 1); ubCnt++)
				uwKNL_LatyTab[ubCnt] = uwKNL_LatyTab[ubCnt + 1];
			ubKNL_LatyCnt = KNL_LATY_BUF - 1;
			ubKNL_LatyDispFlag |= 1;
		}
		else
		{
			tKNL_VdoLatency.tLatency[tKNL_LatyData.ubStaNum].fAvgLtcy = tKNL_VdoLatency.tLatency[tKNL_LatyData.ubStaNum].fFrmLtcy;
			ubKNL_LatyDispFlag |= 1;
		}
		if((tKNL_VdoLatency.tLatency[tKNL_LatyData.ubStaNum].fFrmLtcy < tKNL_VdoLatency.tLatency[tKNL_LatyData.ubStaNum].fMinLtcy) ||
		   (!tKNL_VdoLatency.tLatency[tKNL_LatyData.ubStaNum].fMinLtcy) || (TRUE == tKNL_LatyData.ubRefhFlag))
		{
			tKNL_VdoLatency.tLatency[tKNL_LatyData.ubStaNum].fMinLtcy = tKNL_VdoLatency.tLatency[tKNL_LatyData.ubStaNum].fFrmLtcy;
			ubKNL_LatyDispFlag |= 2;
		}
		printd(DBG_InfoLvl, "\r\n [%d]L: %.3lf ms\r\n", tKNL_LatyData.ubStaNum, tKNL_VdoLatency.tLatency[tKNL_LatyData.ubStaNum].fFrmLtcy);
		if((pKNL_PerDbgFunc[1]) && (ubKNL_LatyDispFlag & 0x1))
			pKNL_PerDbgFunc[1](PER_SPRFAVGL_RPT, tKNL_LatyData.ubStaNum, tKNL_VdoLatency.tLatency[tKNL_LatyData.ubStaNum].fAvgLtcy);			
		if((pKNL_PerDbgFunc[1]) && (ubKNL_LatyDispFlag & 0x2))
			pKNL_PerDbgFunc[1](PER_SPRFMINL_RPT, tKNL_LatyData.ubStaNum, tKNL_VdoLatency.tLatency[tKNL_LatyData.ubStaNum].fMinLtcy);
		if((pKNL_PerDbgFunc[1]) && (TRUE == tKNL_VdoLatency.ubDbg) && (TRUE == tKNL_LatyData.ubDispFlag))
			pKNL_PerDbgFunc[1](PER_SPRFFRML_RPT, tKNL_LatyData.ubStaNum, tKNL_VdoLatency.tLatency[tKNL_LatyData.ubStaNum].fFrmLtcy);
		ubKNL_LatyDispFlag = 0;
	}
}
#endif
//------------------------------------------------------------------------------
uint8_t ubKNL_H264EncSetup(uint8_t ubCodecIdx)
{
#ifdef OP_STA
	uint8_t ubAdjFlag = FALSE;
#endif
	if(ENCODE_0 != ubCodecIdx)
		return TRUE;
	if(TRUE == ubKNL_GetReEncIfrmFlag())
	{
		H264_ResetIPCnt((H264_ENCODE_INDEX)ubCodecIdx);
		KNL_StopSPRFTxProcess(FALSE);
		KNL_SetReEncIfrmFlag(FALSE);
	}
	ulKNL_CurFrmIdx[(H264_ENCODE_INDEX)ubCodecIdx] = H264_GetPeriod((H264_ENCODE_INDEX)ubCodecIdx);
#ifdef OP_STA
	#ifdef RVCS_APP
	#if (E_RVCS_ALL_I_FRM == 1)
	if(TRUE == ubKNL_UpdVdoGopFlag)
	{
		uint32_t ulGop = KNL_TX_GOP;
		ulGop = (sPRF_APDIRECT_MODE == tKNL_sPRFDrvMd)?KNL_TX_RVCS_GOP:ulKNL_GetVdoGop();
		H264_SetGOP((H264_ENCODE_INDEX)ubCodecIdx, ulGop);
		ubKNL_UpdVdoGopFlag = FALSE;
		printd(DBG_CriticalLvl, "RVCS GOP=%d\r\n", ulGop); 
	}
	#endif
	#if (APP_BLE_SN9380_FUNC_ENABLE == 1)
	if (UIcmd_GetConnSts() == 1 && UIcmd_GetVideoStartStatus() == 1)
	{
		uint8_t ubRet = TRUE;
		ubRet = ubWiFiDt_BleUse_GetVdoTransSts();
		return ubRet;
	}
	#endif
	if(sPRF_APDIRECT_MODE == tKNL_sPRFDrvMd)
	{
		uint8_t ubRet = TRUE;
		if(BB_LINK == ubKNL_GetRtCommLinkStatus(KNL_MASTER_AP))
			ubRet = ubWiFiDt_GetVdoTransSts();
		return ubRet;
	}
	#endif	//! End of #ifdef RVCS_APP
	ubAdjFlag = ubRC_ChkAdjQpRange(ubCodecIdx);
	if(TRUE == ubAdjFlag)
	{
		uint8_t ubNewQp = 35, ubCurQp = 35;

		ubCurQp = H264_GetCurrentQP();
		ubNewQp = ubCurQp + 5;
		if((ubCurQp < ubNewQp) && (ubNewQp >= 43))
			ubNewQp = 43;
		if(ubCurQp != ubNewQp)
			H264_ResetRateControl(ubNewQp);
	}
#endif
	return TRUE;
}
//------------------------------------------------------------------------------
void H264EncParamUpdate(KNL_PROCESS tProc)
{
#ifdef OP_STA
	KNL_NODE_INFO tNodeInfo;

	tNodeInfo = tKNL_GetNodeInfo(tProc.ubSrcNum, KNL_NODE_H264_ENC);
	#if sPRF_LTYMEAS_EN
	if(sPRF_APDIRECT_MODE != tKNL_sPRFDrvMd)
	{
		if((tProc.ubSrcNum <= KNL_SRC_4_MAIN) && (ENCODE_0 == tNodeInfo.ubCodecIdx))
		{
			tKNL_VdoLatency.tLatency[0].ulsFrmTm = tProc.ulsFrmTm;
			if(TRUE == tKNL_VdoLatency.ubDbg)
			{
				if(!(ulKNL_CurFrmIdx[(H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx] % 80))
					sPRF_DBG_PROC(11, 1);
				else
					sPRF_DBG_PROC(11, 0);
			}
		}
	}
	#endif
	if(!(++tKNL_H264EncInfo[tNodeInfo.ubCodecIdx].ubFrames % ubKNL_GetVdoFps()))
		tKNL_H264EncInfo[tNodeInfo.ubCodecIdx].ubFrames = 0;
	if(!tKNL_H264EncInfo[tNodeInfo.ubCodecIdx].ubFps)
		tKNL_H264EncInfo[tNodeInfo.ubCodecIdx].ubFps = ubKNL_GetVdoFps();
#endif
}
//------------------------------------------------------------------------------
uint32_t ulKNL_H264EncReport(uint8_t ubSrcNum, uint32_t ulEncBs, uint32_t ulFrmIdx)
{
	uint32_t ulRpt = 0;
#ifdef OP_STA
	KNL_NODE_INFO tNodeInfo;

	tNodeInfo = tKNL_GetNodeInfo(ubSrcNum, KNL_NODE_H264_ENC);
	if(ubKNL_ResetIFlg[ubSrcNum])
	{
		if(!ulFrmIdx)
			ubKNL_ResetIFlg[ubSrcNum] = FALSE;
		else
			H264_ResetIPCnt((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx);
		if(TRUE == ubKNL_RstVdoGrpFlag)
		{
			ubKNL_RstVdoGrpFlag = FALSE;
			ubKNL_ResetIFlg[ubSrcNum] = FALSE;
		}
		ulKNL_CurFrmIdx[tNodeInfo.ubCodecIdx] = 0;		
	}
	if((!tKNL_H264EncInfo[tNodeInfo.ubCodecIdx].ubFrames) && (tKNL_H264EncInfo[tNodeInfo.ubCodecIdx].ubFps) && (tNodeInfo.ubCodecIdx <= ENCODE_3))
	{
		ulKNL_VdoOutAccCnt[tNodeInfo.ubCodecIdx] = ulKNL_VdoOutAccCntTemp[tNodeInfo.ubCodecIdx];
		ulKNL_VdoOutAccCntTemp[tNodeInfo.ubCodecIdx] = 0;
	}
	if(ubSrcNum <= KNL_SRC_4_MAIN)
	{
		uint8_t ubStaNum = 0;
		ubStaNum = ubKNL_SrcNumMap(ubSrcNum);
		if(ubStaNum <= KNL_STA4)
		{
			if((ulEncBs + 64) > tKNL_VdoBsOvfInfo.ulBsBufSize)
			{
				tKNL_VdoBsOvfInfo.ulBsOvfAddr[ubStaNum] = ulKNL_GetBsOvfBufAddr(ubSrcNum);
				printd(DBG_CriticalLvl, "\r\n  [%d]OVF:%d > %d\r\n", ubStaNum, ulEncBs, tKNL_VdoBsOvfInfo.ulBsBufSize);
			}
		}
	#if sPRF_LTYMEAS_EN
		if((sPRF_APDIRECT_MODE != tKNL_sPRFDrvMd) && (ENCODE_0 == tNodeInfo.ubCodecIdx))
			ulRpt = tKNL_VdoLatency.tLatency[0].ulsFrmTm;
	#endif
	}
	if(TRUE == tKNL_H264EncInfo[tNodeInfo.ubCodecIdx].ubEn)
	{
		float fCurBs = 0;
		uint8_t ubQp = 0;

		tKNL_H264EncInfo[tNodeInfo.ubCodecIdx].ulBps += (ulEncBs * 8);
		fCurBs = (float)ulEncBs/1024;
		ubQp   = ubKNL_GetQp(tNodeInfo.ubCodecIdx);
		printd(DBG_InfoLvl, "  %02d:[%fKB, QP:%02d]\n", tKNL_H264EncInfo[tNodeInfo.ubCodecIdx].ubFrames, fCurBs, ubQp);
		if(!tKNL_H264EncInfo[tNodeInfo.ubCodecIdx].ubFrames)
		{
			printd(DBG_InfoLvl, " Bps:%fKB\n", (float)tKNL_H264EncInfo[tNodeInfo.ubCodecIdx].ulBps/8192);
			tKNL_H264EncInfo[tNodeInfo.ubCodecIdx].ulBps = 0;
		}
	}
#endif
	return ulRpt;
}
//------------------------------------------------------------------------------
void KNL_ImgRateCtrlFlow(uint8_t ubSrcNum, uint8_t ubCodecIdx, uint8_t ubFpsUpdFlag)
{
	if(ubRC_GetFlg(ubCodecIdx))
	{
		uint8_t ubRcUpdTarg = FALSE;

		ubRcUpdTarg = ubRC_GetUpdateFlg(ubCodecIdx);
		if((ubRcUpdTarg) || (TRUE == ubFpsUpdFlag))
		{
			uint32_t ulTargtBitRate = 0;
			uint8_t ubCurQp = 35, ubMinQp = 35;

			if(ubRcUpdTarg & 0x1)
			{
				H264_SetFrameRate((H264_ENCODE_INDEX)ubCodecIdx, ubRC_GetFps());
				ubRcUpdTarg &= ~0x1;
			}
			if(ubRcUpdTarg)
			{
				ulTargtBitRate = ulRC_GetFinalBitRate(ubCodecIdx);
				H264_RcSetEN((H264_ENCODE_INDEX)ubCodecIdx, H264_ENABLE, CBR, ulTargtBitRate);
				ubCurQp = H264_GetCurrentQP();
				ubMinQp = ubRC_GetFinalMinQp(ubCodecIdx);
			#ifdef RVCS_APP
				#if (E_RVCS_ALL_I_FRM == 1)
				if(sPRF_APDIRECT_MODE == tsPRF_GetDrvMode())
					H264_ResetRateControl(((ubCurQp > ubMinQp)?ubMinQp:ubMinQp));
				else
				#endif
					H264_ResetRateControl(((ubCurQp > ubMinQp)?ubCurQp:ubMinQp));			
			#else
				H264_ResetRateControl(((ubCurQp > ubMinQp)?ubCurQp:ubMinQp));
			#endif
				H264_SetRCParameter((H264_ENCODE_INDEX)ubCodecIdx, ulTargtBitRate, ubRC_GetFps());
				H264_SetMaxQP((H264_ENCODE_INDEX)ubCodecIdx, ubRC_GetFinalMaxQp(ubCodecIdx));
				H264_SetMinQP((H264_ENCODE_INDEX)ubCodecIdx, ubMinQp);
				RC_SetUpdateFlg(ubCodecIdx, 0);
			#ifndef RVCS_APP
				if(ubRcUpdTarg)
					printd(DBG_InfoLvl, "\n<-RC:%d\n", ubRcUpdTarg);
			#endif
			}
		}
#ifdef OP_STA
		if((DISPLAY_1T1R != DISPLAY_MODE) && (sPRF_APDIRECT_MODE != tKNL_sPRFDrvMd))
		{
			KNL_NODE_INFO tNodeInfo;
			uint8_t ubFpsTg = 20;

			tNodeInfo = tKNL_GetNodeInfo(ubSrcNum, KNL_NODE_H264_ENC);
			ubFpsTg   = ((HD_WIDTH == tNodeInfo.uwVdoH) && (HD_HEIGHT == tNodeInfo.uwVdoV))?
					    (1 == ubsPRF_GetAttachedDevNums())?HD_RES1T_FPS:HD_RES2T_FPS:VDO_FRAME_RATE(tNodeInfo.uwVdoH, tNodeInfo.uwVdoV);
			if(ubKNL_GetSysMaxFps() != ubFpsTg)
			{
				RC_UpdateDynaFpsParam(ubFpsTg, RC_MIN_FPS);
				if(ubKNL_GetVdoFps() != ubFpsTg)
				{
					KNL_SetVdoFps(ubFpsTg);
					SEN_SetFrameRate(SENSOR_PATH1, ubFpsTg);
				}
				KNL_SetSysMaxFps(ubFpsTg);
				printd(DBG_CriticalLvl, "\nM.FPS= %d\n", ubFpsTg);
			}
		}
#endif
	}
}
//------------------------------------------------------------------------------
uint32_t ulKNL_AddEncImgInfo(KNL_PROCESS tImgInfo)
{
	uint32_t ulExtSz = 0;
#if (APP_PLYBK_ENABLE == 0)	// modify to add playback function for RVCS App
	if(sPRF_APDIRECT_MODE == tKNL_sPRFDrvMd)
		return tImgInfo.ulSize;
#endif
	ulExtSz = ulKNL_AddAuxInfo(KNL_VDO_PKT, tImgInfo.ubSrcNum, tImgInfo.ulDramAddr2, tImgInfo.ulSize, tImgInfo.ulIdx, tImgInfo.ulGop, tImgInfo.ubVdoGop, KNL_TIMER_Get1ms());
#if (APP_PLYBK_ENABLE == 1)	// modify to add playback function for RVCS App
	if(sPRF_APDIRECT_MODE == tKNL_sPRFDrvMd) {
		return ulExtSz;
	}
#endif
#if sPRF_LTYMEAS_EN
	*((uint32_t *)(tImgInfo.ulDramAddr2 + ulExtSz - KNL_INFO_TXSFRMTM)) = tImgInfo.ulsFrmTm;
#endif
	return ulExtSz;
}
//------------------------------------------------------------------------------
void KNL_H264DecSetup(KNL_PROCESS tProc)
{
#if (defined(OP_AP) && sPRF_LTYMEAS_EN)
	uint8_t ubStaNum;

	ubStaNum = ubKNL_SrcNumMap(tProc.ubSrcNum);
	if(ubStaNum > KNL_STA4)
		return;
	tKNL_VdoLatency.tLatency[ubStaNum].ulsFrmTm = tProc.ulsFrmTm;
	tKNL_VdoLatency.tLatency[ubStaNum].ulFrmIdx = tProc.ulIdx;
	if((tKNL_VdoLatency.tLatency[ubStaNum].ulFrmIdx) && !(tKNL_VdoLatency.tLatency[ubStaNum].ulFrmIdx % 80))
		sPRF_DBG_PROC(6, 1);
#endif
}
//------------------------------------------------------------------------------
uint8_t ubKNL_H264DecReport(uint8_t ubSrcNum, H264_RESULT *DecResult)
{
	uint8_t ubRpt = TRUE;

	if(H264_FAIL == DecResult->Result)
	{
		uint8_t ubPreNode;

		ubRpt     = FALSE;
		ubPreNode = ubKNL_GetPreNode(ubSrcNum, KNL_NODE_H264_DEC);
		if((KNL_NODE_VDO_BS_BUF1 == ubPreNode) || (KNL_NODE_VDO_BS_BUF2 == ubPreNode))
		{
			uint8_t ubRet = BUF_OK;
			ubRet = ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_DEC, ubSrcNum, DecResult->BSAddr);
			if(ubRet != BUF_OK)
				printd(DBG_ErrorLvl, "Err @%s[0x%X]\n", __func__, DecResult->BSAddr);
		}
		printd(DBG_ErrorLvl, "\r\n	[%d]DEC ERR@%s, Bs: %d\r\n", ubSrcNum, (tKNL_GetFrameType(DecResult->BSAddr) == KNL_I_FRAME)?"I Frm":"P Frm", ulKNL_ImgSize);
	}
#if (defined(OP_AP) && sPRF_LTYMEAS_EN)
	else
	{
		uint8_t ubStaNum;

		ubStaNum = ubKNL_SrcNumMap(ubSrcNum);
		if((FALSE == tKNL_VdoLatency.ubEn) || (ubStaNum > KNL_STA4))
			return ubRpt;
		LCD_IntMask(LCD_INT_MASK_ENABLE);
		tKNL_VdoLatency.tLatency[ubStaNum].uldFrmTm[tKNL_VdoLatency.tLatency[ubStaNum].ubsTmIdx] = tKNL_VdoLatency.tLatency[ubStaNum].ulsFrmTm;
		if(tKNL_VdoLatency.tLatency[ubStaNum].ubsTmIdx == LCD_PINGPONG_BUF_MAX)
		{
			tKNL_VdoLatency.tLatency[ubStaNum].uldFrmTm[LCD_PINGPONG_BUF_MAX-1] = tKNL_VdoLatency.tLatency[ubStaNum].uldFrmTm[tKNL_VdoLatency.tLatency[ubStaNum].ubsTmIdx];
			tKNL_VdoLatency.tLatency[ubStaNum].uldFrmTm[tKNL_VdoLatency.tLatency[ubStaNum].ubsTmIdx] = 0;
		}
		if(++tKNL_VdoLatency.tLatency[ubStaNum].ubsTmIdx >= SPRF_FRMTM_BUF)
			tKNL_VdoLatency.tLatency[ubStaNum].ubsTmIdx = SPRF_FRMTM_BUF - 1;
		if((tKNL_VdoLatency.tLatency[ubStaNum].ulFrmIdx) && !(tKNL_VdoLatency.tLatency[ubStaNum].ulFrmIdx % 80) && (FALSE == tKNL_VdoLatency.tLatency[ubStaNum].ubDispFlag))
			tKNL_VdoLatency.tLatency[ubStaNum].ubDispFlag = TRUE;
		if(!tKNL_VdoLatency.tLatency[ubStaNum].ulFrmIdx)
			tKNL_VdoLatency.tLatency[ubStaNum].ubRefhFlag = TRUE;
		if(FALSE == tKNL_VdoLatency.tLatency[ubStaNum].ubUpdFlag)
			tKNL_VdoLatency.tLatency[ubStaNum].ubUpdFlag = TRUE;
		LCD_IntMask(LCD_INT_MASK_DISABLE);
	}
#endif
	return ubRpt;
}
//------------------------------------------------------------------------------
void KNL_sPRFDevPwrCtrl(sPRF_PwrCtrl_t tCtrl)
{
#ifdef sPRF_PWR_CTRL
	sPRF_PWR_CTRL(tCtrl);
#endif
}
//------------------------------------------------------------------------------
static void KNL_sPRFMonitorThread(void const *argument)
{
	uint8_t ubKNL_sRfDevId;
	KNL_ROLE tKNL_sPRfRole[] = {[sPRF_STA1] = KNL_STA1,
								[sPRF_STA2] = KNL_STA2,
								[sPRF_STA3] = KNL_STA3,
								[sPRF_STA4]	= KNL_STA4,
								[sPRF_AP] 	= KNL_MASTER_AP};

	while(1)
	{
		osMessageGet(osKNL_sPrfFrmQue, &ubKNL_sRfDevId, osWaitForever);
		if((KNL_CAPHQ_TXRDY == tKNL_CapHQImgSte) &&
		   (KNL_MASTER_AP == tKNL_sPRfRole[ubKNL_sRfDevId]))
			tKNL_CapHQImgSte = KNL_CAPHQ_DIS;
#ifdef OP_AP
		ulKNL_FrmTRxNumTemp[(KNL_ROLE)ubKNL_sRfDevId]++;
#endif
		if(ptKNL_BbFrmMonitCbFunc)
			ptKNL_BbFrmMonitCbFunc(ubKNL_sRfDevId);
    }
}
//------------------------------------------------------------------------------
// ubFrmType: 0:I frame, 1:P frame
// ubEvent: 0xAA:JPEG frame, 0:H.264 frame
#ifdef RVCS_APP
uint32_t ulKNL_SetWiFiDtBufAddr_DwnldMode(uint32_t ulBsBufAddr, uint32_t ulBsSz, uint8_t ubEvent, uint32_t ulFileSize)
{
    uint32_t ulTemp = 0xFFFFFFFF;

	printd(DBG_Debug3Lvl, "ulKNL_SetWiFiDtBufAddr_DwnldMode, buf_sz:%d, file_sz:%d, evt:0x%x\n", ulBsSz, ulFileSize, ubEvent);

    if(ubWiFiDt_TxMQReq(ulBsBufAddr, ulBsSz, 0, 30, ubEvent, ulFileSize) != 1)
    {
        printd(DBG_ErrorLvl, "ulKNL_SetWiFiDtBufAddr_DwnldMode no Buf\n");
        ulTemp = BUF_FAIL;
    }
    return ulTemp;
}
//------------------------------------------------------------------------------
uint32_t ulKNL_SetWiFiDtBufAddr(uint32_t ulBsBufAddr, uint32_t ulBsSz, uint32_t ubFrmType, uint8_t ubVdoGop, uint8_t ubEvent)
{
    uint32_t ulTemp = 0xFFFFFFFF;

    if(ubWiFiDt_TxMQReq(ulBsBufAddr, ulBsSz, ubFrmType, ubVdoGop, ubEvent, KNL_TIMER_Get1ms()) != 1)
    {
        printd(DBG_ErrorLvl, "ulKNL_SetWiFiDtBufAddr no Buf\n");
        ulTemp = BUF_FAIL;
    }
    return ulTemp;
}
#if defined(OP_STA)
//------------------------------------------------------------------------------
void KNL_SwitchDrvMdRes(sPRF_DrvMode_t tDrvMode)
{
	KNL_ROLE tRoleNum = KNL_STA1;
	KNL_SRC tSrcNum;
	uint16_t uwTargH = 0, uwTargV = 0;
	uint16_t uwCurH = 0, uwCurV = 0;
	uint8_t ubResData[8] ={0};
	tRoleNum = (KNL_ROLE)ubKNL_GetRole();
	if(ptKNL_VdoRoleMap2SrcNum)
		tSrcNum = ptKNL_VdoRoleMap2SrcNum(KNL_MAIN_PATH, tRoleNum);
	else
		tSrcNum = (KNL_SRC)(KNL_SRC_1_MAIN + tRoleNum);
	uwCurH = uwKNL_GetVdoH(tSrcNum);
	uwCurV = uwKNL_GetVdoV(tSrcNum);
	printf("uwCurH==%d,uwCurV==%d\n",uwCurH,uwCurV);
	

	switch(tDrvMode)
	{
		case sPRF_APDIRECT_MODE:
		if (ubRES_SWITCH == 0)
		{
		  #if (APP_BLE_SN9380_FUNC_ENABLE == 1)
			uwTargH = QVGA_WIDTH;
			uwTargV = QVGA_HEIGHT;
		  #else
			uwTargH = VGA_WIDTH;
			uwTargV = VGA_HEIGHT;
		  #endif
		}
		else if (ubRES_SWITCH == 1)
		{
			uwTargH = HD_WIDTH;
			uwTargV = HD_HEIGHT;
		}
		else if (ubRES_SWITCH == 2)
		{
			uwTargH = FHD_WIDTH;
			uwTargV = FHD_HEIGHT;
		}
	}
	ubResData[0] = (uwTargH & 0xFF00) >> 8;
	ubResData[1] = (uwTargH & 0xFF);
	ubResData[2] = (uwTargV & 0xFF00) >> 8;
	ubResData[3] = (uwTargV & 0xFF);
	ubResData[4] = tSrcNum;
	ubResData[5] = 1;
	KNL_VdoResSetting((TWC_TAG)tRoleNum, ubResData);
}
//------------------------------------------------------------------------------
float KNL_RC_ResoSwitch_Ratio(void)
{
	float ratio = 1.0;
#if (DT_DISPLAY_MODE == DT_DISPLAY_FHD)	
	if (uwKNL_GetVdoH(ubKNL_GetRole()) == VGA_WIDTH) {
		ratio *= 0.9*0.9;
	}
	else if (uwKNL_GetVdoH(ubKNL_GetRole()) == HD_WIDTH) {
		ratio *= 0.9;
	}	
#elif (DT_DISPLAY_MODE == DT_DISPLAY_HD)
	if (uwKNL_GetVdoH(ubKNL_GetRole()) == VGA_WIDTH) {
		ratio *= 0.9;
	}
#endif

	return ratio;
}

//------------------------------------------------------------------------------
void KNL_SwitchRes(uint8_t ubSwitchDir)
{
	if (ubSwitchDir != 0 && ubSwitchDir != 1) {
		printd(DBG_ErrorLvl, "invalid swtch dir:%d\n", ubSwitchDir);
		return;
	}

	if (ubSwitchDir == 0 && uwKNL_GetVdoH(ubKNL_GetRole()) == VGA_WIDTH) {
		printd(DBG_ErrorLvl, "RESO is VGA, no switch DOWN\n");
		return;
	}

#if (DT_DISPLAY_MODE == DT_DISPLAY_FHD)	
	if (ubSwitchDir == 1 && uwKNL_GetVdoH(ubKNL_GetRole()) == FHD_WIDTH) {
		printd(DBG_ErrorLvl, "RESO is FHD, no switch UP\n");
		return;
	}
#elif (DT_DISPLAY_MODE == DT_DISPLAY_HD)	
	if (ubSwitchDir == 1 && uwKNL_GetVdoH(ubKNL_GetRole()) == HD_WIDTH) {
		printd(DBG_ErrorLvl, "RESO is HD, no switch UP\n");
		return;
	}
#endif

	if (uwKNL_GetVdoH(ubKNL_GetRole()) == FHD_WIDTH)
		ubRES_SWITCH = 2;
	else if (uwKNL_GetVdoH(ubKNL_GetRole()) == HD_WIDTH)
		ubRES_SWITCH = 1;
	else
		ubRES_SWITCH = 0;

	if (ubSwitchDir == 1 && ubRES_SWITCH != 2)
		ubRES_SWITCH++;
	else if (ubSwitchDir == 0 && ubRES_SWITCH != 0)
		ubRES_SWITCH--;

  	ubRC_SetFlg(ENCODE_0, FALSE);
	KNL_SwitchDrvMdRes(sPRF_APDIRECT_MODE);
  	KNL_SetReEncIfrmFlag(TRUE);	
	if(ubRES_SWITCH == 0)
	  #if (APP_BLE_SN9380_FUNC_ENABLE	==1)		
		WiFiDt_Setup_Lite(VDO_FRC_FPS, QVGA_WIDTH, QVGA_HEIGHT, tKNL_Get_StreamType());
	  #else
   	    WiFiDt_Setup_Lite(VDO_FRC_FPS, VGA_WIDTH, VGA_HEIGHT, tKNL_Get_StreamType());
	  #endif
	else if(ubRES_SWITCH == 1)
		WiFiDt_Setup_Lite(VDO_FRC_FPS, HD_WIDTH, HD_HEIGHT, tKNL_Get_StreamType());
	else if(ubRES_SWITCH == 2)
		WiFiDt_Setup_Lite(VDO_FRC_FPS, FHD_WIDTH, FHD_HEIGHT, tKNL_Get_StreamType());

	ubRC_SetFlg(ENCODE_0, TRUE);
	#if (E_RVCS_ALL_I_FRM == 1)
	ubKNL_UpdVdoGopFlag = TRUE;
	#endif
}

void KNL_SetupRes(uint8_t ubReso)
{
#if (DT_DISPLAY_MODE == DT_DISPLAY_FHD)	
	if (ubReso == 2 && uwKNL_GetVdoH(ubKNL_GetRole()) == FHD_WIDTH) {
		printd(DBG_ErrorLvl, "RESO is already FHD\n");
		return;
	}
#elif (DT_DISPLAY_MODE == DT_DISPLAY_HD)	
	if (ubReso == 1 && uwKNL_GetVdoH(ubKNL_GetRole()) == HD_WIDTH) {
		printd(DBG_ErrorLvl, "RESO is already HD\n");
		return;
	}
#endif

#if (APP_BLE_SN9380_FUNC_ENABLE == 1)
	if (ubReso == 0 && uwKNL_GetVdoH(ubKNL_GetRole()) == QVGA_WIDTH) {
		printd(DBG_ErrorLvl, "RESO is already QVGA\n");
		return;
	}
#else
	if (ubReso == 0 && uwKNL_GetVdoH(ubKNL_GetRole()) == VGA_WIDTH) {
		printd(DBG_ErrorLvl, "RESO is already VGA\n");
		return;
	}
#endif

	ubRES_SWITCH = ubReso;

  	ubRC_SetFlg(ENCODE_0, FALSE);
	KNL_SwitchDrvMdRes(sPRF_APDIRECT_MODE);
  	KNL_SetReEncIfrmFlag(TRUE);	
	if(ubRES_SWITCH == 0)
	  #if (APP_BLE_SN9380_FUNC_ENABLE == 1)
		WiFiDt_Setup_Lite(VDO_FRC_FPS, QVGA_WIDTH, QVGA_HEIGHT, tKNL_Get_StreamType());
	  #else
  	    WiFiDt_Setup_Lite(VDO_FRC_FPS, VGA_WIDTH, VGA_HEIGHT, tKNL_Get_StreamType());
	  #endif
	else if(ubRES_SWITCH == 1)
		WiFiDt_Setup_Lite(VDO_FRC_FPS, HD_WIDTH, HD_HEIGHT, tKNL_Get_StreamType());
	else if(ubRES_SWITCH == 2)
		WiFiDt_Setup_Lite(VDO_FRC_FPS, FHD_WIDTH, FHD_HEIGHT, tKNL_Get_StreamType());

	ubRC_SetFlg(ENCODE_0, TRUE);
	#if (E_RVCS_ALL_I_FRM == 1)
	ubKNL_UpdVdoGopFlag = TRUE;
	#endif
}

#endif
#endif
//------------------------------------------------------------------------------
void KNL_sPRFTxVdoProcess(KNL_PROCESS tProc)
{
#ifdef OP_STA
	int iTxRet = FALSE;

	if(FALSE == ubKNL_ResetIFlg[tProc.ubSrcNum])
	{
		sPRF_DrvMode_t tDrvMd = sPRF_TRX_MODE;
		uint8_t ubRole = sPRF_AP;
		tDrvMd = tsPRF_GetDrvMode();
		if(BB_LINK == ubKNL_GetCommLinkStatus(KNL_MASTER_AP))
		{
			if(sPRF_APDIRECT_MODE != tDrvMd)
			{
				iTxRet = sPRF_Send(sPRF_AP, sPRF_VDO_PKT, (uint8_t *)tProc.ulDramAddr2, tProc.ulSize, ((!tProc.ulIdx)?TRUE:FALSE));
			}
			if((!tProc.ulIdx) && (KNL_CAPHQ_EN == tKNL_CapHQImgSte))
				tKNL_CapHQImgSte = KNL_CAPHQ_TXRDY;
		#ifdef RVCS_APP
			else if((sPRF_APDIRECT_MODE == tDrvMd) && (BB_LINK == ubKNL_GetRtCommLinkStatus(KNL_MASTER_AP)))
			{
				iTxRet = TRUE;
				// MJPEG frame
				if (tProc.ubEvent == 0xAA) 
					printd(DBG_Debug3Lvl, "Event:0x%x, MJPG Idx[0x%x] fsz[%d]\n", tProc.ubEvent, tProc.ulIdx, tProc.ulSize);

			#if (APP_BLE_SN9380_FUNC_ENABLE == 1) 
				if (UIcmd_GetConnSts() == 1 && UIcmd_GetVideoStartStatus() == 1/*&& (BB_LINK == ubKNL_GetRtCommLinkStatus(KNL_MASTER_AP))*/)
				{
					ubWiFiDt_BleUse_VideoBufRequest(tProc.ulDramAddr2, tProc.ulSize, tProc.ulIdx, KNL_TIMER_Get1ms(), 
						BLE_AT_CMD_TX_HDR_LEN+BLE_AT_CMD_TAIL_LEN, 					/* AT cmd header len */
						BLE_VIDEO_HDR_LEN,  										/* BLE video header len */
						BLE_VIDEO_LENGTH_LEN 										/* Padding len */);
				}else 
			#endif
				if(ubWiFiDt_TxMQReq(tProc.ulDramAddr2, tProc.ulSize, tProc.ulIdx, tProc.ubVdoGop, tProc.ubEvent, KNL_TIMER_Get1ms()) != 1)
				{
					printd(DBG_ErrorLvl, "1 No Wifi Buf\n");
					iTxRet = FALSE;
					osDelay(10);
				}
			}
			#if (APP_BLE_SN9380_FUNC_ENABLE == 1) 
			else {
				if (UIcmd_GetConnSts() == 1 && UIcmd_GetVideoStartStatus() == 1) {
					//UIcmd_video_stop();
					printd(DBG_ErrorLvl, "stts mode: %d, stop ble video\n", tDrvMd);
				}
				else
					printd(DBG_Debug3Lvl, "stts mode: %d, lnkSts:%d\n", tDrvMd, ubKNL_GetRtCommLinkStatus(KNL_MASTER_AP));
			}
			#endif
		#endif
		}
		else
		{
			if(sPRF_APDIRECT_MODE == tDrvMd)
				iTxRet = TRUE;
			else
				iTxRet = FALSE;
		}
		if((FALSE == iTxRet) && (ubKNL_ExistNode(tProc.ubSrcNum, KNL_NODE_H264_ENC)))
			KNL_SetReEncIfrmFlag(TRUE);
		else if(TRUE == iTxRet)
			osMessagePut(osKNL_sPrfFrmQue, &ubRole, 0);
	}
#if (APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
    if (tProc.ubEvent == 0xAA)
        return;
#endif
#endif
	ubKNL_ReleaseBsBufAddr(KNL_NODE_COMM_TX_VDO, tProc.ubSrcNum, tProc.ulDramAddr2);
}
//------------------------------------------------------------------------------
void KNL_sPRFTxAdoProcess(KNL_PROCESS tProc)
{
	uint8_t ubTemp;
	uint8_t ubNextNode;
	uint8_t ubLinkRole;
	uint8_t ubAdoRtyCnt = 0;
    KNL_SRC tKNL_AdoSrcNum;
	sPRF_DevId_t tKNL_sPRfRole[] = {
									[KNL_STA1] = sPRF_STA1,
									[KNL_STA2] = sPRF_STA2,
									[KNL_STA3] = sPRF_STA3,
									[KNL_STA4] = sPRF_STA4,
									[KNL_MASTER_AP] = sPRF_AP
								   };
#ifdef OP_STA
	ubLinkRole = KNL_MASTER_AP;
#else
	ubLinkRole = ubKNL_SrcNumMap(tProc.ubSrcNum);
	if(0xFF == ubLinkRole)
		goto SPRF_SEND_ADO_ERR;
#endif
    tKNL_AdoSrcNum = KNL_SRC_NONE;
    for(uint8_t ubSrcNum = KNL_SRC_1_OTHER_A; ubSrcNum <= KNL_SRC_4_OTHER_B; ubSrcNum++)
    {
        if(ubKNL_ExistNode(ubSrcNum, KNL_NODE_ADC_BUF))
        {
        #ifdef OP_STA
            if((ubSrcNum % 4) == ubKNL_GetRole())
            {
                tKNL_AdoSrcNum = (KNL_SRC)ubSrcNum;
                break;
            }
        #endif
        #ifdef OP_AP
            tKNL_AdoSrcNum = (KNL_SRC)ubSrcNum;
            break;
        #endif
        }
    }
	
	ubNextNode = (tProc.ubNextNode == KNL_NODE_MSC_ADO)?KNL_NODE_MSC_ADO:ubKNL_GetNextNode(tProc.ubSrcNum, KNL_NODE_ADC_BUF);
	if((ubNextNode == KNL_NODE_COMM_TX_ADO) || (ubNextNode == KNL_NODE_MSC_ADO))
	{
		if((BB_LOST_LINK == ubKNL_GetCommLinkStatus(ubLinkRole)) ||
		   (((ubLinkRole > KNL_STA4) && (ubLinkRole != KNL_MASTER_AP))))
			goto SPRF_SEND_ADO_ERR;
		if(!ubAdoRtyCnt)
		{
			switch(ubNextNode)
			{
				case KNL_NODE_COMM_TX_ADO:
					break;
				case KNL_NODE_MSC_ADO:
				{
					ADO_AUD32_ENC_INFO tAdo32EncInfo;
					ADO_ENC_PACK_INFO_t *AdoEncPackInfo;
					uint32_t ulEncAddr;
                    uint32_t ulAdcAddr = ulBUF_GetAdcFreeBuf();
					ADO_RETURN_FLAG EncStatusFlg;
					uint32_t ulEncTime;
					float fCpuUsage;
					
                    if(BUF_FAIL == ulAdcAddr)
                    goto SPRF_SEND_ADO_ERR;
					
                    tProc.ulDramAddr2 = ulAdcAddr;
					AdoEncPackInfo = (ADO_ENC_PACK_INFO_t*)tProc.ulDramAddr2;
					ulEncAddr = tProc.ulDramAddr2 + sizeof(ADO_ENC_PACK_INFO_t);
					
					memset((uint8_t*)AdoEncPackInfo, 0x0, sizeof(ADO_ENC_PACK_INFO_t));
					memcpy(AdoEncPackInfo->chADO_StreamTag, ADO_STREAM_TAG, sizeof(ADO_STREAM_TAG)-1);
					AdoEncPackInfo->ulStartupFlag = ubKNL_UsbdAdoEncStFlag;
					AdoEncPackInfo->ulTimestamp   = KNL_TIMER_Get1ms();
					if(TRUE == ubKNL_UsbdAdoEncStFlag)
						ubKNL_UsbdAdoEncStFlag = FALSE;

                    ulEncTime = KNL_TIMER_Get1ms();
                    
	#if (ADO_ENC_TYPE==AUDIO32_ENC)
					tAdo32EncInfo = ADO_Ado32_Encode(0, tProc.ulDramAddr1, ulEncAddr, tProc.ulSize);
                    EncStatusFlg = ADO_SUCCESS;
	#elif (ADO_ENC_TYPE==SW_AAC_ENC)
					{
					uint32_t ulEncSz;
                    EncStatusFlg = ADO_AAC_EncEncode(0, tProc.ulDramAddr1, tProc.ulSize, ulEncAddr, &ulEncSz);
					tAdo32EncInfo.ulOutputSize = ulEncSz;
					}
	#endif
                    
                    ulEncTime = KNL_TIMER_Get1ms() - ulEncTime;
                    fCpuUsage = (100*ulEncTime)/((1000*tProc.ulSize)/32000);
                    
                    printf("--->enc time=%d, cpu usage=%f\n",ulEncTime,fCpuUsage);
                    
                    if(!tAdo32EncInfo.ulOutputSize || EncStatusFlg!=ADO_SUCCESS)
                    {
                        printd(DBG_ErrorLvl, "KNL sPRFTxAdo ENC Fail @%s !\n", __func__);
                        goto SPRF_SEND_ADO_ERR;
                    }
					AdoEncPackInfo->ulEncodedSize = tAdo32EncInfo.ulOutputSize;
	#if (ADO_ENC_TYPE==AUDIO32_ENC)
					// set other info
					AdoEncPackInfo->EncType    = ADO32;
					AdoEncPackInfo->SampleRate = SAMPLERATE_16kHZ;
					AdoEncPackInfo->Channel    = MONO;
					AdoEncPackInfo->ubReserved = 0;
					tProc.ulSize = tAdo32EncInfo.ulOutputSize + sizeof(ADO_ENC_PACK_INFO_t);
					tProc.ulSize = ulKNL_AddAuxInfo(KNL_ADO_PKT, tKNL_AdoSrcNum, tProc.ulDramAddr2, tProc.ulSize, 0, 0, 0, KNL_TIMER_Get1ms());
	#elif (ADO_ENC_TYPE==SW_AAC_ENC)
                    // set other info
					AdoEncPackInfo->EncType    = AAC;
					AdoEncPackInfo->SampleRate = tKNL_AdoInfo.AdcFmt.sample_rate; 
					AdoEncPackInfo->Channel    = tKNL_AdoInfo.AdcFmt.channel;
					AdoEncPackInfo->ubReserved = 0;
					tProc.ulSize = tAdo32EncInfo.ulOutputSize + sizeof(ADO_ENC_PACK_INFO_t);
                    tProc.ulSize = ulKNL_AddAuxInfo(KNL_ADO_PKT, tKNL_AdoSrcNum, tProc.ulDramAddr2, tProc.ulSize, 0, 0, 0, KNL_TIMER_Get1ms());                   
	#endif
					ubBUF_ReleaseAdoUsbdBuf(tProc.ulDramAddr1);
					break;
				}
				default:
					goto SPRF_SEND_ADO_ERR;
			}
		}
		if(sPRF_APDIRECT_MODE != tKNL_sPRFDrvMd)
		{
			sPRF_Send(tKNL_sPRfRole[ubLinkRole], sPRF_ADO_PKT, (uint8_t *)tProc.ulDramAddr2, tProc.ulSize, FALSE);
			ubTemp = ubBUF_ReleaseAdcBuf(tProc.ulDramAddr2);
			if(ubTemp == BUF_OK)
				printd(DBG_Debug3Lvl, "Release BUF_ADC Ok\r\n");
			else
				printd(DBG_ErrorLvl, "Release BUF_ADC Fail\r\n");
		}
	#if (defined(OP_STA) && defined(RVCS_APP))
		else
			WiFiDt_SendAdoData(KNL_STA1, (uint8_t *)tProc.ulDramAddr2+sizeof(ADO_ENC_PACK_INFO_t), (tProc.ulSize-sizeof(ADO_ENC_PACK_INFO_t)), KNL_TIMER_Get1ms());
	#endif
		return;
	}
SPRF_SEND_ADO_ERR:
	if(ubNextNode == KNL_NODE_MSC_ADO)
		ubBUF_ReleaseAdoUsbdBuf(tProc.ulDramAddr1);
	if((tProc.ulDramAddr2) && (sPRF_APDIRECT_MODE != tKNL_sPRFDrvMd))
		ubBUF_ReleaseAdcBuf(tProc.ulDramAddr2);
}
//------------------------------------------------------------------------------
uint32_t ulKNL_GetSPRFRxBufAddr(sPRF_DevId_t tDevId, sPRF_PktType_t tPacketType, uint8_t ubBufType)
{
	uint32_t ulDataAddr = 0;

	switch(tPacketType)
	{
		case sPRF_VDO_PKT:
		{
			KNL_SRC tVdoSrcNum[] = {[sPRF_STA1] = KNL_SRC_1_MAIN, [sPRF_STA2] = KNL_SRC_2_MAIN,
								    [sPRF_STA3] = KNL_SRC_3_MAIN, [sPRF_STA4] = KNL_SRC_4_MAIN};
			if(tDevId > sPRF_STA4)
				break;
			if(ubBufType)
				ulKNL_CurFrmIdx[tDevId] = 0;
			else
				ulKNL_CurFrmIdx[tDevId] = 1;
#if (defined(OP_AP) && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
            if(tKNL_RecordAct.tSimFolder == KNL_SIM_FLD && tKNL_GetRecordFunc() == KNL_VIDEO_PLAY)
               ulDataAddr = ulKNL_GetBsBufAddr(KNL_SRC_1_MAIN);
            else
#endif				
			ulDataAddr = ulKNL_GetBsBufAddr(tVdoSrcNum[tDevId]);
			if(BUF_FAIL == ulDataAddr)
				ulDataAddr = 0;
			break;
		}
		case sPRF_ADO_PKT:
		{
			static uint32_t (*pSPrfGetAdoDac_Buf[])(void) = {[0] = ulBUF_GetDac0FreeBuf, [1] = ulBUF_GetDac1FreeBuf,
															 [2] = ulBUF_GetDac2FreeBuf, [3] = ulBUF_GetDac3FreeBuf};
			uint8_t ubStaNum = 0;

			if((tDevId > sPRF_STA4) && (tDevId != sPRF_AP))
				break;
			if(sPRF_AP == tDevId)
			{
				KNL_SRC tAdoSrcNum;
				if(ptKNL_AdoRoleMap2SrcNum)
					tAdoSrcNum = ptKNL_AdoRoleMap2SrcNum(KNL_SUB_PATH, (KNL_ROLE)ubKNL_GetRole());
				else
					tAdoSrcNum = (KNL_SRC)(KNL_SRC_1_OTHER_B + (KNL_ROLE)ubKNL_GetRole());
				ubStaNum = ubKNL_SrcNumMap(tAdoSrcNum);
			}
			else
			{
				KNL_SRC tAdoSrcNum[] = {[sPRF_STA1] = KNL_SRC_1_OTHER_A, [sPRF_STA2] = KNL_SRC_2_OTHER_A,
										[sPRF_STA3] = KNL_SRC_3_OTHER_A, [sPRF_STA4] = KNL_SRC_4_OTHER_A};
				ubStaNum = ubKNL_SrcNumMap(tAdoSrcNum[tDevId]);
			}
			if(0xFF == ubStaNum)
				break;
			ulDataAddr = pSPrfGetAdoDac_Buf[ubStaNum]();
			if(BUF_FAIL == ulDataAddr)
				ulDataAddr = 0;
			break;
		}
		default:
			break;
	}
	return ulDataAddr;
}
//------------------------------------------------------------------------------
uint32_t ulKNL_GetBsOvfBufAddr(uint8_t ubSrcNum)
{
	BUF_MODE tBsBufMode[] = {
								[KNL_SRC_1_MAIN] = BUF_VDO_MAIN_BS0,
								[KNL_SRC_2_MAIN] = BUF_VDO_MAIN_BS1,
								[KNL_SRC_3_MAIN] = BUF_VDO_MAIN_BS2,
								[KNL_SRC_4_MAIN] = BUF_VDO_MAIN_BS3,
							};
	uint32_t ulBsAddr = 0;
	uint8_t ubStaNum = 0;

	if(ubSrcNum > KNL_SRC_4_MAIN)
		return 0;
	ubStaNum = ubKNL_SrcNumMap(ubSrcNum);
	if(0xFF == ubStaNum)
		return 0;
	if(FALSE == ubBUF_ChkVdoMainBsBufIdx(tBsBufMode[ubSrcNum], FALSE))
	{
#if 0
		ulBsAddr = ulKNL_GetBsBufAddr(ubSrcNum);
		if(BUF_FAIL == ulBsAddr)
			ulBsAddr = 0;
#endif
	}
	return ulBsAddr;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_ReleaseBsOvfBuf(uint8_t ubSrcNum)
{
	uint8_t ubStaNum = 0;
	uint8_t ubRet = BUF_OK;
	uint8_t (*pSPrfRelsBsBuf[])(uint32_t) = {[0] = ubBUF_ReleaseVdoMainBs0Buf, [1] = ubBUF_ReleaseVdoMainBs1Buf,
											 [2] = ubBUF_ReleaseVdoMainBs2Buf, [3] = ubBUF_ReleaseVdoMainBs3Buf};

	if(ubSrcNum > KNL_SRC_4_MAIN)
		return ubRet;
	ubStaNum = ubKNL_SrcNumMap(ubSrcNum);
	if(0xFF == ubStaNum)
		return ubRet;
	if(tKNL_VdoBsOvfInfo.ulBsOvfAddr[ubStaNum])
	{
		ubRet = pSPrfRelsBsBuf[ubStaNum](tKNL_VdoBsOvfInfo.ulBsOvfAddr[ubStaNum]);
		tKNL_VdoBsOvfInfo.ulBsOvfAddr[ubStaNum] = 0;
		if(BUF_OK == ubRet)
			printd(DBG_CriticalLvl, "\r\n	[%d]OVF OK\r\n", ubStaNum);
	}
	return ubRet;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_ReleaseSPRFRxBufAddr(KNL_PACKET_TYPE tPktType, uint8_t ubStaNum, uint32_t ulBufAddr)
{
	uint8_t ubRet = BUF_FAIL;
	KNL_ROLE tRcvSta[] = {
							[BB_GET_STA1] = KNL_STA1,
							[BB_GET_STA2] = KNL_STA2,
							[BB_GET_STA3] = KNL_STA3,
							[BB_GET_STA4] = KNL_STA4,
							[BB_GET_AP]   = KNL_MASTER_AP,
						 };
	if(KNL_ADO_PKT == tPktType)
	{
		static uint8_t (*pSPrfRseAdoDac_Buf[])(uint32_t) = {[0] = ubBUF_ReleaseDac0Buf, [1] = ubBUF_ReleaseDac1Buf,
														    [2] = ubBUF_ReleaseDac2Buf, [3] = ubBUF_ReleaseDac3Buf};
		if(BB_GET_AP == ubStaNum)
		{
			KNL_SRC tAdoSrcNum;
			if(ptKNL_AdoRoleMap2SrcNum)
				tAdoSrcNum = ptKNL_AdoRoleMap2SrcNum(KNL_SUB_PATH, (KNL_ROLE)ubKNL_GetRole());
			else
				tAdoSrcNum = (KNL_SRC)(KNL_SRC_1_OTHER_B + (KNL_ROLE)ubKNL_GetRole());
			ubStaNum = ubKNL_SrcNumMap(tAdoSrcNum);			
		}
		else
		{
			KNL_SRC tAdoSrcNum[] = {[KNL_STA1] = KNL_SRC_1_OTHER_A, [KNL_STA2] = KNL_SRC_2_OTHER_A,
									[KNL_STA3] = KNL_SRC_3_OTHER_A, [KNL_STA4] = KNL_SRC_4_OTHER_A};
			if(ubStaNum > BB_GET_STA4)
				return ubRet;
			ubStaNum = ubKNL_SrcNumMap(tAdoSrcNum[tRcvSta[ubStaNum]]);
		}
		if(0xFF == ubStaNum)
			return ubRet;
		ubRet = pSPrfRseAdoDac_Buf[ubStaNum](ulBufAddr);
	}
	return ubRet;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_GetSPRFDataBufNum(sPRF_DevId_t tDevId)
{
	uint8_t ubFreeBufNum = 0;

	KNL_SRC tSrcNum;
	KNL_ROLE tRole[] = {
							[sPRF_STA1] = KNL_STA1,
							[sPRF_STA2] = KNL_STA2,
							[sPRF_STA3] = KNL_STA3,
							[sPRF_STA4] = KNL_STA4,
					   };
	BUF_MODE tBufMd[] = {
							[KNL_SRC_1_MAIN] = BUF_VDO_MAIN_BS0,
							[KNL_SRC_2_MAIN] = BUF_VDO_MAIN_BS1,
							[KNL_SRC_3_MAIN] = BUF_VDO_MAIN_BS2,
							[KNL_SRC_4_MAIN] = BUF_VDO_MAIN_BS3,
						};

	if(tDevId > sPRF_STA4)
		return 0;
	if(ptKNL_VdoRoleMap2SrcNum)
		tSrcNum = ptKNL_VdoRoleMap2SrcNum(KNL_MAIN_PATH, (KNL_ROLE)tRole[tDevId]);
	else
		tSrcNum = (KNL_SRC)(KNL_SRC_1_MAIN + (KNL_ROLE)tRole[tDevId]);
	if((tSrcNum ==  KNL_SRC_1_MAIN) || (tSrcNum <= KNL_SRC_4_MAIN))
	{
		osSemaphoreWait(tKNL_BsBufCtrlSem, osWaitForever);
		ubFreeBufNum = ubBUF_GetVdoMainBsFreeBufNum(tBufMd[tSrcNum]);
		osSemaphoreRelease(tKNL_BsBufCtrlSem);
	}
	return ubFreeBufNum;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_sPRFRxProcess(sPRF_RxRpt_t tSPRF_RxRpt)
{
	GET_STA tRcvSta[] = {
							[sPRF_STA1] = BB_GET_STA1,
							[sPRF_STA2] = BB_GET_STA2,
							[sPRF_STA3] = BB_GET_STA3,
							[sPRF_STA4] = BB_GET_STA4,
							[sPRF_AP]   = BB_GET_AP
						};
	RX_DON tRxdata;
	uint8_t ubRet = TRUE;
	osMessageQId osRxPktQId = NULL;

	if((tSPRF_RxRpt.tRptId > sPRF_STA4) && (tSPRF_RxRpt.tRptId != sPRF_AP))
		return ubRet;
	tRxdata.tSTA   = tRcvSta[tSPRF_RxRpt.tRptId];
	tRxdata.ulAddr = tSPRF_RxRpt.ulDataAddr;
	tRxdata.ulSize = tSPRF_RxRpt.ulDataSize;
	if(sPRF_VDO_PKT == tSPRF_RxRpt.tPacketType)
	{
		if(tRxdata.ulSize > tKNL_VdoBsOvfInfo.ulBsBufSize)
		{
			KNL_SRC tVdoSrcNum[] = {[sPRF_STA1] = KNL_SRC_1_MAIN, [sPRF_STA2] = KNL_SRC_2_MAIN,
									[sPRF_STA3] = KNL_SRC_3_MAIN, [sPRF_STA4] = KNL_SRC_4_MAIN};
			tKNL_VdoBsOvfInfo.ulBsOvfAddr[tSPRF_RxRpt.tRptId] = ulKNL_GetBsOvfBufAddr(tVdoSrcNum[tSPRF_RxRpt.tRptId]);
			printd(DBG_CriticalLvl, "\r\n	[%d]OVF:%d > %d -> %d\r\n", tSPRF_RxRpt.tRptId, tRxdata.ulSize, tKNL_VdoBsOvfInfo.ulBsBufSize, ulKNL_CurFrmIdx[tSPRF_RxRpt.tRptId]);
		}
		osRxPktQId = KNL_QueRxVdo;
	}
	else if(sPRF_ADO_PKT == tSPRF_RxRpt.tPacketType)
		osRxPktQId = KNL_QueRxAdo;
	if(NULL != osRxPktQId)
		osMessagePut(osRxPktQId, &tRxdata, 0);
	return ubRet;
}
//------------------------------------------------------------------------------
void KNL_StopSPRFTxProcess(uint8_t ubClrBuf)
{
	KNL_ROLE tKNL_Role;
#if (defined(OP_STA) || defined(OP_AP) && (defined(BSP_DVR_SDK)))
	SEN_SetIspOutEn(FALSE);
	SEN_SetDetectVideoState(0);
#endif
	if(TRUE == ubClrBuf)
		sPRF_BufferReset();
	KNL_ResetVdoProc();
	osMessageReset(KNL_CommTxProcQueue);
	for(tKNL_Role = KNL_STA1; tKNL_Role <= KNL_STA4; tKNL_Role++)
	{
		BUF_Reset((BUF_VDO_MAIN_BS0 + tKNL_Role));
		tKNL_VdoBsOvfInfo.ulBsOvfAddr[tKNL_Role] = 0;
	}
#if (defined(OP_STA) || defined(OP_AP) && (defined(BSP_DVR_SDK)))
	SEN_SetIspOutEn(TRUE);
	SEN_SetDetectVideoState(1);
#endif
}
//------------------------------------------------------------------------------
void KNL_ResetVdoGop(sPRF_DevId_t tDevId, uint32_t ulGop)
{
	KNL_NODE_INFO tNodeInfo;
	KNL_SRC tSrcNum[] = {
							[sPRF_STA1] = KNL_SRC_1_MAIN,
							[sPRF_STA2] = KNL_SRC_2_MAIN,
							[sPRF_STA3] = KNL_SRC_3_MAIN,
							[sPRF_STA4] = KNL_SRC_4_MAIN,
						};
	uint32_t ulCurGop = 0;

	if(tDevId > sPRF_STA4)
		return;
	ulCurGop = ulKNL_GetVdoGop();
	KNL_SetVdoGop(ulGop);
	if(ubKNL_ExistNode(tSrcNum[tDevId], KNL_NODE_H264_ENC))
	{
		tNodeInfo = tKNL_GetNodeInfo(tSrcNum[tDevId], KNL_NODE_H264_ENC);
		H264_SetGOP((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx, ulGop);
		printd(DBG_CriticalLvl, "GOP:%d->%d\n", ulCurGop, ulGop);
	}
}
//------------------------------------------------------------------------------
void KNL_SetDrvMode(sPRF_DrvMode_t tDrvMd)
{
#if (defined(OP_AP) && defined(RVCS_APP))
	if(tDrvMd != tsPRF_GetDrvMode())
	{
		sPRF_SetDrvMode(tDrvMd);
		printd(DBG_CriticalLvl, "\n  Drv Chg to %s\n", (sPRF_TRX_MODE == tDrvMd)?"pWiFi":"WiFiDt");
	}
#endif
}
//------------------------------------------------------------------------------
#if (defined(OP_STA) && defined(RVCS_APP))
void KNL_ChkDrvMdRes(sPRF_DrvMode_t tDrvMode)
{
	static uint16_t uwKNL_TrxMdResH = HD_WIDTH, uwKNL_TrxMdResV = HD_HEIGHT;
	KNL_ROLE tRoleNum = KNL_STA1;
	KNL_SRC tSrcNum;
	uint16_t uwTargH = 0, uwTargV = 0;
	uint16_t uwCurH = 0, uwCurV = 0;
	uint8_t ubResData[8] ={0};

	tRoleNum = (KNL_ROLE)ubKNL_GetRole();
	if(ptKNL_VdoRoleMap2SrcNum)
		tSrcNum = ptKNL_VdoRoleMap2SrcNum(KNL_MAIN_PATH, tRoleNum);
	else
		tSrcNum = (KNL_SRC)(KNL_SRC_1_MAIN + tRoleNum);
	uwCurH = uwKNL_GetVdoH(tSrcNum);
	uwCurV = uwKNL_GetVdoV(tSrcNum);
	switch(tDrvMode)
	{
		case sPRF_APDIRECT_MODE:
			uwKNL_TrxMdResH = uwCurH;
			uwKNL_TrxMdResV = uwCurV;
			uwTargH = VDO_DT_H_SIZE;
			uwTargV = VDO_DT_V_SIZE;
			if((uwCurH != uwTargH) || (uwCurV != uwTargV))
				break;
			return;
		case sPRF_TRX_MODE:
			uwTargH = uwKNL_TrxMdResH;
			uwTargV = uwKNL_TrxMdResV;
			if((uwCurH != uwTargH) || (uwCurV != uwTargV))
				break;
			return;
		default:
			return;
	}
	ubResData[0] = (uwTargH & 0xFF00) >> 8;
	ubResData[1] = (uwTargH & 0xFF);
	ubResData[2] = (uwTargV & 0xFF00) >> 8;
	ubResData[3] = (uwTargV & 0xFF);
	ubResData[4] = tSrcNum;
	KNL_VdoResSetting((TWC_TAG)tRoleNum, ubResData);
}
#endif //! End of #if (defined(OP_STA) && defined(RVCS_APP))
//------------------------------------------------------------------------------
void KNL_DrvMdSwSetup(void)
{
#ifdef RVCS_APP
	sPRF_DrvMode_t tDrvMd = sPRF_TRX_MODE;

	tDrvMd = tsPRF_GetDrvMode();
	if(tKNL_sPRFDrvMd != tDrvMd)
	{
		switch(tDrvMd)
		{
		#ifdef OP_STA
			case sPRF_TRX_MODE:
				ubRC_SetFlg(ENCODE_0, FALSE);
				ubKNL_StbLinkStsRrefFlag = TRUE;
				KNL_sPRFLinkReportFunc(sPRF_AP, sPRF_LOST_LINK);
				WiFiDt_Close();
				WiFiDt_AppUninit();
				break;
			case sPRF_APDIRECT_MODE:
				ubRC_SetFlg(ENCODE_0, FALSE);
				ubKNL_StbLinkStsRrefFlag = TRUE;
				KNL_sPRFLinkReportFunc(sPRF_AP, sPRF_LOST_LINK);
				break;
		#endif
			default:
				break;
		}
	}
#endif	//! End of #ifdef RVCS_APP
}
#endif	//! End of #ifdef S2019A
//------------------------------------------------------------------------------
#if (defined(S2019A) || (defined(OP_AP) && defined(sWIFIBDG)))
void KNL_sPRFLinkReportFunc(sPRF_DevId_t tDevId, sPRF_LinkSts_t tLinkSts)
{
#ifdef S2019A
	LINK_REPORT tLinkRptQ;
	LINK_ROLE tLinkRole[] = {
								[sPRF_STA1] = BB_STA1,
								[sPRF_STA2] = BB_STA2,
								[sPRF_STA3] = BB_STA3,
								[sPRF_STA4] = BB_STA4,
								[sPRF_AP]   = BB_MASTER_AP
							};

	if((tDevId > sPRF_STA4) && (tDevId != sPRF_AP))
		return;
	tLinkRptQ.tRole   = tLinkRole[tDevId];
	tLinkRptQ.tStatus = (tLinkSts == sPRF_LINK)?BB_LINK:BB_LOST_LINK;
	osMessagePut(KNL_LinkQ, &tLinkRptQ, 0);
#endif
#if (defined(OP_AP) && (defined(RVCS_APP) || defined(sWIFIBDG)))
	if((sPRF_BRIDGE_MODE == tKNL_sPRFDrvMd) && (sPRF_AP == tDevId) && (sPRF_LINK == tLinkSts))
	#if (defined(S2019A) || defined(A7130))
		ubKNL_LinkStatus[5] = BB_LINK;
	#else
		ubKNL_RtLinkStatus[5] = BB_LINK;
	#endif
#endif
}
//------------------------------------------------------------------------------
#if (defined(RVCS_APP) || (defined(OP_AP) && defined(sWIFIBDG)))
uint32_t tKNL_Get_StreamType(void)
{
	#if (E_RVCS_ALL_I_FRM == 1)
		return E_STREAM_MODE_ALL_I;
	#else
		return E_STREAM_MODE_I_P;
	#endif
}
#endif
//------------------------------------------------------------------------------
void KNL_EnStaDtDrvMode(void)
{
#if (defined(RVCS_APP) || (defined(OP_AP) && defined(sWIFIBDG)))
	WiFiDt_SetupStaEth();
	WiFiDt_SetupDevInfo();
	WiFiDt_EnStaEth();
#endif
}
//------------------------------------------------------------------------------
#if (defined(OP_AP) && (defined(RVCS_APP) || defined(sWIFIBDG)))
static void KNL_ApBdgThread(void const *argument)
{
	KNL_ApBdgQue_t tKNL_ApBdgQue;
	uint8_t ubKNL_BdgRet = 1;
	while(1)
	{
		osMessageGet(osKNL_ApBdgQue, &tKNL_ApBdgQue, osWaitForever);
		ubKNL_BdgRet = ubWiFiDt_TxMQReq(tKNL_ApBdgQue.ulBsAddr, tKNL_ApBdgQue.ulBsSize, tKNL_ApBdgQue.ulFrmIdx, tKNL_ApBdgQue.ubVdoGop, 0, KNL_TIMER_Get1ms());
		if((2 == ubKNL_BdgRet) || (3 == ubKNL_BdgRet))	//! if((ubKNL_BdgRet != 1) && (ubKNL_BdgRet != 0x66))
		{
			if(TRUE == tKNL_ApBdgInfo.ubIfrmFlag)
			{
				printd(DBG_ErrorLvl, "\n  BDG:%d\n", ubKNL_BdgRet);
				tKNL_ApBdgInfo.ubErrFlag = TRUE;
				if(osKNL_ApBdgQue)
					osMessageReset(osKNL_ApBdgQue);
				BUF_Reset(BUF_WIFI_BDG);
				continue;
			}
		}
		ubBUF_ReleaseVdoBdgBsBuf(tKNL_ApBdgQue.ulBsAddr);
	}
}
//------------------------------------------------------------------------------
void KNL_StopApBdgeProc(void)
{
	WiFiDt_StopSend();
	if(osKNL_ApBdgQue)
		osMessageReset(osKNL_ApBdgQue);
	BUF_Reset(BUF_WIFI_BDG);
	BUF_Reset(BUF_ADO_ADC);
	tKNL_ApBdgInfo.ubIfrmFlag = FALSE;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_ApBdgRxSendLostLinkImg(void)
{
	uint32_t ulBdgBsAddr = 0, ulBdgBsSize = 0;
	KNL_FRAME_TYPE tFrmType;
	KNL_ApBdgQue_t tApBdgQue;
	uint32_t ulFrmIdx = 0;
	uint8_t  ubVdoGop = 100;
	uint8_t ubBdgRxRet = FALSE;

	if((sPRF_BRIDGE_MODE != tKNL_sPRFDrvMd) || (BB_LINK != ubKNL_GetRtCommLinkStatus(KNL_MASTER_AP)))
	{
		printd(DBG_Debug3Lvl, "ApBdg send lost link: not link\n");
		return TRUE;
	}

	ulBdgBsAddr = ulBUF_GetVdoBdgBsFreeBuf();
	if(BUF_FAIL == ulBdgBsAddr)
	{
		printd(DBG_ErrorLvl, "%s	BDG BUF Busy\n", __FUNCTION__);
		return FALSE;
	}

	ulBdgBsSize = OSD_LostLinkAppImg(ulBdgBsAddr);
	tFrmType = tKNL_GetFrameType(ulBdgBsAddr);
	if (tFrmType != KNL_I_FRAME || ulBdgBsSize == 0)
	{
		printd(DBG_ErrorLvl, "Invalid lost link image:%s sz:%d\n", (tFrmType != KNL_I_FRAME)?" Not I frame,":"", ulBdgBsSize);
		return FALSE;
	}
	else
	{
		printd(DBG_Debug3Lvl, "ulBdgBs: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x, sz:%d\n", 
			*(uint8_t *)(ulBdgBsAddr+0), *(uint8_t *)(ulBdgBsAddr+1), *(uint8_t *)(ulBdgBsAddr+2), *(uint8_t *)(ulBdgBsAddr+3),
			*(uint8_t *)(ulBdgBsAddr+4), *(uint8_t *)(ulBdgBsAddr+5), *(uint8_t *)(ulBdgBsAddr+6), *(uint8_t *)(ulBdgBsAddr+7),
			ulBdgBsSize);
	}

	if((KNL_I_FRAME == tFrmType) && (FALSE == tKNL_ApBdgInfo.ubIfrmFlag))
	{
		tKNL_ApBdgInfo.ubIfrmFlag	= TRUE;
		tKNL_ApBdgInfo.ubResChgFlag = FALSE;
	}

	if(!ubWiFiDt_QueryAppConnectStatus())
	{
		if(osKNL_ApBdgQue)
			osMessageReset(osKNL_ApBdgQue);
		BUF_Reset(BUF_WIFI_BDG);
		return TRUE;
	}
	if(TRUE == tKNL_ApBdgInfo.ubErrFlag)
	{
		tKNL_ApBdgInfo.ubErrFlag  = FALSE;
		tKNL_ApBdgInfo.ubIfrmFlag = FALSE;
		return ubBdgRxRet;
	}
	
	if(ulBdgBsSize > tKNL_VdoBsOvfInfo.ulBsBufSize)
		ubBUF_ChkVdoBdgBsBufIdx();


	ubBdgRxRet = TRUE;
	ulFrmIdx   = 0;
	tApBdgQue.ulBsAddr = ulBdgBsAddr;
	tApBdgQue.ulBsSize = ulBdgBsSize;
	tApBdgQue.ulFrmIdx = ulFrmIdx;
	tApBdgQue.ubVdoGop = ubVdoGop;
	osMessagePut(osKNL_ApBdgQue, &tApBdgQue, 0);

	return TRUE;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_ApBdgRxProc(sPRF_PktType_t tPacketType, KNL_SRC tBdgSrc, uint32_t ulDataAddr, uint32_t ulDataSize)
{
	static uint8_t ubKNL_ApBdgLowBufFlag = FALSE;
	static uint8_t ubKNL_ApBdgNoBufFlag = FALSE;
	static uint8_t ubKNL_ApBdgNoBufCnt = 0;
	static uint8_t ubKNL_RstVdoGrpCnt = 0;
	uint32_t ulBdgBsAddr = 0, ulBdgBsSize = 0;
	uint8_t ubBdgRxRet = FALSE, ubBsBufNum = 0;
	DMAC_RESULT tDmaResult = DMAC_OK;
	KNL_FRAME_TYPE tFrmType;

	if((sPRF_BRIDGE_MODE != tKNL_sPRFDrvMd) || (BB_LINK != ubKNL_GetRtCommLinkStatus(KNL_MASTER_AP)))
		return TRUE;
	switch(tPacketType)
	{
		case sPRF_VDO_PKT:
			if(tKNL_ApBdgInfo.tBgdSrcNum != tBdgSrc)
				return TRUE;
			if(!ubWiFiDt_QueryAppConnectStatus())
			{
				if(osKNL_ApBdgQue)
					osMessageReset(osKNL_ApBdgQue);
				BUF_Reset(BUF_WIFI_BDG);
				return TRUE;
			}
			if(TRUE == tKNL_ApBdgInfo.ubErrFlag)
			{
				tKNL_ApBdgInfo.ubErrFlag  = FALSE;
				tKNL_ApBdgInfo.ubIfrmFlag = FALSE;
				ubKNL_ApBdgNoBufFlag      = FALSE;
				ubKNL_ApBdgLowBufFlag     = FALSE;
				ubKNL_RstVdoGrpCnt        = 0;
				return ubBdgRxRet;
			}
			ulBdgBsAddr = ulBUF_GetVdoBdgBsFreeBuf();
			if(BUF_FAIL == ulBdgBsAddr)
			{
				if(FALSE == ubKNL_ApBdgNoBufFlag)
				{
					ubKNL_ApBdgNoBufFlag 	  = TRUE;
					tKNL_ApBdgInfo.ubIfrmFlag = FALSE;
					printd(DBG_ErrorLvl, "  BDG BUF Busy\n");
				}
				else if(++ubKNL_ApBdgNoBufCnt >= 6)
				{
					WiFiDt_StopSend();
					ubKNL_ApBdgNoBufCnt = 0;
				}
				return TRUE;
			}
			ubKNL_ApBdgNoBufCnt = 0;
			tFrmType = tKNL_GetFrameType(ulDataAddr);
			if(TRUE == ubKNL_ApBdgNoBufFlag)
			{
				ubBsBufNum = ubBUF_GetVdoBdgBsFreeBufNum();
				if(ubBsBufNum <= 5)
				{
					ubBUF_ReleaseVdoBdgBsBuf(ulBdgBsAddr);
					return TRUE;
				}
				if(KNL_I_FRAME != tFrmType)
				{
					ubBdgRxRet = TRUE;
					if(!(ubKNL_RstVdoGrpCnt++ % 15))
					{
						ubBdgRxRet 			= FALSE;
						ubKNL_RstVdoGrpFlag = TRUE;
						ubKNL_RstVdoGrpCnt  = 1;
					}
					ubBUF_ReleaseVdoBdgBsBuf(ulBdgBsAddr);
					return ubBdgRxRet;
				}
				else
				{
					ubKNL_ApBdgNoBufFlag = FALSE;
					ubKNL_RstVdoGrpFlag  = FALSE;
					ubKNL_RstVdoGrpCnt   = 0;
					printd(DBG_CriticalLvl, "\n  BDG BUF[%d]->I\n", ubBsBufNum);
				}
			}
			if((KNL_I_FRAME != tFrmType) && (FALSE == tKNL_ApBdgInfo.ubIfrmFlag))
			{
				ubBUF_ReleaseVdoBdgBsBuf(ulBdgBsAddr);
				return ubBdgRxRet;
			}
			if((KNL_I_FRAME == tFrmType) && (FALSE == tKNL_ApBdgInfo.ubIfrmFlag))
			{
				tKNL_ApBdgInfo.ubIfrmFlag   = TRUE;
				tKNL_ApBdgInfo.ubResChgFlag = FALSE;
			}
			ulBdgBsSize = ulKNL_GetFrameSz(ulDataAddr, ulDataSize);
			if(ulBdgBsSize > tKNL_VdoBsOvfInfo.ulBsBufSize)
				ubBUF_ChkVdoBdgBsBufIdx();
			tDmaResult = tDMAC_MemCopy(ulDataAddr, ulBdgBsAddr, ulBdgBsSize, NULL);
			if(DMAC_OK == tDmaResult)
			{
				KNL_ApBdgQue_t tApBdgQue;
				uint32_t ulFrmIdx = 0;
				uint8_t  ubVdoGop = 0;
				uint8_t ubLowBufThd = BUF_NUM_BDG_VDO_BS * 0.4;
				ubBsBufNum = ubBUF_GetVdoBdgBsFreeBufNum();
				ubBdgRxRet = TRUE;
				ubVdoGop   = ubKNL_GetPktVdoGop(ulDataAddr, ulDataSize);
				ulFrmIdx   = ulKNL_GetPktFrmIdx(ulDataAddr, ulDataSize);
				tApBdgQue.ulBsAddr = ulBdgBsAddr;
				tApBdgQue.ulBsSize = ulBdgBsSize;
				tApBdgQue.ulFrmIdx = ulFrmIdx;
				tApBdgQue.ubVdoGop = ubVdoGop;
				osMessagePut(osKNL_ApBdgQue, &tApBdgQue, 0);
				if((FALSE == ubKNL_ApBdgLowBufFlag) && (FALSE == ubBdgRxRet))
				{
					ubKNL_ApBdgLowBufFlag = TRUE;
					ubKNL_RstVdoGrpFlag	  = TRUE;
					printd(DBG_CriticalLvl, "\n  Low BUF[%d] Detect\n", ubLowBufThd);
				}
				else if((ubBsBufNum >= (ubLowBufThd + 6)) && (TRUE == ubKNL_ApBdgLowBufFlag))
				{
					ubKNL_ApBdgLowBufFlag = FALSE;
					printd(DBG_CriticalLvl, "\n  BUF[%d] Recovery\n", (ubLowBufThd + 6));
				}
			}
			else
			{
				ubBUF_ReleaseVdoBdgBsBuf(ulBdgBsAddr);
				ubBdgRxRet = FALSE;
			}
			break;
		case sPRF_ADO_PKT:
		{
			uint32_t ulAdoSz = 0, ulTime = 0;
			ulAdoSz = ulKNL_GetAdoPktSZ(ulDataAddr, ulDataSize);
			ulTime  = ulKNL_GetTimeStamp1(ulDataAddr, ulDataSize);
			WiFiDt_SendAdoData(KNL_STA1, (uint8_t *)ulDataAddr+sizeof(ADO_ENC_PACK_INFO_t), (ulAdoSz-sizeof(ADO_ENC_PACK_INFO_t)), ulTime);
			break;
		}
		default:
			break;
	}
	return ubBdgRxRet;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_ApBdgTxProc(sPRF_PktType_t tPacketType, uint8_t *pData, uint32_t ulDataSize)
{
	uint8_t ubBdgTxRet = 0;
	switch(tPacketType)
	{
		case sPRF_ADO_PKT:
		{
			KNL_PROCESS tProc;
			KNL_ROLE tBdgRole;
			KNL_SRC tAdoSrcNum = KNL_SRC_NONE;
			DMAC_RESULT tDmaResult = DMAC_OK;
			ADO_ENC_PACK_INFO_t *pAdoEncInfo;
			uint32_t ulAdcBufAddr = 0, ulAdoPktSize = 0;

			if(KNL_SRC_NONE == tKNL_ApBdgInfo.tBgdSrcNum)
				break;
			tBdgRole    = VDO_KNLSrcNumMap2KNLRoleNum(tKNL_ApBdgInfo.tBgdSrcNum);
			tAdoSrcNum  = ADO_GetSourceNumber(KNL_SUB_PATH, tBdgRole);
			ulAdcBufAddr = ulBUF_GetAdcFreeBuf();
			if(BUF_FAIL == ulAdcBufAddr)
				break;
			pAdoEncInfo = (ADO_ENC_PACK_INFO_t *)pData;
			pAdoEncInfo->ulTimestamp = KNL_TIMER_Get1ms();
			ulAdoPktSize = ulDataSize;
			tDmaResult = tDMAC_MemCopy((uint32_t)pAdoEncInfo, ulAdcBufAddr, ulAdoPktSize, NULL);
			if(DMAC_OK != tDmaResult)
			{
				ubBUF_ReleaseAdcBuf(ulAdcBufAddr);
				printd(DBG_ErrorLvl, "DMA NRDY @%s !\n", __func__);
				break;
			}			
			tProc.ubSrcNum	  = tAdoSrcNum;
			#if (!defined(S2019A) && defined(OP_AP) && defined(sWIFIBDG))
			tProc.ubCurNode   = KNL_NODE_BDG_PTT;
			#endif
			tProc.ubNextNode  = KNL_NODE_ADC_BUF;
			tProc.ulDramAddr1 = 0;
			tProc.ulDramAddr2 = ulAdcBufAddr;
			tProc.ulSize 	  = ulKNL_AddAuxInfo(KNL_ADO_PKT, tAdoSrcNum, ulAdcBufAddr, ulAdoPktSize, 0, 0, 0, pAdoEncInfo->ulTimestamp);
			if(osMessagePut(KNL_AdoCodecProcQueue, &tProc, 0) != osOK)
			{
				ubBUF_ReleaseAdcBuf(ulAdcBufAddr);
				printd(DBG_ErrorLvl, "ADO BDG Q->Full !!!\n");
			}
			break;
		}
		default:
			break;
	}
	return ubBdgTxRet;
}
//------------------------------------------------------------------------------
void KNL_SetApBdgPrvSrc(KNL_SRC tBdgSrc)
{
	KNL_SRC tPrvSrc = KNL_SRC_NONE;
	if(tKNL_ApBdgInfo.tBgdSrcNum == tBdgSrc)
		return;
	if(KNL_SRC_NONE != tKNL_ApBdgInfo.tBgdSrcNum)
	{
		tPrvSrc = tKNL_ApBdgInfo.tBgdSrcNum;
		tKNL_ApBdgInfo.tBgdSrcNum = KNL_SRC_NONE;
		printd(DBG_CriticalLvl, "\n  AP Src %d->%d\n", tPrvSrc, tBdgSrc);
		KNL_StopApBdgeProc();
	}
	tKNL_ApBdgInfo.tBgdSrcNum = tBdgSrc;
}
//------------------------------------------------------------------------------
KNL_SRC tKNL_GetApBdgPrvSrc(void)
{
	if((sPRF_BRIDGE_MODE != tKNL_sPRFDrvMd) || (BB_LINK != ubKNL_GetCommLinkStatus(KNL_MASTER_AP)))
		return KNL_SRC_NONE;
	return tKNL_ApBdgInfo.tBgdSrcNum;
}
#endif	//! End of #if (defined(OP_AP) && (defined(RVCS_APP) || defined(sWIFIBDG)))
//------------------------------------------------------------------------------
void KNL_DrvModeSwProc(sPRF_DrvMode_t tDrvMd)
{
#if (defined(OP_STA) && defined(RVCS_APP))
	KNL_SRC tSrcNum;
	KNL_ROLE tRoleNum = KNL_STA1;

	if(tKNL_sPRFDrvMd == tDrvMd)
		return;
	tRoleNum = (KNL_ROLE)ubKNL_GetRole();
	if(ptKNL_VdoRoleMap2SrcNum)
		tSrcNum = ptKNL_VdoRoleMap2SrcNum(KNL_MAIN_PATH, tRoleNum);
	else
		tSrcNum = (KNL_SRC)(KNL_SRC_1_MAIN + tRoleNum);
	switch(tDrvMd)
	{
		case sPRF_TRX_MODE:
			ubRC_SetFlg(ENCODE_0, FALSE);
			BUF_Reset(BUF_ADO_ADC);
			KNL_ChkDrvMdRes(sPRF_TRX_MODE);
			RC_PresetSetup(RC_QTY_AND_DYNAFPS);
			KNL_ImgRateCtrlFlow(tSrcNum, ENCODE_0, TRUE);
			KNL_SetReEncIfrmFlag(TRUE);
			ubKNL_StbLinkStsRrefFlag = TRUE;
			KNL_sPRFLinkReportFunc(sPRF_AP, sPRF_LOST_LINK);
			break;
		case sPRF_APDIRECT_MODE:
			ubRC_SetFlg(ENCODE_0, FALSE);
			#if (APP_BLE_SN9380_FUNC_ENABLE == 0)
			KNL_ChkDrvMdRes(sPRF_APDIRECT_MODE);
			#endif
			KNL_SetReEncIfrmFlag(TRUE);
			WiFiDt_Setup(VDO_FRC_FPS, VDO_DT_H_SIZE, VDO_DT_V_SIZE, tKNL_Get_StreamType());
			WiFiDt_AppInit(&KNL_LinkQ);
			WiFiDt_SetupDevInfo();
			WiFiDt_Open();
			RC_PresetSetup(RC_DT_DYNAQTYFPS);
			#if (APP_BLE_SN9380_FUNC_ENABLE == 1)
			if (UIcmd_GetVideoStartStatus() == 0)
				KNL_sPRFLinkReportFunc(sPRF_AP, sPRF_LOST_LINK);
			#else
			KNL_sPRFLinkReportFunc(sPRF_AP, sPRF_LOST_LINK);
			#endif
			break;
		default:
			return;
	}
	tKNL_sPRFDrvMd = tDrvMd;
	#if (E_RVCS_ALL_I_FRM == 1)
	ubKNL_UpdVdoGopFlag = TRUE;
	#endif
#endif	//! End of #if (defined(RVCS_APP) && defined(OP_STA))
#if (defined(OP_AP) && (defined(RVCS_APP) || defined(sWIFIBDG)))
	KNL_SRC tSrcNum;
	KNL_ROLE tRoleNum = KNL_STA1;

	if(tKNL_sPRFDrvMd == tDrvMd)
		return;
	switch(tDrvMd)
	{
		case sPRF_TRX_MODE:
			tKNL_ApBdgInfo.tBgdSrcNum = KNL_SRC_NONE;
			KNL_StopApBdgeProc();
			tKNL_ApBdgInfo.ubErrFlag  = FALSE;
			tKNL_ApBdgInfo.ubIfrmFlag = FALSE;
			sPRF_EnAutoSwCh(TRUE);
			break;
		case sPRF_BRIDGE_MODE:
			sPRF_EnAutoSwCh(FALSE);
			tSrcNum = KNL_SRC_1_MAIN;
			for(tRoleNum = KNL_STA1; tRoleNum <= KNL_STA4; tRoleNum++)
			{
				if(BB_LINK == ubKNL_GetCommLinkStatus(tRoleNum))
				{
					tSrcNum = (ptKNL_VdoRoleMap2SrcNum)?ptKNL_VdoRoleMap2SrcNum(KNL_MAIN_PATH, tRoleNum):(KNL_SRC)(KNL_SRC_1_MAIN + tRoleNum);
					break;
				}
			}
			KNL_SetApBdgPrvSrc(tSrcNum);
			WiFiDt_Setup(ubKNL_GetVdoFps(), uwKNL_GetVdoH(tSrcNum), uwKNL_GetVdoV(tSrcNum), tKNL_Get_StreamType());
			WiFiDt_AppInit(&KNL_LinkQ);
			WiFiDt_SetupDevInfo();
			WiFiDt_Open();
			BUF_Reset(BUF_WIFI_BDG);
			tKNL_ApBdgInfo.ubIfrmFlag = FALSE;
			tKNL_ApBdgInfo.ubErrFlag  = FALSE;
			if(NULL == osKNL_ApBdgQue)
			{
				osMessageQDef(KnlApBdgQue, BUF_NUM_BDG_VDO_BS, KNL_ApBdgQue_t);
				osKNL_ApBdgQue = osMessageCreate(osMessageQ(KnlApBdgQue), NULL);
			}
			else
				osMessageReset(osKNL_ApBdgQue);
			if(NULL == osKNL_ApBgdThdId)
			{
				osThreadDef(KnlApBgdThd, KNL_ApBdgThread, osPriorityRealtime, 1, 2048);
				osKNL_ApBgdThdId = osThreadCreate(osThread(KnlApBgdThd), NULL);
			}
			break;
		default:
			return;
	}
	tKNL_sPRFDrvMd = tDrvMd;
#endif	//! End of #if (defined(OP_AP) && (defined(RVCS_APP) || defined(sWIFIBDG)))
}
#endif	//! End of #if (defined(S2019A) || (defined(OP_AP) && defined(sWIFIBDG)))
//------------------------------------------------------------------------------
uint32_t ulKNL_GetAdoPktSZ(uint32_t ulAddr,uint32_t ulSize)
{
	uint32_t ulRtnValue;

	ulRtnValue = 0;
	ulRtnValue += (((uint32_t)(*((uint8_t *)(ulAddr+ulSize-(KNL_INFO_ADOSIZE+3)))))<<0);
	ulRtnValue += (((uint32_t)(*((uint8_t *)(ulAddr+ulSize-(KNL_INFO_ADOSIZE+2)))))<<8);
	ulRtnValue += (((uint32_t)(*((uint8_t *)(ulAddr+ulSize-(KNL_INFO_ADOSIZE+1)))))<<16);
	ulRtnValue += (((uint32_t)(*((uint8_t *)(ulAddr+ulSize-KNL_INFO_ADOSIZE))))<<24);

	return ulRtnValue;
}		

//------------------------------------------------------------------------------
void KNL_AdoSourceSelect(KNL_ADO_SRC_SEL Sel)
{
	switch(Sel)
	{
		case LOCAL_REMOTE:
			printd(DBG_ErrorLvl, "KNL->ado src sel LOCAL_REMOTE\n");
			break;
		case APP_LOCAL_REMOTE:
			printd(DBG_ErrorLvl, "KNL->ado src sel APP_LOCAL_REMOTE\n");
			break;
	}
	KNL_AdoSrcSel = Sel;
}
//------------------------------------------------------------------------------
#ifdef A7130
void KNL_AdcBufProcess(KNL_PROCESS tProc)
{
	uint32_t ulAdcAddr = 0;
	uint8_t ubTemp;
	uint8_t ubNextNode;	
	uint8_t ubLinkRole;
	uint32_t ulExtSz;
	uint8_t ubAdoRtyCnt = 0;
	uint8_t ubTotalBufNum;
	uint8_t ubUsedBufNum;	
	uint8_t ubBufOkFlg = 0;

RTYSEND_ADO:
	if(tBB_GetTxAdoPath() == BB_TX_ADO_STA1)
	{
		ubLinkRole = KNL_STA1;
	}
	else if(tBB_GetTxAdoPath() == BB_TX_ADO_STA2)
	{
		ubLinkRole = KNL_STA2;
	}
	else if(tBB_GetTxAdoPath() == BB_TX_ADO_STA3)
	{
		ubLinkRole = KNL_STA3;
	}
	else if(tBB_GetTxAdoPath() == BB_TX_ADO_STA4)
	{
		ubLinkRole = KNL_STA4;
	}
	else if(tBB_GetTxAdoPath() == BB_TX_ADO_SLAVE_AP)
	{
		ubLinkRole = KNL_SLAVE_AP;
	}
	else if(tBB_GetTxAdoPath() == BB_TX_ADO_MASTER_AP)
	{
		ubLinkRole = KNL_MASTER_AP;
	}

	ubNextNode = (tProc.ubNextNode == KNL_NODE_MSC_ADO)?KNL_NODE_MSC_ADO:ubKNL_GetNextNode(tProc.ubSrcNum, KNL_NODE_ADC_BUF);
	if((ubNextNode == KNL_NODE_COMM_TX_ADO) || (ubNextNode == KNL_NODE_MSC_ADO))
	{
		if(ubKNL_GetCommLinkStatus(ubLinkRole) == BB_LOST_LINK)		
			goto SEND_ADO_ERR;

		ubBufOkFlg = 0;
		ubTotalBufNum = ubBB_GetTxTotalBufNum(BB_DATA_AUDIO,BB_TX_MASTER);
		ubUsedBufNum  = ubBB_GetTxUsedBufNum(BB_DATA_AUDIO,BB_TX_MASTER);
		if((ubTotalBufNum-ubUsedBufNum) >= 1)
			ubBufOkFlg = 1;
		if((ubBB_GetStartFlg() == BB_TASK_START) && (ubBufOkFlg))
		{
			SET_BUF tKNL_BbStatus;

			if(!ubAdoRtyCnt)
			{
				DMAC_RESULT tDmaResult = DMAC_OK;

				ulAdcAddr = ulBUF_GetAdcFreeBuf();
				if(BUF_FAIL == ulAdcAddr)
					goto SEND_ADO_ERR;
				switch(ubNextNode)
				{
					case KNL_NODE_COMM_TX_ADO:
					{
						if(KNL_AdoSrcSel!=LOCAL_REMOTE)
							goto SEND_ADO_ERR;
						tDmaResult = tDMAC_MemCopy(tProc.ulDramAddr2, ulAdcAddr, tProc.ulSize,NULL);
						if(DMAC_OK != tDmaResult)
						{
							printd(DBG_ErrorLvl, "DMA NRDY @%s !\n", __func__);
							goto SEND_ADO_ERR;
						}
						break;
					}
					case KNL_NODE_MSC_ADO:
					{
						if(KNL_AdoSrcSel!=APP_LOCAL_REMOTE)
							goto SEND_ADO_ERR;
						ADO_AUD32_ENC_INFO tAdo32EncInfo;
						ADO_ENC_PACK_INFO_t *AdoEncPackInfo;
						uint32_t ulEncAddr;
						
						AdoEncPackInfo = (ADO_ENC_PACK_INFO_t*)ulAdcAddr;
						ulEncAddr = ulAdcAddr + sizeof(ADO_ENC_PACK_INFO_t);
						
						memset((uint8_t*)AdoEncPackInfo, 0x0, sizeof(ADO_ENC_PACK_INFO_t));
						memcpy(AdoEncPackInfo->chADO_StreamTag, ADO_STREAM_TAG, sizeof(ADO_STREAM_TAG)-1);
						AdoEncPackInfo->ulStartupFlag = ubKNL_UsbdAdoEncStFlag;
						AdoEncPackInfo->ulTimestamp   = KNL_TIMER_Get1ms();
						if(TRUE == ubKNL_UsbdAdoEncStFlag)
							ubKNL_UsbdAdoEncStFlag = FALSE;
						tAdo32EncInfo = ADO_Ado32_Encode(0, tProc.ulDramAddr1, ulEncAddr, tProc.ulSize);
						if(!tAdo32EncInfo.ulOutputSize)
						{
							printd(DBG_ErrorLvl, "ADO32 ENC Fail @%s !\n", __func__);
							goto SEND_ADO_ERR;
						}
                        AdoEncPackInfo->ulEncodedSize = tAdo32EncInfo.ulOutputSize;
						// set other info
						AdoEncPackInfo->EncType    = ADO32;
						AdoEncPackInfo->SampleRate = SAMPLERATE_16kHZ;
						AdoEncPackInfo->Channel    = MONO;
						AdoEncPackInfo->ubReserved = 0;
						
						tProc.ulSize = tAdo32EncInfo.ulOutputSize + sizeof(ADO_ENC_PACK_INFO_t);
						ubBUF_ReleaseAdoUsbdBuf(tProc.ulDramAddr1);
						break;
					}
					default:
						goto SEND_ADO_ERR;
				}
				ulExtSz = ulKNL_AddAuxInfo(KNL_ADO_PKT, tProc.ubSrcNum, ulAdcAddr, tProc.ulSize, 0, 0, 0, KNL_TIMER_Get1ms());
			}
			
		
			tKNL_BbStatus = tBB_SendData(NULL,BB_DATA_AUDIO,(uint8_t *)ulAdcAddr,ulExtSz,(SET_TX_PATH)NULL,0);
			
			switch(tKNL_BbStatus)
			{
				case BB_SET_BUF_SUCCESS:
					printd(DBG_Debug3Lvl, "A:0x%x\r\n",ulExtSz);
					break;
				case BB_SET_BUF_BUSY:
					printd(DBG_Debug3Lvl, "A->RTY:0x%x\r\n",ulExtSz);
					if(++ubAdoRtyCnt < 25)
					{
						osDelay(20);
						goto RTYSEND_ADO;
					}
					break;
				default:
					break;
			}
			ubTemp = ubBUF_ReleaseAdcBuf(ulAdcAddr);
			if(ubTemp == BUF_OK)
			{
				printd(DBG_Debug3Lvl, "Release BUF_ADC Ok\r\n");
			}
			else
			{
				printd(DBG_ErrorLvl, "Release BUF_ADC Fail\r\n");
			}
		}
		else
		{
			BB_ClearTxBuf(BB_TX_MASTER, BB_DATA_AUDIO);
		}
	}
SEND_ADO_ERR:
	if(ubNextNode == KNL_NODE_MSC_ADO)
		ubBUF_ReleaseAdoUsbdBuf(tProc.ulDramAddr1);
	if((ulAdcAddr) && (BUF_FAIL != ulAdcAddr))
		ubBUF_ReleaseAdcBuf(ulAdcAddr);
}
#endif

#if RTC676x
void KNL_AdcBufProcess2(KNL_PROCESS tProc)
{
	uint32_t ulAdcAddr = 0;
	uint8_t ubTemp;
	uint8_t ubNextNode;	
	uint8_t ubLinkRole;
	uint32_t ulExtSz;
	uint8_t ubAdoRtyCnt = 0;
	uint8_t ubTotalBufNum;
	uint8_t ubUsedBufNum;	
	uint8_t ubBufOkFlg = 0;
	
	uint32_t ulTemp;

//RTYSEND_ADO:
	if(tBB_GetTxAdoPath() == BB_TX_ADO_STA1)
	{
		ubLinkRole = KNL_STA1;
	}
	else if(tBB_GetTxAdoPath() == BB_TX_ADO_STA2)
	{
		ubLinkRole = KNL_STA2;
	}
	else if(tBB_GetTxAdoPath() == BB_TX_ADO_STA3)
	{
		ubLinkRole = KNL_STA3;
	}
	else if(tBB_GetTxAdoPath() == BB_TX_ADO_STA4)
	{
		ubLinkRole = KNL_STA4;
	}
	else if(tBB_GetTxAdoPath() == BB_TX_ADO_SLAVE_AP)
	{
		ubLinkRole = KNL_SLAVE_AP;
	}
	else if(tBB_GetTxAdoPath() == BB_TX_ADO_MASTER_AP)
	{
		ubLinkRole = KNL_MASTER_AP;
	}

#ifdef OP_AP
	ubLinkRole = ubKNL_GetStaInfo(KNL_ROLENUM, ubLinkRole);
	if(0xFF == ubLinkRole)
	{
		printd(DBG_ErrorLvl, "Role Number Err @%s !\n", __func__);
		goto SEND_ADO_ERR;
	}
#endif
	ubNextNode = (tProc.ubNextNode == KNL_NODE_MSC_ADO)?KNL_NODE_MSC_ADO:ubKNL_GetNextNode(tProc.ubSrcNum, KNL_NODE_ADC_BUF);
	if((ubNextNode == KNL_NODE_COMM_TX_ADO) || (ubNextNode == KNL_NODE_MSC_ADO))
	{
		if(ubKNL_GetCommLinkStatus(ubLinkRole) == BB_LOST_LINK)		
			goto SEND_ADO_ERR;

		ubBufOkFlg = 0;
//		ubTotalBufNum = ubBB_GetTxTotalBufNum(BB_DATA_AUDIO,BB_TX_MASTER);
//		ubUsedBufNum  = ubBB_GetTxUsedBufNum(BB_DATA_AUDIO,BB_TX_MASTER);
		ubTotalBufNum = BUF_NUM_ADO_PACKETIZE;
		ubUsedBufNum  = osMessages(KNL_AdoPacketizeQue);
		
		if((ubTotalBufNum-ubUsedBufNum) >= 1)
			ubBufOkFlg = 1;
		//if((ubBB_GetStartFlg() == BB_TASK_START) && (ubBufOkFlg))
		if(ubBufOkFlg)
		{
//			SET_BUF tKNL_BbStatus;

			if(!ubAdoRtyCnt)
			{
				DMAC_RESULT tDmaResult = DMAC_OK;

				#if (defined(OP_AP) && defined(sWIFIBDG))
				if(KNL_NODE_BDG_PTT == tProc.ubCurNode)
				{
					ulAdcAddr = tProc.ulDramAddr2;
					ulExtSz   = tProc.ulSize;
					goto RDY_SND_ADO;
				}
				#endif
				ulAdcAddr = ulBUF_GetAdcFreeBuf();
				if(BUF_FAIL == ulAdcAddr)
					goto SEND_ADO_ERR;
				switch(ubNextNode)
				{
					case KNL_NODE_COMM_TX_ADO:
					{
						if(KNL_AdoSrcSel!=LOCAL_REMOTE)
							goto SEND_ADO_ERR;
						tDmaResult = tDMAC_MemCopy(tProc.ulDramAddr2, ulAdcAddr, tProc.ulSize,NULL);
						if(DMAC_OK != tDmaResult)
						{
							printd(DBG_ErrorLvl, "DMA NRDY @%s !\n", __func__);
							goto SEND_ADO_ERR;
						}
						break;
					}
					case KNL_NODE_MSC_ADO:
					{
						if(KNL_AdoSrcSel!=APP_LOCAL_REMOTE)
							goto SEND_ADO_ERR;
						ADO_AUD32_ENC_INFO tAdo32EncInfo;
						ADO_ENC_PACK_INFO_t *AdoEncPackInfo;
						uint32_t ulEncAddr;

						AdoEncPackInfo = (ADO_ENC_PACK_INFO_t*)ulAdcAddr;
						ulEncAddr = ulAdcAddr + sizeof(ADO_ENC_PACK_INFO_t);
						
						memset((uint8_t*)AdoEncPackInfo, 0x0, sizeof(ADO_ENC_PACK_INFO_t));
						memcpy(AdoEncPackInfo->chADO_StreamTag, ADO_STREAM_TAG, sizeof(ADO_STREAM_TAG)-1);
						AdoEncPackInfo->ulStartupFlag = ubKNL_UsbdAdoEncStFlag;
						AdoEncPackInfo->ulTimestamp   = KNL_TIMER_Get1ms();
						if(TRUE == ubKNL_UsbdAdoEncStFlag)
							ubKNL_UsbdAdoEncStFlag = FALSE;
						tAdo32EncInfo = ADO_Ado32_Encode(0, tProc.ulDramAddr1, ulEncAddr, tProc.ulSize);
						if(!tAdo32EncInfo.ulOutputSize)
						{
							printd(DBG_ErrorLvl, "ADO32 ENC Fail @%s !\n", __func__);
							goto SEND_ADO_ERR;
						}
						AdoEncPackInfo->ulEncodedSize = tAdo32EncInfo.ulOutputSize;
						// set other info
						AdoEncPackInfo->EncType    = ADO32;
						AdoEncPackInfo->SampleRate = SAMPLERATE_16kHZ;
						AdoEncPackInfo->Channel    = MONO;
						AdoEncPackInfo->ubReserved = 0;
						
						tProc.ulSize = tAdo32EncInfo.ulOutputSize + sizeof(ADO_ENC_PACK_INFO_t);
						ubBUF_ReleaseAdoUsbdBuf(tProc.ulDramAddr1);                                           
						break;
					}
					default:
						goto SEND_ADO_ERR;
				}
				ulExtSz = ulKNL_AddAuxInfo(KNL_ADO_PKT, tProc.ubSrcNum, ulAdcAddr, tProc.ulSize, 0, 0, 0, KNL_TIMER_Get1ms());
			}
			
//			tKNL_BbStatus = tBB_SendData(NULL,BB_DATA_AUDIO,(uint8_t *)ulAdcAddr,ulExtSz,(SET_TX_PATH)NULL);
//			switch(tKNL_BbStatus)
//			{
//				case BB_SET_BUF_SUCCESS:
//					printd(DBG_Debug3Lvl, "A:0x%x\r\n",ulExtSz);
//					break;
//				case BB_SET_BUF_BUSY:
//					printd(DBG_Debug3Lvl, "A->RTY:0x%x\r\n",ulExtSz);
//					if(++ubAdoRtyCnt < 25)
//					{
//						osDelay(20);
//						goto RTYSEND_ADO;
//					}
//					break;
//				default:
//					break;
//			}
#if (defined(OP_AP) && defined(sWIFIBDG))			
RDY_SND_ADO:
#endif
			//Copy to AdoPacketizeBuf
			ulTemp = ulBUF_GetAdoPacketizeFreeBuf();
			if(ulTemp != BUF_FAIL)
			{
				tDMAC_MemCopy(ulAdcAddr, ulTemp,ulExtSz,NULL);
				
				//Next Node					
				tProc.ubCodecIdx	= 0;	//Justin 2020.03.17
				tProc.tPktType	 	= PKT_ADO;				
				//tProc.ulDramAddr2 	= ulAdcAddr;
				tProc.ulDramAddr2 	= ulTemp;
				
				tProc.ulSize		= ulExtSz;
				if(osMessagePut(KNL_AdoPacketizeQue, &tProc, 0) == osErrorResource)
				{					
					printd(DBG_ErrorLvl, "PktQ->F\r\n");
				}
			}			
			
			ubTemp = ubBUF_ReleaseAdcBuf(ulAdcAddr);
			if(ubTemp == BUF_OK)
			{
				printd(DBG_Debug3Lvl, "Release BUF_ADC Ok\r\n");
			}
			else
			{
				printd(DBG_ErrorLvl, "Release BUF_ADC Fail\r\n");
			}
			return;
		}
//		else
//		{
//			BB_ClearTxBuf(BB_TX_MASTER, BB_DATA_AUDIO);
//		}
	}
SEND_ADO_ERR:
	if(ubNextNode == KNL_NODE_MSC_ADO)
		ubBUF_ReleaseAdoUsbdBuf(tProc.ulDramAddr1);
	if((ulAdcAddr) && (BUF_FAIL != ulAdcAddr))
		ubBUF_ReleaseAdcBuf(ulAdcAddr);
}
#endif
//------------------------------------------------------------------------------
void KNL_RetryAdcBufProcess(KNL_PROCESS tProc)
{
#ifdef A7130
	KNL_PROCESS tKNLInfo;
	uint8_t ubTemp;
	LINK_ROLE tLinkRole;

	if(tBB_GetTxAdoPath() == BB_TX_ADO_STA1)
	{
		tLinkRole = BB_STA1;
	}
	else if(tBB_GetTxAdoPath() == BB_TX_ADO_STA2)
	{
		tLinkRole = BB_STA2;
	}
	else if(tBB_GetTxAdoPath() == BB_TX_ADO_STA3)
	{
		tLinkRole = BB_STA3;
	}
	else if(tBB_GetTxAdoPath() == BB_TX_ADO_STA4)
	{
		tLinkRole = BB_STA4;
	}	
	else if(tBB_GetTxAdoPath() == BB_TX_ADO_MASTER_AP)
	{
		tLinkRole = BB_MASTER_AP;
	}
	else if(tBB_GetTxAdoPath() == BB_TX_ADO_SLAVE_AP)
	{
		tLinkRole = BB_SLAVE_AP;
	}
	if((ubBB_GetStartFlg() == BB_TASK_START) && (ubKNL_GetCommLinkStatus(tLinkRole) == BB_LINK))
	{
		SET_BUF tKNL_BbStatus;

	
		tKNL_BbStatus = tBB_SendData(NULL,BB_DATA_AUDIO,(uint8_t *)tProc.ulDramAddr2,tProc.ulSize,(SET_TX_PATH)NULL,0);
		if(BB_SET_BUF_SUCCESS == tKNL_BbStatus)	
		{
			printd(DBG_Debug3Lvl, "RA:0x%x\r\n",tProc.ulSize);
			//Relase BS Buffer
			//-------------------------------------------------------------
			ubTemp = ubBUF_ReleaseAdcBuf(tProc.ulDramAddr2);
			if(ubTemp == BUF_OK)
			{
				printd(DBG_Debug3Lvl, "Release BUF_ADO Ok\r\n");
			}
			else
			{
				printd(DBG_ErrorLvl, "Release BUF_ADC Fail\r\n");
			}
		}
		else if(BB_SET_BUF_BUSY == tKNL_BbStatus)	
		{
			printd(DBG_Debug3Lvl, "RAQ:0x%x\r\n",tProc.ulSize);
			osDelay(30);
			//Retry Method
			tKNLInfo.ubSrcNum    = tProc.ubSrcNum;
			tKNLInfo.ubCurNode   = KNL_NODE_RETRY_ADC_BUF;
			tKNLInfo.ubNextNode  = KNL_NODE_RETRY_ADC_BUF;
			tKNLInfo.ulDramAddr1 = tProc.ulDramAddr1;
			tKNLInfo.ulDramAddr2 = tProc.ulDramAddr2;
			tKNLInfo.ulSize      = tProc.ulSize;
			if(osMessagePutToFront(KNL_AdoCodecProcQueue, &tKNLInfo, 0) == osErrorResource)
			{
				ubBUF_ReleaseAdcBuf(tKNLInfo.ulDramAddr2);
				printd(DBG_ErrorLvl, "KNL_ADO Q->Full !!!!\r\n");
			}
		}
	}
	else
	{
		printd(DBG_Debug3Lvl, "BU(A)\r\n");
		//Relase BS Buffer
		ubTemp = ubBUF_ReleaseAdcBuf(tKNLInfo.ulDramAddr2);
		if(ubTemp == BUF_OK)
		{
			printd(DBG_Debug3Lvl, "Release BUF_ADC Ok\r\n");
		}
		else
		{
			printd(DBG_ErrorLvl, "Release BUF_ADC Fail\r\n");
		}
	}
#endif
}
//------------------------------------------------------------------------------
void KNL_DacBufProcess(KNL_PROCESS tProc)
{
	uint8_t ubTemp = BUF_FAIL, ubSrcNumMap;
	uint8_t ubNextNode;
	uint32_t ulAdoPktSize = 0;
	ADO_Queue_INFO EN_INFO;	//!< static ADO_Queue_INFO EN_INFO;

	ulAdoPktSize = ulKNL_GetAdoPktSZ(tProc.ulDramAddr2, tProc.ulSize);
	ubNextNode   = ubKNL_GetNextNode(tProc.ubSrcNum,tProc.ubNextNode);
	if((ubKNL_ChkAdoFlowAct(tProc.ubSrcNum)) || ((tUSBD_GetClassMode() == USBD_COMPOSITE_MODE) && (TRUE == ubUSBD_ChkCompMscClass())) || (tADO_GetMixMode() == ADO_ON))
	{
		if(ubNextNode == KNL_NODE_DAC)
		{
			if((tADO_GetAdo32Enable() == ADO_ON) && (tKNL_AdoInfo.HwCompressMode == COMPRESS_NONE))
			{
				EN_INFO.EncType = ADO32;
			}
			if((tADO_GetSwAlawEnable() == ADO_ON) && (tKNL_AdoInfo.HwCompressMode == COMPRESS_NONE))
			{
				EN_INFO.EncType = ALAW;
			}
			else if((tADO_GetAACEnable() == ADO_ON) && (tKNL_AdoInfo.HwCompressMode == COMPRESS_NONE))
			{
				EN_INFO.EncType = AAC;
			}
			else if((tADO_GetAdo32Enable() == ADO_OFF) && (tADO_GetAACEnable() == ADO_OFF) && (tKNL_AdoInfo.HwCompressMode == COMPRESS_ALAW))
			{
				//ALAW
				EN_INFO.EncType = NONE;
			}
			else if((tADO_GetAdo32Enable() == ADO_OFF) && (tADO_GetAACEnable() == ADO_OFF) && (tKNL_AdoInfo.HwCompressMode == COMPRESS_NONE))
			{
				//PCM
				EN_INFO.EncType = NONE;
			}
			EN_INFO.SrcAddr = tProc.ulDramAddr2;
			EN_INFO.SrcSize	= ulAdoPktSize;
//			printf("----->Src:%d\n",EN_INFO.ubSrcNum);
			EN_INFO.PlyType = NORMAL_PLY;
#if defined(BSP_DVR_SDK)
            if(ubKNL_GetSrcNumPosition((KNL_SRC)tProc.ubSrcNum) != KNL_LOCAL)
#endif
#ifdef OP_STA
			EN_INFO.ubSrcNum = 0;
#else	
			EN_INFO.ubSrcNum = ubKNL_SrcNumMap(tProc.ubSrcNum);
#endif
			EN_INFO.ubPlaySrcNum = EN_INFO.ubSrcNum;
			EN_INFO.ulDecAddr	 = 0;
			
			if(tADO_GetMixMode() == ADO_ON)
			EN_INFO.ubPlaySrcNum = 0xFF;	
			
		#ifdef OP_AP
			if((tUSBD_GetClassMode() == USBD_COMPOSITE_MODE) && ((TRUE == ubUSBD_ChkCompMscClass()))||(USBD_MULTI_UAC & ubUSBD_GetMultiDrvMode())) 
			{
#if defined(BSP_DVR_SDK)
			    if(ubKNL_GetSrcNumPosition((KNL_SRC)tProc.ubSrcNum) != KNL_LOCAL)
#endif
                {            
                    EN_INFO.ubPlaySrcNum = (ubKNL_ChkAdoFlowAct(tProc.ubSrcNum))?ubKNL_SrcNumMap(tProc.ubSrcNum):0xFF;
                }
				EN_INFO.ulDecAddr  	 = ulKNL_SetUsbdAdoPktInfo(tProc.ulDramAddr2, tProc.ulSize);
				EN_INFO.ulDecAddr 	+= ((EN_INFO.ulDecAddr)?UVC_OFS_SUB_FRAME_DATA:0);
			}
		#endif
			if(ADO_DecBufWrtInChk(EN_INFO.PlyType, EN_INFO.EncType, EN_INFO.SrcSize)==DEC_BUF_EMPTY)
			{
				if(ubADO_DecBufWrtIn(&EN_INFO)==0)
				{
					printf("KNL Dac Buf Process fail->DecBufWrt fail\n");
				}
			}
            else
            {
                printf("ADO_DecBufWrtInChk fail: %X\n", EN_INFO.ulDecAddr);
                if(EN_INFO.ulDecAddr)
                {
#ifdef OP_AP									
                    if((tUSBD_GetClassMode() == USBD_COMPOSITE_MODE) && (TRUE == ubUSBD_ChkCompMscClass())) 
                        ubBUF_ReleaseAdoUsbdBuf(EN_INFO.ulDecAddr - UVC_OFS_SUB_FRAME_DATA);
                    else
                        ubBUF_ReleaseAdoUsbdBuf(EN_INFO.ulDecAddr - UVC_OFS_SUB_FRAME_DATA - UVC_OFS_DATAGAP);
#endif					
                }
            }
		}
		else
		{
			printd(DBG_ErrorLvl, "Err @KNL_DacBufProcess\r\n");
		}
	}
	//Release Buffer
#if defined(BSP_DVR_SDK)
	if(ubKNL_GetSrcNumPosition((KNL_SRC)tProc.ubSrcNum) != KNL_LOCAL)
#endif
    {   
    	ubSrcNumMap = ubKNL_SrcNumMap(tProc.ubSrcNum);
    	if(ubSrcNumMap == 0)
    	{
    		ubTemp = ubBUF_ReleaseDac0Buf(tProc.ulDramAddr2);
    	}
    	else if(ubSrcNumMap == 1)
    	{
    		ubTemp = ubBUF_ReleaseDac1Buf(tProc.ulDramAddr2);
    	}
    	else if(ubSrcNumMap == 2)
    	{
    		ubTemp = ubBUF_ReleaseDac2Buf(tProc.ulDramAddr2);
    	}
    	else if(ubSrcNumMap == 3)
    	{
    		ubTemp = ubBUF_ReleaseDac3Buf(tProc.ulDramAddr2);
    	}
    }
	if(ubTemp == BUF_FAIL)
	{
		printd(DBG_ErrorLvl, "Release Dac Buffer Err !!!!\r\n");
	}
}
//------------------------------------------------------------------------------
uint32_t ulKNL_AlignAdoPktSz(uint32_t ulInputSz)
{
//	if((ulInputSz%BB_STA_ADO_SUB_PKT_LEN) == 0)
//	{
//		return ulInputSz;
//	}
//	else
//	{
//		return ((ulInputSz/BB_STA_ADO_SUB_PKT_LEN)*BB_STA_ADO_SUB_PKT_LEN)+BB_STA_ADO_SUB_PKT_LEN;
//	}
	
	//if((ulInputSz%BB_STA1_ADO_SUB_PKT_LEN) == 0)
	if((ulInputSz%KNL_ADO_SUB_PKT_LEN) == 0)
	{
		return ulInputSz;
	}
	else
	{
		//return ((ulInputSz/BB_STA1_ADO_SUB_PKT_LEN)*BB_STA1_ADO_SUB_PKT_LEN)+BB_STA1_ADO_SUB_PKT_LEN;
		return ((ulInputSz/KNL_ADO_SUB_PKT_LEN)*KNL_ADO_SUB_PKT_LEN)+KNL_ADO_SUB_PKT_LEN;
	}
}
//------------------------------------------------------------------------------
uint32_t ulKNL_GetTimeStamp1(uint32_t ulAddr,uint32_t ulSize)
{
	return *((uint32_t *)(ulAddr+ulSize-KNL_INFO_TIMESTP_LSB));
}
//------------------------------------------------------------------------------
uint32_t ulKNL_GetTimeStamp2(uint32_t ulAddr,uint32_t ulSize)
{
	return *((uint32_t *)(ulAddr+ulSize-KNL_INFO_TIMESTP_MSB));
}
//------------------------------------------------------------------------------
uint8_t ubKNL_GetPktSrcNum(uint32_t ulAddr,uint32_t ulSize)
{
	return *((uint8_t *)(ulAddr+ulSize-KNL_INFO_SRCNUM));
}
//------------------------------------------------------------------------------
uint8_t ubKNL_GetPktOpMode(uint32_t ulAddr,uint32_t ulSize)
{
	return *((uint8_t *)(ulAddr+ulSize-KNL_INFO_OPMODE));
}
#if (OP_AP && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
void KNL_GetTxFSInfo(uint32_t ulAddr,uint32_t ulSize)
{
    uint32_t ulInfoSize=0;
    uint32_t ulFrameSize=0;
    uint8_t ubInfoType=0;
    uint8_t ubPaddingSize=0;
    KNL_TXFldInfoSz = 0;
    KNL_TXFileInfoSz = 0;
	ulInfoSize += (((uint32_t)(*((uint8_t *)(ulAddr+ulSize-(KNL_INFO_FS_SZ+0)))))<<0);
	ulInfoSize += (((uint32_t)(*((uint8_t *)(ulAddr+ulSize-(KNL_INFO_FS_SZ+1)))))<<8);
	ulInfoSize += (((uint32_t)(*((uint8_t *)(ulAddr+ulSize-(KNL_INFO_FS_SZ+2)))))<<16);
	ulInfoSize += (((uint32_t)(*((uint8_t *)(ulAddr+ulSize-(KNL_INFO_FS_SZ+3)))))<<24);
    if(ulInfoSize != 0)
    {
        ulFrameSize = ulKNL_GetFrameSz(ulAddr,ulSize);
        ubInfoType = *((uint8_t *)(ulAddr+ulSize-KNL_INFO_FS_TP));
        ubPaddingSize = *((uint8_t *)(ulAddr+ulSize-KNL_INFO_FS_PAD));
        if(ubInfoType == 0 && pKNL_TXFldInfo != NULL)
        {
            printd(DBG_InfoLvl,"GetTxFoldInfo = %d %d %x\n",ubInfoType,ubPaddingSize,ulInfoSize);
            KNL_TXFldInfoSz = (ulInfoSize-ubPaddingSize);
            memcpy((uint8_t*)pKNL_TXFldInfo,(uint8_t*)(ulAddr+ulFrameSize),(ulInfoSize-ubPaddingSize));
            ptKNL_TxFsCbFunc(0);
        }
        else if(ubInfoType == 1 && pKNL_TXFilInfo != NULL)
        {
            printd(DBG_InfoLvl,"GetTxFileInfo = %d %d %x\n",ubInfoType,ubPaddingSize,ulInfoSize);
            KNL_TXFileInfoSz = (ulInfoSize-ubPaddingSize);
            memcpy((uint8_t*)pKNL_TXFilInfo,(uint8_t*)(ulAddr+ulFrameSize),(ulInfoSize-ubPaddingSize));
            ptKNL_TxFsCbFunc(1);
        }
        else if(ubInfoType == 2 )
        {
            printd(DBG_InfoLvl,"GetTxHidenInfo = %d %d %x\n",ubInfoType,ubPaddingSize,ulInfoSize);
            memcpy((uint8_t*)&tKNL_TXFSHiddenInfo,(uint8_t*)(ulAddr+ulFrameSize),(ulInfoSize-ubPaddingSize));
            ptKNL_TxFsCbFunc(2);
        }
        else
            printd(DBG_InfoLvl,"TxFileInfo Err!!\n");
    }
}
#endif
//------------------------------------------------------------------------------
uint32_t ulKNL_GetPktFrmIdx(uint32_t ulAddr,uint32_t ulSize)
{
	uint32_t ulRtnValue;	
	
	ulRtnValue = 0;
	ulRtnValue += (((uint32_t)(*((uint8_t *)(ulAddr+ulSize-(KNL_INFO_FRMIDX+3)))))<<0);
	ulRtnValue += (((uint32_t)(*((uint8_t *)(ulAddr+ulSize-(KNL_INFO_FRMIDX+2)))))<<8);
	ulRtnValue += (((uint32_t)(*((uint8_t *)(ulAddr+ulSize-(KNL_INFO_FRMIDX+1)))))<<16);
	ulRtnValue += (((uint32_t)(*((uint8_t *)(ulAddr+ulSize-KNL_INFO_FRMIDX))))<<24);
	
	return ulRtnValue;
}
//------------------------------------------------------------------------------
uint32_t ulKNL_GetPktGop(uint32_t ulAddr,uint32_t ulSize)
{
	uint32_t ulRtnValue;	
	
	ulRtnValue = 0;
	ulRtnValue += (((uint32_t)(*((uint8_t *)(ulAddr+ulSize-(KNL_INFO_GOP+3)))))<<0);
	ulRtnValue += (((uint32_t)(*((uint8_t *)(ulAddr+ulSize-(KNL_INFO_GOP+2)))))<<8);
	ulRtnValue += (((uint32_t)(*((uint8_t *)(ulAddr+ulSize-(KNL_INFO_GOP+1)))))<<16);
	ulRtnValue += (((uint32_t)(*((uint8_t *)(ulAddr+ulSize-KNL_INFO_GOP))))<<24);
	
	return ulRtnValue;
}

uint32_t ulKNL_GetFrameSz(uint32_t ulAddr,uint32_t ulSize)
{
	uint32_t ulRtnValue;	

	osSemaphoreWait(tKNL_GetFramSzSem, osWaitForever);
	
    ulRtnValue = 0;
	ulRtnValue += (((uint32_t)(*((uint8_t *)(ulAddr+ulSize-KNL_INFO_FRAME_SZ+0))))<<0);
	ulRtnValue += (((uint32_t)(*((uint8_t *)(ulAddr+ulSize-KNL_INFO_FRAME_SZ+1))))<<8);
	ulRtnValue += (((uint32_t)(*((uint8_t *)(ulAddr+ulSize-KNL_INFO_FRAME_SZ+2))))<<16);
	ulRtnValue += (((uint32_t)(*((uint8_t *)(ulAddr+ulSize-KNL_INFO_FRAME_SZ+3))))<<24);
	
	osSemaphoreRelease(tKNL_GetFramSzSem);
	
	return ulRtnValue;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_GetPktVdoGop(uint32_t ulAddr,uint32_t ulSize)
{
	return *((uint8_t *)(ulAddr+ulSize-KNL_INFO_VGOP));
}
//------------------------------------------------------------------------------
uint16_t ubKNL_GetPktHRes(uint32_t ulAddr,uint32_t ulSize)
{
	return (*((uint8_t *)(ulAddr+ulSize-(KNL_INFO_RES+3))) << 8) + (*((uint8_t *)(ulAddr+ulSize-(KNL_INFO_RES+2))));
}
//------------------------------------------------------------------------------
uint16_t ubKNL_GetPktVRes(uint32_t ulAddr,uint32_t ulSize)
{
	return (*((uint8_t *)(ulAddr+ulSize-(KNL_INFO_RES+1))) << 8) + (*((uint8_t *)(ulAddr+ulSize-KNL_INFO_RES)));
}
//------------------------------------------------------------------------------
uint8_t ubKNL_GetFrameSeq(uint32_t ulAddr,uint32_t ulSize)
{
	return *((uint8_t *)(ulAddr+ulSize-KNL_INFO_FRMSEQ));
}
//------------------------------------------------------------------------------
uint8_t ubKNL_GetPaddLen(uint32_t ulAddr,uint32_t ulSize)
{
	return *((uint8_t *)(ulAddr+ulSize-KNL_INFO_PADD));
}
//------------------------------------------------------------------------------
uint8_t ubKNL_GetHQCapFlag(uint32_t ulAddr, uint32_t ulSize)
{
	return *((uint8_t *)(ulAddr+ulSize-KNL_INFO_HQCAP));
}
//------------------------------------------------------------------------------
uint32_t ulKNL_GetTxVsyncFrmTm(uint32_t ulAddr, uint32_t ulSize)
{
	uint32_t ulFrmTm = 0;
#if (defined(S2019A) && sPRF_LTYMEAS_EN)
	ulFrmTm = *((uint32_t *)(ulAddr + ulSize - KNL_INFO_TXSFRMTM));
#endif
	return ulFrmTm;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_GetAhdCamTypeInf(uint32_t ulAddr, uint32_t ulSize)
{
	return *((uint8_t *)(ulAddr+ulSize-KNL_INFO_AHD_CAM_TYPE)); 
}	
//------------------------------------------------------------------------------
uint8_t ubKNL_ChkDebugPkt(uint32_t ulAddr,uint32_t ulSize)
{
//	uint8_t hw_crc_8 = 0;	
//	CRC2_t CRC2_Setup;	
//	uint32_t ulCrcCalSz;
//	uint8_t  ubCorrectCrc;	
	
	return 1;
	
//	if(!ubKNL_GetVdoChkAct())
//	{
//		return 1;
//	}

//	ulCrcCalSz = *((uint32_t *)(ulAddr+ulSize-32));
//	
//	CRC2_Setup.CRC_INIT_VALUE = INIT_ALL_ZERO;
//	CRC2_Setup.CRC_FINAL_XOR_VALUE = XOR_ALL_ZERO;
//	CRC2_Setup.CRC_ORDER = 7;	
//	hw_crc_8 = (uint8_t)CRC2_Calc(CRC2_Setup, P_8, ulAddr, ulAddr, ulCrcCalSz);		
//	
//	ubCorrectCrc = *((uint8_t *)(ulAddr+ulSize-16));
//	if(hw_crc_8 != ubCorrectCrc)
//	{	
//		return 0;
//	}	
//	return 1;		
}

void KNL_ResendIframeFunc(KNL_ROLE tKNL_Role)
{
#ifdef OP_AP
	if(tKNL_Role <= KNL_STA4)
		ubKNL_AppResendIFrmFlg[tKNL_Role] = TRUE;
	printd(DBG_CriticalLvl, "	I->STA[%d]\n", tKNL_Role);
#endif
}

void KNL_ResendIframe(void)
{
#ifdef OP_AP
    uint8_t ubSrc[4],i,ubSrcNum;
	KNL_DISP_TYPE tDispType;

	tDispType = tKNL_GetDispType();
	for(i = 0; i < ubKNL_GetMaxStaNum(); i++)
		ubSrc[i] = KNL_SRC_NONE;
	ubSrcNum = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[0]:ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
#if defined(BSP_DVR_SDK)
	ubSrc[0] = (ubKNL_GetSrcNumPosition((KNL_SRC)ubSrcNum) == KNL_LOCAL)? KNL_SRC_NONE:
                ((KNL_SRC_NONE != ubSrcNum) && (BB_LINK == ubKNL_GetCommLinkStatus(ubKNL_SrcNumMap(ubSrcNum))))?ubSrcNum:KNL_SRC_NONE;
#else
	ubSrc[0] = ((KNL_SRC_NONE != ubSrcNum) && (BB_LINK == ubKNL_GetCommLinkStatus(ubKNL_SrcNumMap(ubSrcNum))))?ubSrcNum:KNL_SRC_NONE;
#endif
	if(KNL_DISP_SINGLE != tDispType)
	{
		ubSrcNum = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[1]:ubKNL_GetDispSrc(KNL_DISP_LOCATION2);
#if defined(BSP_DVR_SDK)
		ubSrc[1] = (ubKNL_GetSrcNumPosition((KNL_SRC)ubSrcNum) == KNL_LOCAL)? KNL_SRC_NONE:
                    ((KNL_SRC_NONE != ubSrcNum) && (BB_LINK == ubKNL_GetCommLinkStatus(ubKNL_SrcNumMap(ubSrcNum))))?ubSrcNum:KNL_SRC_NONE;
#else
		ubSrc[1] = ((KNL_SRC_NONE != ubSrcNum) && (BB_LINK == ubKNL_GetCommLinkStatus(ubKNL_SrcNumMap(ubSrcNum))))?ubSrcNum:KNL_SRC_NONE;
#endif
	}
	switch(tDispType)
	{
		case KNL_DISP_QUAD:
			ubSrcNum = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[2]:ubKNL_GetDispSrc(KNL_DISP_LOCATION3);
#if defined(BSP_DVR_SDK)
			ubSrc[2] = (ubKNL_GetSrcNumPosition((KNL_SRC)ubSrcNum) == KNL_LOCAL)? KNL_SRC_NONE:
			            ((KNL_SRC_NONE != ubSrcNum) && (BB_LINK == ubKNL_GetCommLinkStatus(ubKNL_SrcNumMap(ubSrcNum))))?ubSrcNum:KNL_SRC_NONE;
#else
			ubSrc[2] = ((KNL_SRC_NONE != ubSrcNum) && (BB_LINK == ubKNL_GetCommLinkStatus(ubKNL_SrcNumMap(ubSrcNum))))?ubSrcNum:KNL_SRC_NONE;
#endif						
			ubSrcNum = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[3]:ubKNL_GetDispSrc(KNL_DISP_LOCATION4);
#if defined(BSP_DVR_SDK)
			ubSrc[3] = (ubKNL_GetSrcNumPosition((KNL_SRC)ubSrcNum) == KNL_LOCAL)? KNL_SRC_NONE:
                        ((KNL_SRC_NONE != ubSrcNum) && (BB_LINK == ubKNL_GetCommLinkStatus(ubKNL_SrcNumMap(ubSrcNum))))?ubSrcNum:KNL_SRC_NONE;
#else
			ubSrc[3] = ((KNL_SRC_NONE != ubSrcNum) && (BB_LINK == ubKNL_GetCommLinkStatus(ubKNL_SrcNumMap(ubSrcNum))))?ubSrcNum:KNL_SRC_NONE;
#endif						
			break;
		case KNL_DISP_SINGLE:
			ubSrc[1] = KNL_SRC_NONE;
			break;
		default:
			break;
	}
    for(i = 0; i < ubKNL_GetMaxStaNum(); i++)
    {
        if(ubSrc[i] != KNL_SRC_NONE)
        {    
            KNL_ResendIframeFunc((KNL_ROLE)ubSrc[i]);   
        }
    }  
#endif
}

static void KNL_TwcMonitThread(void const *argument)
{
	KNL_PROCESS tProc;
	uint8_t ubKnlTwcSts = TWC_SUCCESS;
	uint8_t ubData[8] = {0}, ubLen = 1;
	ubLen = ubLen;//Avoid Warning

	while(1)
	{
		osMessageGet(KNL_TwcMonitQueue, &tProc, osWaitForever);
		if(!ubKNL_GetCommLinkStatus(tProc.ubTargetRole))
			continue;
		ubLen = 1;
		switch((TWC_OPC)tProc.ubTwcCmd)
		{
			case TWC_VDORES_SETTING:
				if(TRUE == ubKNL_VdoResChgTwcFlg[tProc.ubTargetRole])
					continue;
				memset(&ubData, 0, 8);
				ubData[0] = uwKNL_GetVdoH(tProc.ubSrcNum) >> 8;
				ubData[1] = uwKNL_GetVdoH(tProc.ubSrcNum) & 0xFF;
				ubData[2] = uwKNL_GetVdoV(tProc.ubSrcNum) >> 8;
				ubData[3] = uwKNL_GetVdoV(tProc.ubSrcNum) & 0xFF;
				ubData[4] = tProc.ubSrcNum;
				ubLen 	  = 5;
				ubKNL_VdoResChgTwcFlg[tProc.ubTargetRole]  = TRUE;
				break;

			case TWC_RESEND_I_EXT:
				memset(&ubData, 0, 8);
			#ifdef OP_AP
			    ubData[3] = tKNL_CapHQImgSte;
				if(KNL_CAPHQ_EN == tKNL_CapHQImgSte)
					tKNL_CapHQImgSte = KNL_CAPHQ_DIS;
			#endif
				ubData[4] = tProc.ubRstVdoGrp;
				ubLen = 8;
				ubKNL_VdoResendITwcFlg[tProc.ubTargetRole] = TRUE;
				break;

			case TWC_RESEND_I_INT:
				memset(&ubData, 0, 8);
				ubLen 	  = 2;
				ubKNL_VdoResendITwcFlg[tProc.ubTargetRole] = TRUE;
				break;

			case TWC_SYNC_GOP:
			#if OP_AP
                memset(&ubData, 0, 8);
                ubLen = 4;
				#if APP_REC_FUNC_ENABLE
				ubData[0] = KNL_TX_RECGOP>>24;
				ubData[1] = KNL_TX_RECGOP>>16;
				ubData[2] = KNL_TX_RECGOP>>8;
				ubData[3] = KNL_TX_RECGOP&0xFF;
				#else
				ubData[0] = KNL_TX_GOP>>24;
				ubData[1] = KNL_TX_GOP>>16;
				ubData[2] = KNL_TX_GOP>>8;
				ubData[3] = KNL_TX_GOP&0xFF;
				#endif
			#elif OP_STA
				memset(&ubData, 0, 8);
				ubData[0] = ubKNL_GetRole();
				ubLen = 1;
			#endif
				break;

			case TWC_STA_ON_LINE:
				ubData[0] = 0;
				ubData[1] = 0;
				ubData[2] = 0;
				ubData[3] = 0;
			
				if(ubKNL_StaOnLineMap & 0x01)
				{
					ubData[0] = 1;
				}
				if(ubKNL_StaOnLineMap & 0x02)
				{
					ubData[1] = 1;
				}
				if(ubKNL_StaOnLineMap & 0x04)
				{
					ubData[2] = 1;
				}
				if(ubKNL_StaOnLineMap & 0x08)
				{
					ubData[3] = 1;
				}				
				ubLen  = 4;
				break;
            case TWC_SYNC_FRAME:
			#ifndef S2019A
                #if OP_AP
                        memset(&ubData, 0, 8);
						#ifdef A7130
						ubData[0] = ulKNL_GetFps(KNL_BB_FRM_OK, (KNL_SRC_1_MAIN+tProc.ubTargetRole));
						#endif
						#ifdef RTC676x
                        ubData[0] = ubKNL_OutFps[tProc.ubTargetRole];
						#endif
                        ubLen = 1;
                #elif OP_STA
                        memset(&ubData, 0, 8);
                        ubData[0] = ubKNL_GetRole();
                        ubLen = 1;
                #endif
			#endif
                break;
			case TWC_TRXBW_RPT:
			{
			#if (defined(RTC676x) && defined(OP_STA) && TRXBW_RPT_EN)
				uint32_t ulRfBwRpt = 0;

				memset(&ubData, 0, 8);
				ulRfBwRpt = ulRTC676x_GetRtBw(0) / 1024;
				ubData[0] = ubKNL_GetRole();
				ubData[1] = ulRfBwRpt >> 24;
				ubData[2] = ulRfBwRpt >> 16;
				ubData[3] = ulRfBwRpt >> 8;
				ubData[4] = ulRfBwRpt & 0xFF;
				ubLen 	  = 5;
				break;
			#else
				continue;
			#endif
			}
			default:
				continue;
		}
	#ifdef RTC676x
		ubKnlTwcSts = ubKNL_TwcSend((TWC_TAG)tProc.ubTargetRole,(TWC_OPC)tProc.ubTwcCmd,ubData,8,16);
		if(ubKnlTwcSts != TWC_SUCCESS)
		{
			printd(DBG_CriticalLvl, "TWC Fail[%d]:%d\r\n",tProc.ubTargetRole, tProc.ubTwcCmd);
		}
	#endif
	#if (defined(A7130) || defined(S2019A))
		ubKnlTwcSts = ubKNL_TwcSend(tProc.ubTargetRole,(TWC_OPC)tProc.ubTwcCmd,ubData,ubLen,8);
		if(ubKnlTwcSts == TWC_SUCCESS)
		{
			printd(DBG_CriticalLvl, "[%d]:%s[%d]->OK\r\n", tProc.ubTargetRole, "TWC", (TWC_OPC)tProc.ubTwcCmd);
		}
		else
		{
			printd(DBG_CriticalLvl, "[%d]:%s[%d]->Fail\r\n", tProc.ubTargetRole, "TWC", (TWC_OPC)tProc.ubTwcCmd);
			switch((TWC_OPC)tProc.ubTwcCmd)
			{
				case TWC_VDORES_SETTING:
					ubKNL_VdoResChgTwcFlg[tProc.ubTargetRole] = FALSE;
					break;
				case TWC_RESEND_I_EXT:
				case TWC_RESEND_I_INT:
					ubKNL_VdoResendITwcFlg[tProc.ubTargetRole] = FALSE;
				break;			
				default:
					break;
			}
		}
	#endif
	#if (defined(OP_AP) && APP_REC_FUNC_ENABLE)
		if((TWC_SYNC_GOP == (TWC_OPC)tProc.ubTwcCmd) && (TWC_SUCCESS == ubKnlTwcSts))
			KNL_SetVdoGop(KNL_TX_RECGOP);
	#endif
	}
}

#define osTick_RATE		100
static void KNL_AvgPlyThread(void const *argument)
{
	KNL_PROCESS tProc;	
	uint32_t ulDlyMs;	
	uint32_t ulTimeBase = 1000/osTick_RATE;	
	uint32_t ulMinusMs = 0;
	uint32_t ulQNum;
	uint8_t ubSrcNum = (uint8_t)((uint32_t)argument);
	
	while(1)
	{
		if(!ubKNL_AvgPlyStartFlg[ubSrcNum])
		{
			ulMinusMs = 0;
			ulDlyMs = 1000/ubKNL_GetVdoFps();
			ulDlyMs = (ulDlyMs/ulTimeBase)*ulTimeBase;			
			osDelay(20);			
		}
		else
		{			
			ulQNum = osMessages(KNL_AvgPlyQ[ubSrcNum].Id);
			printd(DBG_Debug3Lvl, "AQ[%d]:%d\r\n",ubSrcNum,ulQNum);			
			
			if(ulQNum < (ubKNL_GetStartPlyNum()-1))
			{				
				osDelay(ulDlyMs/2);				
				ulMinusMs = 0;
			}
			else if(ulQNum == (ubKNL_GetStartPlyNum()-1))
			{
				ulMinusMs = 0;
			}
			else
			{
				ulMinusMs = ulDlyMs/2;
			}
			
			if(osMessages(KNL_AvgPlyQ[ubSrcNum].Id))
			{
				osMessageGet(KNL_AvgPlyQ[ubSrcNum].Id, &tProc, osWaitForever);
				printd(DBG_Debug3Lvl, "AvgPlyQue->%d\r\n",tProc.ulIdx);			
				
				if(osMessagePutToFront(KNL_VdoCodecProcQueue, &tProc, 0) == osErrorResource)
				{		
					printd(DBG_ErrorLvl, "KNL_Q->Full !!!!\r\n");
				}			
				
				osDelay(ulDlyMs-ulMinusMs);				
			}
		}
	}
}
//------------------------------------------------------------------------------
static void KNL_VdoInProcThread(void const *argument)
{
	KNL_PROCESS tProc;

	while(1)
	{
		osMessageGet(KNL_VdoInProcQueue, &tProc, osWaitForever);
		switch(tProc.ubNextNode)
		{
			case KNL_NODE_SEN_YUV_BUF:
				if(TRUE == ubKNL_ImgBusyFlg)
				{
					ubBUF_ReleaseSenYuvBuf(tProc.ulDramAddr1);
					printd(DBG_ErrorLvl, "  Img Busy!");
					continue;
				}
				KNL_SenYuvBufProcess(tProc);
				break;
			default:
			#if (defined(OP_STA) || defined(OP_AP) && (defined(BSP_DVR_SDK)))
				printd(DBG_ErrorLvl, "[%d]Node Err !\n", tProc.ubNextNode);
				SEN_SetFirstOutFlg(1);
				if(ubSEN_GetActiveFlg(SENSOR_PATH1))
				{
					BUF_Reset(BUF_SEN_1_YUV);
				}
				if(ubSEN_GetActiveFlg(SENSOR_PATH2))
				{
					BUF_Reset(BUF_SEN_2_YUV);
				}
				if(ubSEN_GetActiveFlg(SENSOR_PATH3))
				{
					BUF_Reset(BUF_SEN_3_YUV);
				}
				osMessageReset(KNL_VdoInProcQueue);
				SEN_SetFirstOutFlg(0);
			#endif
				break;
		}
	}
}

#if (defined(OP_STA) || defined(BSP_DVR_SDK))
static void KNL_ResSwProcThread(void const *argument)
{
	KNL_PROCESS tProc;	
	KNL_NODE_INFO tNodeInfo;
	uint8_t ubCodecIdx;
	uint8_t ubWaitCnt = 0;
	uint8_t ubWaitTh = 25;	//25*20 = 500ms
	
	while(1)
	{
		osMessageGet(KNL_ResSwProcQueue, &tProc, osWaitForever);		
		ubWaitCnt = 0;		
		
		tNodeInfo = tKNL_GetNodeInfo(tProc.ubSrcNum,KNL_NODE_H264_ENC);
		ubCodecIdx = tNodeInfo.ubCodecIdx - ENCODE_0;		
		//if(ubKNL_ChkVdoFlowAct(tProc.ubSrcNum) && ubKNL_InitImgFlg && ubKNL_InitH264EncFlg[ubCodecIdx])
		
		if(ubKNL_InitImgFlg && ubKNL_InitH264EncFlg[ubCodecIdx])
		{			
			
			if(TRUE == ubKNL_ChgResFlg)
			{
				static uint8_t ubKNL_H264ResetFlg = FALSE;
				uint32_t ulResSize = uwKNL_GetVdoH(tProc.ubSrcNum) * uwKNL_GetVdoV(tProc.ubSrcNum) * 3 / 2;
								
				if(FALSE == ubKNL_H264ResetFlg)
				{
					uint8_t ubNodeIdx;
					uint8_t ubBufIdx[4] = {[ENCODE_0] = 0, [ENCODE_1] = 1, [ENCODE_2] = 2, [ENCODE_3] = 3};
					uint8_t ubSetFps = 0;
					
					
					while(!ubKNL_ChkImgRdy())
					{
						osDelay(20);
						ubWaitCnt++;						
						if(ubWaitCnt >= ubWaitTh)
						{
							printf("Wait H264 Time-Out !!!!\r\n");
							break;
						}
					}
					H264_Reset();					
#if (defined(OP_STA) || defined(BSP_DVR_SDK))					
                	SEN_SetIspOutEn(FALSE);
               		SEN_SetDetectVideoState(0);
#endif					
					osMessageReset(KNL_VdoCodecProcQueue);
					if(ubKNL_ExistNode(tProc.ubSrcNum, KNL_NODE_VDO_BS_BUF1))
					{
						tNodeInfo = tKNL_GetNodeInfo(tProc.ubSrcNum,KNL_NODE_VDO_BS_BUF1);
						tNodeInfo.uwVdoH = uwKNL_GetVdoH(tProc.ubSrcNum);
						tNodeInfo.uwVdoV = uwKNL_GetVdoV(tProc.ubSrcNum);
						ubNodeIdx = ubKNL_GetNodeIdx(tProc.ubSrcNum, KNL_NODE_VDO_BS_BUF1);
						ubKNL_SetVdoPathNode(tProc.ubSrcNum, ubNodeIdx, tNodeInfo);
					}
					
					tNodeInfo = tKNL_GetNodeInfo(tProc.ubSrcNum,KNL_NODE_H264_ENC);
					tNodeInfo.uwVdoH = uwKNL_GetVdoH(tProc.ubSrcNum);
					tNodeInfo.uwVdoV = uwKNL_GetVdoV(tProc.ubSrcNum);
					ubNodeIdx = ubKNL_GetNodeIdx(tProc.ubSrcNum, KNL_NODE_H264_ENC);
					ubKNL_SetVdoPathNode(tProc.ubSrcNum, ubNodeIdx, tNodeInfo);
                    #if (defined(OP_STA)&&(defined(BSP_VBM_SDK)||defined(BSP_RVCS_SDK))&&defined(VDO_SUBPATH_ENABLE)&&(VDO_SUBPATH_ENABLE!=0))
                    KNL_DpSwBufInit();	// Keep Aux Stream recording
                    #else
					BUF_ResetFreeAddr();					
					KNL_BufInit();					
                    #endif
					ubSetFps = VDO_FRAME_RATE(tNodeInfo.uwVdoH, tNodeInfo.uwVdoV);
					if(ubKNL_GetVdoFps() != ubSetFps)
					{
						KNL_SetVdoFps(ubSetFps);
						SEN_SetFrameRate(SENSOR_PATH1, ubSetFps);
						printd(DBG_CriticalLvl, "\nFPS: %d\n", ubSetFps);
					}
					KNL_SetSysMaxFps(ubSetFps);					
					if(RC_MODE_DYNAMIC_FPS2 == ubRC_GetOpMode((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx))
					{					
						RC_DynamicFpsMode(ubKNL_GetSysMaxFps(),RC_MIN_FPS,RC_SECTION_NUM,1);
					}					
                    #if (defined(OP_STA)&&(defined(BSP_VBM_SDK)||defined(BSP_RVCS_SDK))&&defined(VDO_SUBPATH_ENABLE)&&(VDO_SUBPATH_ENABLE!=0))
                    GLB->H264_RATE = 1;	// Two stream need used more frequence
            		GLB->IMG_RATE  = 3;
                    #else
					SetH264Rate(tNodeInfo.uwVdoH, tNodeInfo.uwVdoV, ubSetFps);
                    #endif
					#if (defined(OP_AP) && defined(BSP_DVR_SDK))
						H264_EncodeInit((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV,ulBUF_GetBlkBufAddr(ubBufIdx[(H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx],BUF_IMG_ENC),ubRC_GetFps(),30);
					#else
						H264_EncodeInit((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV,ulBUF_GetBlkBufAddr(ubBufIdx[(H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx],BUF_IMG_ENC),ubRC_GetFps(),ulKNL_GetVdoGop());
					#endif				
					H264_SetMaxQP((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,ubRC_GetMaxQp(tNodeInfo.ubCodecIdx));
					H264_SetMinQP((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,ubRC_GetMinQp(tNodeInfo.ubCodecIdx));
					H264_RcSetEN((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,H264_ENABLE,CBR,ulRC_GetInitBitRate(tNodeInfo.ubCodecIdx));
					H264_ResetIPCnt((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx);
					ubKNL_H264ResetFlg = TRUE;
					ulResSize = 0;										
				}
#if (defined(OP_STA) || defined(BSP_DVR_SDK))				
				if(ubSEN_GetPathSrc(SENSOR_PATH1) == tProc.ubSrcNum)
				{
                    SEN_SetResChgState(SENSOR_PATH1,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
					SEN_SetPathAddr(SENSOR_PATH1, ulBUF_GetSen1YuvFreeBuf());
				}
                if(ubSEN_GetPathSrc(SENSOR_PATH2) == tProc.ubSrcNum)
				{
					SEN_SetResChgState(SENSOR_PATH2,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);                   
					SEN_SetPathAddr(SENSOR_PATH2, ulBUF_GetSen2YuvFreeBuf());
				}
                if(ubSEN_GetPathSrc(SENSOR_PATH3) == tProc.ubSrcNum)
				{
                    SEN_SetResChgState(SENSOR_PATH3,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
					SEN_SetPathAddr(SENSOR_PATH3, ulBUF_GetSen3YuvFreeBuf());
				}
                
                SEN_SetIspOutEn(TRUE);
                SEN_SetDetectVideoState(1);
#endif			
				#if defined(RTC676x)
				if(ubKNL_StopTrxFlg[0])
					ubKNL_StopTrxFlg[0] = 0;
				if(ubKNL_StopTrxFlg[1])
					ubKNL_StopTrxFlg[1] = 0;
				if(ubKNL_StopTrxFlg[2])
					ubKNL_StopTrxFlg[2] = 0;
			#endif				
				

				ubKNL_ChgResFlg 	= FALSE;
				ubKNL_H264ResetFlg  = FALSE;
#if defined(OP_STA)				
			    MD_Switch(ubKNL_MDResChRestore());
#endif			    
			}
		}		
	}
}

#endif
//------------------------------------------------------------------------------
static void KNL_VdoCodecProcThread(void const *argument)
{
	KNL_PROCESS tProc;

	while(1)
	{
		osMessageGet(KNL_VdoCodecProcQueue, &tProc, osWaitForever);
		switch(tProc.ubNextNode)
		{
			case KNL_NODE_H264_ENC:
			case KNL_NODE_H264_DEC:
				KNL_H264CodecProcess(tProc);
				break;

			case KNL_NODE_JPG_DEC1:
				KNL_JpegDec1Process(tProc);
				break;

			case KNL_NODE_JPG_DEC2:
				KNL_JpegDec2Process(tProc);
				break;

			case KNL_NODE_JPG_ENC:
				KNL_JpegEncProcess(tProc);
				break;

			case KNL_NODE_IMG_MERGE_BUF:
				KNL_ImgMergeBufProcess(tProc);
				break;

			case KNL_NODE_VDO_BS_BUF1:
				KNL_VdoBsBuf1Process(tProc);
				break;

			case KNL_NODE_VDO_BS_BUF2:
				KNL_VdoBsBuf2Process(tProc);
				break;

			case KNL_NODE_IMG_MERGE_H:
				KNL_ImgMergeHProcess(tProc);
				break;

			case KNL_NODE_LCD:
				if(KNL_NODE_VDO_BS_BUF1 == tProc.ubCurNode)
					ubKNL_ReleaseBsBufAddr(KNL_NODE_LCD,tProc.ubSrcNum,tProc.ulDramAddr2);
				break;

			case KNL_NODE_END:
				ubKNL_ReleaseBsBufAddr(KNL_NODE_END,tProc.ubSrcNum,tProc.ulDramAddr2);
				break;
		}
	}
}

//------------------------------------------------------------------------------
static void KNL_AdoCodecProcThread(void const *argument)
{
	KNL_PROCESS tProc;

	while(1)
	{
        osMessageGet(KNL_AdoCodecProcQueue, &tProc, osWaitForever);
		switch(tProc.ubNextNode)
		{
			case KNL_NODE_MSC_ADO:
			case KNL_NODE_ADC_BUF:
			#if A7130
				KNL_AdcBufProcess(tProc);
			#endif
			#if RTC676x
				KNL_AdcBufProcess2(tProc);
			#endif
			#ifdef S2019A
				KNL_sPRFTxAdoProcess(tProc);
			#endif
				break;
			case KNL_NODE_RETRY_ADC_BUF:
				KNL_RetryAdcBufProcess(tProc);
				break;
			case KNL_NODE_DAC_BUF:
				KNL_DacBufProcess(tProc);
				break;
			default:
				break;
		}
	}
}

#ifdef RTC676x
uint8_t ubKNL_GetVdoPacketizeQueNum(void)
{
	return osMessages(KNL_VdoPacketizeQue);
}
#endif
#define PKT_STATUS_NACK		0
#define PKT_STATUS_ACK		1

uint8_t ubKNL_VdoTotalIdx[4] = {0,0,0,0};
//------------------------------------------------------------------------------
#ifdef RTC676x
static void KNL_VdoPacketizeProcThread(void const *argument)
{		
	uint8_t ubDropFlg = 0;	//1->Drop frame after modulation switch, 0->Keep frame after modulation switch	
	
	uint8_t ubSlot1Flg = 0;
	uint32_t ulWaitSwCnt = 0;
	
	int BasebandRate;	
	
	//MAX_VDO_PACKET_LEN
	uint32_t ulMaxVdoPktLen;
	uint32_t ulVdoPayloadSz;
	
	uint16_t uwChkSum;
	int free_buf_count = 0;
    size_t free_buf_count_len = sizeof(free_buf_count);
	uint8_t ubWaitDlyCnt = 0;
	uint8_t ubWaitMaxDlyTh = 50;
	
	uint8_t ubTimeOutCnt = 0;
	uint8_t ubTimeOutMaxTh = 5;
	
	int result;
	KNL_PROCESS tProc;	
	uint16_t i,j,k;				//Take care "Type"
	
	uint16_t uwTotalPktNum;		//Total Packet Number
	uint16_t uwAckPktNum;		//Ack Packet Number
	uint32_t ulPktBufAddr;
	uint32_t ulSendAddr;
	int Id;
	uint64_t udlAck = 0,udlAckTemp = 0;
	uint8_t ubTotalIdx = 0;
	uint8_t ubLinkStatus = 0;
	
	uint8_t ubPktSendThisRun;
	uint8_t ubRunTimes = 0;
	uint8_t ubTemp = 0;
	uint8_t ubTemp2 = 0;		
	//uint8_t ubAckPkt = 0;	
	
	uint16_t uwPktSendMap[64];	//Take care "Type"
	
	uint8_t ubPktStatus[256];	//Max Frame Size -> 256*PKT_PAYLOAD_SZ = 192KB
								//0->Not Yet, 1->Ok		
								
	uint32_t ulActiveLen = 0;	//Bitstream Size + Aux Size
	
	result = result;
	
	while(1)
	{
		osMessageGet(KNL_VdoPacketizeQue, &tProc, osWaitForever);
		
		if(ubKNL_ChkVdoFlowAct(tProc.ubSrcNum))
		{	
			ubRunTimes = 0;	//For Debug
			
			//Initial
		#if (RF_MODE_SW_SEL == RF_MODE_SW_OLD)
			if(KNL_NewRwBbRateMode == PREF_BBR_BPSK)
			{
				if(rf_get_bandwidth_config() == BW_FULL_BANDWIDTH)
				{			
					if(KNL_GetEvenSlot() == 1200)
					{
						ubSlot1Flg = 1;
						ulMaxVdoPktLen = RW_S2M_SZ_BPSK_1T_1200;
					}
					else if(KNL_GetEvenSlot() == 1667)
					{
						ubSlot1Flg = 1;
						ulMaxVdoPktLen = RW_S2M_SZ_BPSK_1T_1667;						
					}
				}
				else
				{
					if(KNL_GetEvenSlot() == 1200)
					{
						ubSlot1Flg = 0;
						ulMaxVdoPktLen = RW_S2M_SZ_BPSK_NT_1200;
					}
					else if(KNL_GetEvenSlot() == 1667)
					{
						ubSlot1Flg = 0;
						ulMaxVdoPktLen = RW_S2M_SZ_BPSK_NT_1667;						
					}
				}		
			}
			else if(KNL_NewRwBbRateMode == PREF_BBR_QPSK)
			{
				if(rf_get_bandwidth_config() == BW_FULL_BANDWIDTH)
				{			
					if(KNL_GetEvenSlot() == 1200)
					{
						ubSlot1Flg = 1;
						ulMaxVdoPktLen = RW_S2M_SZ_QPSK_1T_1200;
					}
					else if(KNL_GetEvenSlot() == 1667)
					{
						ubSlot1Flg = 1;
						ulMaxVdoPktLen = RW_S2M_SZ_QPSK_1T_1667;						
					}
				}
				else
				{
					if(KNL_GetEvenSlot() == 1200)
					{
						ubSlot1Flg = 0;
						ulMaxVdoPktLen = RW_S2M_SZ_QPSK_NT_1200;	
					}
					else if(KNL_GetEvenSlot() == 1667)
					{
						ubSlot1Flg = 0;
						ulMaxVdoPktLen = RW_S2M_SZ_QPSK_NT_1667;
					}
				}		
			}
			else if(KNL_NewRwBbRateMode == PREF_BBR_16QAM)
			{
				if(rf_get_bandwidth_config() == BW_FULL_BANDWIDTH)
				{			
					if(KNL_GetEvenSlot() == 1200)
					{
						ubSlot1Flg = 1;
						ulMaxVdoPktLen = RW_S2M_SZ_16QAM_1T_1200;
					}
					else if(KNL_GetEvenSlot() == 1667)
					{
						ubSlot1Flg = 1;
						ulMaxVdoPktLen = RW_S2M_SZ_16QAM_1T_1667;						
					}
				}
				else
				{
					if(KNL_GetEvenSlot() == 1200)
					{
						ubSlot1Flg = 0;
						ulMaxVdoPktLen = RW_S2M_SZ_16QAM_NT_1200;	
					}
					else if(KNL_GetEvenSlot() == 1667)
					{
						ubSlot1Flg = 0;
						ulMaxVdoPktLen = RW_S2M_SZ_16QAM_NT_1667;
					}
				}		
			}
			
			if(KNL_NewRwBbRateMode != KNL_CurRwBbRateMode)
			{
				KNL_CurRwBbRateMode = KNL_NewRwBbRateMode;				
				
				if(RC_MODE_DYNAMIC_FPS2 == ubRC_GetOpMode((H264_ENCODE_INDEX)ENCODE_0))
				{
					if(KNL_CurRwBbRateMode == PREF_BBR_16QAM)						
						//RC_DynamicFpsMode(ubKNL_GetSysMaxFps(),RC_MIN_FPS,RC_SECTION_NUM,fKNL_PreRatio*0.9);
						RC_DynamicFpsMode(ubKNL_GetSysMaxFps(),ubKNL_GetSysMaxFps(),1,fKNL_PreRatio*0.9);						
					else if(KNL_CurRwBbRateMode == PREF_BBR_QPSK)
						RC_DynamicFpsMode(ubKNL_GetSysMaxFps(),RC_MIN_FPS,RC_SECTION_NUM,1);
				}
				
				printf("Update Mode:%d\r\n",KNL_CurRwBbRateMode);
				BasebandRate = KNL_CurRwBbRateMode;
				
				//Dynamic Modulation
				ulWaitSwCnt = 0;				
				while(ulWaitSwCnt < 30)
				{
					rf_getopt(RF_DRV_OPT_TX_FREE_BUF_CNT, &free_buf_count, &free_buf_count_len);
					if(free_buf_count == 64)
					{
						printf("Wait Done -> Ok\r\n");
						break;
					}
					osDelay(10);
					ulWaitSwCnt++;
				}
				if(ulWaitSwCnt == 30)
				{
					printf("Wait Done -> Fail\r\n");
				}
				rf_setopt(RF_SO_PREFBBR, &BasebandRate, sizeof(BasebandRate));
				
				//Dynamic Power Setting
				if(KNL_CurRwBbRateMode == PREF_BBR_QPSK)
				{
					//RTC676x_SetPower(RW_PWR_QPSK);
					RTC676x_SetPower(RW_PWR_PKT_TX,RW_PWR_HIGH);
				}
				else if(KNL_CurRwBbRateMode == PREF_BBR_16QAM)
				{					
					RTC676x_SetPower(RW_PWR_PKT_TX,RW_PWR_MEDIUM);					
				}				
			}
		#endif
			
		#if (RF_MODE_SW_SEL == RF_MODE_SW_NEW)				
			if(tKNL_RfModeSwInfo.ubModeUpdateFlg)
			{				
				//ubDropFlg = 1;				
				
				tKNL_RfModeSwInfo.ubModeUpdateFlg = 0;				
				
				if(tKNL_RfModeSwInfo.tMode == MODE_QPSKTO16QAM)
				{					
					printf("Mode Update -> QPSKTO16QAM\r\n");
					
					tKNL_RfModulationMode = MODE_16QAM;	
					BasebandRate = PREF_BBR_16QAM;					
				}	
				else if(tKNL_RfModeSwInfo.tMode == MODE_16QAM)
				{					
					printf("Mode Update -> 16QAM\r\n");					
					tKNL_RfModulationMode = MODE_16QAM;		
					BasebandRate = PREF_BBR_16QAM;
				}	
				else if(tKNL_RfModeSwInfo.tMode == MODE_QPSK)
				{					
					printf("Mode Update -> QPSK\r\n");					
					tKNL_RfModulationMode = MODE_QPSK;		
					BasebandRate = PREF_BBR_QPSK;
				}
				
				//Dynamic Modulation
				ulWaitSwCnt = 0;				
				while(ulWaitSwCnt < 30)
				{
					rf_getopt(RF_DRV_OPT_TX_FREE_BUF_CNT, &free_buf_count, &free_buf_count_len);
					if(free_buf_count == 64)
					{
						printf("Wait Done -> Ok\r\n");
						break;
					}
					osDelay(10);
					ulWaitSwCnt++;
				}	
				if(ulWaitSwCnt == 30)
				{
					printf("Wait Done -> Fail\r\n");
				}				
				
				rf_setopt(RF_SO_PREFBBR, &BasebandRate, sizeof(BasebandRate));
				
				//Dynamic Power Setting
				if(tKNL_RfModulationMode == MODE_QPSK)
				{					
					RTC676x_SetPower(RW_PWR_PKT_TX,RW_PWR_HIGH);
				}
				else if(tKNL_RfModulationMode == MODE_16QAM)
				{					
					RTC676x_SetPower(RW_PWR_PKT_TX,RW_PWR_MEDIUM);					
				}				
			}
			
			if(tKNL_RfModulationMode == MODE_QPSK)
			{
				if(rf_get_bandwidth_config() == BW_FULL_BANDWIDTH)
				{			
					if(KNL_GetEvenSlot() == 1200)
					{
						ubSlot1Flg = 1;
						ulMaxVdoPktLen = RW_S2M_SZ_QPSK_1T_1200;
					}
					else if(KNL_GetEvenSlot() == 1667)
					{
						ubSlot1Flg = 1;
						ulMaxVdoPktLen = RW_S2M_SZ_QPSK_1T_1667;						
					}
				}
				else
				{
					if(KNL_GetEvenSlot() == 1200)
					{
						ubSlot1Flg = 0;
						ulMaxVdoPktLen = RW_S2M_SZ_QPSK_NT_1200;	
					}
					else if(KNL_GetEvenSlot() == 1667)
					{
						ubSlot1Flg = 0;
						ulMaxVdoPktLen = RW_S2M_SZ_QPSK_NT_1667;
					}
				}		
			}
			else if(tKNL_RfModulationMode == MODE_16QAM)
			{
				if(rf_get_bandwidth_config() == BW_FULL_BANDWIDTH)
				{			
					if(KNL_GetEvenSlot() == 1200)
					{
						ubSlot1Flg = 1;
						ulMaxVdoPktLen = RW_S2M_SZ_16QAM_1T_1200;
					}
					else if(KNL_GetEvenSlot() == 1667)
					{
						ubSlot1Flg = 1;
						ulMaxVdoPktLen = RW_S2M_SZ_16QAM_1T_1667;						
					}
				}
				else
				{
					if(KNL_GetEvenSlot() == 1200)
					{
						ubSlot1Flg = 0;
						ulMaxVdoPktLen = RW_S2M_SZ_16QAM_NT_1200;	
					}
					else if(KNL_GetEvenSlot() == 1667)
					{
						ubSlot1Flg = 0;
						ulMaxVdoPktLen = RW_S2M_SZ_16QAM_NT_1667;
					}
				}		
			}				
			
			if(tKNL_RfModeSwInfo.ubRcUpdateFlg)
			{
				printf("RC Update\r\n");
				
				tKNL_RfModeSwInfo.ubRcUpdateFlg = 0;
				
				if(RC_MODE_DYNAMIC_FPS2 == ubRC_GetOpMode((H264_ENCODE_INDEX)ENCODE_0))
				{
					if(tKNL_RfModulationMode == MODE_16QAM)						
					{
						//RC_DynamicFpsMode(ubKNL_GetSysMaxFps(),RC_MIN_FPS,RC_SECTION_NUM,fKNL_PreRatio*0.9);
						printf("SysMaxFps:%d\r\n",ubKNL_GetSysMaxFps());						
						RC_DynamicFpsMode(ubKNL_GetSysMaxFps(),ubKNL_GetSysMaxFps(),1,fKNL_PreRatio*0.9);						
					}
					else if(tKNL_RfModulationMode == MODE_QPSK)
					{
						printf("SysMaxFps:%d\r\n",ubKNL_GetSysMaxFps());
						RC_DynamicFpsMode(ubKNL_GetSysMaxFps(),RC_MIN_FPS,RC_SECTION_NUM,1);
					}
				}
			}
		#endif
			
			if(	(ulMaxVdoPktLen == RW_S2M_SZ_BPSK_1T_1200)||
				(ulMaxVdoPktLen == RW_S2M_SZ_BPSK_1T_1667)||
				(ulMaxVdoPktLen == RW_S2M_SZ_QPSK_1T_1200)||
				(ulMaxVdoPktLen == RW_S2M_SZ_QPSK_1T_1667)||
				(ulMaxVdoPktLen == RW_S2M_SZ_16QAM_1T_1200)||
				(ulMaxVdoPktLen == RW_S2M_SZ_16QAM_1T_1667)	)
			{
				ubSlot1Flg = 1;
			}
			else
			{
				ubSlot1Flg = 0;
			}			
			
			ulVdoPayloadSz = ulMaxVdoPktLen-PKT_HEADER_SZ;
			
			ulActiveLen = tProc.ulSize;		
			//uwTotalPktNum = (tProc.ulSize+(PKT_PAYLOAD_SZ-1))/PKT_PAYLOAD_SZ;
			//uwTotalPktNum = (tProc.ulSize+4+(PKT_VDO_PAYLOAD_SZ-1))/PKT_VDO_PAYLOAD_SZ;	//4 Bytes for Active Length
			uwTotalPktNum = (tProc.ulSize+4+(ulVdoPayloadSz-1))/ulVdoPayloadSz;	//4 Bytes for Active Length			
			if(uwTotalPktNum >= 256)
				printf("Err-Over Max PktNum:%d\r\n",uwTotalPktNum);
			
			uwAckPktNum  = 0;
			for(i=0;i<uwTotalPktNum;i++)
			{
				ubPktStatus[i] = PKT_STATUS_NACK;
			}
			
			//Get Frame Buffer		
			ulPktBufAddr = ulBUF_GetBlkBufAddr(0,BUF_RW_FRAME);
			
			//(1)Add Header Information to Packet
			//(2)Copy Frame to Packetize
			ubTotalIdx = ubKNL_VdoTotalIdx[tProc.ubCodecIdx]++;
			for(i=0;i<uwTotalPktNum;i++)			
			{
			#if 1
				//Header
				*(uint8_t *)(ulPktBufAddr+(ulMaxVdoPktLen*(uint32_t)i)+PKT_INFO_OFS_MODE) 		= (KNL_CurRwBbRateMode & 0x0F)+(ubSlot1Flg<<4);	//New
				*(uint8_t *)(ulPktBufAddr+(ulMaxVdoPktLen*(uint32_t)i)+PKT_INFO_OFS_RSV) 		= 0;					//New
				
				*(uint8_t *)(ulPktBufAddr+(ulMaxVdoPktLen*(uint32_t)i)+PKT_INFO_OFS_TYPE) 		= tProc.tPktType;
				
				*(uint8_t *)(ulPktBufAddr+(ulMaxVdoPktLen*(uint32_t)i)+PKT_INFO_OFS_ROLE) 		= ubKNL_GetRole();
				*(uint8_t *)(ulPktBufAddr+(ulMaxVdoPktLen*(uint32_t)i)+PKT_INFO_OFS_SRCNUM)		= tProc.ubSrcNum;
				*(uint8_t *)(ulPktBufAddr+(ulMaxVdoPktLen*(uint32_t)i)+PKT_INFO_OFS_TOTAL_IDX)	= ubTotalIdx;
				
				*(uint8_t *)(ulPktBufAddr+(ulMaxVdoPktLen*(uint32_t)i)+PKT_INFO_OFS_TOTAL_NUM+0)	= (uwTotalPktNum & 0x00FF);
				*(uint8_t *)(ulPktBufAddr+(ulMaxVdoPktLen*(uint32_t)i)+PKT_INFO_OFS_TOTAL_NUM+1)	= (uwTotalPktNum & 0xFF00) >> 8;
				
				*(uint8_t *)(ulPktBufAddr+(ulMaxVdoPktLen*(uint32_t)i)+PKT_INFO_OFS_FRM_IDX+0)	= (tProc.ulIdx & 0x00FF);
				*(uint8_t *)(ulPktBufAddr+(ulMaxVdoPktLen*(uint32_t)i)+PKT_INFO_OFS_FRM_IDX+1)	= (tProc.ulIdx & 0xFF00) >> 8;
				
				*(uint8_t *)(ulPktBufAddr+(ulMaxVdoPktLen*(uint32_t)i)+PKT_INFO_OFS_PKT_IDX+0)	= (i & 0x00FF);
				*(uint8_t *)(ulPktBufAddr+(ulMaxVdoPktLen*(uint32_t)i)+PKT_INFO_OFS_PKT_IDX+1)	= (i & 0xFF00) >> 8;								
								
				uwChkSum = 0;
				for(k=0;k<PKT_ACTIVE_HEADER_SZ;k++)
				{
					//uwChkSum = uwChkSum + *(uint8_t *)(ulPktBufAddr+(ulMaxVdoPktLen*(uint32_t)i)+PKT_INFO_OFS_TYPE+k);
					uwChkSum = uwChkSum + *(uint8_t *)(ulPktBufAddr+(ulMaxVdoPktLen*(uint32_t)i)+PKT_INFO_OFS_MODE+k);
				}
				*(uint8_t *)(ulPktBufAddr+(ulMaxVdoPktLen*(uint32_t)i)+PKT_INFO_OFS_CHKSUM+0)	= (uwChkSum & 0x00FF);
				*(uint8_t *)(ulPktBufAddr+(ulMaxVdoPktLen*(uint32_t)i)+PKT_INFO_OFS_CHKSUM+1)	= (uwChkSum & 0xFF00) >> 8;
							
				//Payload
				memcpy((uint8_t *)(ulPktBufAddr+PKT_HEADER_SZ+(ulMaxVdoPktLen*(uint32_t)i)),(uint8_t *)(tProc.ulDramAddr2+(ulVdoPayloadSz*(uint32_t)i)),ulVdoPayloadSz);										
				//tDMAC_MemCopy((uint32_t)(tProc.ulDramAddr2+(ulVdoPayloadSz*(uint32_t)i)), (uint32_t)(ulPktBufAddr+PKT_HEADER_SZ+(ulMaxVdoPktLen*(uint32_t)i)),ulVdoPayloadSz, NULL);
				
				if(i == (uwTotalPktNum-1))	//Add Active Length
				{
					*(uint8_t *)(ulPktBufAddr+(ulMaxVdoPktLen*(uint32_t)i)+ulMaxVdoPktLen-4)	= (ulActiveLen & 0x000000FF) >> 0;
					*(uint8_t *)(ulPktBufAddr+(ulMaxVdoPktLen*(uint32_t)i)+ulMaxVdoPktLen-3)	= (ulActiveLen & 0x0000FF00) >> 8;
					*(uint8_t *)(ulPktBufAddr+(ulMaxVdoPktLen*(uint32_t)i)+ulMaxVdoPktLen-2)	= (ulActiveLen & 0x00FF0000) >> 16;
					*(uint8_t *)(ulPktBufAddr+(ulMaxVdoPktLen*(uint32_t)i)+ulMaxVdoPktLen-1)	= (ulActiveLen & 0xFF000000) >> 24;
				}
			#endif				
				
			
			}
			
			//while(uwAckPktNum < uwTotalPktNum)
			//while((uwAckPktNum < uwTotalPktNum) && ubKNL_ChkVdoFlowAct(tProc.ubSrcNum))
			while((uwAckPktNum < uwTotalPktNum) && ubKNL_ChkVdoFlowAct(tProc.ubSrcNum) && (!ubDropFlg))			
			{
				ubRunTimes++;

				if((ubRunTimes % 8) == 0)
				{
					osDelay(20);
				}
				
				if(ubKNL_StopTrxFlg[0])
				{						
					printf("(VDO11)Force to break\r\n");
					//Dummy Send					
					uwAckPktNum = uwTotalPktNum;//Force to break;						
					osDelay(20);
					break;
				}
				
				if(ubDropFlg)
				{
					printf("(VDO21)Force to break\r\n");					
					//Dummy Send
					uwAckPktNum = uwTotalPktNum;//Force to break;						
					osDelay(20);
					break;
				}				
				
				//Master side get id of slaves at index 0 ~ 3
				//Slave side get master id at index 0
				Id = rf_get_remote_id(0);
				
				ubLinkStatus = rf_get_link_status(rf_get_remote_id(0));
				//ubLinkStatus = ubKNL_GetCommLinkStatus(0);	//Don't care input parameter @Cam			
				
				if((uwTotalPktNum - uwAckPktNum) >= MAX_PKT_ACC_ACK)
				{
					ubPktSendThisRun = MAX_PKT_ACC_ACK;
				}
				else
				{
					ubPktSendThisRun = uwTotalPktNum - uwAckPktNum;
				}	

				//Initial
				j = 0;
				udlAck = 0;
				ubTemp = 0;					
		
				for(i=0;i<uwTotalPktNum;i++)
				{				
					if(ubPktStatus[i] != PKT_STATUS_ACK)
					{
						uwPktSendMap[j] = i;
						
						if(ubLinkStatus && ubKNL_ChkVdoFlowAct(tProc.ubSrcNum))						
						//if(ubKNL_GetRtCommLinkStatus(0))	//Don't care input parameter @Cam
						{
							//ulSendAddr = ulPktBufAddr+(MAX_VDO_PACKET_LEN*(uint32_t)i);
							ulSendAddr = ulPktBufAddr+(ulMaxVdoPktLen*(uint32_t)i);
							
							if(ubTemp != (ubPktSendThisRun-1))
							{								
								//Free Packet Buffer Check
								ubWaitDlyCnt = 0;								
								rf_getopt(RF_DRV_OPT_TX_FREE_BUF_CNT, &free_buf_count, &free_buf_count_len);	
							
								while((free_buf_count < 3) && ubKNL_ChkVdoFlowAct(tProc.ubSrcNum) && (!ubKNL_StopTrxFlg[0])&& (!ubDropFlg))
								{										
									//-------------------------------------------
									if(!rf_get_link_status(rf_get_remote_id(0)))
										break;								
									//===========================================
									osDelay(20);
									
									ubWaitDlyCnt++;									
									if(ubWaitDlyCnt > ubWaitMaxDlyTh)
									{
										printf("VT1\r\n");
										break;
									}
									rf_getopt(RF_DRV_OPT_TX_FREE_BUF_CNT, &free_buf_count, &free_buf_count_len);
								}																
								
								result = rf_send_video_packet((uint8_t *)ulSendAddr, ulMaxVdoPktLen, 0, Id, &udlAckTemp);								
								//result = iKNL_SendPacket(COMM_DATA_TYPE_VDO,(uint8_t *)ulSendAddr, ulMaxVdoPktLen, 0, Id, &udlAckTemp);								
								
								if(result != ulMaxVdoPktLen)
								{
									if(result != COMM_NACK)
										printf("VF1:%d\r\n",result);
									
									ubTimeOutCnt = 0;									
									while(((result == COMM_TRY_AGAIN_1) || (result == COMM_TRY_AGAIN_2)|| (result == COMM_TIMEOUT_1)|| (result == COMM_TIMEOUT_2))&& (!ubKNL_StopTrxFlg[0]) && (!ubDropFlg))									
									{										
										//-------------------------------------------
										if(!rf_get_link_status(rf_get_remote_id(0)))
											break;								
										//===========================================									
										osDelay(20);									
										
										ubTimeOutCnt++;
										if(ubTimeOutCnt > ubTimeOutMaxTh)
										{
											printf("VF1-TimeOut:%d\r\n",result);
											break;
										}
										
										result = rf_send_video_packet((uint8_t *)ulSendAddr, ulMaxVdoPktLen, 0, Id, &udlAckTemp);										
										//result = iKNL_SendPacket(COMM_DATA_TYPE_VDO,(uint8_t *)ulSendAddr, ulMaxVdoPktLen, 0, Id, &udlAckTemp);										
									}									
								}								
							}
							else
							{								
								//Free Packet Buffer Check
								ubWaitDlyCnt = 0;								
								rf_getopt(RF_DRV_OPT_TX_FREE_BUF_CNT, &free_buf_count, &free_buf_count_len);								
								while((free_buf_count < 3) && ubKNL_ChkVdoFlowAct(tProc.ubSrcNum)&& (!ubKNL_StopTrxFlg[0]) && (!ubDropFlg))
								{										
									//-------------------------------------------
									if(!rf_get_link_status(rf_get_remote_id(0)))
										break;								
									//===========================================
									osDelay(20);
									
									ubWaitDlyCnt++;									
									if(ubWaitDlyCnt > ubWaitMaxDlyTh)
									{
										printf("VT2\r\n");
										break;
									}
									rf_getopt(RF_DRV_OPT_TX_FREE_BUF_CNT, &free_buf_count, &free_buf_count_len);
								}											
								
								result = rf_send_video_packet((uint8_t *)ulSendAddr, ulMaxVdoPktLen, MSG_REQACK, Id, &udlAck);								
								//result = iKNL_SendPacket(COMM_DATA_TYPE_VDO,(uint8_t *)ulSendAddr, ulMaxVdoPktLen, MSG_REQACK, Id, &udlAck);								
								
								if(result != ulMaxVdoPktLen)
								{
									if(result != COMM_NACK)
										printf("VF2:%d\r\n",result);
									
									ubTimeOutCnt = 0;									
									while(((result == COMM_TRY_AGAIN_1) || (result == COMM_TRY_AGAIN_2)|| (result == COMM_TIMEOUT_1)|| (result == COMM_TIMEOUT_2)) && (!ubKNL_StopTrxFlg[0])&& (!ubDropFlg))
									{
										//-------------------------------------------
										if(!rf_get_link_status(rf_get_remote_id(0)))
											break;								
										//===========================================
										osDelay(20);
										
										ubTimeOutCnt++;
										if(ubTimeOutCnt > ubTimeOutMaxTh)
										{
											printf("VF2-TimeOut:%d\r\n",result);
											break;
										}
										
										result = rf_send_video_packet((uint8_t *)ulSendAddr, ulMaxVdoPktLen, MSG_REQACK, Id, &udlAck);										
										//result = iKNL_SendPacket(COMM_DATA_TYPE_VDO,(uint8_t *)ulSendAddr, ulMaxVdoPktLen, MSG_REQACK, Id, &udlAck);										
									}									
								}							
							}
						}
						j++;
						ubTemp++;					
					}
					if(ubTemp >= ubPktSendThisRun)
					{
						break;
					}
				}			
				

				ubTemp2 = 0;
				
				for(i=0;i<ubPktSendThisRun;i++)
				{				
					//Take-Care Bit-Mapping
					//if(udlAck & (((uint64_t)0x01)<<i))
					if(udlAck & (((uint64_t)0x01)<<(ubPktSendThisRun-1-i)))
					{
						ubPktStatus[uwPktSendMap[i]] = PKT_STATUS_ACK;
						uwAckPktNum++;
						ubTemp2++;
						
						PKT_UpdateInfo(KNL_ACK_OK);
					}
					else
					{
						PKT_UpdateInfo(KNL_ACK_FAIL);
					}
				}			

				
				//printf("(TN,AN,SN,AN,F:%d,%d,%d,%d,%d)\r\n",uwTotalPktNum,uwAckPktNum,ubPktSendThisRun,ubTemp2,ubAckPkt);
	//			if(ubTemp2 != ubPktSendThisRun)
	//			{
	//				printf("(%d,%d)\r\n",ubPktSendThisRun,ubTemp2);
	//			}	
				if(ubLinkStatus == 0)//Lost-Link Case
				{
					//Dummy Send					
					uwAckPktNum = uwTotalPktNum;//Force to break;						
					osDelay(20);
					break;
				}
				if(ubKNL_StopTrxFlg[0])
				{						
					printf("(VDO12)Force to break\r\n");					
					break;
				}
				
				if(ubDropFlg)
				{
					printf("(VDO22)Force to break\r\n");					
					break;	
				}				
			}
					
			if(tProc.ubIsBigBuf)
			{
				if(ubBUF_ReleaseVdoPacketizeBigBuf(tProc.ulDramAddr2) != BUF_OK)
				{
					printf("Fail @%s\r\n",__func__);
				}	
			}
			else
			{
				if(ubBUF_ReleaseVdoPacketizeSmallBuf(tProc.ulDramAddr2) != BUF_OK)
				{
					printf("Fail @%s\r\n",__func__);
				}	
			}
			
			//printf("F(%d,%d)\r\n",uwTotalPktNum,ubRunTimes);		
			//printf("F(%d)\r\n",tProc.ulIdx);
			//printf("F-%d,0x%x,0x%x\r\n",tProc.ulIdx,ulActiveLen,uwTotalPktNum*PKT_PAYLOAD_SZ);
		}
		else
		{
			if(tProc.ubIsBigBuf)
			{
				if(ubBUF_ReleaseVdoPacketizeBigBuf(tProc.ulDramAddr2) != BUF_OK)
				{
					printf("Fail @%s\r\n",__func__);
				}
			}
			else
			{
				if(ubBUF_ReleaseVdoPacketizeBigBuf(tProc.ulDramAddr2) != BUF_OK)
				{
					printf("Fail @%s\r\n",__func__);
				}
			}
		}		
		
		if(ubDropFlg)
		{
			ubDropFlg = 0;
			printf("Switch Done\r\n");
		}
	}
}
#endif	

uint8_t ubKNL_AdoTotalIdx[4] = {0,0,0,0};
//------------------------------------------------------------------------------
#ifdef RTC676x
static void KNL_AdoPacketizeProcThread(void const *argument)
{
#if defined(RTC676x)
#if APP_RTC676X_FOTA_ENABLE	
	uint8_t ubErrEndFlg = 0;
#endif
#endif
	uint16_t uwChkSum;	//Check for Header
	uint8_t ubChkSum;
	
	
	int free_buf_count = 0;
    size_t free_buf_count_len = sizeof(free_buf_count);
	uint8_t ubWaitDlyCnt = 0;
	uint8_t ubWaitMaxDlyTh = 50;
	
	uint8_t ubTimeOutCnt = 0;
	uint8_t ubTimeOutMaxTh = 5;
	
	int result;
	KNL_PROCESS tProc;	
	uint16_t i,j,k;				//Take care "Type"	
	uint16_t uwTotalPktNum;		//Total Packet Number
	uint16_t uwAckPktNum;		//Ack Packet Number
	uint32_t ulPktBufAddr;
	uint32_t ulSendAddr;
	int Id;
	uint64_t udlAck = 0,udlAckTemp = 0;
	uint8_t ubTotalIdx = 0;
	uint8_t ubLinkStatus = 0;
	
	uint8_t ubPktSendThisRun;
	uint8_t ubRunTimes = 0;
	uint8_t ubTemp = 0;
	uint8_t ubTemp2 = 0;
	//uint8_t ubAckPkt = 0;	
	
	uint16_t uwPktSendMap[64];	//Take care "Type"
	
	uint8_t ubPktStatus[256];	//Max Frame Size -> 256*PKT_PAYLOAD_SZ = 192KB
								//0->Not Yet, 1->Ok		
								
	uint32_t ulActiveLen = 0;	//Bitstream Size + Aux Size
	result = result;
	
	while(1)
	{
		osMessageGet(KNL_AdoPacketizeQue, &tProc, osWaitForever);
		if(ubKNL_ChkAdoFlowAct(tProc.ubSrcNum) || (tProc.ubNextNode == KNL_NODE_MSC_ADO) || (KNL_NODE_BDG_PTT == tProc.ubCurNode))		
		{	
		#if defined(RTC676x)
		#if APP_RTC676X_FOTA_ENABLE		
			ubErrEndFlg = 0;
		#endif
		#endif
			
			ubRunTimes = 0;	//For Debug
			
			//Initial
			ulActiveLen = tProc.ulSize;		
			//uwTotalPktNum = (tProc.ulSize+(PKT_PAYLOAD_SZ-1))/PKT_PAYLOAD_SZ;
			//uwTotalPktNum = (tProc.ulSize+4+(PKT_PAYLOAD_SZ-1))/PKT_PAYLOAD_SZ;	//4 Bytes for Active Length
			uwTotalPktNum = (tProc.ulSize+4+(PKT_ADO_PAYLOAD_SZ-1))/PKT_ADO_PAYLOAD_SZ;	//4 Bytes for Active Length
			
			
			uwAckPktNum  = 0;
			for(i=0;i<uwTotalPktNum;i++)
			{
				ubPktStatus[i] = PKT_STATUS_NACK;
			}
			
			//Get "Audio" Frame Buffer		
			ulPktBufAddr = ulBUF_GetBlkBufAddr(0,BUF_RW_FRAME)+BUF_SZ_MAX_VDO;
			
			//(1)Add Header Information to Packet
			//(2)Copy Frame to Packetize
			ubTotalIdx = ubKNL_AdoTotalIdx[tProc.ubCodecIdx]++;
			for(i=0;i<uwTotalPktNum;i++)			
			{				
				//Header				
				*(uint8_t *)(ulPktBufAddr+(MAX_ADO_PACKET_LEN*(uint32_t)i)+PKT_INFO_OFS_MODE) 		= KNL_CurRwBbRateMode;	//New
				*(uint8_t *)(ulPktBufAddr+(MAX_ADO_PACKET_LEN*(uint32_t)i)+PKT_INFO_OFS_RSV) 		= 0;					//New				
				
				*(uint8_t *)(ulPktBufAddr+(MAX_ADO_PACKET_LEN*(uint32_t)i)+PKT_INFO_OFS_TYPE) 		= tProc.tPktType;
				
				*(uint8_t *)(ulPktBufAddr+(MAX_ADO_PACKET_LEN*(uint32_t)i)+PKT_INFO_OFS_ROLE) 		= ubKNL_GetRole();
				*(uint8_t *)(ulPktBufAddr+(MAX_ADO_PACKET_LEN*(uint32_t)i)+PKT_INFO_OFS_SRCNUM)		= tProc.ubSrcNum;
				*(uint8_t *)(ulPktBufAddr+(MAX_ADO_PACKET_LEN*(uint32_t)i)+PKT_INFO_OFS_TOTAL_IDX)	= ubTotalIdx;
				
				*(uint8_t *)(ulPktBufAddr+(MAX_ADO_PACKET_LEN*(uint32_t)i)+PKT_INFO_OFS_TOTAL_NUM+0)	= (uwTotalPktNum & 0x00FF);
				*(uint8_t *)(ulPktBufAddr+(MAX_ADO_PACKET_LEN*(uint32_t)i)+PKT_INFO_OFS_TOTAL_NUM+1)	= (uwTotalPktNum & 0xFF00) >> 8;
				
				*(uint8_t *)(ulPktBufAddr+(MAX_ADO_PACKET_LEN*(uint32_t)i)+PKT_INFO_OFS_FRM_IDX+0)	= (tProc.ulIdx & 0x00FF);
				*(uint8_t *)(ulPktBufAddr+(MAX_ADO_PACKET_LEN*(uint32_t)i)+PKT_INFO_OFS_FRM_IDX+1)	= (tProc.ulIdx & 0xFF00) >> 8;
				
				*(uint8_t *)(ulPktBufAddr+(MAX_ADO_PACKET_LEN*(uint32_t)i)+PKT_INFO_OFS_PKT_IDX+0)	= (i & 0x00FF);
				*(uint8_t *)(ulPktBufAddr+(MAX_ADO_PACKET_LEN*(uint32_t)i)+PKT_INFO_OFS_PKT_IDX+1)	= (i & 0xFF00) >> 8;
				
				
				
				//Payload
				memcpy((uint8_t *)(ulPktBufAddr+PKT_HEADER_SZ+(MAX_ADO_PACKET_LEN*(uint32_t)i)),(uint8_t *)(tProc.ulDramAddr2+(PKT_ADO_PAYLOAD_SZ*(uint32_t)i)),PKT_ADO_PAYLOAD_SZ);						
				//printf("B[%d]:0x%x\r\n",(PKT_PAYLOAD_SZ*i),*(uint8_t *)(ulPktBufAddr+PKT_HEADER_SZ+(MAX_PACKET_LEN*i)));
				
				if(i == (uwTotalPktNum-1))	//Add Active Length
				{
					*(uint8_t *)(ulPktBufAddr+(MAX_ADO_PACKET_LEN*(uint32_t)i)+MAX_ADO_PACKET_LEN-4)	= (ulActiveLen & 0x000000FF) >> 0;
					*(uint8_t *)(ulPktBufAddr+(MAX_ADO_PACKET_LEN*(uint32_t)i)+MAX_ADO_PACKET_LEN-3)	= (ulActiveLen & 0x0000FF00) >> 8;
					*(uint8_t *)(ulPktBufAddr+(MAX_ADO_PACKET_LEN*(uint32_t)i)+MAX_ADO_PACKET_LEN-2)	= (ulActiveLen & 0x00FF0000) >> 16;
					*(uint8_t *)(ulPktBufAddr+(MAX_ADO_PACKET_LEN*(uint32_t)i)+MAX_ADO_PACKET_LEN-1)	= (ulActiveLen & 0xFF000000) >> 24;
				}
				
				//Check for Payload
				//---------------------------------------------------------------------------------------------------------------
				ubChkSum = 0;
				for(k=0;k<(MAX_ADO_PACKET_LEN-PKT_HEADER_SZ);k++)
				{										
					//ubChkSum = ubChkSum + *(uint8_t *)(ulPktBufAddr+PKT_HEADER_SZ+k);
					ubChkSum = ubChkSum + *(uint8_t *)(ulPktBufAddr+(MAX_ADO_PACKET_LEN*(uint32_t)i)+PKT_HEADER_SZ+k);
				}
				*(uint8_t *)(ulPktBufAddr+(MAX_ADO_PACKET_LEN*(uint32_t)i)+PKT_INFO_OFS_RSV) 		= ubChkSum;					//New
				//===============================================================================================================
				
				//Check for Header				
				//---------------------------------------------------------------------------------------------------------------
				uwChkSum = 0;				
				for(k=0;k<PKT_ACTIVE_HEADER_SZ;k++)
				{									
					uwChkSum = uwChkSum + *(uint8_t *)(ulPktBufAddr+(MAX_ADO_PACKET_LEN*(uint32_t)i)+PKT_INFO_OFS_MODE+k);
				}
				*(uint8_t *)(ulPktBufAddr+(MAX_ADO_PACKET_LEN*(uint32_t)i)+PKT_INFO_OFS_CHKSUM+0)	= (uwChkSum & 0x00FF);
				*(uint8_t *)(ulPktBufAddr+(MAX_ADO_PACKET_LEN*(uint32_t)i)+PKT_INFO_OFS_CHKSUM+1)	= (uwChkSum & 0xFF00) >> 8;
				//===============================================================================================================
				
			}
			
			//while(uwAckPktNum < uwTotalPktNum)
			while((uwAckPktNum < uwTotalPktNum) && (ubKNL_ChkAdoFlowAct(tProc.ubSrcNum) || (tProc.ubNextNode == KNL_NODE_MSC_ADO) || (KNL_NODE_BDG_PTT == tProc.ubCurNode)))
			{
				ubRunTimes++;	

				if((ubRunTimes % 8) == 0)
				{
					osDelay(10);
				}

				if(ubKNL_StopTrxFlg[1])
				{	
				#if defined(RTC676x)
				#if APP_RTC676X_FOTA_ENABLE			
					if(tProc.tPktType == PKT_FOTA)			
						ubErrEndFlg = 1;
				#endif
				#endif
					printf("(ADO)Force to Break\r\n");
					break;
				}
				
				//Master side get id of slaves at index 0 ~ 3
				//Slave side get master id at index 0
			#ifdef OP_STA			
				Id = rf_get_remote_id(0);				
				ubLinkStatus = rf_get_link_status(rf_get_remote_id(0));
			#endif
			#ifdef OP_AP
#if defined(BSP_DVR_SDK)
                if(ubKNL_GetSrcNumPosition((KNL_SRC)tProc.ubSrcNum) != KNL_LOCAL)
#endif
                {
					uint8_t ubAdoRole;

					ubAdoRole = ubKNL_SrcNumMap(tProc.ubSrcNum);
					ubAdoRole = ubKNL_GetStaInfo(KNL_ROLENUM, ubAdoRole);
					if(0xFF == ubAdoRole)
					{
						printd(DBG_ErrorLvl, "Role Number Err @%s !\n", __func__);
						break;
					}
    				Id = rf_get_remote_id(ubAdoRole);				
    				ubLinkStatus = rf_get_link_status(rf_get_remote_id(ubAdoRole));
                }
			#endif
				//ubLinkStatus = ubKNL_GetCommLinkStatus(0);	//Don't care input parameter @Cam			
				
				if((uwTotalPktNum - uwAckPktNum) >= MAX_PKT_ACC_ACK)
				{
					ubPktSendThisRun = MAX_PKT_ACC_ACK;
				}
				else
				{
					ubPktSendThisRun = uwTotalPktNum - uwAckPktNum;
				}	

				//Initial
				j = 0;
				udlAck = 0;
				ubTemp = 0;
				//ubAckPkt = 0;			
		
				for(i=0;i<uwTotalPktNum;i++)
				{				
					if(ubPktStatus[i] != PKT_STATUS_ACK)
					{
						uwPktSendMap[j] = i;		
						
						//if(rf_get_link_status(rf_get_remote_id(0)))
						if(ubLinkStatus && (ubKNL_ChkAdoFlowAct(tProc.ubSrcNum) || (tProc.ubNextNode == KNL_NODE_MSC_ADO) || (KNL_NODE_BDG_PTT == tProc.ubCurNode)))
						//if(ubKNL_GetRtCommLinkStatus(0))	//Don't care input parameter @Cam
						{
							ulSendAddr = ulPktBufAddr+(MAX_ADO_PACKET_LEN*(uint32_t)i);
							
							if(ubTemp != (ubPktSendThisRun-1))
							{														
								//Free Packet Buffer Check
								ubWaitDlyCnt = 0;								
								rf_getopt(RF_DRV_OPT_TX_FREE_BUF_CNT, &free_buf_count, &free_buf_count_len);									
								//while((free_buf_count < 3) && (ubKNL_ChkVdoFlowAct(tProc.ubSrcNum) || (KNL_NODE_BDG_PTT == tProc.ubCurNode)) && (!ubKNL_StopTrxFlg[1]))
								while((free_buf_count < 3) && ((KNL_NODE_BDG_PTT == tProc.ubCurNode)) && (!ubKNL_StopTrxFlg[1]))
								{										
								#if OP_STA									
									//-------------------------------------------
									if(!rf_get_link_status(rf_get_remote_id(0)))
										break;								
									//===========================================
								#endif
									osDelay(20);
									
									ubWaitDlyCnt++;									
									if(ubWaitDlyCnt > ubWaitMaxDlyTh)
									{
										printf("AT1\r\n");
										break;
									}
									rf_getopt(RF_DRV_OPT_TX_FREE_BUF_CNT, &free_buf_count, &free_buf_count_len);
								}								
								
								//KNL_StartChkATimeOut();
								result = rf_send_audio_packet((uint8_t *)ulSendAddr, MAX_ADO_PACKET_LEN, 0, Id, &udlAckTemp);	
								//KNL_StopChkATimeOut();
								//result = iKNL_SendPacket(COMM_DATA_TYPE_ADO,(uint8_t *)ulSendAddr, MAX_ADO_PACKET_LEN, 0, Id, &udlAckTemp);								
								
								
								if(result != MAX_ADO_PACKET_LEN)
								{
									if(result != COMM_NACK)
										printf("AF1:%d\r\n",result);
								
									ubTimeOutCnt = 0;									
									while(((result == COMM_TRY_AGAIN_1) || (result == COMM_TRY_AGAIN_2)|| (result == COMM_TIMEOUT_1)|| (result == COMM_TIMEOUT_2)) && (!ubKNL_StopTrxFlg[1]))
									{
									#if OP_STA									
									//-------------------------------------------
										if(!rf_get_link_status(rf_get_remote_id(0)))
											break;								
									//===========================================
									#endif
										osDelay(20);
										
										ubTimeOutCnt++;
										if(ubTimeOutCnt > ubTimeOutMaxTh)
										{
											printf("AF1-TimeOut:%d\r\n",result);
											break;
										}
										
										//KNL_StartChkATimeOut();
										result = rf_send_audio_packet((uint8_t *)ulSendAddr, MAX_ADO_PACKET_LEN, 0, Id, &udlAckTemp);										
										//KNL_StopChkATimeOut();
										//result = iKNL_SendPacket(COMM_DATA_TYPE_ADO,(uint8_t *)ulSendAddr, MAX_ADO_PACKET_LEN, 0, Id, &udlAckTemp);									
									}									
									
								}								
							}
							else
							{							
								//Free Packet Buffer Check
								ubWaitDlyCnt = 0;								
								rf_getopt(RF_DRV_OPT_TX_FREE_BUF_CNT, &free_buf_count, &free_buf_count_len);									
								//while((free_buf_count < 3) && (ubKNL_ChkVdoFlowAct(tProc.ubSrcNum) || (KNL_NODE_BDG_PTT == tProc.ubCurNode)) && (!ubKNL_StopTrxFlg[1]))
								while((free_buf_count < 3) && ((KNL_NODE_BDG_PTT == tProc.ubCurNode)) && (!ubKNL_StopTrxFlg[1]))
								{										
								#if OP_STA									
								//-------------------------------------------
									if(!rf_get_link_status(rf_get_remote_id(0)))
										break;								
								//===========================================
								#endif
									osDelay(20);
									
									ubWaitDlyCnt++;									
									if(ubWaitDlyCnt > ubWaitMaxDlyTh)
									{
										printf("AT2\r\n");
										break;
									}
									rf_getopt(RF_DRV_OPT_TX_FREE_BUF_CNT, &free_buf_count, &free_buf_count_len);
								}							
								
								//KNL_StartChkATimeOut();
								result = rf_send_audio_packet((uint8_t *)ulSendAddr, MAX_ADO_PACKET_LEN, MSG_REQACK, Id, &udlAck);								
								//KNL_StopChkATimeOut();
								//result = iKNL_SendPacket(COMM_DATA_TYPE_ADO,(uint8_t *)ulSendAddr, MAX_ADO_PACKET_LEN, MSG_REQACK, Id, &udlAck);								
								
								if(result != MAX_ADO_PACKET_LEN)
								{
									if(result != COMM_NACK)
										printf("AF2:%d\r\n",result);
									
									ubTimeOutCnt = 0;									
									while(((result == COMM_TRY_AGAIN_1) || (result == COMM_TRY_AGAIN_2)|| (result == COMM_TIMEOUT_1)|| (result == COMM_TIMEOUT_2)) && (!ubKNL_StopTrxFlg[1]))
									{
									#if OP_STA									
									//-------------------------------------------
										if(!rf_get_link_status(rf_get_remote_id(0)))
											break;								
									//===========================================
									#endif
										osDelay(20);
										
										ubTimeOutCnt++;
										if(ubTimeOutCnt > ubTimeOutMaxTh)
										{
											printf("AF2-TimeOut:%d\r\n",result);
											break;
										}
										//KNL_StartChkATimeOut();
										result = rf_send_audio_packet((uint8_t *)ulSendAddr, MAX_ADO_PACKET_LEN, MSG_REQACK, Id, &udlAck);										
										//KNL_StopChkATimeOut();
										//result = iKNL_SendPacket(COMM_DATA_TYPE_ADO,(uint8_t *)ulSendAddr, MAX_ADO_PACKET_LEN, MSG_REQACK, Id, &udlAck);										
									}									
								}							
							}
						}
						j++;
						ubTemp++;					
					}
					if(ubTemp >= ubPktSendThisRun)
					{
						break;
					}
				}			
				

				ubTemp2 = 0;
				
				for(i=0;i<ubPktSendThisRun;i++)
				{				
					//Take-Care Bit-Mapping
					//if(udlAck & (((uint64_t)0x01)<<i))
					if(udlAck & (((uint64_t)0x01)<<(ubPktSendThisRun-1-i)))
					{
						ubPktStatus[uwPktSendMap[i]] = PKT_STATUS_ACK;
						uwAckPktNum++;
						ubTemp2++;
						
						//PKT_UpdateInfo(KNL_ACK_OK);
					}
					else
					{
						//PKT_UpdateInfo(KNL_ACK_FAIL);
					}
				}			

				
	//			printf("(TN,AN,SN,AN,F:%d,%d,%d,%d)\r\n",uwTotalPktNum,uwAckPktNum,ubPktSendThisRun,ubTemp2);
	//			if(ubTemp2 != ubPktSendThisRun)
	//			{
	//				printf("(%d,%d)\r\n",ubPktSendThisRun,ubTemp2);
	//			}	
				if(ubLinkStatus == 0)//Lost-Link Case
				{
				#if defined(RTC676x)
				#if APP_RTC676X_FOTA_ENABLE		
					if(tProc.tPktType == PKT_FOTA)			
						ubErrEndFlg = 1;
				#endif
				#endif
					
					//Dummy Send					
					uwAckPktNum = uwTotalPktNum;//Force to break;						
					osDelay(20);
					break;
				}
				
				if(ubKNL_StopTrxFlg[1])
				{
				#if defined(RTC676x)
				#if APP_RTC676X_FOTA_ENABLE			
					if(tProc.tPktType == PKT_FOTA)			
						ubErrEndFlg = 1;
				#endif
				#endif
					
					printf("(ADO)Force to Break\r\n");
					break;
				}			
			}	
					
			if(tProc.tPktType != PKT_FOTA)
			{
				if(ubBUF_ReleaseAdoPacketizeBuf(tProc.ulDramAddr2) != BUF_OK)
				{
					printf("Fail @%s\r\n",__func__);
				}				
			}
			
			//printf("F(%d,%d)\r\n",uwTotalPktNum,ubRunTimes);		
			//printf("F(%d)\r\n",tProc.ulIdx);
			//printf("F-%d,0x%x,0x%x\r\n",tProc.ulIdx,ulActiveLen,uwTotalPktNum*PKT_PAYLOAD_SZ);
		#if defined(RTC676x)
		#if APP_RTC676X_FOTA_ENABLE	
			if((tProc.tPktType == PKT_FOTA) && (!ubErrEndFlg))
			{
				ubKNL_FotaTrxFlg = 0;
			}
			else if(tProc.tPktType == PKT_FOTA)
			{
				printf("Error-End\r\n");
				ubKNL_FotaTrxFlg = 0;
			}
		#endif
		#endif
		}
		else
		{
			if(tProc.tPktType != PKT_FOTA)
			{
				if(ubBUF_ReleaseAdoPacketizeBuf(tProc.ulDramAddr2) != BUF_OK)
				{
					printf("Fail @%s\r\n",__func__);
				}
			}
		}
	}
}
#endif

void KNL_SendResendICmd(uint8_t ubTargetRole)
{
	KNL_PROCESS tKNLInfo;	
	
	tKNLInfo.ubTargetRole = ubTargetRole;
	tKNLInfo.ubTwcCmd	  = TWC_RESEND_I_INT;

	if(osMessagePut(KNL_TwcMonitQueue, &tKNLInfo, 0) == osErrorResource)
	{
		printd(DBG_ErrorLvl, "KNL_TwcMonitQ->Full !!!!\r\n");
	}
}

void KNL_SendStaOnLineInfo(uint8_t ubStaMap)
{
	KNL_PROCESS tKNLInfo;
	uint8_t ubTemp[4];
	uint8_t i;
	
	ubKNL_StaOnLineMap = ubStaMap;
	
	for(i=0;i<4;i++)
	{
		if(ubStaMap & (0x0001<<i))
		{
			ubTemp[i] = 1;
		}
		else
		{
			ubTemp[i] = 0;
		}
	}	
	
	for(i=0;i<4;i++)
	{
		if(ubTemp[i])
		{
			tKNLInfo.ubTargetRole = KNL_STA1+i;
			tKNLInfo.ubTwcCmd	  = TWC_STA_ON_LINE;

			if(osMessagePut(KNL_TwcMonitQueue, &tKNLInfo, 0) == osErrorResource)
			{
				printd(DBG_ErrorLvl, "KNL_TwcMonitQ->Full !!!!\r\n");
			}
		}
	}
}

#ifdef RTC676x	
static void KNL_Packet0ProcThread(void const *argument)
{
	//uint8_t reset = 1;
	
#if OP_AP
	int PreRcvMode = PREF_BBR_QPSK;
	int CurRcvMode = PREF_BBR_QPSK;	
	uint32_t ulMaxVdoPktLen;
	uint32_t ulVdoPayloadSz;
	
	//For Common
	KNL_PROCESS tProc;
	uint8_t ubPkt[PACKET_BUF_LEN];
	uint8_t ubCopyFlg = 0;
	uint8_t ubTotalIdx 	= 0;
	uint16_t uwTotalNum = 0;
	uint16_t uwFrmIdx 	= 0;
	uint16_t uwPktIdx 	= 0;
	uint32_t ulDstAddr = 0;
	uint16_t uwRdyPktNum;
	uint16_t i,j;
	uint32_t ulTemp;
	uint8_t ubOutFlg = 0;
	uint32_t ulActiveLen = 0;
	uint8_t ubTemp[4];
	uint8_t ubCrcOkFlg = 0;

	//For Video
	uint8_t ubVdo_PreTotalIdx = 0;	
	uint8_t ubVdo_StartRcvFrameFlg = 0;
	uint32_t ulVdo_StartRcvTotalIdx = 0;	
	uint32_t ulVdo_FrmBufAddr;
	uint8_t ubVdo_RdyFlg[MAX_NUM_PKT_PER_FRAME];	
	uint16_t uwVdo_PreOutFrmIdx = 0;
	uint8_t ubVdo_ChkOutFlg = 0;
	
	//For Audio
	uint8_t ubAdo_PreTotalIdx = 0;	
	uint8_t ubAdo_StartRcvFrameFlg = 0;
	uint32_t ulAdo_StartRcvTotalIdx = 0;	
	uint32_t ulAdo_FrmBufAddr;
	uint8_t ubAdo_RdyFlg[MAX_NUM_PKT_PER_FRAME];		
	uint8_t ubAdo_PreOutTotalIdx = 0xFF;
	
	//For Data Valid or Not
	uint8_t ubDataValidFlg = 0;
	uint16_t uwChkSumInPkt = 0;	
	uint16_t uwChkSumInCal = 0;	
	
	uint8_t ubChkSumInPkt = 0;
	uint8_t ubChkSumInCal = 0;
	
	osSemaphoreRelease(tKNL_PacketThRdySem[0].Id);
	
	while(1)
	{
		osMessageGet(KNL_PacketQue[0].Id, &tProc, osWaitForever);		
		
		//Initial
		ubCopyFlg = 0;
		ubDataValidFlg = 1;		
		
		//Get Header Information				
		memcpy(ubPkt,(uint8_t *)tProc.ulDramAddr2,PKT_RECV_LEN);		
		
		ulMaxVdoPktLen = tProc.ulSize;
		ulVdoPayloadSz = ulMaxVdoPktLen-PKT_HEADER_SZ;
		
		//Release First
		if(ubBUF_ReleasePacket0Buf(tProc.ulDramAddr2) != BUF_OK)
		{
			printf("Fail @%s\r\n",__func__);
		}	

		//Check Modulation Mode
		if((ubPkt[PKT_INFO_OFS_MODE] == PREF_BBR_BPSK) ||(ubPkt[PKT_INFO_OFS_MODE] == PREF_BBR_QPSK) ||(ubPkt[PKT_INFO_OFS_MODE] == PREF_BBR_16QAM))
			CurRcvMode = ubPkt[PKT_INFO_OFS_MODE]&0x0F;

		if(ubPkt[PKT_INFO_OFS_TYPE] == PKT_ADO)		//Audio
		{			
			ubTotalIdx 	= ubPkt[PKT_INFO_OFS_TOTAL_IDX];
			uwTotalNum 	= ((uint16_t)ubPkt[PKT_INFO_OFS_TOTAL_NUM])+(((uint16_t)ubPkt[PKT_INFO_OFS_TOTAL_NUM+1])<<8);			
			uwPktIdx 	= ((uint16_t)ubPkt[PKT_INFO_OFS_PKT_IDX])+(((uint16_t)ubPkt[PKT_INFO_OFS_PKT_IDX+1])<<8);		
			
			//Check Header
			uwChkSumInPkt = ubPkt[PKT_INFO_OFS_CHKSUM];
			uwChkSumInPkt = uwChkSumInPkt + (((uint16_t)ubPkt[PKT_INFO_OFS_CHKSUM+1])<<8);						
			uwChkSumInCal = 0;			
			for(j=0;j<PKT_ACTIVE_HEADER_SZ;j++)
			{
				uwChkSumInCal = uwChkSumInCal + (uint16_t)ubPkt[j];
			}
			
			//Check Payload
			ubChkSumInPkt = ubPkt[PKT_INFO_OFS_RSV];
			ubChkSumInCal = 0;
			for(j=0;j<(MAX_ADO_PACKET_LEN - PKT_HEADER_SZ);j++)
			{
				ubChkSumInCal = ubChkSumInCal + ubPkt[j+PKT_HEADER_SZ];
			}
			
			//printf("(%d,%d,%d,%d)\r\n",ubTotalIdx,uwTotalNum,uwFrmIdx,uwPktIdx);		
			
			//Check Data Valid or Not			
			if((uwTotalNum > MAX_NUM_PKT_PER_FRAME) || (uwTotalNum == 0))
				ubDataValidFlg = 0;		
			if(uwPktIdx >= uwTotalNum)
				ubDataValidFlg = 0;
			if(uwChkSumInPkt != uwChkSumInCal)
				ubDataValidFlg = 0;
			if(ubChkSumInPkt != ubChkSumInCal)
				ubDataValidFlg = 0;			
			
			if(ubDataValidFlg == 0)
			{
				printf("PktErr @%s\r\n",__func__);
			}
			
			if(ubDataValidFlg)
			{
				if(!ubAdo_StartRcvFrameFlg)	//Receive Any Packet
				{
					//Initial					
					ulAdo_StartRcvTotalIdx = ubTotalIdx;			
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubAdo_RdyFlg[i] = 0;
					
					ubAdo_PreTotalIdx = ubTotalIdx;
					
					//First Pkt @ Frame			
					ulAdo_FrmBufAddr = ulBUF_GetAdoPacketize0FreeBuf();
					if(ulAdo_FrmBufAddr != BUF_FAIL)
					{
						ubCopyFlg = 1;
						ubAdo_StartRcvFrameFlg = 1;
					}
				}				
				else if(ubAdo_StartRcvFrameFlg && (ubTotalIdx != ubAdo_PreTotalIdx))
				{
					//Drop Previous Frame			
					if(ubBUF_ReleaseAdoPacketize0Buf(ulAdo_FrmBufAddr) == BUF_FAIL)
						printf("Release Fail1 @%s\r\n",__func__);
					
					ubAdo_StartRcvFrameFlg = 0;
					
					//Initial			
					ulAdo_StartRcvTotalIdx = ubTotalIdx;			

					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubAdo_RdyFlg[i] = 0;
					
					ubAdo_PreTotalIdx = ubTotalIdx;
					
					//New Frame				
					ulAdo_FrmBufAddr = ulBUF_GetAdoPacketize0FreeBuf();
					if(ulAdo_FrmBufAddr != BUF_FAIL)
					{
						ubCopyFlg = 1;
						ubAdo_StartRcvFrameFlg = 1;
					}			
				}		
				else if(ubAdo_StartRcvFrameFlg && (ubTotalIdx == ulAdo_StartRcvTotalIdx))
				{
					ubCopyFlg = 1;
				}
				else if(ubAdo_StartRcvFrameFlg)
				{
					//Drop Previous Frame			
					if(ubBUF_ReleaseAdoPacketize0Buf(ulAdo_FrmBufAddr) == BUF_FAIL)
						printf("Release Fail2 @%s\r\n",__func__);
					
					ubAdo_StartRcvFrameFlg = 0;
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubAdo_RdyFlg[i] = 0;
				}
				
				if(ubCopyFlg && (!ubAdo_RdyFlg[uwPktIdx]) && ubAdo_StartRcvFrameFlg)
				{			
					ulDstAddr = ulAdo_FrmBufAddr+(PKT_ADO_PAYLOAD_SZ*((uint32_t)uwPktIdx));			
					memcpy((uint8_t *)ulDstAddr,(uint8_t *)&ubPkt[PKT_HEADER_SZ],PKT_ADO_PAYLOAD_SZ);
					ubAdo_RdyFlg[uwPktIdx] = 1;
				}

				//Final Check
				uwRdyPktNum = 0;
				for(i=0;i<uwTotalNum;i++)
				{
					if(ubAdo_RdyFlg[i])
						uwRdyPktNum++;
					if(uwRdyPktNum == uwTotalNum)
					{					
						ubOutFlg = 0;
						
						if(ubTotalIdx != ubAdo_PreOutTotalIdx)
						{
							ubOutFlg = 1;
							ubAdo_PreOutTotalIdx = ubTotalIdx;
						}				
						
						if(ubOutFlg)
						{											
							ulTemp = ulAdo_FrmBufAddr;
							if(ulTemp != BUF_FAIL)
							{						
								ulActiveLen = 0;
								ubTemp[0] = *((uint8_t *)(ulTemp+(uwTotalNum*PKT_ADO_PAYLOAD_SZ)-4));
								ubTemp[1] = *((uint8_t *)(ulTemp+(uwTotalNum*PKT_ADO_PAYLOAD_SZ)-3));
								ubTemp[2] = *((uint8_t *)(ulTemp+(uwTotalNum*PKT_ADO_PAYLOAD_SZ)-2));
								ubTemp[3] = *((uint8_t *)(ulTemp+(uwTotalNum*PKT_ADO_PAYLOAD_SZ)-1));
								ulActiveLen = 	((uint32_t)ubTemp[0])+(((uint32_t)ubTemp[1])<<8)+(((uint32_t)ubTemp[2])<<16)+(((uint32_t)ubTemp[3])<<24);
								
								if(ulActiveLen <= BUF_SZ_MAX_ADO)
								{								
									//Check CRC is Valid or In-Valid
									//=====================================
									uint32_t ulCrcCalSz;
									uint8_t ubCrc8InPkt,ubCrc8Cal;						
									
									ubCrc8InPkt = *((uint8_t *)(ulTemp+ulActiveLen-48));
									
									ubTemp[0] = 0;
									ubTemp[1] = 0;
									ubTemp[2] = 0;
									ubTemp[3] = 0;
									
									ubTemp[0] = *((uint8_t *)(ulTemp+ulActiveLen-48+1));
									ubTemp[1] = *((uint8_t *)(ulTemp+ulActiveLen-48+2));
									ubTemp[2] = *((uint8_t *)(ulTemp+ulActiveLen-48+3));	
									ubTemp[3] = *((uint8_t *)(ulTemp+ulActiveLen-48+4));
				
									ulCrcCalSz = (((uint32_t)ubTemp[0])<<0)+(((uint32_t)ubTemp[1])<<8)+(((uint32_t)ubTemp[2])<<16)+(((uint32_t)ubTemp[3])<<24);
									
									ubCrc8Cal = ubKNL_TransmitCRC8(ulTemp, ulCrcCalSz);
						
									if(ubCrc8InPkt == ubCrc8Cal)
									{
										//printf("CA[0]->OK\r\n");
										ubCrcOkFlg = 1;
									}
									else
									{
										printf("CA[0]->Fail1\r\n");
										ubCrcOkFlg = 0;										
													
										//printf("RF Software Reset(1) @%s\r\n",__func__);				
										//rf_setopt(RF_OPT_SW_RST, &reset, 1);
										//printf("RF Software Reset(2) @%s\r\n",__func__);
										ubKNL_AccessErrCnt(KNL_OPERATION_PLUS,0);
									}
								}	
								else
								{
									printf("CA[0]->Fail2\r\n");
									ubCrcOkFlg = 0;									
									
									//printf("RF Software Reset(1) @%s\r\n",__func__);				
									//rf_setopt(RF_OPT_SW_RST, &reset, 1);
									//printf("RF Software Reset(2) @%s\r\n",__func__);
									ubKNL_AccessErrCnt(KNL_OPERATION_PLUS,0);
								}
			
								//=====================================
								if(ubCrcOkFlg)
								{
									RX_DON data;								
									data.Type = BB_DATA_AUDIO;
									data.tSTA = (GET_STA) BB_GET_STA1;
									data.ulAddr = (uint32_t)ulTemp;
									data.ulSize = ulActiveLen;
									data.ubGetCrc = 0;
									data.ulCrcLen = 0;

									//printf("A_OI:%d\r\n",ubTotalIdx);
									// Put frame to message queue																
									if(osMessagePut(KNL_QueRxAdo, &data, 0) != osOK)
										printf("QueFull(KNL_QueRxAdo)\r\n");
								}		
								else
								{
									if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubAdo_StartRcvFrameFlg)
										ubBUF_ReleaseAdoPacketize0Buf(ulAdo_FrmBufAddr);
								}								
							}
							else
							{
								if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubAdo_StartRcvFrameFlg)
									ubBUF_ReleaseAdoPacketize0Buf(ulAdo_FrmBufAddr);
							}
						}
						else
						{					
							if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubAdo_StartRcvFrameFlg)
								ubBUF_ReleaseAdoPacketize0Buf(ulAdo_FrmBufAddr);
						}
						
						if((RELEASE_BUF_METHOD == RELEASE_BUF_DIRECT) && ubAdo_StartRcvFrameFlg)
							ubBUF_ReleaseAdoPacketize0Buf(ulAdo_FrmBufAddr);
					
						ubAdo_StartRcvFrameFlg = 0;	
						
						for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
							ubAdo_RdyFlg[i] = 0;				
						
						break;
					}
				}	
			}
			else
			{
				if(ubAdo_StartRcvFrameFlg)
				{
					//Drop Previous Frame			
					ubBUF_ReleaseAdoPacketize0Buf(ulAdo_FrmBufAddr);
					ubAdo_StartRcvFrameFlg = 0;
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubAdo_RdyFlg[i] = 0;
				}
			}			
		}
		else if(ubPkt[PKT_INFO_OFS_TYPE] == PKT_MAIN_VDO)	//Main-Video
		{		
			ubTotalIdx 	= ubPkt[PKT_INFO_OFS_TOTAL_IDX];
			uwTotalNum 	= ((uint16_t)ubPkt[PKT_INFO_OFS_TOTAL_NUM])+(((uint16_t)ubPkt[PKT_INFO_OFS_TOTAL_NUM+1])<<8);
			uwFrmIdx 	= ((uint16_t)ubPkt[PKT_INFO_OFS_FRM_IDX])+(((uint16_t)ubPkt[PKT_INFO_OFS_FRM_IDX+1])<<8);
			uwPktIdx 	= ((uint16_t)ubPkt[PKT_INFO_OFS_PKT_IDX])+(((uint16_t)ubPkt[PKT_INFO_OFS_PKT_IDX+1])<<8);					
			uwChkSumInPkt = ubPkt[PKT_INFO_OFS_CHKSUM];
			uwChkSumInPkt = uwChkSumInPkt + (((uint16_t)ubPkt[PKT_INFO_OFS_CHKSUM+1])<<8);
			uwChkSumInCal = 0;
			for(j=0;j<PKT_ACTIVE_HEADER_SZ;j++)
			{
				uwChkSumInCal = uwChkSumInCal + (uint16_t)ubPkt[j];
			}
			//Check Data Valid or Not			
			if((uwTotalNum > MAX_NUM_PKT_PER_FRAME) ||(uwTotalNum == 0))
				ubDataValidFlg = 0;
			if(uwFrmIdx > KNL_TX_GOP)
				ubDataValidFlg = 0;			
			if(uwPktIdx >= uwTotalNum)
				ubDataValidFlg = 0;
			if(uwChkSumInPkt != uwChkSumInCal)
				ubDataValidFlg = 0;
			if(CurRcvMode != PreRcvMode)
			{
				if(ubVdo_StartRcvFrameFlg)
					ubDataValidFlg = 0;
			}			
			
			
			if(ubDataValidFlg == 0)
			{
				printf("PktErr @%s\r\n",__func__);
			}					
			
			//printf("(%d,%d,%d,%d)\r\n",ubTotalIdx,uwTotalNum,uwFrmIdx,uwPktIdx);	
			if(ubDataValidFlg)
			{				
				if(!ubVdo_StartRcvFrameFlg)	//Receive Any Packet
				{
					//Initial					
					ulVdo_StartRcvTotalIdx = ubTotalIdx;			
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubVdo_RdyFlg[i] = 0;
					
					ubVdo_PreTotalIdx = ubTotalIdx;
					
					//First Pkt @ Frame			
					ulVdo_FrmBufAddr = ulBUF_GetVdoPacketize0FreeBuf();
					if(ulVdo_FrmBufAddr != BUF_FAIL)
					{
						ubCopyFlg = 1;
						ubVdo_StartRcvFrameFlg = 1;
					}
				}				
				else if(ubVdo_StartRcvFrameFlg && (ubTotalIdx != ubVdo_PreTotalIdx))
				{
					//Drop Previous Frame			
					if(ubBUF_ReleaseVdoPacketize0Buf(ulVdo_FrmBufAddr) == BUF_FAIL)
						printf("Release Fail1 @%s\r\n",__func__);
					
					ubVdo_StartRcvFrameFlg = 0;
					
					//Initial			
					ulVdo_StartRcvTotalIdx = ubTotalIdx;			

					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubVdo_RdyFlg[i] = 0;
					
					ubVdo_PreTotalIdx = ubTotalIdx;
					
					//New Frame				
					ulVdo_FrmBufAddr = ulBUF_GetVdoPacketize0FreeBuf();
					if(ulVdo_FrmBufAddr != BUF_FAIL)
					{
						ubCopyFlg = 1;
						ubVdo_StartRcvFrameFlg = 1;
					}					
				}		
				else if(ubVdo_StartRcvFrameFlg && (ubTotalIdx == ulVdo_StartRcvTotalIdx))
				{
					ubCopyFlg = 1;
				}				
				else if(ubVdo_StartRcvFrameFlg)
				{
					//Drop Previous Frame					
					if(ubBUF_ReleaseVdoPacketize0Buf(ulVdo_FrmBufAddr) == BUF_FAIL)
						printf("Release Fail2 @%s\r\n",__func__);
					
					ubVdo_StartRcvFrameFlg = 0;
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubVdo_RdyFlg[i] = 0;
				}
			
				if(ubCopyFlg && (!ubVdo_RdyFlg[uwPktIdx]) && ubVdo_StartRcvFrameFlg)
				{			
					ulDstAddr = ulVdo_FrmBufAddr+(ulVdoPayloadSz*((uint32_t)uwPktIdx));			
					memcpy((uint8_t *)ulDstAddr,(uint8_t *)&ubPkt[PKT_HEADER_SZ],ulVdoPayloadSz);
					ubVdo_RdyFlg[uwPktIdx] = 1;
				}

				//Final Check
				uwRdyPktNum = 0;
				for(i=0;i<uwTotalNum;i++)
				{
					if(ubVdo_RdyFlg[i])
						uwRdyPktNum++;
					if(uwRdyPktNum == uwTotalNum)
					{
						//printf("F0-%d\r\n",uwFrmIdx);
						
						ubOutFlg = 0;						
						if(uwFrmIdx == 0)
						{
							ubOutFlg = 1;	
							uwVdo_PreOutFrmIdx = 0;
							
							ubVdo_ChkOutFlg = 1;
						}
						else
						{					
							if(ubVdo_ChkOutFlg)
							{
								if(uwFrmIdx == (uwVdo_PreOutFrmIdx+1))
								{
									ubOutFlg = 1;
									uwVdo_PreOutFrmIdx = uwFrmIdx;
								}
								else if(uwFrmIdx == uwVdo_PreOutFrmIdx)
								{
									ubOutFlg = 0;
								}
								else
								{
									ubOutFlg = 0;						
									uwVdo_PreOutFrmIdx = 0xFFFF;	//Wait Next Packet is I-Frame
									
									ubVdo_ChkOutFlg = 0;
									
									printf("MissF[%d]\r\n",0);
									
									KNL_SendResendICmd(KNL_STA1);
									if(pKNL_PerDbgFunc[0])
									{
										ubKNL_FrmLossFlag[KNL_STA1] = TRUE;
										pKNL_PerDbgFunc[0](PER_FRMSTS_RPT, KNL_STA1, FRM_LOSS_ERR);
									}
								}
							}
						}
						
						if(ubKNL_CodecFailFlg[0])
						{
							ubKNL_CodecFailFlg[0] = 0;
							ubOutFlg = 0;					
						}				
						
						if(ubOutFlg)
						{						
							ubKNL_OutFpsTemp[0]++;
												
							ulTemp = ulVdo_FrmBufAddr;
							if(ulTemp != BUF_FAIL)
							{							
								ulActiveLen = 0;
								ubTemp[0] = *((uint8_t *)(ulTemp+(uwTotalNum*ulVdoPayloadSz)-4));
								ubTemp[1] = *((uint8_t *)(ulTemp+(uwTotalNum*ulVdoPayloadSz)-3));
								ubTemp[2] = *((uint8_t *)(ulTemp+(uwTotalNum*ulVdoPayloadSz)-2));
								ubTemp[3] = *((uint8_t *)(ulTemp+(uwTotalNum*ulVdoPayloadSz)-1));
								ulActiveLen = 	((uint32_t)ubTemp[0])+(((uint32_t)ubTemp[1])<<8)+(((uint32_t)ubTemp[2])<<16)+(((uint32_t)ubTemp[3])<<24);
								
								if(ulActiveLen <= BUF_SZ_MAX_VDO)
								{
									if(ulKNL_GetFrameSz(ulVdo_FrmBufAddr,ulActiveLen) > ulBUF_GetVdoPacketize0BufSz())
									{
										printf("AuxSz[0]\r\n");
										ulActiveLen = 0xFFFFFFFFL;//Force to Invalid Size
									}
								}
								
								if(ulActiveLen <= BUF_SZ_MAX_VDO)
								{
									//Check CRC is Valid or In-Valid
									//=====================================
									uint32_t ulCrcCalSz;
									uint8_t ubCrc8InPkt,ubCrc8Cal;						
									
									ubCrc8InPkt = *((uint8_t *)(ulTemp+ulActiveLen-48));
									
									ubTemp[0] = 0;
									ubTemp[1] = 0;
									ubTemp[2] = 0;
									ubTemp[3] = 0;
									
									ubTemp[0] = *((uint8_t *)(ulTemp+ulActiveLen-48+1));
									ubTemp[1] = *((uint8_t *)(ulTemp+ulActiveLen-48+2));
									ubTemp[2] = *((uint8_t *)(ulTemp+ulActiveLen-48+3));	
									ubTemp[3] = *((uint8_t *)(ulTemp+ulActiveLen-48+4));
				
									ulCrcCalSz = (((uint32_t)ubTemp[0])<<0)+(((uint32_t)ubTemp[1])<<8)+(((uint32_t)ubTemp[2])<<16)+(((uint32_t)ubTemp[3])<<24);
									
									ubCrc8Cal = ubKNL_TransmitCRC8(ulTemp, ulCrcCalSz);
						
									if(ubCrc8InPkt == ubCrc8Cal)
									{
										//printf("CV[0]->OK\r\n");
										ubCrcOkFlg = 1;
									}
									else
									{
										printf("CV[0]->Fail1\r\n");
										ubCrcOkFlg = 0;
										
										//printf("RF Software Reset(1) @%s\r\n",__func__);				
										//rf_setopt(RF_OPT_SW_RST, &reset, 1);
										//printf("RF Software Reset(2) @%s\r\n",__func__);
										ubKNL_AccessErrCnt(KNL_OPERATION_PLUS,0);
										
										uwVdo_PreOutFrmIdx = 0xFFFF;	//Wait Next Packet is I-Frame							
										KNL_SendResendICmd(KNL_STA1);
									}
								}	
								else
								{
									printf("CV[0]->Fail2:%d KB\r\n",ulActiveLen/1024);
									ubCrcOkFlg = 0;
									
									//printf("RF Software Reset(1) @%s\r\n",__func__);				
									//rf_setopt(RF_OPT_SW_RST, &reset, 1);
									//printf("RF Software Reset(2) @%s\r\n",__func__);
									ubKNL_AccessErrCnt(KNL_OPERATION_PLUS,0);
										
									uwVdo_PreOutFrmIdx = 0xFFFF;	//Wait Next Packet is I-Frame							
									KNL_SendResendICmd(KNL_STA1);
								}
			
								//=====================================
								if(ubCrcOkFlg)
								{								
								#if 1
									RX_DON data;
									data.Type = BB_DATA_VIDEO;
									data.tSTA = (GET_STA) BB_GET_STA1;
									data.ulAddr = (uint32_t)ulTemp;
									data.ulSize = ulActiveLen;
									data.ubGetCrc = 0;
									data.ulCrcLen = 0;

									// Put frame to message queue
									if(osMessagePut(KNL_QueRxVdo, &data, 0) != osOK)
										printf("QueFull(KNL_QueRxVdo)\r\n");										
								#else
									tKNL_RxVdoInProcess(BB_GET_STA1, ulTemp, ulActiveLen);
								#endif
								}
								else
								{									
									if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubVdo_StartRcvFrameFlg)
										ubBUF_ReleaseVdoPacketize0Buf(ulVdo_FrmBufAddr);
									
									if(pKNL_PerDbgFunc[0])
										pKNL_PerDbgFunc[0](PER_FRMSTS_RPT, KNL_STA1, FRM_CRC_ERR);
								}								
							}
							else
							{								
								if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubVdo_StartRcvFrameFlg)
									ubBUF_ReleaseVdoPacketize0Buf(ulVdo_FrmBufAddr);
							}
						}
						else
						{		
							if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubVdo_StartRcvFrameFlg)					
								ubBUF_ReleaseVdoPacketize0Buf(ulVdo_FrmBufAddr);
						}					
					
						if((RELEASE_BUF_METHOD == RELEASE_BUF_DIRECT) && ubVdo_StartRcvFrameFlg)					
							ubBUF_ReleaseVdoPacketize0Buf(ulVdo_FrmBufAddr);
						
						ubVdo_StartRcvFrameFlg = 0;	
						
						for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
							ubVdo_RdyFlg[i] = 0;				
						
						break;
					}
				}
			}
			else
			{
				if(ubVdo_StartRcvFrameFlg)
				{
					//Drop Previous Frame			
					ubBUF_ReleaseVdoPacketize0Buf(ulVdo_FrmBufAddr);
					ubVdo_StartRcvFrameFlg = 0;
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubVdo_RdyFlg[i] = 0;
				}
			}			
		}						
		else			//Cmd
		{
			uwChkSumInPkt = ubPkt[MAX_CMD_PACKET_LEN-2];
			uwChkSumInPkt = uwChkSumInPkt + (((uint16_t)ubPkt[MAX_CMD_PACKET_LEN-1])<<8);			
			
			ulTemp = ulBUF_GetBlkBufAddr(0,BUF_RW_FRAME)+BUF_SZ_MAX_VDO+BUF_SZ_MAX_ADO+(BUF_SZ_PKT*1);
			
			for(i=0;i<MAX_CMD_PACKET_LEN-2;i++)
			{
				*((uint8_t *)(ulTemp+i)) = ubPkt[i];
			}			
			
			uwChkSumInCal = uwCHECKSUM_Calc(ulTemp,MAX_CMD_PACKET_LEN-2);			
			
			if(uwChkSumInPkt == uwChkSumInCal)
			{				
				//printf("Cmd Ok[0]\r\n");
				TWCR_RcvData((uint8_t)TWC_STA1,(TWC_OPC)ubPkt[3],&ubPkt[4]);
			}
			else
			{
				printf("Cmd Fail[0]\r\n");
				
				//printf("RF Software Reset(1) @%s\r\n",__func__);				
				//rf_setopt(RF_OPT_SW_RST, &reset, 1);
				//printf("RF Software Reset(2) @%s\r\n",__func__);
				ubKNL_AccessErrCnt(KNL_OPERATION_PLUS,0);
			}						
		}
		
		if((CurRcvMode == PREF_BBR_BPSK) ||(CurRcvMode == PREF_BBR_QPSK) ||(CurRcvMode == PREF_BBR_16QAM))
			PreRcvMode = CurRcvMode;
		
	}
#endif
	
#if OP_STA
#if APP_RTC676X_FOTA_ENABLE
	//uint16_t n;				//[FOTA]
	//uint16_t uwShowInfoNum;	//[FOTA]	
	//uint32_t m;				//[FOTA]
	//FOTA_INFO tFotaInfo;		//[FOTA]
	uint8_t ubChkOkFlg;			//[FOTA]
	//uint8_t ubPreData;		//[FOTA]
	//uint8_t ubCurData;		//[FOTA]	
	//uint16_t uwTmp_FotaNumOfFrm = 0;
	//uint16_t uwTmp_FotaCurFrmIdx = 0;
	//uint16_t uwTmp_FotaPreFrmIdx = 0;	
	FOTA_INFO tInfo;	
#endif
	
	KNL_PROCESS tProc;
	uint8_t ubPkt[PACKET_BUF_LEN];	
	
	//==========================================================	
	uint8_t ubCopyFlg = 0;
	uint8_t ubTotalIdx 	= 0;
	uint16_t uwTotalNum = 0;
	//uint16_t uwFrmIdx 	= 0;
	uint16_t uwPktIdx 	= 0;
	uint32_t ulDstAddr = 0;
	uint16_t uwRdyPktNum;
	uint16_t i,j;
	uint32_t ulTemp;
	uint8_t ubOutFlg = 0;
	uint32_t ulActiveLen = 0;
	uint8_t ubTemp[4];
	uint8_t ubCrcOkFlg = 0;	
	
	//For Audio
	uint8_t ubAdo_PreTotalIdx = 0;	
	uint8_t ubAdo_StartRcvFrameFlg = 0;
	uint32_t ulAdo_StartRcvTotalIdx = 0;	
	uint32_t ulAdo_FrmBufAddr;
	uint8_t ubAdo_RdyFlg[MAX_NUM_PKT_PER_FRAME];		
	uint8_t ubAdo_PreOutTotalIdx = 0xFF;
	//==========================================================
	
	//For Data Valid or Not
	uint8_t ubDataValidFlg = 0;			
	uint16_t uwChkSumInPkt = 0;	
	uint16_t uwChkSumInCal = 0;	

	uint8_t ubChkSumInPkt = 0;
	uint8_t ubChkSumInCal = 0;
	
	osSemaphoreRelease(tKNL_PacketThRdySem[0].Id);
	
	while(1)
	{
		osMessageGet(KNL_PacketQue[0].Id, &tProc, osWaitForever);
		
		//Initial
		ubCopyFlg = 0;
		ubDataValidFlg = 1;			
		
		//Get Header Information				
		memcpy(ubPkt,(uint8_t *)tProc.ulDramAddr2,PKT_RECV_LEN);		
		
		//Release First
		if(ubBUF_ReleasePacket0Buf(tProc.ulDramAddr2) != BUF_OK)
		{
			printf("Fail @%s\r\n",__func__);
		}	

		if(ubPkt[PKT_INFO_OFS_TYPE] == PKT_ADO)		//Audio
		{			
			ubTotalIdx 	= ubPkt[PKT_INFO_OFS_TOTAL_IDX];
			uwTotalNum 	= ((uint16_t)ubPkt[PKT_INFO_OFS_TOTAL_NUM])+(((uint16_t)ubPkt[PKT_INFO_OFS_TOTAL_NUM+1])<<8);		
			uwPktIdx 	= ((uint16_t)ubPkt[PKT_INFO_OFS_PKT_IDX])+(((uint16_t)ubPkt[PKT_INFO_OFS_PKT_IDX+1])<<8);		
			uwChkSumInPkt = ubPkt[PKT_INFO_OFS_CHKSUM];
			uwChkSumInPkt = uwChkSumInPkt + (((uint16_t)ubPkt[PKT_INFO_OFS_CHKSUM+1])<<8);						
			uwChkSumInCal = 0;
			for(j=0;j<PKT_ACTIVE_HEADER_SZ;j++)
			{
				uwChkSumInCal = uwChkSumInCal + (uint16_t)ubPkt[j];
			}
			
			//Check Payload
			ubChkSumInPkt = ubPkt[PKT_INFO_OFS_RSV];
			ubChkSumInCal = 0;
			for(j=0;j<(MAX_ADO_PACKET_LEN - PKT_HEADER_SZ);j++)
			{
				ubChkSumInCal = ubChkSumInCal + ubPkt[j+PKT_HEADER_SZ];
			}
			
			//printf("(%d,%d,%d,%d)\r\n",ubTotalIdx,uwTotalNum,uwFrmIdx,uwPktIdx);		
			
			//Check Data Valid or Not			
			if((uwTotalNum > MAX_NUM_PKT_PER_FRAME) || (uwTotalNum == 0))
				ubDataValidFlg = 0;			
			if(uwPktIdx >= uwTotalNum)
				ubDataValidFlg = 0;
			if(uwChkSumInPkt != uwChkSumInCal)
				ubDataValidFlg = 0;			
			if(ubChkSumInPkt != ubChkSumInCal)
				ubDataValidFlg = 0;
			
			if(ubDataValidFlg == 0)
			{
				printf("PktErr @%s\r\n",__func__);
			}
			
			if(ubDataValidFlg)
			{				
				if(!ubAdo_StartRcvFrameFlg)	//Receive Any Packet
				{
					//Initial					
					ulAdo_StartRcvTotalIdx = ubTotalIdx;			
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubAdo_RdyFlg[i] = 0;
					
					ubAdo_PreTotalIdx = ubTotalIdx;
					
					//First Pkt @ Frame			
					ulAdo_FrmBufAddr = ulBUF_GetAdoPacketize0FreeBuf();
					if(ulAdo_FrmBufAddr != BUF_FAIL)
					{
						ubCopyFlg = 1;
						ubAdo_StartRcvFrameFlg = 1;
					}
				}				
				else if(ubAdo_StartRcvFrameFlg && (ubTotalIdx != ubAdo_PreTotalIdx))
				{
					//Drop Previous Frame			
					if(ubBUF_ReleaseAdoPacketize0Buf(ulAdo_FrmBufAddr) == BUF_FAIL)
						printf("Release Fail1 @%s\r\n",__func__);
					
					ubAdo_StartRcvFrameFlg = 0;
					
					//Initial			
					ulAdo_StartRcvTotalIdx = ubTotalIdx;			

					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubAdo_RdyFlg[i] = 0;
					
					ubAdo_PreTotalIdx = ubTotalIdx;
					
					//New Frame				
					ulAdo_FrmBufAddr = ulBUF_GetAdoPacketize0FreeBuf();
					if(ulAdo_FrmBufAddr != BUF_FAIL)
					{
						ubCopyFlg = 1;
						ubAdo_StartRcvFrameFlg = 1;
					}			
				}		
				else if(ubAdo_StartRcvFrameFlg && (ubTotalIdx == ulAdo_StartRcvTotalIdx))
				{
					ubCopyFlg = 1;
				}
				else if(ubAdo_StartRcvFrameFlg)
				{
					//Drop Previous Frame			
					if(ubBUF_ReleaseAdoPacketize0Buf(ulAdo_FrmBufAddr) == BUF_FAIL)
						printf("Release Fail2 @%s\r\n",__func__);
					
					ubAdo_StartRcvFrameFlg = 0;
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubAdo_RdyFlg[i] = 0;
				}
			
				if(ubCopyFlg && (!ubAdo_RdyFlg[uwPktIdx]) && ubAdo_StartRcvFrameFlg)
				{			
					ulDstAddr = ulAdo_FrmBufAddr+(PKT_ADO_PAYLOAD_SZ*((uint32_t)uwPktIdx));			
					memcpy((uint8_t *)ulDstAddr,(uint8_t *)&ubPkt[PKT_HEADER_SZ],PKT_ADO_PAYLOAD_SZ);
					ubAdo_RdyFlg[uwPktIdx] = 1;
				}

				//Final Check
				uwRdyPktNum = 0;
				for(i=0;i<uwTotalNum;i++)
				{
					if(ubAdo_RdyFlg[i])
						uwRdyPktNum++;
					if(uwRdyPktNum == uwTotalNum)
					{					
						ubOutFlg = 0;
						
						if(ubTotalIdx != ubAdo_PreOutTotalIdx)
						{
							ubOutFlg = 1;
							ubAdo_PreOutTotalIdx = ubTotalIdx;
						}				
						
						if(ubOutFlg)
						{											
							ulTemp = ulAdo_FrmBufAddr;
							if(ulTemp != BUF_FAIL)
							{						
								ulActiveLen = 0;
								ubTemp[0] = *((uint8_t *)(ulTemp+(uwTotalNum*PKT_ADO_PAYLOAD_SZ)-4));
								ubTemp[1] = *((uint8_t *)(ulTemp+(uwTotalNum*PKT_ADO_PAYLOAD_SZ)-3));
								ubTemp[2] = *((uint8_t *)(ulTemp+(uwTotalNum*PKT_ADO_PAYLOAD_SZ)-2));
								ubTemp[3] = *((uint8_t *)(ulTemp+(uwTotalNum*PKT_ADO_PAYLOAD_SZ)-1));
								ulActiveLen = 	((uint32_t)ubTemp[0])+(((uint32_t)ubTemp[1])<<8)+(((uint32_t)ubTemp[2])<<16)+(((uint32_t)ubTemp[3])<<24);
								
								if(ulActiveLen <= BUF_SZ_MAX_ADO)
								{
									//Check CRC is Valid or In-Valid
									//=====================================
									uint32_t ulCrcCalSz;
									uint8_t ubCrc8InPkt,ubCrc8Cal;						
									
									ubCrc8InPkt = *((uint8_t *)(ulTemp+ulActiveLen-48));
									
									ubTemp[0] = 0;
									ubTemp[1] = 0;
									ubTemp[2] = 0;
									ubTemp[3] = 0;
									
									ubTemp[0] = *((uint8_t *)(ulTemp+ulActiveLen-48+1));
									ubTemp[1] = *((uint8_t *)(ulTemp+ulActiveLen-48+2));
									ubTemp[2] = *((uint8_t *)(ulTemp+ulActiveLen-48+3));	
									ubTemp[3] = *((uint8_t *)(ulTemp+ulActiveLen-48+4));
				
									ulCrcCalSz = (((uint32_t)ubTemp[0])<<0)+(((uint32_t)ubTemp[1])<<8)+(((uint32_t)ubTemp[2])<<16)+(((uint32_t)ubTemp[3])<<24);
									
									ubCrc8Cal = ubKNL_TransmitCRC8(ulTemp, ulCrcCalSz);
						
									if(ubCrc8InPkt == ubCrc8Cal)
									{
										//printf("CA[0]->OK\r\n");
										ubCrcOkFlg = 1;
									}
									else
									{
										printf("CA[0]->Fail1\r\n");
										ubCrcOkFlg = 0;
										
										//printf("RF Software Reset(1) @%s\r\n",__func__);				
										//rf_setopt(RF_OPT_SW_RST, &reset, 1);
										//printf("RF Software Reset(2) @%s\r\n",__func__);
										ubKNL_AccessErrCnt(KNL_OPERATION_PLUS,0);
									}
								}
								else
								{
									printf("CA[0]->Fail2\r\n");
									ubCrcOkFlg = 0;
									
									//printf("RF Software Reset(1) @%s\r\n",__func__);				
									//rf_setopt(RF_OPT_SW_RST, &reset, 1);
									//printf("RF Software Reset(2) @%s\r\n",__func__);
									ubKNL_AccessErrCnt(KNL_OPERATION_PLUS,0);
								}
			
								//=====================================
								if(ubCrcOkFlg)
								{
									RX_DON data;								
									data.Type = BB_DATA_AUDIO;
									data.tSTA = (GET_STA) BB_GET_STA1;
									data.ulAddr = (uint32_t)ulTemp;
									data.ulSize = ulActiveLen;
									data.ubGetCrc = 0;
									data.ulCrcLen = 0;

									//printf("A_OI:%d\r\n",ubTotalIdx);
									// Put frame to message queue								
									if(osMessagePut(KNL_QueRxAdo, &data, 0) != osOK)
										printf("QueFull(KNL_QueRxAdo)\r\n");
								}	
								else
								{
									if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubAdo_StartRcvFrameFlg)
										ubBUF_ReleaseAdoPacketize0Buf(ulAdo_FrmBufAddr);
								}
							}
							else
							{
								if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubAdo_StartRcvFrameFlg)
									ubBUF_ReleaseAdoPacketize0Buf(ulAdo_FrmBufAddr);
							}
						}
						else
						{
							if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubAdo_StartRcvFrameFlg)
								ubBUF_ReleaseAdoPacketize0Buf(ulAdo_FrmBufAddr);
						}			
						
						if((RELEASE_BUF_METHOD == RELEASE_BUF_DIRECT) && ubAdo_StartRcvFrameFlg)
							ubBUF_ReleaseAdoPacketize0Buf(ulAdo_FrmBufAddr);
						
						ubAdo_StartRcvFrameFlg = 0;	
						
						for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
							ubAdo_RdyFlg[i] = 0;				
						
						break;
					}
				}
			}
			else
			{
				if(ubAdo_StartRcvFrameFlg)
				{
					//Drop Previous Frame			
					ubBUF_ReleaseAdoPacketize0Buf(ulAdo_FrmBufAddr);
					ubAdo_StartRcvFrameFlg = 0;
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubAdo_RdyFlg[i] = 0;
				}
			}
		}	
		
	#if APP_RTC676X_FOTA_ENABLE
		//FOTA
		//--------------------------------------------------------------------------------------------------------
		else if(ubPkt[PKT_INFO_OFS_TYPE] == PKT_FOTA)		//FOTA
		{			
			ubTotalIdx 	= ubPkt[PKT_INFO_OFS_TOTAL_IDX];
			uwTotalNum 	= ((uint16_t)ubPkt[PKT_INFO_OFS_TOTAL_NUM])+(((uint16_t)ubPkt[PKT_INFO_OFS_TOTAL_NUM+1])<<8);		
			uwPktIdx 	= ((uint16_t)ubPkt[PKT_INFO_OFS_PKT_IDX])+(((uint16_t)ubPkt[PKT_INFO_OFS_PKT_IDX+1])<<8);		
			uwChkSumInPkt = ubPkt[PKT_INFO_OFS_CHKSUM];
			uwChkSumInPkt = uwChkSumInPkt + (((uint16_t)ubPkt[PKT_INFO_OFS_CHKSUM+1])<<8);						
			uwChkSumInCal = 0;
			for(j=0;j<PKT_ACTIVE_HEADER_SZ;j++)
			{
				uwChkSumInCal = uwChkSumInCal + (uint16_t)ubPkt[j];
			}
			
			//Check Payload
			ubChkSumInPkt = ubPkt[PKT_INFO_OFS_RSV];
			ubChkSumInCal = 0;
			for(j=0;j<(MAX_ADO_PACKET_LEN - PKT_HEADER_SZ);j++)
			{
				ubChkSumInCal = ubChkSumInCal + ubPkt[j+PKT_HEADER_SZ];
			}
			
			//printf("(%d,%d,%d,%d)\r\n",ubTotalIdx,uwTotalNum,uwFrmIdx,uwPktIdx);		
			
			//Check Data Valid or Not			
			if((uwTotalNum > MAX_NUM_PKT_PER_FRAME) || (uwTotalNum == 0))
				ubDataValidFlg = 0;			
			if(uwPktIdx >= uwTotalNum)
				ubDataValidFlg = 0;
			if(uwChkSumInPkt != uwChkSumInCal)
				ubDataValidFlg = 0;			
			if(ubChkSumInPkt != ubChkSumInCal)
				ubDataValidFlg = 0;
			
			if(ubDataValidFlg == 0)
			{
				printf("PktErr @%s\r\n",__func__);
			}
			
			if(ubDataValidFlg)
			{				
				if(!ubAdo_StartRcvFrameFlg)	//Receive Any Packet
				{
					//Initial					
					ulAdo_StartRcvTotalIdx = ubTotalIdx;			
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubAdo_RdyFlg[i] = 0;
					
					ubAdo_PreTotalIdx = ubTotalIdx;
					
					//First Pkt @ Frame			
					ulAdo_FrmBufAddr = ulBUF_GetAdoPacketize0FreeBuf();
					if(ulAdo_FrmBufAddr != BUF_FAIL)
					{
						ubCopyFlg = 1;
						ubAdo_StartRcvFrameFlg = 1;
					}
				}				
				else if(ubAdo_StartRcvFrameFlg && (ubTotalIdx != ubAdo_PreTotalIdx))
				{
					//Drop Previous Frame			
					if(ubBUF_ReleaseAdoPacketize0Buf(ulAdo_FrmBufAddr) == BUF_FAIL)
						printf("Release Fail1 @%s\r\n",__func__);
					
					ubAdo_StartRcvFrameFlg = 0;
					
					//Initial			
					ulAdo_StartRcvTotalIdx = ubTotalIdx;			

					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubAdo_RdyFlg[i] = 0;
					
					ubAdo_PreTotalIdx = ubTotalIdx;
					
					//New Frame				
					ulAdo_FrmBufAddr = ulBUF_GetAdoPacketize0FreeBuf();
					if(ulAdo_FrmBufAddr != BUF_FAIL)
					{
						ubCopyFlg = 1;
						ubAdo_StartRcvFrameFlg = 1;
					}			
				}		
				else if(ubAdo_StartRcvFrameFlg && (ubTotalIdx == ulAdo_StartRcvTotalIdx))
				{
					ubCopyFlg = 1;
				}
				else if(ubAdo_StartRcvFrameFlg)
				{
					//Drop Previous Frame			
					if(ubBUF_ReleaseAdoPacketize0Buf(ulAdo_FrmBufAddr) == BUF_FAIL)
						printf("Release Fail2 @%s\r\n",__func__);
					
					ubAdo_StartRcvFrameFlg = 0;
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubAdo_RdyFlg[i] = 0;
				}
			
				if(ubCopyFlg && (!ubAdo_RdyFlg[uwPktIdx]) && ubAdo_StartRcvFrameFlg)
				{			
					ulDstAddr = ulAdo_FrmBufAddr+(PKT_ADO_PAYLOAD_SZ*((uint32_t)uwPktIdx));			
					memcpy((uint8_t *)ulDstAddr,(uint8_t *)&ubPkt[PKT_HEADER_SZ],PKT_ADO_PAYLOAD_SZ);
					ubAdo_RdyFlg[uwPktIdx] = 1;
				}

				//Final Check
				uwRdyPktNum = 0;
				for(i=0;i<uwTotalNum;i++)
				{
					if(ubAdo_RdyFlg[i])
						uwRdyPktNum++;
					if(uwRdyPktNum == uwTotalNum)
					{					
						ubOutFlg = 0;
						
						if(ubTotalIdx != ubAdo_PreOutTotalIdx)
						{
							ubOutFlg = 1;
							ubAdo_PreOutTotalIdx = ubTotalIdx;
						}				
						
						if(ubOutFlg)
						{											
							ulTemp = ulAdo_FrmBufAddr;
							if(ulTemp != BUF_FAIL)
							{						
								ulActiveLen = 0;
								ubTemp[0] = *((uint8_t *)(ulTemp+(uwTotalNum*PKT_ADO_PAYLOAD_SZ)-4));
								ubTemp[1] = *((uint8_t *)(ulTemp+(uwTotalNum*PKT_ADO_PAYLOAD_SZ)-3));
								ubTemp[2] = *((uint8_t *)(ulTemp+(uwTotalNum*PKT_ADO_PAYLOAD_SZ)-2));
								ubTemp[3] = *((uint8_t *)(ulTemp+(uwTotalNum*PKT_ADO_PAYLOAD_SZ)-1));
								ulActiveLen = 	((uint32_t)ubTemp[0])+(((uint32_t)ubTemp[1])<<8)+(((uint32_t)ubTemp[2])<<16)+(((uint32_t)ubTemp[3])<<24);
								
								if(ulActiveLen <= BUF_SZ_MAX_ADO)
								{
									//Check CRC is Valid or In-Valid
									//=====================================
									uint32_t ulCrcCalSz;
									uint8_t ubCrc8InPkt,ubCrc8Cal;						
									
									ubCrc8InPkt = *((uint8_t *)(ulTemp+ulActiveLen-48));
									
									ubTemp[0] = 0;
									ubTemp[1] = 0;
									ubTemp[2] = 0;
									ubTemp[3] = 0;
									
									ubTemp[0] = *((uint8_t *)(ulTemp+ulActiveLen-48+1));
									ubTemp[1] = *((uint8_t *)(ulTemp+ulActiveLen-48+2));
									ubTemp[2] = *((uint8_t *)(ulTemp+ulActiveLen-48+3));	
									ubTemp[3] = *((uint8_t *)(ulTemp+ulActiveLen-48+4));
				
									ulCrcCalSz = (((uint32_t)ubTemp[0])<<0)+(((uint32_t)ubTemp[1])<<8)+(((uint32_t)ubTemp[2])<<16)+(((uint32_t)ubTemp[3])<<24);
									
									ubCrc8Cal = ubKNL_TransmitCRC8(ulTemp, ulCrcCalSz);
						
									if(ubCrc8InPkt == ubCrc8Cal)
									{
										//printf("CA[0]->OK\r\n");
										ubCrcOkFlg = 1;
									}
									else
									{
										printf("CA[0]->Fail1\r\n");
										ubCrcOkFlg = 0;
										
										//printf("RF Software Reset(1) @%s\r\n",__func__);				
										//rf_setopt(RF_OPT_SW_RST, &reset, 1);
										//printf("RF Software Reset(2) @%s\r\n",__func__);
										ubKNL_AccessErrCnt(KNL_OPERATION_PLUS,0);
									}
								}
								else
								{
									printf("CA[0]->Fail2\r\n");
									ubCrcOkFlg = 0;
									
									//printf("RF Software Reset(1) @%s\r\n",__func__);				
									//rf_setopt(RF_OPT_SW_RST, &reset, 1);
									//printf("RF Software Reset(2) @%s\r\n",__func__);
									ubKNL_AccessErrCnt(KNL_OPERATION_PLUS,0);
								}
			
								//=====================================
								if(ubCrcOkFlg)
								{									
									tInfo.ulRealFwSz	= 
														((uint32_t)(*(uint8_t *)(ulTemp+FOTA_REAL_FW_SZ_OFS)))			+									
														(((uint32_t)(*(uint8_t *)(ulTemp+FOTA_REAL_FW_SZ_OFS+1)))<<8) 	+
														(((uint32_t)(*(uint8_t *)(ulTemp+FOTA_REAL_FW_SZ_OFS+2)))<<16) 	+									
														(((uint32_t)(*(uint8_t *)(ulTemp+FOTA_REAL_FW_SZ_OFS+3)))<<24);
									
									tInfo.ulPadFwSz		= 
														((uint32_t)(*(uint8_t *)(ulTemp+FOTA_PAD_FW_SZ_OFS)))			+									
														(((uint32_t)(*(uint8_t *)(ulTemp+FOTA_PAD_FW_SZ_OFS+1)))<<8) 	+
														(((uint32_t)(*(uint8_t *)(ulTemp+FOTA_PAD_FW_SZ_OFS+2)))<<16) 	+									
														(((uint32_t)(*(uint8_t *)(ulTemp+FOTA_PAD_FW_SZ_OFS+3)))<<24);
									
									tInfo.uwNumOfFrm	= 
														((uint16_t)(*(uint8_t *)(ulTemp+FOTA_NUM_OF_FRM_OFS)))			+									
														(((uint16_t)(*(uint8_t *)(ulTemp+FOTA_NUM_OF_FRM_OFS+1)))<<8);
									
									tInfo.uwSzPerFrm	= 
														((uint16_t)(*(uint8_t *)(ulTemp+FOTA_SZ_PER_FRM_OFS)))			+									
														(((uint16_t)(*(uint8_t *)(ulTemp+FOTA_SZ_PER_FRM_OFS+1)))<<8);
									
									tInfo.ubFwType		= *(uint8_t *)(ulTemp+FOTA_FW_TYPE_OFS);
									
									tInfo.uwFrmIdx	= 
														((uint16_t)(*(uint8_t *)(ulTemp+FOTA_FRM_IDX_OFS)))				+									
														(((uint16_t)(*(uint8_t *)(ulTemp+FOTA_FRM_IDX_OFS+1)))<<8);
														
									/*
									printf("----------------\r\n");
									printf("RealFwSz:%d\r\n",tInfo.ulRealFwSz);
									printf("PadFwSz:%d\r\n",tInfo.ulPadFwSz);
									printf("NumOfFrm:%d\r\n",tInfo.uwNumOfFrm);
									printf("SzPerFrm:%d\r\n",tInfo.uwSzPerFrm);
									printf("FwType:%d\r\n",tInfo.ubFwType);
									printf("FrmIdx:%d\r\n",tInfo.uwFrmIdx);
									*/
									//printf("----------------\r\n");
									//printf("Rcv:%d\r\n",ulActiveLen);
									//printf("RealSz:%d\r\n",tInfo.ulRealFwSz);
									//printf("PadSz:%d\r\n",tInfo.ulPadFwSz);
									//printf("N:%d\r\n",tInfo.uwNumOfFrm);
									//printf("SzFrm:%d\r\n",tInfo.uwSzPerFrm);
									//printf("T:%d\r\n",tInfo.ubFwType);
									//printf("I:%d\r\n",tInfo.uwFrmIdx);
									//printf("%d,%d\r\n",tInfo.uwNumOfFrm,tInfo.uwFrmIdx);
									if(tInfo.uwFrmIdx == 0)
									{
										printf("[Start]Receive FOTA Data\r\n");
									}
									else if(tInfo.uwFrmIdx == (tInfo.uwNumOfFrm-1))
									{
										printf("[Stop]Receive FOTA Data\r\n");
									}
									
									ubChkOkFlg = 1;
									//Check Valid
									//----------------------------------------------------
									if(tInfo.ulRealFwSz > FOTA_MAX_REAL_FW_SZ) 
									{
										ubChkOkFlg = 0;
										printf("Fail at RealFwSz:%d\r\n",tInfo.ulRealFwSz);
									}
									if(tInfo.ulPadFwSz > FOTA_MAX_PAD_FW_SZ) 
									{
										ubChkOkFlg = 0;
										printf("Fail at PadFwSz:%d\r\n",tInfo.ulPadFwSz);
									}
									if(tInfo.uwNumOfFrm > FOTA_MAX_NUM_OF_FRM) 
									{
										ubChkOkFlg = 0;
										printf("Fail at NumOfFrm:%d\r\n",tInfo.uwNumOfFrm);
									}
									if(tInfo.uwSzPerFrm > FOTA_MAX_SZ_PER_FRM) 
									{
										ubChkOkFlg = 0;
										printf("Fail at SzPerFrm:%d\r\n",tInfo.uwSzPerFrm);
									}
									if(tInfo.ubFwType > FOTA_MAX_FW_TYPE) 
									{
										ubChkOkFlg = 0;
										printf("Fail at FwType:%d\r\n",tInfo.ubFwType);
									}
									if(tInfo.uwFrmIdx > FOTA_MAX_FRM_IDX) 
									{
										ubChkOkFlg = 0;
										printf("Fail at FrmIdx:%d\r\n",tInfo.uwFrmIdx);										
									}									
									//printf("ChkOkFlg:%d\r\n",ubChkOkFlg);
									
									
									if(!ubChkOkFlg)
									{
										ubKNL_FotaStartRcvFlg = 0;
										uwKNL_FotaNumOfFrm = 0;
										uwKNL_FotaCurFrmIdx = 0;
										uwKNL_FotaPreFrmIdx = 0;
										ulKNL_FotaRealFwSz = 0;
										ulKNL_FotaPadFwSz = 0;
									}
									else
									{
										if(tInfo.uwFrmIdx == 0)
										{
											uwKNL_FotaCurFrmIdx = 0;
											uwKNL_FotaPreFrmIdx = 0;
											uwKNL_FotaNumOfFrm  = tInfo.uwNumOfFrm;
											ulKNL_FotaRealFwSz  = tInfo.ulRealFwSz;
											ulKNL_FotaPadFwSz 	= tInfo.ulPadFwSz;
											
											tDMAC_MemCopy(ulTemp+16,ulBUF_GetBlkBufAddr(0,BUF_FOTA),tInfo.uwSzPerFrm,NULL);
											
											if(uwKNL_FotaCurFrmIdx == (uwKNL_FotaNumOfFrm-1))
											{
												ubChkOkFlg = 1;
												
												//printf("Finish to Rcv:%d Bytes,RealSz:%d\r\n",ulKNL_FotaPadFwSz,ulKNL_FotaRealFwSz);
												printf("Rcv:%d,%d\r\n",ulKNL_FotaPadFwSz,ulKNL_FotaRealFwSz);												
												ulKNL_FotaDataSize = ulKNL_FotaRealFwSz;
												
												//CB Function Event
												//--------------------------------
												if(pKNL_FotaCbFuncAtTx != NULL)
													pKNL_FotaCbFuncAtTx();												
												
												/*
												uwShowInfoNum = ulKNL_FotaRealFwSz/FOTA_MAX_SZ_PER_FRM;
												for(n=0;n<uwShowInfoNum;n++)
												{
													printf("D[%d KB]:0x%x\r\n",n*15,*((uint8_t *)(ulBUF_GetBlkBufAddr(0,BUF_FOTA)+(FOTA_MAX_SZ_PER_FRM*n))));
													if((n%10) == 0)
													{
														osDelay(20);
													}
												}												
												printf("D[FN]:0x%x\r\n",*((uint8_t *)(ulBUF_GetBlkBufAddr(0,BUF_FOTA)+ulKNL_FotaRealFwSz-1)));												
												*/
											}
										}
										else if(tInfo.uwFrmIdx == (uwKNL_FotaPreFrmIdx+1))
										{
											uwKNL_FotaCurFrmIdx = tInfo.uwFrmIdx;
											uwKNL_FotaPreFrmIdx = uwKNL_FotaCurFrmIdx;									

											tDMAC_MemCopy(ulTemp+16,ulBUF_GetBlkBufAddr(0,BUF_FOTA)+(((uint32_t)uwKNL_FotaPreFrmIdx)*((uint32_t)tInfo.uwSzPerFrm)),tInfo.uwSzPerFrm,NULL);
											
											if(uwKNL_FotaCurFrmIdx == (uwKNL_FotaNumOfFrm-1))
											{
												ubChkOkFlg = 1;
												
												//printf("Finish to Rcv:%d Bytes,RealSz:%d\r\n",ulKNL_FotaPadFwSz,ulKNL_FotaRealFwSz);
												printf("Rcv:%d,%d\r\n",ulKNL_FotaPadFwSz,ulKNL_FotaRealFwSz);
												
												ulKNL_FotaDataSize = ulKNL_FotaRealFwSz;
												//CB Function Event
												//--------------------------------
												if(pKNL_FotaCbFuncAtTx != NULL)
													pKNL_FotaCbFuncAtTx();
												//================================											
												
												/*
												uwShowInfoNum = ulKNL_FotaRealFwSz/FOTA_MAX_SZ_PER_FRM;
												for(n=0;n<uwShowInfoNum;n++)
												{
													printf("D[%d KB]:0x%x\r\n",n*15,*((uint8_t *)(ulBUF_GetBlkBufAddr(0,BUF_FOTA)+(FOTA_MAX_SZ_PER_FRM*n))));
													if((n%10) == 0)
													{
														osDelay(20);
													}
												}												
												printf("D[FN]:0x%x\r\n",*((uint8_t *)(ulBUF_GetBlkBufAddr(0,BUF_FOTA)+ulKNL_FotaRealFwSz-1)));												
												*/
											}
										}
									}
									
									//====================================================
																
									if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubAdo_StartRcvFrameFlg)
										ubBUF_ReleaseAdoPacketize0Buf(ulTemp);
									
									//======================================================================
									
									/*
									RX_DON data;								
									data.Type = BB_DATA_AUDIO;
									data.tSTA = (GET_STA) BB_GET_STA1;
									data.ulAddr = (uint32_t)ulTemp;
									data.ulSize = ulActiveLen;
									data.ubGetCrc = 0;
									data.ulCrcLen = 0;									

									//printf("A_OI:%d\r\n",ubTotalIdx);
									// Put frame to message queue								
									if(osMessagePut(KNL_QueRxAdo, &data, 0) != osOK)
										printf("QueFull(KNL_QueRxAdo)\r\n");									
									*/
								}	
								else
								{
									if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubAdo_StartRcvFrameFlg)
										ubBUF_ReleaseAdoPacketize0Buf(ulAdo_FrmBufAddr);
								}
							}
							else
							{
								if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubAdo_StartRcvFrameFlg)
									ubBUF_ReleaseAdoPacketize0Buf(ulAdo_FrmBufAddr);
							}
						}
						else
						{
							if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubAdo_StartRcvFrameFlg)
								ubBUF_ReleaseAdoPacketize0Buf(ulAdo_FrmBufAddr);
						}			
						
						if((RELEASE_BUF_METHOD == RELEASE_BUF_DIRECT) && ubAdo_StartRcvFrameFlg)
							ubBUF_ReleaseAdoPacketize0Buf(ulAdo_FrmBufAddr);
						
						ubAdo_StartRcvFrameFlg = 0;	
						
						for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
							ubAdo_RdyFlg[i] = 0;				
						
						break;
					}
				}
			}
			else
			{
				if(ubAdo_StartRcvFrameFlg)
				{
					//Drop Previous Frame			
					ubBUF_ReleaseAdoPacketize0Buf(ulAdo_FrmBufAddr);
					ubAdo_StartRcvFrameFlg = 0;
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubAdo_RdyFlg[i] = 0;
				}
			}
		}	
	#endif
		else
		{
			uwChkSumInPkt = ubPkt[MAX_CMD_PACKET_LEN-2];
			uwChkSumInPkt = uwChkSumInPkt + (((uint16_t)ubPkt[MAX_CMD_PACKET_LEN-1])<<8);		
			
			ulTemp = ulBUF_GetBlkBufAddr(0,BUF_RW_FRAME)+BUF_SZ_MAX_VDO+BUF_SZ_MAX_ADO+(BUF_SZ_PKT*1);
			
			for(i=0;i<MAX_CMD_PACKET_LEN-2;i++)
			{
				*((uint8_t *)(ulTemp+i)) = ubPkt[i];
			}			
			
			uwChkSumInCal = uwCHECKSUM_Calc(ulTemp,MAX_CMD_PACKET_LEN-2);				
			
			if(uwChkSumInPkt == uwChkSumInCal)
			{				
				//printf("Cmd Ok[0]\r\n");
				//TWCR_RcvData((uint8_t)TWC_AP_MASTER,(TWC_OPC)ubPkt[1],&ubPkt[2]);
				TWCR_RcvData((uint8_t)TWC_AP_MASTER,(TWC_OPC)ubPkt[3],&ubPkt[4]);				
			}
			else
			{
				printf("Cmd Fail[0]\r\n");
				
				//printf("RF Software Reset(1) @%s\r\n",__func__);				
				//rf_setopt(RF_OPT_SW_RST, &reset, 1);
				//printf("RF Software Reset(2) @%s\r\n",__func__);
				ubKNL_AccessErrCnt(KNL_OPERATION_PLUS,0);
			}				
		}		
	}
#endif
}
#endif

#if (defined(OP_AP) && defined(RTC676x))
static void KNL_Packet1ProcThread(void const *argument)
{
	//uint8_t reset = 1;
	
	int PreRcvMode = PREF_BBR_QPSK;
	int CurRcvMode = PREF_BBR_QPSK;	
	uint32_t ulMaxVdoPktLen;
	uint32_t ulVdoPayloadSz;
	
	//For Common
	KNL_PROCESS tProc;
	uint8_t ubPkt[PACKET_BUF_LEN];
	uint8_t ubCopyFlg = 0;
	uint8_t ubTotalIdx 	= 0;
	uint16_t uwTotalNum = 0;
	uint16_t uwFrmIdx 	= 0;
	uint16_t uwPktIdx 	= 0;
	uint32_t ulDstAddr = 0;
	uint16_t uwRdyPktNum;
	uint16_t i,j;
	uint32_t ulTemp;
	uint8_t ubOutFlg = 0;
	uint32_t ulActiveLen = 0;
	uint8_t ubTemp[4];
	uint8_t ubCrcOkFlg = 0;

	//For Video
	uint8_t ubVdo_PreTotalIdx = 0;	
	uint8_t ubVdo_StartRcvFrameFlg = 0;
	uint32_t ulVdo_StartRcvTotalIdx = 0;	
	uint32_t ulVdo_FrmBufAddr;
	uint8_t ubVdo_RdyFlg[MAX_NUM_PKT_PER_FRAME];	
	uint16_t uwVdo_PreOutFrmIdx = 0;
	uint8_t ubVdo_ChkOutFlg = 0;
	
	//For Audio
	uint8_t ubAdo_PreTotalIdx = 0;	
	uint8_t ubAdo_StartRcvFrameFlg = 0;
	uint32_t ulAdo_StartRcvTotalIdx = 0;	
	uint32_t ulAdo_FrmBufAddr;
	uint8_t ubAdo_RdyFlg[MAX_NUM_PKT_PER_FRAME];		
	uint8_t ubAdo_PreOutTotalIdx = 0xFF;
	
	//For Data Valid or Not
	uint8_t ubDataValidFlg = 0;
	uint16_t uwChkSumInPkt = 0;	
	uint16_t uwChkSumInCal = 0;	
	
	uint8_t ubChkSumInPkt = 0;
	uint8_t ubChkSumInCal = 0;
	
	osSemaphoreRelease(tKNL_PacketThRdySem[1].Id);
	
	while(1)
	{
		osMessageGet(KNL_PacketQue[1].Id, &tProc, osWaitForever);		
		
		//Initial
		ubCopyFlg = 0;		
		ubDataValidFlg = 1;		
		
		//Get Header Information				
		memcpy(ubPkt,(uint8_t *)tProc.ulDramAddr2,PKT_RECV_LEN);		
		
		ulMaxVdoPktLen = tProc.ulSize;
		ulVdoPayloadSz = ulMaxVdoPktLen-PKT_HEADER_SZ;
		
		//Release First
		if(ubBUF_ReleasePacket1Buf(tProc.ulDramAddr2) != BUF_OK)
		{
			printf("Fail @%s\r\n",__func__);
		}	

		//Check Modulation Mode
		if((ubPkt[PKT_INFO_OFS_MODE] == PREF_BBR_BPSK) ||(ubPkt[PKT_INFO_OFS_MODE] == PREF_BBR_QPSK) ||(ubPkt[PKT_INFO_OFS_MODE] == PREF_BBR_16QAM))
			CurRcvMode = ubPkt[PKT_INFO_OFS_MODE]&0x0F;
		if(ubPkt[PKT_INFO_OFS_TYPE] == PKT_ADO)		//Audio
		{			
			ubTotalIdx 	= ubPkt[PKT_INFO_OFS_TOTAL_IDX];
			uwTotalNum 	= ((uint16_t)ubPkt[PKT_INFO_OFS_TOTAL_NUM])+(((uint16_t)ubPkt[PKT_INFO_OFS_TOTAL_NUM+1])<<8);			
			uwPktIdx 	= ((uint16_t)ubPkt[PKT_INFO_OFS_PKT_IDX])+(((uint16_t)ubPkt[PKT_INFO_OFS_PKT_IDX+1])<<8);		
			
			//Check Header			
			uwChkSumInPkt = ubPkt[PKT_INFO_OFS_CHKSUM];
			uwChkSumInPkt = uwChkSumInPkt + (((uint16_t)ubPkt[PKT_INFO_OFS_CHKSUM+1])<<8);			
			uwChkSumInCal = 0;
			for(j=0;j<PKT_ACTIVE_HEADER_SZ;j++)
			{
				uwChkSumInCal = uwChkSumInCal + (uint16_t)ubPkt[j];
			}
			
			//Check Payload
			ubChkSumInPkt = ubPkt[PKT_INFO_OFS_RSV];
			ubChkSumInCal = 0;
			for(j=0;j<(MAX_ADO_PACKET_LEN - PKT_HEADER_SZ);j++)
			{
				ubChkSumInCal = ubChkSumInCal + ubPkt[j+PKT_HEADER_SZ];
			}			
			
			//printf("(%d,%d,%d,%d)\r\n",ubTotalIdx,uwTotalNum,uwFrmIdx,uwPktIdx);		
			
			//Check Data Valid or Not			
			if((uwTotalNum > MAX_NUM_PKT_PER_FRAME) || (uwTotalNum == 0))
				ubDataValidFlg = 0;		
			if(uwPktIdx >= uwTotalNum)
				ubDataValidFlg = 0;			
			if(uwChkSumInPkt != uwChkSumInCal)
				ubDataValidFlg = 0;
			
			if(ubChkSumInPkt != ubChkSumInCal)
				ubDataValidFlg = 0;
			
			if(ubDataValidFlg == 0)
			{
				printf("PktErr @%s\r\n",__func__);
			}
			
			if(ubDataValidFlg)
			{				
				if(!ubAdo_StartRcvFrameFlg)	//Receive Any Packet
				{
					//Initial					
					ulAdo_StartRcvTotalIdx = ubTotalIdx;			
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubAdo_RdyFlg[i] = 0;
					
					ubAdo_PreTotalIdx = ubTotalIdx;
					
					//First Pkt @ Frame			
					ulAdo_FrmBufAddr = ulBUF_GetAdoPacketize1FreeBuf();
					if(ulAdo_FrmBufAddr != BUF_FAIL)
					{
						ubCopyFlg = 1;
						ubAdo_StartRcvFrameFlg = 1;
					}
				}				
				else if(ubAdo_StartRcvFrameFlg && (ubTotalIdx != ubAdo_PreTotalIdx))
				{
					//Drop Previous Frame			
					if(ubBUF_ReleaseAdoPacketize1Buf(ulAdo_FrmBufAddr) == BUF_FAIL)
						printf("Release Fail1 @%s\r\n",__func__);
					
					ubAdo_StartRcvFrameFlg = 0;
					
					//Initial			
					ulAdo_StartRcvTotalIdx = ubTotalIdx;			

					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubAdo_RdyFlg[i] = 0;
					
					ubAdo_PreTotalIdx = ubTotalIdx;
					
					//New Frame				
					ulAdo_FrmBufAddr = ulBUF_GetAdoPacketize1FreeBuf();
					if(ulAdo_FrmBufAddr != BUF_FAIL)
					{
						ubCopyFlg = 1;
						ubAdo_StartRcvFrameFlg = 1;
					}			
				}		
				else if(ubAdo_StartRcvFrameFlg && (ubTotalIdx == ulAdo_StartRcvTotalIdx))
				{
					ubCopyFlg = 1;
				}
				else if(ubAdo_StartRcvFrameFlg)
				{
					//Drop Previous Frame			
					if(ubBUF_ReleaseAdoPacketize1Buf(ulAdo_FrmBufAddr) == BUF_FAIL)
						printf("Release Fail2 @%s\r\n",__func__);
					
					ubAdo_StartRcvFrameFlg = 0;
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubAdo_RdyFlg[i] = 0;
				}
			
				if(ubCopyFlg && (!ubAdo_RdyFlg[uwPktIdx]) && ubAdo_StartRcvFrameFlg)
				{			
					ulDstAddr = ulAdo_FrmBufAddr+(PKT_ADO_PAYLOAD_SZ*((uint32_t)uwPktIdx));			
					memcpy((uint8_t *)ulDstAddr,(uint8_t *)&ubPkt[PKT_HEADER_SZ],PKT_ADO_PAYLOAD_SZ);
					ubAdo_RdyFlg[uwPktIdx] = 1;
				}

				//Final Check
				uwRdyPktNum = 0;
				for(i=0;i<uwTotalNum;i++)
				{
					if(ubAdo_RdyFlg[i])
						uwRdyPktNum++;
					if(uwRdyPktNum == uwTotalNum)
					{					
						ubOutFlg = 0;
						
						if(ubTotalIdx != ubAdo_PreOutTotalIdx)
						{
							ubOutFlg = 1;
							ubAdo_PreOutTotalIdx = ubTotalIdx;
						}				
						
						if(ubOutFlg)
						{											
							ulTemp = ulAdo_FrmBufAddr;
							if(ulTemp != BUF_FAIL)
							{						
								ulActiveLen = 0;
								ubTemp[0] = *((uint8_t *)(ulTemp+(uwTotalNum*PKT_ADO_PAYLOAD_SZ)-4));
								ubTemp[1] = *((uint8_t *)(ulTemp+(uwTotalNum*PKT_ADO_PAYLOAD_SZ)-3));
								ubTemp[2] = *((uint8_t *)(ulTemp+(uwTotalNum*PKT_ADO_PAYLOAD_SZ)-2));
								ubTemp[3] = *((uint8_t *)(ulTemp+(uwTotalNum*PKT_ADO_PAYLOAD_SZ)-1));
								ulActiveLen = 	((uint32_t)ubTemp[0])+(((uint32_t)ubTemp[1])<<8)+(((uint32_t)ubTemp[2])<<16)+(((uint32_t)ubTemp[3])<<24);
								
								if(ulActiveLen <= BUF_SZ_MAX_ADO)
								{
									//Check CRC is Valid or In-Valid
									//=====================================
									uint32_t ulCrcCalSz;
									uint8_t ubCrc8InPkt,ubCrc8Cal;						
									
									ubCrc8InPkt = *((uint8_t *)(ulTemp+ulActiveLen-48));
									
									ubTemp[0] = 0;
									ubTemp[1] = 0;
									ubTemp[2] = 0;
									ubTemp[3] = 0;
									
									ubTemp[0] = *((uint8_t *)(ulTemp+ulActiveLen-48+1));
									ubTemp[1] = *((uint8_t *)(ulTemp+ulActiveLen-48+2));
									ubTemp[2] = *((uint8_t *)(ulTemp+ulActiveLen-48+3));	
									ubTemp[3] = *((uint8_t *)(ulTemp+ulActiveLen-48+4));
				
									ulCrcCalSz = (((uint32_t)ubTemp[0])<<0)+(((uint32_t)ubTemp[1])<<8)+(((uint32_t)ubTemp[2])<<16)+(((uint32_t)ubTemp[3])<<24);
									
									ubCrc8Cal = ubKNL_TransmitCRC8(ulTemp, ulCrcCalSz);
						
									if(ubCrc8InPkt == ubCrc8Cal)
									{
										//printf("CA[1]->OK\r\n");
										ubCrcOkFlg = 1;
									}
									else
									{
										printf("CA[1]->Fail1\r\n");
										ubCrcOkFlg = 0;
										
										//printf("RF Software Reset(1) @%s\r\n",__func__);				
										//rf_setopt(RF_OPT_SW_RST, &reset, 1);
										//printf("RF Software Reset(2) @%s\r\n",__func__);
										ubKNL_AccessErrCnt(KNL_OPERATION_PLUS,0);
									}	
								}
								else
								{
									printf("CA[1]->Fail2\r\n");
									ubCrcOkFlg = 0;
									
									//printf("RF Software Reset(1) @%s\r\n",__func__);				
									//rf_setopt(RF_OPT_SW_RST, &reset, 1);
									//printf("RF Software Reset(2) @%s\r\n",__func__);
									ubKNL_AccessErrCnt(KNL_OPERATION_PLUS,0);
								}
			
								//=====================================
								if(ubCrcOkFlg)
								{
									RX_DON data;								
									data.Type = BB_DATA_AUDIO;
									data.tSTA = (GET_STA) BB_GET_STA2;
									data.ulAddr = (uint32_t)ulTemp;
									data.ulSize = ulActiveLen;
									data.ubGetCrc = 0;
									data.ulCrcLen = 0;

									//printf("A_OI[1]:%d\r\n",ubTotalIdx);
									// Put frame to message queue								
									if(osMessagePut(KNL_QueRxAdo, &data, 0) != osOK)
										printf("QueFull(KNL_QueRxAdo)\r\n");
								}
								else
								{
									if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubAdo_StartRcvFrameFlg)
										ubBUF_ReleaseAdoPacketize1Buf(ulAdo_FrmBufAddr);
								}
							}
							else
							{
								if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubAdo_StartRcvFrameFlg)
									ubBUF_ReleaseAdoPacketize1Buf(ulAdo_FrmBufAddr);
							}							
						}	
						else
						{
							if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubAdo_StartRcvFrameFlg)
								ubBUF_ReleaseAdoPacketize1Buf(ulAdo_FrmBufAddr);
						}
					
						if((RELEASE_BUF_METHOD == RELEASE_BUF_DIRECT) && ubAdo_StartRcvFrameFlg)
							ubBUF_ReleaseAdoPacketize1Buf(ulAdo_FrmBufAddr);
					
						ubAdo_StartRcvFrameFlg = 0;	
						
						for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
							ubAdo_RdyFlg[i] = 0;				
						
						break;
					}
				}
			}
			else
			{
				if(ubAdo_StartRcvFrameFlg)
				{
					//Drop Previous Frame			
					ubBUF_ReleaseAdoPacketize1Buf(ulAdo_FrmBufAddr);
					ubAdo_StartRcvFrameFlg = 0;
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubAdo_RdyFlg[i] = 0;
				}
			}			
		}
		else if(ubPkt[PKT_INFO_OFS_TYPE] == PKT_MAIN_VDO)	//Main-Video
		{		
			ubTotalIdx 	= ubPkt[PKT_INFO_OFS_TOTAL_IDX];
			uwTotalNum 	= ((uint16_t)ubPkt[PKT_INFO_OFS_TOTAL_NUM])+(((uint16_t)ubPkt[PKT_INFO_OFS_TOTAL_NUM+1])<<8);
			uwFrmIdx 	= ((uint16_t)ubPkt[PKT_INFO_OFS_FRM_IDX])+(((uint16_t)ubPkt[PKT_INFO_OFS_FRM_IDX+1])<<8);
			uwPktIdx 	= ((uint16_t)ubPkt[PKT_INFO_OFS_PKT_IDX])+(((uint16_t)ubPkt[PKT_INFO_OFS_PKT_IDX+1])<<8);		
			uwChkSumInPkt = ubPkt[PKT_INFO_OFS_CHKSUM];
			uwChkSumInPkt = uwChkSumInPkt + (((uint16_t)ubPkt[PKT_INFO_OFS_CHKSUM+1])<<8);						
			uwChkSumInCal = 0;
			for(j=0;j<PKT_ACTIVE_HEADER_SZ;j++)
			{
				uwChkSumInCal = uwChkSumInCal + (uint16_t)ubPkt[j];
			}
			
			//Check Data Valid or Not			
			if((uwTotalNum > MAX_NUM_PKT_PER_FRAME) ||(uwTotalNum == 0))
				ubDataValidFlg = 0;
			if(uwFrmIdx > KNL_TX_GOP)
				ubDataValidFlg = 0;				
			if(uwPktIdx >= uwTotalNum)
				ubDataValidFlg = 0;
			if(uwChkSumInPkt != uwChkSumInCal)
				ubDataValidFlg = 0;
			if(CurRcvMode != PreRcvMode)
			{
				if(ubVdo_StartRcvFrameFlg)
					ubDataValidFlg = 0;
			}			
			
			
			if(ubDataValidFlg == 0)
			{
				printf("PktErr @%s\r\n",__func__);
			}
			
			if(ubDataValidFlg)
			{			
				if(!ubVdo_StartRcvFrameFlg)	//Receive Any Packet
				{
					//Initial					
					ulVdo_StartRcvTotalIdx = ubTotalIdx;			
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubVdo_RdyFlg[i] = 0;
					
					ubVdo_PreTotalIdx = ubTotalIdx;
					
					//First Pkt @ Frame			
					ulVdo_FrmBufAddr = ulBUF_GetVdoPacketize1FreeBuf();
					if(ulVdo_FrmBufAddr != BUF_FAIL)
					{
						ubCopyFlg = 1;
						ubVdo_StartRcvFrameFlg = 1;
					}
				}				
				else if(ubVdo_StartRcvFrameFlg && (ubTotalIdx != ubVdo_PreTotalIdx))
				{
					//Drop Previous Frame			
					if(ubBUF_ReleaseVdoPacketize1Buf(ulVdo_FrmBufAddr) == BUF_FAIL)
						printf("Release Fail1 @%s\r\n",__func__);
					
					ubVdo_StartRcvFrameFlg = 0;
					
					//Initial			
					ulVdo_StartRcvTotalIdx = ubTotalIdx;			

					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubVdo_RdyFlg[i] = 0;
					
					ubVdo_PreTotalIdx = ubTotalIdx;
					
					//New Frame				
					ulVdo_FrmBufAddr = ulBUF_GetVdoPacketize1FreeBuf();
					if(ulVdo_FrmBufAddr != BUF_FAIL)
					{
						ubCopyFlg = 1;
						ubVdo_StartRcvFrameFlg = 1;
					}			
				}		
				else if(ubVdo_StartRcvFrameFlg && (ubTotalIdx == ulVdo_StartRcvTotalIdx))
				{
					ubCopyFlg = 1;
				}				
				else if(ubVdo_StartRcvFrameFlg)
				{
					//Drop Previous Frame			
					if(ubBUF_ReleaseVdoPacketize1Buf(ulVdo_FrmBufAddr) == BUF_FAIL)
						printf("Release Fail2 @%s\r\n",__func__);
					
					ubVdo_StartRcvFrameFlg = 0;
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubVdo_RdyFlg[i] = 0;
				}
			
				if(ubCopyFlg && (!ubVdo_RdyFlg[uwPktIdx]) && ubVdo_StartRcvFrameFlg)
				{			
					ulDstAddr = ulVdo_FrmBufAddr+(ulVdoPayloadSz*((uint32_t)uwPktIdx));			
					memcpy((uint8_t *)ulDstAddr,(uint8_t *)&ubPkt[PKT_HEADER_SZ],ulVdoPayloadSz);
					ubVdo_RdyFlg[uwPktIdx] = 1;
				}

				//Final Check
				uwRdyPktNum = 0;
				for(i=0;i<uwTotalNum;i++)
				{
					if(ubVdo_RdyFlg[i])
						uwRdyPktNum++;
					if(uwRdyPktNum == uwTotalNum)
					{
						//printf("F1-%d\r\n",uwFrmIdx);
						
						ubOutFlg = 0;						
						if(uwFrmIdx == 0)
						{
							ubOutFlg = 1;	
							uwVdo_PreOutFrmIdx = 0;
							
							ubVdo_ChkOutFlg = 1;
						}
						else
						{					
							if(ubVdo_ChkOutFlg)
							{
								if(uwFrmIdx == (uwVdo_PreOutFrmIdx+1))
								{
									ubOutFlg = 1;
									uwVdo_PreOutFrmIdx = uwFrmIdx;
								}
								else if(uwFrmIdx == uwVdo_PreOutFrmIdx)
								{
									ubOutFlg = 0;
								}
								else
								{
									ubOutFlg = 0;						
									uwVdo_PreOutFrmIdx = 0xFFFF;	//Wait Next Packet is I-Frame
									
									ubVdo_ChkOutFlg = 0;
									
									printf("MissF[%d]\r\n",1);
									
									KNL_SendResendICmd(KNL_STA2);
									if(pKNL_PerDbgFunc[0])
									{
										ubKNL_FrmLossFlag[KNL_STA2] = TRUE;
										pKNL_PerDbgFunc[0](PER_FRMSTS_RPT, KNL_STA2, FRM_LOSS_ERR);
									}
								}
							}
						}
						
						if(ubKNL_CodecFailFlg[1])
						{
							ubKNL_CodecFailFlg[1] = 0;
							ubOutFlg = 0;					
						}				
						
						if(ubOutFlg)
						{						
							ubKNL_OutFpsTemp[1]++;
													
							ulTemp = ulVdo_FrmBufAddr;
							if(ulTemp != BUF_FAIL)
							{							
								ulActiveLen = 0;
								ubTemp[0] = *((uint8_t *)(ulTemp+(uwTotalNum*ulVdoPayloadSz)-4));
								ubTemp[1] = *((uint8_t *)(ulTemp+(uwTotalNum*ulVdoPayloadSz)-3));
								ubTemp[2] = *((uint8_t *)(ulTemp+(uwTotalNum*ulVdoPayloadSz)-2));
								ubTemp[3] = *((uint8_t *)(ulTemp+(uwTotalNum*ulVdoPayloadSz)-1));
								ulActiveLen = 	((uint32_t)ubTemp[0])+(((uint32_t)ubTemp[1])<<8)+(((uint32_t)ubTemp[2])<<16)+(((uint32_t)ubTemp[3])<<24);
								
								if(ulActiveLen <= BUF_SZ_MAX_VDO)
								{
									if(ulKNL_GetFrameSz(ulVdo_FrmBufAddr,ulActiveLen) > ulBUF_GetVdoPacketize1BufSz())
									{
										printf("AuxSz[1]\r\n");
										ulActiveLen = 0xFFFFFFFFL;//Force to Invalid Size
									}
								}
								
								if(ulActiveLen <= BUF_SZ_MAX_VDO)
								{
									//Check CRC is Valid or In-Valid
									//=====================================
									uint32_t ulCrcCalSz;
									uint8_t ubCrc8InPkt,ubCrc8Cal;						
									
									ubCrc8InPkt = *((uint8_t *)(ulTemp+ulActiveLen-48));
									
									ubTemp[0] = 0;
									ubTemp[1] = 0;
									ubTemp[2] = 0;
									ubTemp[3] = 0;
									
									ubTemp[0] = *((uint8_t *)(ulTemp+ulActiveLen-48+1));
									ubTemp[1] = *((uint8_t *)(ulTemp+ulActiveLen-48+2));
									ubTemp[2] = *((uint8_t *)(ulTemp+ulActiveLen-48+3));	
									ubTemp[3] = *((uint8_t *)(ulTemp+ulActiveLen-48+4));
				
									ulCrcCalSz = (((uint32_t)ubTemp[0])<<0)+(((uint32_t)ubTemp[1])<<8)+(((uint32_t)ubTemp[2])<<16)+(((uint32_t)ubTemp[3])<<24);
									
									ubCrc8Cal = ubKNL_TransmitCRC8(ulTemp, ulCrcCalSz);
						
									if(ubCrc8InPkt == ubCrc8Cal)
									{
										//printf("CV[1]->OK\r\n");
										ubCrcOkFlg = 1;
									}
									else
									{
										printf("CV[1]->Fail1\r\n");
										ubCrcOkFlg = 0;
										
										//printf("RF Software Reset(1) @%s\r\n",__func__);				
										//rf_setopt(RF_OPT_SW_RST, &reset, 1);
										//printf("RF Software Reset(2) @%s\r\n",__func__);
										ubKNL_AccessErrCnt(KNL_OPERATION_PLUS,0);
										
										uwVdo_PreOutFrmIdx = 0xFFFF;	//Wait Next Packet is I-Frame							
										KNL_SendResendICmd(KNL_STA2);
									}
								}
								else
								{
									//printf("CV[1]->Fail2\r\n");
									printf("CV[1]->Fail2:%d KB\r\n",ulActiveLen/1024);
									ubCrcOkFlg = 0;
									
									//printf("RF Software Reset(1) @%s\r\n",__func__);				
									//rf_setopt(RF_OPT_SW_RST, &reset, 1);
									//printf("RF Software Reset(2) @%s\r\n",__func__);
									ubKNL_AccessErrCnt(KNL_OPERATION_PLUS,0);
										
									uwVdo_PreOutFrmIdx = 0xFFFF;	//Wait Next Packet is I-Frame							
									KNL_SendResendICmd(KNL_STA2);
								}
			
								//=====================================
								if(ubCrcOkFlg)
								{
								#if 1																
									RX_DON data;
									data.Type = BB_DATA_VIDEO;
									data.tSTA = (GET_STA) BB_GET_STA2;
									data.ulAddr = (uint32_t)ulTemp;
									data.ulSize = ulActiveLen;
									data.ubGetCrc = 0;
									data.ulCrcLen = 0;

									// Put frame to message queue
									if(osMessagePut(KNL_QueRxVdo, &data, 0) != osOK)
										printf("QueFull(KNL_QueRxVdo)\r\n");
								#else
									tKNL_RxVdoInProcess(BB_GET_STA2, ulTemp, ulActiveLen);
								#endif
								}
								else
								{									
									if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubVdo_StartRcvFrameFlg)								
										ubBUF_ReleaseVdoPacketize1Buf(ulVdo_FrmBufAddr);
									
									if(pKNL_PerDbgFunc[0])
										pKNL_PerDbgFunc[0](PER_FRMSTS_RPT, KNL_STA2, FRM_CRC_ERR);
								}
							}	
							else
							{								
								if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubVdo_StartRcvFrameFlg)
									ubBUF_ReleaseVdoPacketize1Buf(ulVdo_FrmBufAddr);
							}							
						}	
						else
						{							
							if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubVdo_StartRcvFrameFlg)
								ubBUF_ReleaseVdoPacketize1Buf(ulVdo_FrmBufAddr);
						}						
					
						if((RELEASE_BUF_METHOD == RELEASE_BUF_DIRECT) && ubVdo_StartRcvFrameFlg)
							ubBUF_ReleaseVdoPacketize1Buf(ulVdo_FrmBufAddr);
							
						ubVdo_StartRcvFrameFlg = 0;	
						
						for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
							ubVdo_RdyFlg[i] = 0;				
						
						break;
					}
				}		
			}	
			else
			{
				if(ubVdo_StartRcvFrameFlg)
				{
					//Drop Previous Frame			
					ubBUF_ReleaseVdoPacketize1Buf(ulVdo_FrmBufAddr);
					ubVdo_StartRcvFrameFlg = 0;
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubVdo_RdyFlg[i] = 0;
				}
			}		
		}		
		else	//Cmd
		{
			uwChkSumInPkt = ubPkt[MAX_CMD_PACKET_LEN-2];
			uwChkSumInPkt = uwChkSumInPkt + (((uint16_t)ubPkt[MAX_CMD_PACKET_LEN-1])<<8);			
			
			ulTemp = ulBUF_GetBlkBufAddr(0,BUF_RW_FRAME)+BUF_SZ_MAX_VDO+BUF_SZ_MAX_ADO+(BUF_SZ_PKT*2);
			
			for(i=0;i<MAX_CMD_PACKET_LEN-2;i++)
			{
				*((uint8_t *)(ulTemp+i)) = ubPkt[i];
			}			
			
			uwChkSumInCal = uwCHECKSUM_Calc(ulTemp,MAX_CMD_PACKET_LEN-2);			
			
			if(uwChkSumInPkt == uwChkSumInCal)
			{				
				//printf("Cmd Ok[1]\r\n");
				TWCR_RcvData((uint8_t)TWC_STA2,(TWC_OPC)ubPkt[3],&ubPkt[4]);
			}
			else
			{
				printf("Cmd Fail[1]\r\n");
				
				//printf("RF Software Reset(1) @%s\r\n",__func__);				
				//rf_setopt(RF_OPT_SW_RST, &reset, 1);
				//printf("RF Software Reset(2) @%s\r\n",__func__);
				ubKNL_AccessErrCnt(KNL_OPERATION_PLUS,0);
			}						
		}
		
		if((CurRcvMode == PREF_BBR_BPSK) ||(CurRcvMode == PREF_BBR_QPSK) ||(CurRcvMode == PREF_BBR_16QAM))
			PreRcvMode = CurRcvMode;
		
	}
}
#endif

#if (defined(OP_AP) && defined(RTC676x))
static void KNL_Packet2ProcThread(void const *argument)
{
	//uint8_t reset = 1;
	
	int PreRcvMode = PREF_BBR_QPSK;
	int CurRcvMode = PREF_BBR_QPSK;	
	uint32_t ulMaxVdoPktLen;
	uint32_t ulVdoPayloadSz;
	
	//For Common
	KNL_PROCESS tProc;
	uint8_t ubPkt[PACKET_BUF_LEN];
	uint8_t ubCopyFlg = 0;
	uint8_t ubTotalIdx 	= 0;
	uint16_t uwTotalNum = 0;
	uint16_t uwFrmIdx 	= 0;
	uint16_t uwPktIdx 	= 0;
	uint32_t ulDstAddr = 0;
	uint16_t uwRdyPktNum;
	uint16_t i,j;
	uint32_t ulTemp;
	uint8_t ubOutFlg = 0;
	uint32_t ulActiveLen = 0;
	uint8_t ubTemp[4];
	uint8_t ubCrcOkFlg = 0;

	//For Video
	uint8_t ubVdo_PreTotalIdx = 0;	
	uint8_t ubVdo_StartRcvFrameFlg = 0;
	uint32_t ulVdo_StartRcvTotalIdx = 0;	
	uint32_t ulVdo_FrmBufAddr;
	uint8_t ubVdo_RdyFlg[MAX_NUM_PKT_PER_FRAME];	
	uint16_t uwVdo_PreOutFrmIdx = 0;
	uint8_t ubVdo_ChkOutFlg = 0;
	
	//For Audio
	uint8_t ubAdo_PreTotalIdx = 0;	
	uint8_t ubAdo_StartRcvFrameFlg = 0;
	uint32_t ulAdo_StartRcvTotalIdx = 0;	
	uint32_t ulAdo_FrmBufAddr;
	uint8_t ubAdo_RdyFlg[MAX_NUM_PKT_PER_FRAME];		
	uint8_t ubAdo_PreOutTotalIdx = 0xFF;
	
	//For Data Valid or Not
	uint8_t ubDataValidFlg = 0;
	uint16_t uwChkSumInPkt = 0;	
	uint16_t uwChkSumInCal = 0;
	
	uint8_t ubChkSumInPkt = 0;
	uint8_t ubChkSumInCal = 0;
	
	osSemaphoreRelease(tKNL_PacketThRdySem[2].Id);
	
	while(1)
	{
		osMessageGet(KNL_PacketQue[2].Id, &tProc, osWaitForever);		
		
		//Initial
		ubCopyFlg = 0;
		ubDataValidFlg = 1;		
		
		//Get Header Information				
		memcpy(ubPkt,(uint8_t *)tProc.ulDramAddr2,PKT_RECV_LEN);		
		
		ulMaxVdoPktLen = tProc.ulSize;
		ulVdoPayloadSz = ulMaxVdoPktLen-PKT_HEADER_SZ;
		
		//Release First
		if(ubBUF_ReleasePacket2Buf(tProc.ulDramAddr2) != BUF_OK)
		{
			printf("Fail @%s\r\n",__func__);
		}	

		//Check Modulation Mode
		if((ubPkt[PKT_INFO_OFS_MODE] == PREF_BBR_BPSK) ||(ubPkt[PKT_INFO_OFS_MODE] == PREF_BBR_QPSK) ||(ubPkt[PKT_INFO_OFS_MODE] == PREF_BBR_16QAM))
			CurRcvMode = ubPkt[PKT_INFO_OFS_MODE]&0x0F;
		if(ubPkt[PKT_INFO_OFS_TYPE] == PKT_ADO)		//Audio
		{			
			ubTotalIdx 	= ubPkt[PKT_INFO_OFS_TOTAL_IDX];
			uwTotalNum 	= ((uint16_t)ubPkt[PKT_INFO_OFS_TOTAL_NUM])+(((uint16_t)ubPkt[PKT_INFO_OFS_TOTAL_NUM+1])<<8);			
			uwPktIdx 	= ((uint16_t)ubPkt[PKT_INFO_OFS_PKT_IDX])+(((uint16_t)ubPkt[PKT_INFO_OFS_PKT_IDX+1])<<8);		
			
			//Check Header			
			uwChkSumInPkt = ubPkt[PKT_INFO_OFS_CHKSUM];
			uwChkSumInPkt = uwChkSumInPkt + (((uint16_t)ubPkt[PKT_INFO_OFS_CHKSUM+1])<<8);						
			uwChkSumInCal = 0;			
			for(j=0;j<PKT_ACTIVE_HEADER_SZ;j++)
			{
				uwChkSumInCal = uwChkSumInCal + (uint16_t)ubPkt[j];
			}
			
			//Check Payload
			ubChkSumInPkt = ubPkt[PKT_INFO_OFS_RSV];
			ubChkSumInCal = 0;
			for(j=0;j<(MAX_ADO_PACKET_LEN - PKT_HEADER_SZ);j++)
			{
				ubChkSumInCal = ubChkSumInCal + (uint16_t)ubPkt[j+PKT_HEADER_SZ];
			}			
			
			//printf("(%d,%d,%d,%d)\r\n",ubTotalIdx,uwTotalNum,uwFrmIdx,uwPktIdx);		
			
			//Check Data Valid or Not			
			if((uwTotalNum > MAX_NUM_PKT_PER_FRAME) || (uwTotalNum == 0))
				ubDataValidFlg = 0;			
			if(uwPktIdx >= uwTotalNum)
				ubDataValidFlg = 0;
			if(uwChkSumInPkt != uwChkSumInCal)
				ubDataValidFlg = 0;
			if(ubChkSumInPkt != ubChkSumInCal)
				ubDataValidFlg = 0;
			
			if(ubDataValidFlg == 0)
			{
				printf("PktErr @%s\r\n",__func__);
			}
			
			if(ubDataValidFlg)
			{
				if(!ubAdo_StartRcvFrameFlg)	//Receive Any Packet
				{
					//Initial					
					ulAdo_StartRcvTotalIdx = ubTotalIdx;			
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubAdo_RdyFlg[i] = 0;
					
					ubAdo_PreTotalIdx = ubTotalIdx;
					
					//First Pkt @ Frame			
					ulAdo_FrmBufAddr = ulBUF_GetAdoPacketize2FreeBuf();
					if(ulAdo_FrmBufAddr != BUF_FAIL)
					{
						ubCopyFlg = 1;
						ubAdo_StartRcvFrameFlg = 1;
					}
				}				
				else if(ubAdo_StartRcvFrameFlg && (ubTotalIdx != ubAdo_PreTotalIdx))
				{
					//Drop Previous Frame			
					if(ubBUF_ReleaseAdoPacketize2Buf(ulAdo_FrmBufAddr) == BUF_FAIL)
						printf("Release Fail1 @%s\r\n",__func__);						
					
					ubAdo_StartRcvFrameFlg = 0;
					
					//Initial			
					ulAdo_StartRcvTotalIdx = ubTotalIdx;			

					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubAdo_RdyFlg[i] = 0;
					
					ubAdo_PreTotalIdx = ubTotalIdx;
					
					//New Frame				
					ulAdo_FrmBufAddr = ulBUF_GetAdoPacketize2FreeBuf();
					if(ulAdo_FrmBufAddr != BUF_FAIL)
					{
						ubCopyFlg = 1;
						ubAdo_StartRcvFrameFlg = 1;
					}			
				}		
				else if(ubAdo_StartRcvFrameFlg && (ubTotalIdx == ulAdo_StartRcvTotalIdx))
				{
					ubCopyFlg = 1;
				}
				else if(ubAdo_StartRcvFrameFlg)
				{
					//Drop Previous Frame			
					if(ubBUF_ReleaseAdoPacketize2Buf(ulAdo_FrmBufAddr) == BUF_FAIL)
						printf("Release Fail2 @%s\r\n",__func__);
					ubAdo_StartRcvFrameFlg = 0;
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubAdo_RdyFlg[i] = 0;
				}
			
				if(ubCopyFlg && (!ubAdo_RdyFlg[uwPktIdx]) && ubAdo_StartRcvFrameFlg)
				{			
					ulDstAddr = ulAdo_FrmBufAddr+(PKT_ADO_PAYLOAD_SZ*((uint32_t)uwPktIdx));			
					memcpy((uint8_t *)ulDstAddr,(uint8_t *)&ubPkt[PKT_HEADER_SZ],PKT_ADO_PAYLOAD_SZ);
					ubAdo_RdyFlg[uwPktIdx] = 1;
				}

				//Final Check
				uwRdyPktNum = 0;
				for(i=0;i<uwTotalNum;i++)
				{
					if(ubAdo_RdyFlg[i])
						uwRdyPktNum++;
					if(uwRdyPktNum == uwTotalNum)
					{					
						ubOutFlg = 0;
						
						if(ubTotalIdx != ubAdo_PreOutTotalIdx)
						{
							ubOutFlg = 1;
							ubAdo_PreOutTotalIdx = ubTotalIdx;
						}				
						
						if(ubOutFlg)
						{											
							ulTemp = ulAdo_FrmBufAddr;
							if(ulTemp != BUF_FAIL)
							{						
								ulActiveLen = 0;
								ubTemp[0] = *((uint8_t *)(ulTemp+(uwTotalNum*PKT_ADO_PAYLOAD_SZ)-4));
								ubTemp[1] = *((uint8_t *)(ulTemp+(uwTotalNum*PKT_ADO_PAYLOAD_SZ)-3));
								ubTemp[2] = *((uint8_t *)(ulTemp+(uwTotalNum*PKT_ADO_PAYLOAD_SZ)-2));
								ubTemp[3] = *((uint8_t *)(ulTemp+(uwTotalNum*PKT_ADO_PAYLOAD_SZ)-1));
								ulActiveLen = 	((uint32_t)ubTemp[0])+(((uint32_t)ubTemp[1])<<8)+(((uint32_t)ubTemp[2])<<16)+(((uint32_t)ubTemp[3])<<24);
								
								if(ulActiveLen <= BUF_SZ_MAX_ADO)
								{
									//Check CRC is Valid or In-Valid
									//=====================================
									uint32_t ulCrcCalSz;
									uint8_t ubCrc8InPkt,ubCrc8Cal;						
									
									ubCrc8InPkt = *((uint8_t *)(ulTemp+ulActiveLen-48));
									
									ubTemp[0] = 0;
									ubTemp[1] = 0;
									ubTemp[2] = 0;
									ubTemp[3] = 0;
									
									ubTemp[0] = *((uint8_t *)(ulTemp+ulActiveLen-48+1));
									ubTemp[1] = *((uint8_t *)(ulTemp+ulActiveLen-48+2));
									ubTemp[2] = *((uint8_t *)(ulTemp+ulActiveLen-48+3));	
									ubTemp[3] = *((uint8_t *)(ulTemp+ulActiveLen-48+4));
				
									ulCrcCalSz = (((uint32_t)ubTemp[0])<<0)+(((uint32_t)ubTemp[1])<<8)+(((uint32_t)ubTemp[2])<<16)+(((uint32_t)ubTemp[3])<<24);
									
									ubCrc8Cal = ubKNL_TransmitCRC8(ulTemp, ulCrcCalSz);
						
									if(ubCrc8InPkt == ubCrc8Cal)
									{
										//printf("CA[2]->OK\r\n");
										ubCrcOkFlg = 1;
									}
									else
									{
										printf("CA[2]->Fail1\r\n");
										ubCrcOkFlg = 0;
										
										//printf("RF Software Reset(1) @%s\r\n",__func__);				
										//rf_setopt(RF_OPT_SW_RST, &reset, 1);
										//printf("RF Software Reset(2) @%s\r\n",__func__);
										ubKNL_AccessErrCnt(KNL_OPERATION_PLUS,0);
									}
								}
								else
								{
									printf("CA[2]->Fail2\r\n");
									ubCrcOkFlg = 0;
									
									//printf("RF Software Reset(1) @%s\r\n",__func__);				
									//rf_setopt(RF_OPT_SW_RST, &reset, 1);
									//printf("RF Software Reset(2) @%s\r\n",__func__);
									ubKNL_AccessErrCnt(KNL_OPERATION_PLUS,0);
								}
			
								//=====================================
								if(ubCrcOkFlg)
								{
									RX_DON data;								
									data.Type = BB_DATA_AUDIO;
									data.tSTA = (GET_STA) BB_GET_STA3;
									data.ulAddr = (uint32_t)ulTemp;
									data.ulSize = ulActiveLen;
									data.ubGetCrc = 0;
									data.ulCrcLen = 0;

									//printf("A_OI[2]:%d\r\n",ubTotalIdx);
									// Put frame to message queue								
									if(osMessagePut(KNL_QueRxAdo, &data, 0) != osOK)
										printf("QueFull(KNL_QueRxAdo)\r\n");
								}
								else
								{
									if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubAdo_StartRcvFrameFlg)
										ubBUF_ReleaseAdoPacketize2Buf(ulAdo_FrmBufAddr);
								}
							}
							else
							{
								if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubAdo_StartRcvFrameFlg)
									ubBUF_ReleaseAdoPacketize2Buf(ulAdo_FrmBufAddr);
							}							
						}
						else
						{
							if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubAdo_StartRcvFrameFlg)
								ubBUF_ReleaseAdoPacketize2Buf(ulAdo_FrmBufAddr);
						}	
						
						if((RELEASE_BUF_METHOD == RELEASE_BUF_DIRECT) && ubAdo_StartRcvFrameFlg)
							ubBUF_ReleaseAdoPacketize2Buf(ulAdo_FrmBufAddr);
					
						ubAdo_StartRcvFrameFlg = 0;	
						
						for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
							ubAdo_RdyFlg[i] = 0;				
						
						break;
					}
				}
			}
			else
			{
				if(ubAdo_StartRcvFrameFlg)
				{
					//Drop Previous Frame			
					ubBUF_ReleaseAdoPacketize2Buf(ulAdo_FrmBufAddr);
					ubAdo_StartRcvFrameFlg = 0;
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubAdo_RdyFlg[i] = 0;
				}
			}
		}
		else if(ubPkt[PKT_INFO_OFS_TYPE] == PKT_MAIN_VDO)	//Main-Video
		{		
			ubTotalIdx 	= ubPkt[PKT_INFO_OFS_TOTAL_IDX];
			uwTotalNum 	= ((uint16_t)ubPkt[PKT_INFO_OFS_TOTAL_NUM])+(((uint16_t)ubPkt[PKT_INFO_OFS_TOTAL_NUM+1])<<8);
			uwFrmIdx 	= ((uint16_t)ubPkt[PKT_INFO_OFS_FRM_IDX])+(((uint16_t)ubPkt[PKT_INFO_OFS_FRM_IDX+1])<<8);
			uwPktIdx 	= ((uint16_t)ubPkt[PKT_INFO_OFS_PKT_IDX])+(((uint16_t)ubPkt[PKT_INFO_OFS_PKT_IDX+1])<<8);		
			uwChkSumInPkt = ubPkt[PKT_INFO_OFS_CHKSUM];
			uwChkSumInPkt = uwChkSumInPkt + (((uint16_t)ubPkt[PKT_INFO_OFS_CHKSUM+1])<<8);						
			uwChkSumInCal = 0;
			for(j=0;j<PKT_ACTIVE_HEADER_SZ;j++)
			{
				uwChkSumInCal = uwChkSumInCal + (uint16_t)ubPkt[j];
			}
			//printf("(%d,%d,%d,%d)\r\n",ubTotalIdx,uwTotalNum,uwFrmIdx,uwPktIdx);		
			
			//Check Data Valid or Not			
			if((uwTotalNum > MAX_NUM_PKT_PER_FRAME) ||(uwTotalNum == 0))
				ubDataValidFlg = 0;
			if(uwFrmIdx > KNL_TX_GOP)
				ubDataValidFlg = 0;				
			if(uwPktIdx >= uwTotalNum)
				ubDataValidFlg = 0;
			if(uwChkSumInPkt != uwChkSumInCal)
				ubDataValidFlg = 0;
			if(CurRcvMode != PreRcvMode)
			{
				if(ubVdo_StartRcvFrameFlg)
					ubDataValidFlg = 0;
			}			
			
			if(ubDataValidFlg == 0)
			{
				printf("PktErr @%s\r\n",__func__);
			}
			
			if(ubDataValidFlg)
			{
				if(!ubVdo_StartRcvFrameFlg)	//Receive Any Packet
				{
					//Initial					
					ulVdo_StartRcvTotalIdx = ubTotalIdx;			
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubVdo_RdyFlg[i] = 0;
					
					ubVdo_PreTotalIdx = ubTotalIdx;
					
					//First Pkt @ Frame			
					ulVdo_FrmBufAddr = ulBUF_GetVdoPacketize2FreeBuf();
					if(ulVdo_FrmBufAddr != BUF_FAIL)
					{
						ubCopyFlg = 1;
						ubVdo_StartRcvFrameFlg = 1;
					}
				}				
				else if(ubVdo_StartRcvFrameFlg && (ubTotalIdx != ubVdo_PreTotalIdx))
				{
					//Drop Previous Frame			
					if(ubBUF_ReleaseVdoPacketize2Buf(ulVdo_FrmBufAddr) == BUF_FAIL)
						printf("Release Fail1 @%s\r\n",__func__);
					
					ubVdo_StartRcvFrameFlg = 0;
					
					//Initial			
					ulVdo_StartRcvTotalIdx = ubTotalIdx;			

					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubVdo_RdyFlg[i] = 0;
					
					ubVdo_PreTotalIdx = ubTotalIdx;
					
					//New Frame				
					ulVdo_FrmBufAddr = ulBUF_GetVdoPacketize2FreeBuf();
					if(ulVdo_FrmBufAddr != BUF_FAIL)
					{
						ubCopyFlg = 1;
						ubVdo_StartRcvFrameFlg = 1;
					}			
				}		
				else if(ubVdo_StartRcvFrameFlg && (ubTotalIdx == ulVdo_StartRcvTotalIdx))
				{
					ubCopyFlg = 1;
				}
				else if(ubVdo_StartRcvFrameFlg)
				{
					//Drop Previous Frame			
					if(ubBUF_ReleaseVdoPacketize2Buf(ulVdo_FrmBufAddr) == BUF_FAIL)
						printf("Release Fail2 @%s\r\n",__func__);
					ubVdo_StartRcvFrameFlg = 0;
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubVdo_RdyFlg[i] = 0;
				}
			
				if(ubCopyFlg && (!ubVdo_RdyFlg[uwPktIdx]) && ubVdo_StartRcvFrameFlg)
				{			
					ulDstAddr = ulVdo_FrmBufAddr+(ulVdoPayloadSz*((uint32_t)uwPktIdx));			
					memcpy((uint8_t *)ulDstAddr,(uint8_t *)&ubPkt[PKT_HEADER_SZ],ulVdoPayloadSz);
					ubVdo_RdyFlg[uwPktIdx] = 1;
				}

				//Final Check
				uwRdyPktNum = 0;
				for(i=0;i<uwTotalNum;i++)
				{
					if(ubVdo_RdyFlg[i])
						uwRdyPktNum++;
					if(uwRdyPktNum == uwTotalNum)
					{
						//printf("F2-%d\r\n",uwFrmIdx);
						
						ubOutFlg = 0;						
						if(uwFrmIdx == 0)
						{
							ubOutFlg = 1;	
							uwVdo_PreOutFrmIdx = 0;
							
							ubVdo_ChkOutFlg = 1;
						}
						else
						{					
							if(ubVdo_ChkOutFlg)
							{							
								if(uwFrmIdx == (uwVdo_PreOutFrmIdx+1))
								{
									ubOutFlg = 1;
									uwVdo_PreOutFrmIdx = uwFrmIdx;
								}
								else if(uwFrmIdx == uwVdo_PreOutFrmIdx)
								{
									ubOutFlg = 0;
								}
								else
								{
									ubOutFlg = 0;						
									uwVdo_PreOutFrmIdx = 0xFFFF;	//Wait Next Packet is I-Frame
									
									ubVdo_ChkOutFlg = 0;
									
									printf("MissF[%d]\r\n",2);
									
									KNL_SendResendICmd(KNL_STA3);
									if(pKNL_PerDbgFunc[0])
									{
										ubKNL_FrmLossFlag[KNL_STA3] = TRUE;
										pKNL_PerDbgFunc[0](PER_FRMSTS_RPT, KNL_STA3, FRM_LOSS_ERR);
									}
								}
							}
						}
						
						if(ubKNL_CodecFailFlg[2])
						{
							ubKNL_CodecFailFlg[2] = 0;
							ubOutFlg = 0;					
						}				
						
						if(ubOutFlg)
						{						
							ubKNL_OutFpsTemp[2]++;
													
							ulTemp = ulVdo_FrmBufAddr;
							if(ulTemp != BUF_FAIL)
							{								
								ulActiveLen = 0;
								ubTemp[0] = *((uint8_t *)(ulTemp+(uwTotalNum*ulVdoPayloadSz)-4));
								ubTemp[1] = *((uint8_t *)(ulTemp+(uwTotalNum*ulVdoPayloadSz)-3));
								ubTemp[2] = *((uint8_t *)(ulTemp+(uwTotalNum*ulVdoPayloadSz)-2));
								ubTemp[3] = *((uint8_t *)(ulTemp+(uwTotalNum*ulVdoPayloadSz)-1));
								ulActiveLen = 	((uint32_t)ubTemp[0])+(((uint32_t)ubTemp[1])<<8)+(((uint32_t)ubTemp[2])<<16)+(((uint32_t)ubTemp[3])<<24);
								
								if(ulActiveLen <= BUF_SZ_MAX_VDO)
								{
									if(ulKNL_GetFrameSz(ulVdo_FrmBufAddr,ulActiveLen) > ulBUF_GetVdoPacketize2BufSz())
									{
										printf("AuxSz[2]\r\n");
										ulActiveLen = 0xFFFFFFFFL;//Force to Invalid Size
									}
								}
								
								if(ulActiveLen <= BUF_SZ_MAX_VDO)
								{
									//Check CRC is Valid or In-Valid
									//=====================================
									uint32_t ulCrcCalSz;
									uint8_t ubCrc8InPkt,ubCrc8Cal;						
									
									ubCrc8InPkt = *((uint8_t *)(ulTemp+ulActiveLen-48));
									
									ubTemp[0] = 0;
									ubTemp[1] = 0;
									ubTemp[2] = 0;
									ubTemp[3] = 0;
									
									ubTemp[0] = *((uint8_t *)(ulTemp+ulActiveLen-48+1));
									ubTemp[1] = *((uint8_t *)(ulTemp+ulActiveLen-48+2));
									ubTemp[2] = *((uint8_t *)(ulTemp+ulActiveLen-48+3));	
									ubTemp[3] = *((uint8_t *)(ulTemp+ulActiveLen-48+4));
				
									ulCrcCalSz = (((uint32_t)ubTemp[0])<<0)+(((uint32_t)ubTemp[1])<<8)+(((uint32_t)ubTemp[2])<<16)+(((uint32_t)ubTemp[3])<<24);
									
									ubCrc8Cal = ubKNL_TransmitCRC8(ulTemp, ulCrcCalSz);
						
									if(ubCrc8InPkt == ubCrc8Cal)
									{
										//printf("CV[2]->OK\r\n");
										ubCrcOkFlg = 1;
									}
									else
									{
										printf("CV[2]->Fail1\r\n");
										ubCrcOkFlg = 0;
										
										//printf("RF Software Reset(1) @%s\r\n",__func__);				
										//rf_setopt(RF_OPT_SW_RST, &reset, 1);
										//printf("RF Software Reset(2) @%s\r\n",__func__);
										ubKNL_AccessErrCnt(KNL_OPERATION_PLUS,0);
										
										uwVdo_PreOutFrmIdx = 0xFFFF;	//Wait Next Packet is I-Frame							
										KNL_SendResendICmd(KNL_STA3);
									}
								}
								else
								{
									//printf("CV[2]->Fail2\r\n");
									printf("CV[2]->Fail2:%d KB\r\n",ulActiveLen/1024);
									ubCrcOkFlg = 0;
									
									//printf("RF Software Reset(1) @%s\r\n",__func__);				
									//rf_setopt(RF_OPT_SW_RST, &reset, 1);
									//printf("RF Software Reset(2) @%s\r\n",__func__);
									ubKNL_AccessErrCnt(KNL_OPERATION_PLUS,0);
										
									uwVdo_PreOutFrmIdx = 0xFFFF;	//Wait Next Packet is I-Frame							
									KNL_SendResendICmd(KNL_STA3);
								}
			
								//=====================================
								if(ubCrcOkFlg)
								{								
								#if 1								
									RX_DON data;
									data.Type = BB_DATA_VIDEO;
									data.tSTA = (GET_STA) BB_GET_STA3;
									data.ulAddr = (uint32_t)ulTemp;
									data.ulSize = ulActiveLen;
									data.ubGetCrc = 0;
									data.ulCrcLen = 0;

									// Put frame to message queue
									if(osMessagePut(KNL_QueRxVdo, &data, 0) != osOK)
										printf("QueFull(KNL_QueRxVdo)\r\n");
								#else
									tKNL_RxVdoInProcess(BB_GET_STA3, ulTemp, ulActiveLen);
								#endif
								}	
								else
								{									
									if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubVdo_StartRcvFrameFlg)
										ubBUF_ReleaseVdoPacketize2Buf(ulVdo_FrmBufAddr);
									
									if(pKNL_PerDbgFunc[0])
										pKNL_PerDbgFunc[0](PER_FRMSTS_RPT, KNL_STA3, FRM_CRC_ERR);
								}							
							}	
							else
							{								
								if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubVdo_StartRcvFrameFlg)
									ubBUF_ReleaseVdoPacketize2Buf(ulVdo_FrmBufAddr);
							}							
						}	
						else
						{							
							if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubVdo_StartRcvFrameFlg)
								ubBUF_ReleaseVdoPacketize2Buf(ulVdo_FrmBufAddr);
						}						
					
						if((RELEASE_BUF_METHOD == RELEASE_BUF_DIRECT) && ubVdo_StartRcvFrameFlg)
								ubBUF_ReleaseVdoPacketize2Buf(ulVdo_FrmBufAddr);
						
						ubVdo_StartRcvFrameFlg = 0;	
						
						for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
							ubVdo_RdyFlg[i] = 0;				
						
						break;
					}
				}
			}	
			else
			{
				if(ubVdo_StartRcvFrameFlg)
				{
					//Drop Previous Frame			
					ubBUF_ReleaseVdoPacketize2Buf(ulVdo_FrmBufAddr);
					ubVdo_StartRcvFrameFlg = 0;
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubVdo_RdyFlg[i] = 0;
				}
			}			
		}		
		else	//Cmd
		{
			uwChkSumInPkt = ubPkt[MAX_CMD_PACKET_LEN-2];
			uwChkSumInPkt = uwChkSumInPkt + (((uint16_t)ubPkt[MAX_CMD_PACKET_LEN-1])<<8);			
			
			ulTemp = ulBUF_GetBlkBufAddr(0,BUF_RW_FRAME)+BUF_SZ_MAX_VDO+BUF_SZ_MAX_ADO+(BUF_SZ_PKT*3);
			
			for(i=0;i<MAX_CMD_PACKET_LEN-2;i++)
			{
				*((uint8_t *)(ulTemp+i)) = ubPkt[i];
			}			
			
			uwChkSumInCal = uwCHECKSUM_Calc(ulTemp,MAX_CMD_PACKET_LEN-2);			
			
			if(uwChkSumInPkt == uwChkSumInCal)
			{				
				//printf("Cmd Ok[2]\r\n");
				TWCR_RcvData((uint8_t)TWC_STA3,(TWC_OPC)ubPkt[3],&ubPkt[4]);
			}
			else
			{
				printf("Cmd Fail[2]\r\n");
				
				//printf("RF Software Reset(1) @%s\r\n",__func__);				
				//rf_setopt(RF_OPT_SW_RST, &reset, 1);
				//printf("RF Software Reset(2) @%s\r\n",__func__);
				ubKNL_AccessErrCnt(KNL_OPERATION_PLUS,0);
			}						
		}
		
		if((CurRcvMode == PREF_BBR_BPSK) ||(CurRcvMode == PREF_BBR_QPSK) ||(CurRcvMode == PREF_BBR_16QAM))
			PreRcvMode = CurRcvMode;
		
	}
}
#endif

#if (defined(OP_AP) && defined(RTC676x))
static void KNL_Packet3ProcThread(void const *argument)
{
	//uint8_t reset = 1;
	
	int PreRcvMode = PREF_BBR_QPSK;
	int CurRcvMode = PREF_BBR_QPSK;	
	uint32_t ulMaxVdoPktLen;
	uint32_t ulVdoPayloadSz;
	
	//For Common
	KNL_PROCESS tProc;
	uint8_t ubPkt[PACKET_BUF_LEN];
	uint8_t ubCopyFlg = 0;
	uint8_t ubTotalIdx 	= 0;
	uint16_t uwTotalNum = 0;
	uint16_t uwFrmIdx 	= 0;
	uint16_t uwPktIdx 	= 0;
	uint32_t ulDstAddr = 0;
	uint16_t uwRdyPktNum;
	uint16_t i,j;
	uint32_t ulTemp;
	uint8_t ubOutFlg = 0;
	uint32_t ulActiveLen = 0;
	uint8_t ubTemp[4];
	uint8_t ubCrcOkFlg = 0;

	//For Video
	uint8_t ubVdo_PreTotalIdx = 0;	
	uint8_t ubVdo_StartRcvFrameFlg = 0;
	uint32_t ulVdo_StartRcvTotalIdx = 0;	
	uint32_t ulVdo_FrmBufAddr;
	uint8_t ubVdo_RdyFlg[MAX_NUM_PKT_PER_FRAME];	
	uint16_t uwVdo_PreOutFrmIdx = 0;
	uint8_t ubVdo_ChkOutFlg = 0;
	
	//For Audio
	uint8_t ubAdo_PreTotalIdx = 0;	
	uint8_t ubAdo_StartRcvFrameFlg = 0;
	uint32_t ulAdo_StartRcvTotalIdx = 0;	
	uint32_t ulAdo_FrmBufAddr;
	uint8_t ubAdo_RdyFlg[MAX_NUM_PKT_PER_FRAME];		
	uint8_t ubAdo_PreOutTotalIdx = 0xFF;
	
	//For Data Valid or Not
	uint8_t ubDataValidFlg = 0;
	uint16_t uwChkSumInPkt = 0;	
	uint16_t uwChkSumInCal = 0;

	uint8_t ubChkSumInPkt = 0;
	uint8_t ubChkSumInCal = 0;
	
	osSemaphoreRelease(tKNL_PacketThRdySem[3].Id);
	
	while(1)
	{
		osMessageGet(KNL_PacketQue[3].Id, &tProc, osWaitForever);		
		
		//Initial
		ubCopyFlg = 0;
		ubDataValidFlg = 1;		
		
		//Get Header Information				
		memcpy(ubPkt,(uint8_t *)tProc.ulDramAddr2,PKT_RECV_LEN);		
		
		ulMaxVdoPktLen = tProc.ulSize;
		ulVdoPayloadSz = ulMaxVdoPktLen-PKT_HEADER_SZ;
		
		//Release First
		if(ubBUF_ReleasePacket3Buf(tProc.ulDramAddr2) != BUF_OK)
		{
			printf("Fail @%s\r\n",__func__);
		}	

		//Check Modulation Mode
		if((ubPkt[PKT_INFO_OFS_MODE] == PREF_BBR_BPSK) ||(ubPkt[PKT_INFO_OFS_MODE] == PREF_BBR_QPSK) ||(ubPkt[PKT_INFO_OFS_MODE] == PREF_BBR_16QAM))
			CurRcvMode = ubPkt[PKT_INFO_OFS_MODE]&0x0F;

		if(ubPkt[PKT_INFO_OFS_TYPE] == PKT_ADO)		//Audio
		{			
			ubTotalIdx 	= ubPkt[PKT_INFO_OFS_TOTAL_IDX];
			uwTotalNum 	= ((uint16_t)ubPkt[PKT_INFO_OFS_TOTAL_NUM])+(((uint16_t)ubPkt[PKT_INFO_OFS_TOTAL_NUM+1])<<8);			
			uwPktIdx 	= ((uint16_t)ubPkt[PKT_INFO_OFS_PKT_IDX])+(((uint16_t)ubPkt[PKT_INFO_OFS_PKT_IDX+1])<<8);		
			
			//Check Header
			uwChkSumInPkt = ubPkt[PKT_INFO_OFS_CHKSUM];
			uwChkSumInPkt = uwChkSumInPkt + (((uint16_t)ubPkt[PKT_INFO_OFS_CHKSUM+1])<<8);			
			uwChkSumInCal = 0;
			for(j=0;j<PKT_ACTIVE_HEADER_SZ;j++)
			{
				uwChkSumInCal = uwChkSumInCal + (uint16_t)ubPkt[j];
			}
			
			//Check Payload
			ubChkSumInPkt = ubPkt[PKT_INFO_OFS_RSV];
			ubChkSumInCal = 0;
			for(j=0;j<(MAX_ADO_PACKET_LEN - PKT_HEADER_SZ);j++)
			{
				ubChkSumInCal = ubChkSumInCal + (uint16_t)ubPkt[j+PKT_HEADER_SZ];
			}			
			
			//printf("(%d,%d,%d,%d)\r\n",ubTotalIdx,uwTotalNum,uwFrmIdx,uwPktIdx);		
			
			//Check Data Valid or Not			
			if((uwTotalNum > MAX_NUM_PKT_PER_FRAME) || (uwTotalNum == 0))
				ubDataValidFlg = 0;			
			if(uwPktIdx >= uwTotalNum)
				ubDataValidFlg = 0;
			if(uwChkSumInPkt != uwChkSumInCal)
				ubDataValidFlg = 0;
			if(ubChkSumInPkt != ubChkSumInCal)
				ubDataValidFlg = 0;
			
			if(ubDataValidFlg == 0)
			{
				printf("PktErr @%s\r\n",__func__);
			}
			
			if(ubDataValidFlg)
			{				
				if(!ubAdo_StartRcvFrameFlg)	//Receive Any Packet
				{
					//Initial					
					ulAdo_StartRcvTotalIdx = ubTotalIdx;			
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubAdo_RdyFlg[i] = 0;
					
					ubAdo_PreTotalIdx = ubTotalIdx;
					
					//First Pkt @ Frame			
					ulAdo_FrmBufAddr = ulBUF_GetAdoPacketize3FreeBuf();
					if(ulAdo_FrmBufAddr != BUF_FAIL)
					{
						ubCopyFlg = 1;
						ubAdo_StartRcvFrameFlg = 1;
					}
				}				
				else if(ubAdo_StartRcvFrameFlg && (ubTotalIdx != ubAdo_PreTotalIdx))
				{
					//Drop Previous Frame			
					if(ubBUF_ReleaseAdoPacketize3Buf(ulAdo_FrmBufAddr) == BUF_FAIL)
						printf("Release Fail1 @%s\r\n",__func__);
					
					ubAdo_StartRcvFrameFlg = 0;
					
					//Initial			
					ulAdo_StartRcvTotalIdx = ubTotalIdx;			

					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubAdo_RdyFlg[i] = 0;
					
					ubAdo_PreTotalIdx = ubTotalIdx;
					
					//New Frame				
					ulAdo_FrmBufAddr = ulBUF_GetAdoPacketize3FreeBuf();
					if(ulAdo_FrmBufAddr != BUF_FAIL)
					{
						ubCopyFlg = 1;
						ubAdo_StartRcvFrameFlg = 1;
					}			
				}		
				else if(ubAdo_StartRcvFrameFlg && (ubTotalIdx == ulAdo_StartRcvTotalIdx))
				{
					ubCopyFlg = 1;
				}
				else if(ubAdo_StartRcvFrameFlg)
				{
					//Drop Previous Frame			
					if(ubBUF_ReleaseAdoPacketize3Buf(ulAdo_FrmBufAddr) == BUF_FAIL)
						printf("Release Fail2 @%s\r\n",__func__);
					
					ubAdo_StartRcvFrameFlg = 0;
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubAdo_RdyFlg[i] = 0;
				}
			
				if(ubCopyFlg && (!ubAdo_RdyFlg[uwPktIdx]) && ubAdo_StartRcvFrameFlg)
				{			
					ulDstAddr = ulAdo_FrmBufAddr+(PKT_ADO_PAYLOAD_SZ*((uint32_t)uwPktIdx));			
					memcpy((uint8_t *)ulDstAddr,(uint8_t *)&ubPkt[PKT_HEADER_SZ],PKT_ADO_PAYLOAD_SZ);
					ubAdo_RdyFlg[uwPktIdx] = 1;
				}

				//Final Check
				uwRdyPktNum = 0;
				for(i=0;i<uwTotalNum;i++)
				{
					if(ubAdo_RdyFlg[i])
						uwRdyPktNum++;
					if(uwRdyPktNum == uwTotalNum)
					{					
						ubOutFlg = 0;
						
						if(ubTotalIdx != ubAdo_PreOutTotalIdx)
						{
							ubOutFlg = 1;
							ubAdo_PreOutTotalIdx = ubTotalIdx;
						}				
						
						if(ubOutFlg)
						{											
							ulTemp = ulAdo_FrmBufAddr;
							if(ulTemp != BUF_FAIL)
							{						
								ulActiveLen = 0;
								ubTemp[0] = *((uint8_t *)(ulTemp+(uwTotalNum*PKT_ADO_PAYLOAD_SZ)-4));
								ubTemp[1] = *((uint8_t *)(ulTemp+(uwTotalNum*PKT_ADO_PAYLOAD_SZ)-3));
								ubTemp[2] = *((uint8_t *)(ulTemp+(uwTotalNum*PKT_ADO_PAYLOAD_SZ)-2));
								ubTemp[3] = *((uint8_t *)(ulTemp+(uwTotalNum*PKT_ADO_PAYLOAD_SZ)-1));
								ulActiveLen = 	((uint32_t)ubTemp[0])+(((uint32_t)ubTemp[1])<<8)+(((uint32_t)ubTemp[2])<<16)+(((uint32_t)ubTemp[3])<<24);
								
								if(ulActiveLen <= BUF_SZ_MAX_ADO)
								{
									//Check CRC is Valid or In-Valid
									//=====================================
									uint32_t ulCrcCalSz;
									uint8_t ubCrc8InPkt,ubCrc8Cal;						
									
									ubCrc8InPkt = *((uint8_t *)(ulTemp+ulActiveLen-48));
									
									ubTemp[0] = 0;
									ubTemp[1] = 0;
									ubTemp[2] = 0;
									ubTemp[3] = 0;
									
									ubTemp[0] = *((uint8_t *)(ulTemp+ulActiveLen-48+1));
									ubTemp[1] = *((uint8_t *)(ulTemp+ulActiveLen-48+2));
									ubTemp[2] = *((uint8_t *)(ulTemp+ulActiveLen-48+3));	
									ubTemp[3] = *((uint8_t *)(ulTemp+ulActiveLen-48+4));
				
									ulCrcCalSz = (((uint32_t)ubTemp[0])<<0)+(((uint32_t)ubTemp[1])<<8)+(((uint32_t)ubTemp[2])<<16)+(((uint32_t)ubTemp[3])<<24);
									
									ubCrc8Cal = ubKNL_TransmitCRC8(ulTemp, ulCrcCalSz);
						
									if(ubCrc8InPkt == ubCrc8Cal)
									{
										//printf("CA[3]->OK\r\n");
										ubCrcOkFlg = 1;
									}
									else
									{
										printf("CA[3]->Fail1\r\n");
										ubCrcOkFlg = 0;
										
										//printf("RF Software Reset(1) @%s\r\n",__func__);				
										//rf_setopt(RF_OPT_SW_RST, &reset, 1);
										//printf("RF Software Reset(2) @%s\r\n",__func__);
										ubKNL_AccessErrCnt(KNL_OPERATION_PLUS,0);
									}	
								}
								else
								{
									printf("CA[3]->Fail2\r\n");
									ubCrcOkFlg = 0;
									
									//printf("RF Software Reset(1) @%s\r\n",__func__);				
									//rf_setopt(RF_OPT_SW_RST, &reset, 1);
									//printf("RF Software Reset(2) @%s\r\n",__func__);
									ubKNL_AccessErrCnt(KNL_OPERATION_PLUS,0);
								}
			
								//=====================================
								if(ubCrcOkFlg)
								{
									RX_DON data;								
									data.Type = BB_DATA_AUDIO;
									data.tSTA = (GET_STA) BB_GET_STA4;
									data.ulAddr = (uint32_t)ulTemp;
									data.ulSize = ulActiveLen;
									data.ubGetCrc = 0;
									data.ulCrcLen = 0;

									//printf("A_OI[3]:%d\r\n",ubTotalIdx);
									// Put frame to message queue								
									if(osMessagePut(KNL_QueRxAdo, &data, 0) != osOK)
										printf("QueFull(KNL_QueRxAdo)\r\n");
								}
								else
								{
									if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubAdo_StartRcvFrameFlg)	
										ubBUF_ReleaseAdoPacketize3Buf(ulAdo_FrmBufAddr);
								}
							}	
							else
							{
								if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubAdo_StartRcvFrameFlg)	
									ubBUF_ReleaseAdoPacketize3Buf(ulAdo_FrmBufAddr);
							}							
						}	
						else
						{
							if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubAdo_StartRcvFrameFlg)	
								ubBUF_ReleaseAdoPacketize3Buf(ulAdo_FrmBufAddr);
						}
					
						if((RELEASE_BUF_METHOD == RELEASE_BUF_DIRECT) && ubAdo_StartRcvFrameFlg)
							ubBUF_ReleaseAdoPacketize3Buf(ulAdo_FrmBufAddr);
					
						ubAdo_StartRcvFrameFlg = 0;	
						
						for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
							ubAdo_RdyFlg[i] = 0;				
						
						break;
					}
				}
			}
			else
			{
				if(ubAdo_StartRcvFrameFlg)
				{
					//Drop Previous Frame			
					ubBUF_ReleaseAdoPacketize3Buf(ulAdo_FrmBufAddr);
					ubAdo_StartRcvFrameFlg = 0;
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubAdo_RdyFlg[i] = 0;
				}
			}			
		}
		else if(ubPkt[PKT_INFO_OFS_TYPE] == PKT_MAIN_VDO)	//Main-Video
		{		
			ubTotalIdx 	= ubPkt[PKT_INFO_OFS_TOTAL_IDX];
			uwTotalNum 	= ((uint16_t)ubPkt[PKT_INFO_OFS_TOTAL_NUM])+(((uint16_t)ubPkt[PKT_INFO_OFS_TOTAL_NUM+1])<<8);
			uwFrmIdx 	= ((uint16_t)ubPkt[PKT_INFO_OFS_FRM_IDX])+(((uint16_t)ubPkt[PKT_INFO_OFS_FRM_IDX+1])<<8);
			uwPktIdx 	= ((uint16_t)ubPkt[PKT_INFO_OFS_PKT_IDX])+(((uint16_t)ubPkt[PKT_INFO_OFS_PKT_IDX+1])<<8);		
			uwChkSumInPkt = ubPkt[PKT_INFO_OFS_CHKSUM];
			uwChkSumInPkt = uwChkSumInPkt + (((uint16_t)ubPkt[PKT_INFO_OFS_CHKSUM+1])<<8);						
			uwChkSumInCal = 0;
			for(j=0;j<PKT_ACTIVE_HEADER_SZ;j++)
			{
				uwChkSumInCal = uwChkSumInCal + (uint16_t)ubPkt[j];
			}
			//printf("(%d,%d,%d,%d)\r\n",ubTotalIdx,uwTotalNum,uwFrmIdx,uwPktIdx);		
			
			//Check Data Valid or Not			
			if((uwTotalNum > MAX_NUM_PKT_PER_FRAME) ||(uwTotalNum == 0))
				ubDataValidFlg = 0;
			if(uwFrmIdx > KNL_TX_GOP)
				ubDataValidFlg = 0;			
			if(uwPktIdx >= uwTotalNum)
				ubDataValidFlg = 0;
			if(uwChkSumInPkt != uwChkSumInCal)
				ubDataValidFlg = 0;
			if(CurRcvMode != PreRcvMode)
			{
				if(ubVdo_StartRcvFrameFlg)
					ubDataValidFlg = 0;
			}			
			
			
			if(ubDataValidFlg == 0)
			{
				printf("PktErr @%s\r\n",__func__);
			}
			
			if(ubDataValidFlg)
			{
				if(!ubVdo_StartRcvFrameFlg)	//Receive Any Packet
				{
					//Initial				
					ulVdo_StartRcvTotalIdx = ubTotalIdx;			
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubVdo_RdyFlg[i] = 0;
					
					ubVdo_PreTotalIdx = ubTotalIdx;
					
					//First Pkt @ Frame			
					ulVdo_FrmBufAddr = ulBUF_GetVdoPacketize3FreeBuf();
					if(ulVdo_FrmBufAddr != BUF_FAIL)
					{
						ubCopyFlg = 1;
						ubVdo_StartRcvFrameFlg = 1;
					}
				}			
				else if(ubVdo_StartRcvFrameFlg && (ubTotalIdx != ubVdo_PreTotalIdx))
				{
					//Drop Previous Frame			
					if(ubBUF_ReleaseVdoPacketize3Buf(ulVdo_FrmBufAddr) == BUF_FAIL)
						printf("Release Fail1 @%s\r\n",__func__);
					
					ubVdo_StartRcvFrameFlg = 0;
					
					//Initial			
					ulVdo_StartRcvTotalIdx = ubTotalIdx;			

					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubVdo_RdyFlg[i] = 0;
					
					ubVdo_PreTotalIdx = ubTotalIdx;
					
					//New Frame				
					ulVdo_FrmBufAddr = ulBUF_GetVdoPacketize3FreeBuf();
					if(ulVdo_FrmBufAddr != BUF_FAIL)
					{
						ubCopyFlg = 1;
						ubVdo_StartRcvFrameFlg = 1;
					}			
				}		
				else if(ubVdo_StartRcvFrameFlg && (ubTotalIdx == ulVdo_StartRcvTotalIdx))
				{
					ubCopyFlg = 1;
				}
				else if(ubVdo_StartRcvFrameFlg)
				{
					//Drop Previous Frame			
					if(ubBUF_ReleaseVdoPacketize3Buf(ulVdo_FrmBufAddr) == BUF_FAIL)
						printf("Release Fail2 @%s\r\n",__func__);
					
					ubVdo_StartRcvFrameFlg = 0;
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubVdo_RdyFlg[i] = 0;
				}
			
				if(ubCopyFlg && (!ubVdo_RdyFlg[uwPktIdx]) && ubVdo_StartRcvFrameFlg)
				{			
					ulDstAddr = ulVdo_FrmBufAddr+(ulVdoPayloadSz*((uint32_t)uwPktIdx));			
					memcpy((uint8_t *)ulDstAddr,(uint8_t *)&ubPkt[PKT_HEADER_SZ],ulVdoPayloadSz);
					ubVdo_RdyFlg[uwPktIdx] = 1;
				}

				//Final Check
				uwRdyPktNum = 0;
				for(i=0;i<uwTotalNum;i++)
				{
					if(ubVdo_RdyFlg[i])
						uwRdyPktNum++;
					if(uwRdyPktNum == uwTotalNum)
					{
						//printf("F3-%d\r\n",uwFrmIdx);
						
						ubOutFlg = 0;						
						if(uwFrmIdx == 0)
						{
							ubOutFlg = 1;	
							uwVdo_PreOutFrmIdx = 0;
							
							ubVdo_ChkOutFlg = 1;
						}
						else
						{					
							if(ubVdo_ChkOutFlg)
							{
								if(uwFrmIdx == (uwVdo_PreOutFrmIdx+1))
								{
									ubOutFlg = 1;
									uwVdo_PreOutFrmIdx = uwFrmIdx;
								}
								else if(uwFrmIdx == uwVdo_PreOutFrmIdx)
								{
									ubOutFlg = 0;
								}						
								else
								{
									ubOutFlg = 0;						
									uwVdo_PreOutFrmIdx = 0xFFFF;	//Wait Next Packet is I-Frame
									
									ubVdo_ChkOutFlg = 0;
									
									printf("MissF[%d]\r\n",3);
									
									KNL_SendResendICmd(KNL_STA4);
									if(pKNL_PerDbgFunc[0])
									{
										ubKNL_FrmLossFlag[KNL_STA4] = TRUE;
										pKNL_PerDbgFunc[0](PER_FRMSTS_RPT, KNL_STA4, FRM_LOSS_ERR);
									}
								}
							}
						}
						
						if(ubKNL_CodecFailFlg[3])
						{
							ubKNL_CodecFailFlg[3] = 0;
							ubOutFlg = 0;					
						}				
						
						if(ubOutFlg)
						{						
							ubKNL_OutFpsTemp[3]++;
													
							ulTemp = ulVdo_FrmBufAddr;
							if(ulTemp != BUF_FAIL)
							{								
								ulActiveLen = 0;
								ubTemp[0] = *((uint8_t *)(ulTemp+(uwTotalNum*ulVdoPayloadSz)-4));
								ubTemp[1] = *((uint8_t *)(ulTemp+(uwTotalNum*ulVdoPayloadSz)-3));
								ubTemp[2] = *((uint8_t *)(ulTemp+(uwTotalNum*ulVdoPayloadSz)-2));
								ubTemp[3] = *((uint8_t *)(ulTemp+(uwTotalNum*ulVdoPayloadSz)-1));
								ulActiveLen = 	((uint32_t)ubTemp[0])+(((uint32_t)ubTemp[1])<<8)+(((uint32_t)ubTemp[2])<<16)+(((uint32_t)ubTemp[3])<<24);
								
								if(ulActiveLen <= BUF_SZ_MAX_VDO)
								{
									if(ulKNL_GetFrameSz(ulVdo_FrmBufAddr,ulActiveLen) > ulBUF_GetVdoPacketize3BufSz())
									{
										printf("AuxSz[3]\r\n");
										ulActiveLen = 0xFFFFFFFFL;//Force to Invalid Size
									}
								}
								
								if(ulActiveLen <= BUF_SZ_MAX_VDO)
								{
									//Check CRC is Valid or In-Valid
									//=====================================
									uint32_t ulCrcCalSz;
									uint8_t ubCrc8InPkt,ubCrc8Cal;						
									
									ubCrc8InPkt = *((uint8_t *)(ulTemp+ulActiveLen-48));
									
									ubTemp[0] = 0;
									ubTemp[1] = 0;
									ubTemp[2] = 0;
									ubTemp[3] = 0;
									
									ubTemp[0] = *((uint8_t *)(ulTemp+ulActiveLen-48+1));
									ubTemp[1] = *((uint8_t *)(ulTemp+ulActiveLen-48+2));
									ubTemp[2] = *((uint8_t *)(ulTemp+ulActiveLen-48+3));	
									ubTemp[3] = *((uint8_t *)(ulTemp+ulActiveLen-48+4));
				
									ulCrcCalSz = (((uint32_t)ubTemp[0])<<0)+(((uint32_t)ubTemp[1])<<8)+(((uint32_t)ubTemp[2])<<16)+(((uint32_t)ubTemp[3])<<24);
									
									ubCrc8Cal = ubKNL_TransmitCRC8(ulTemp, ulCrcCalSz);
						
									if(ubCrc8InPkt == ubCrc8Cal)
									{
										//printf("CV[3]->OK\r\n");
										ubCrcOkFlg = 1;
									}
									else
									{
										printf("CV[3]->Fail1\r\n");
										ubCrcOkFlg = 0;
										
										//printf("RF Software Reset(1) @%s\r\n",__func__);				
										//rf_setopt(RF_OPT_SW_RST, &reset, 1);
										//printf("RF Software Reset(2) @%s\r\n",__func__);
										ubKNL_AccessErrCnt(KNL_OPERATION_PLUS,0);
										
										uwVdo_PreOutFrmIdx = 0xFFFF;	//Wait Next Packet is I-Frame							
										KNL_SendResendICmd(KNL_STA4);
									}
								}
								else
								{
									//printf("CV[3]->Fail2\r\n");
									printf("CV[3]->Fail2:%d KB\r\n",ulActiveLen/1024);
									ubCrcOkFlg = 0;
									
									//printf("RF Software Reset(1) @%s\r\n",__func__);				
									//rf_setopt(RF_OPT_SW_RST, &reset, 1);
									//printf("RF Software Reset(2) @%s\r\n",__func__);
									ubKNL_AccessErrCnt(KNL_OPERATION_PLUS,0);
									
									uwVdo_PreOutFrmIdx = 0xFFFF;	//Wait Next Packet is I-Frame							
									KNL_SendResendICmd(KNL_STA4);
								}
			
								//=====================================
								if(ubCrcOkFlg)
								{								
								#if 1								
									RX_DON data;
									data.Type = BB_DATA_VIDEO;
									data.tSTA = (GET_STA) BB_GET_STA4;
									data.ulAddr = (uint32_t)ulTemp;
									data.ulSize = ulActiveLen;
									data.ubGetCrc = 0;
									data.ulCrcLen = 0;

									// Put frame to message queue
									if(osMessagePut(KNL_QueRxVdo, &data, 0) != osOK)
										printf("QueFull(KNL_QueRxVdo)\r\n");
								#else
									tKNL_RxVdoInProcess(BB_GET_STA4, ulTemp, ulActiveLen);
								#endif
								}
								else
								{									
									if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubVdo_StartRcvFrameFlg)
										ubBUF_ReleaseVdoPacketize3Buf(ulVdo_FrmBufAddr);
									
									if(pKNL_PerDbgFunc[0])
										pKNL_PerDbgFunc[0](PER_FRMSTS_RPT, KNL_STA4, FRM_CRC_ERR);
								}							
							}
							else
							{								
								if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubVdo_StartRcvFrameFlg)
									ubBUF_ReleaseVdoPacketize3Buf(ulVdo_FrmBufAddr);
							}							
						}
						else
						{							
							if((RELEASE_BUF_METHOD == RELEASE_BUF_QUE) && ubVdo_StartRcvFrameFlg)
								ubBUF_ReleaseVdoPacketize3Buf(ulVdo_FrmBufAddr);
						}						
					
						if((RELEASE_BUF_METHOD == RELEASE_BUF_DIRECT) && ubVdo_StartRcvFrameFlg)
								ubBUF_ReleaseVdoPacketize3Buf(ulVdo_FrmBufAddr);
						
						ubVdo_StartRcvFrameFlg = 0;	
						
						for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
							ubVdo_RdyFlg[i] = 0;				
						
						break;
					}
				}
			}			
			else
			{
				if(ubVdo_StartRcvFrameFlg)
				{
					//Drop Previous Frame			
					ubBUF_ReleaseVdoPacketize3Buf(ulVdo_FrmBufAddr);
					ubVdo_StartRcvFrameFlg = 0;
					
					for(i=0;i<MAX_NUM_PKT_PER_FRAME;i++)	//Clear All Status
						ubVdo_RdyFlg[i] = 0;
				}
			}
		}		
		else	//Cmd
		{
			uwChkSumInPkt = ubPkt[MAX_CMD_PACKET_LEN-2];
			uwChkSumInPkt = uwChkSumInPkt + (((uint16_t)ubPkt[MAX_CMD_PACKET_LEN-1])<<8);			
			
			ulTemp = ulBUF_GetBlkBufAddr(0,BUF_RW_FRAME)+BUF_SZ_MAX_VDO+BUF_SZ_MAX_ADO+(BUF_SZ_PKT*4);
			
			for(i=0;i<MAX_CMD_PACKET_LEN-2;i++)
			{
				*((uint8_t *)(ulTemp+i)) = ubPkt[i];
			}			
			
			uwChkSumInCal = uwCHECKSUM_Calc(ulTemp,MAX_CMD_PACKET_LEN-2);			
			
			if(uwChkSumInPkt == uwChkSumInCal)
			{				
				//printf("Cmd Ok[3]\r\n");
				TWCR_RcvData((uint8_t)TWC_STA4,(TWC_OPC)ubPkt[3],&ubPkt[4]);
			}
			else
			{
				printf("Cmd Fail[3]\r\n");
	//printf("RF Software Reset(1) @%s\r\n",__func__);				
				//rf_setopt(RF_OPT_SW_RST, &reset, 1);
				//printf("RF Software Reset(2) @%s\r\n",__func__);
				ubKNL_AccessErrCnt(KNL_OPERATION_PLUS,0);
			}						
		}
		
		if((CurRcvMode == PREF_BBR_BPSK) ||(CurRcvMode == PREF_BBR_QPSK) ||(CurRcvMode == PREF_BBR_16QAM))
			PreRcvMode = CurRcvMode;		
	}
}
#endif
							

static void KNL_CommTxProcThread(void const *argument)
{
	KNL_PROCESS tProc;

	while(1)
	{
		osMessageGet(KNL_CommTxProcQueue, &tProc, osWaitForever);
		switch(tProc.ubNextNode)
		{
			case KNL_NODE_COMM_TX_VDO:
			#ifdef A7130				
				KNL_BbTxVdoProcess(tProc);
			#endif
			#ifdef RTC676x
				KNL_BbTxVdoProcess2(tProc);
			#endif
			#ifdef S2019A
				KNL_sPRFTxVdoProcess(tProc);
			#endif
				break;
			default:
				break;
		}
	}
}

//------------------------------------------------------------------------------
uint8_t ubKNL_ReleaseBsBufAddr(uint8_t ubCurNode,uint8_t ubSrcNum,uint32_t ulBufAddr)
{
	KNL_NODE_INFO tNodeInfo;
	uint8_t ubTemp;

	osSemaphoreWait(tKNL_BsBufCtrlSem, osWaitForever);
	tNodeInfo = tKNL_GetNodeInfo(ubSrcNum,ubCurNode);
	if(tNodeInfo.ubPreNode == KNL_NODE_VDO_BS_BUF1)
	{
		if(ubSrcNum == KNL_SRC_1_MAIN)
		{
			ubTemp = ubBUF_ReleaseVdoMainBs0Buf(ulBufAddr);
		}
		else if(ubSrcNum == KNL_SRC_2_MAIN)
		{
			ubTemp = ubBUF_ReleaseVdoMainBs1Buf(ulBufAddr);
		}
		else if(ubSrcNum == KNL_SRC_3_MAIN)
		{
			ubTemp = ubBUF_ReleaseVdoMainBs2Buf(ulBufAddr);
		}
		else if(ubSrcNum == KNL_SRC_4_MAIN)
		{
			ubTemp = ubBUF_ReleaseVdoMainBs3Buf(ulBufAddr);
		}
		
		else if(ubSrcNum == KNL_SRC_1_AUX)
		{
			ubTemp = ubBUF_ReleaseVdoAuxBs0Buf(ulBufAddr);
		}
		else if(ubSrcNum == KNL_SRC_2_AUX)
		{
			ubTemp = ubBUF_ReleaseVdoAuxBs1Buf(ulBufAddr);
		}
		else if(ubSrcNum == KNL_SRC_3_AUX)
		{
			ubTemp = ubBUF_ReleaseVdoAuxBs2Buf(ulBufAddr);
		}
		else if(ubSrcNum == KNL_SRC_4_AUX)
		{
			ubTemp = ubBUF_ReleaseVdoAuxBs3Buf(ulBufAddr);
		}
		
		else if(ubSrcNum == KNL_SRC_1_SUB)
		{
			ubTemp = ubBUF_ReleaseVdoSubBs00Buf(ulBufAddr);
		}
		else if(ubSrcNum == KNL_SRC_2_SUB)
		{
			ubTemp = ubBUF_ReleaseVdoSubBs10Buf(ulBufAddr);
		}
		else if(ubSrcNum == KNL_SRC_3_SUB)
		{
			ubTemp = ubBUF_ReleaseVdoSubBs20Buf(ulBufAddr);
		}
		else if(ubSrcNum == KNL_SRC_4_SUB)
		{
			ubTemp = ubBUF_ReleaseVdoSubBs30Buf(ulBufAddr);
		}	
	#if (defined(OP_AP) && defined(BSP_DVR_SDK))
		else if(ubSrcNum == KNL_SRC_STORAGE_LOCAL)		
			ubTemp = ubBUF_ReleaseVdoMainBs2Buf(ulBufAddr);
	#endif		
	}
	else if(tNodeInfo.ubNextNode == KNL_NODE_VDO_BS_BUF1)
	{
		if(ubSrcNum == KNL_SRC_1_MAIN)
		{
			ubTemp = ubBUF_ReleaseVdoMainBs0Buf(ulBufAddr);
		}
		else if(ubSrcNum == KNL_SRC_2_MAIN)
		{
			ubTemp = ubBUF_ReleaseVdoMainBs1Buf(ulBufAddr);
		}
		else if(ubSrcNum == KNL_SRC_3_MAIN)
		{
			ubTemp = ubBUF_ReleaseVdoMainBs2Buf(ulBufAddr);
		}
		else if(ubSrcNum == KNL_SRC_4_MAIN)
		{
			ubTemp = ubBUF_ReleaseVdoMainBs3Buf(ulBufAddr);
		}
		
		else if(ubSrcNum == KNL_SRC_1_AUX)
		{
			ubTemp = ubBUF_ReleaseVdoAuxBs0Buf(ulBufAddr);
		}
		else if(ubSrcNum == KNL_SRC_2_AUX)
		{
			ubTemp = ubBUF_ReleaseVdoAuxBs1Buf(ulBufAddr);
		}
		else if(ubSrcNum == KNL_SRC_3_AUX)
		{
			ubTemp = ubBUF_ReleaseVdoAuxBs2Buf(ulBufAddr);
		}
		else if(ubSrcNum == KNL_SRC_4_AUX)
		{
			ubTemp = ubBUF_ReleaseVdoAuxBs3Buf(ulBufAddr);
		}
		
		else if(ubSrcNum == KNL_SRC_1_SUB)
		{
			ubTemp = ubBUF_ReleaseVdoSubBs00Buf(ulBufAddr);
		}
		else if(ubSrcNum == KNL_SRC_2_SUB)
		{
			ubTemp = ubBUF_ReleaseVdoSubBs10Buf(ulBufAddr);
		}
		else if(ubSrcNum == KNL_SRC_3_SUB)
		{
			ubTemp = ubBUF_ReleaseVdoSubBs20Buf(ulBufAddr);
		}
		else if(ubSrcNum == KNL_SRC_4_SUB)
		{
			ubTemp = ubBUF_ReleaseVdoSubBs30Buf(ulBufAddr);
		}	
	#if (defined(OP_AP) && defined(BSP_DVR_SDK))
		else if(ubSrcNum == KNL_SRC_STORAGE_LOCAL)		
			ubTemp = ubBUF_ReleaseVdoMainBs2Buf(ulBufAddr);
	#endif			
	}
	else if(tNodeInfo.ubPreNode == KNL_NODE_VDO_BS_BUF2)
	{
		if(ubSrcNum == KNL_SRC_1_SUB)
		{
			ubTemp = ubBUF_ReleaseVdoSubBs01Buf(ulBufAddr);
		}
		else if(ubSrcNum == KNL_SRC_2_SUB)
		{
			ubTemp = ubBUF_ReleaseVdoSubBs11Buf(ulBufAddr);
		}
		else if(ubSrcNum == KNL_SRC_3_SUB)
		{
			ubTemp = ubBUF_ReleaseVdoSubBs21Buf(ulBufAddr);
		}
		else if(ubSrcNum == KNL_SRC_4_SUB)
		{
			ubTemp = ubBUF_ReleaseVdoSubBs31Buf(ulBufAddr);
		}	
	}
#ifdef S2019A
	ubTemp = ubKNL_ReleaseBsOvfBuf(ubSrcNum);
#endif	
	osSemaphoreRelease(tKNL_BsBufCtrlSem);
	return ubTemp;
}
//------------------------------------------------------------------------------
uint32_t ulKNL_GetBsBufSz(uint8_t ubSrcNum)
{		
	if(ubSrcNum == KNL_SRC_1_MAIN)	
		return ulBuf_GetBsBufSize(BUF_VDO_MAIN_BS0);	
	else if(ubSrcNum == KNL_SRC_2_MAIN)
		return ulBuf_GetBsBufSize(BUF_VDO_MAIN_BS1);
	else if(ubSrcNum == KNL_SRC_3_MAIN)
		return ulBuf_GetBsBufSize(BUF_VDO_MAIN_BS2);
	else if(ubSrcNum == KNL_SRC_4_MAIN)
		return ulBuf_GetBsBufSize(BUF_VDO_MAIN_BS3);
	
	else if(ubSrcNum == KNL_SRC_1_SUB)
		return ulBuf_GetBsBufSize(BUF_VDO_SUB_BS00);
	else if(ubSrcNum == KNL_SRC_2_SUB)
		return ulBuf_GetBsBufSize(BUF_VDO_SUB_BS10);
	else if(ubSrcNum == KNL_SRC_3_SUB)
		return ulBuf_GetBsBufSize(BUF_VDO_SUB_BS20);
	else if(ubSrcNum == KNL_SRC_4_SUB)
		return ulBuf_GetBsBufSize(BUF_VDO_SUB_BS30);
	
	else if(ubSrcNum == KNL_SRC_1_AUX)
		return ulBuf_GetBsBufSize(BUF_VDO_AUX_BS0);
	else if(ubSrcNum == KNL_SRC_2_AUX)
		return ulBuf_GetBsBufSize(BUF_VDO_AUX_BS1);
	else if(ubSrcNum == KNL_SRC_3_AUX)
		return ulBuf_GetBsBufSize(BUF_VDO_AUX_BS2);
	else if(ubSrcNum == KNL_SRC_4_AUX)
		return ulBuf_GetBsBufSize(BUF_VDO_AUX_BS3);	
#ifdef BSP_DVR_SDK    
	else if(ubSrcNum == KNL_SRC_STORAGE_LOCAL)
		return ulBuf_GetBsBufSize(BUF_VDO_MAIN_BS2);	
#endif
	else
	{
		printf("Err @%s\r\n",__func__);
		return 0;
	}
}
uint32_t ulKNL_GetBsBufAddr(uint8_t ubSrcNum)
{
	uint32_t ulTemp = BUF_FAIL;
#ifdef S2019A
	KNL_NODE_INFO tNodeInfo;
	uint8_t ubisIfrm = FALSE;
	BUF_MODE tBsBufMode[] = {
								[KNL_SRC_1_MAIN] = BUF_VDO_MAIN_BS0,
								[KNL_SRC_2_MAIN] = BUF_VDO_MAIN_BS1,
								[KNL_SRC_3_MAIN] = BUF_VDO_MAIN_BS2,
								[KNL_SRC_4_MAIN] = BUF_VDO_MAIN_BS3,
#ifdef BSP_DVR_SDK
								[KNL_SRC_STORAGE_LOCAL] = BUF_VDO_MAIN_BS2,
#endif
							};
#endif

	osSemaphoreWait(tKNL_BsBufCtrlSem, osWaitForever);
#ifdef S2019A
	if(ubSrcNum <= KNL_SRC_4_MAIN)
	{
		if(ubKNL_ExistNode(ubSrcNum, KNL_NODE_H264_ENC))
			tNodeInfo = tKNL_GetNodeInfo(ubSrcNum, KNL_NODE_H264_ENC);
		else if(ubKNL_ExistNode(ubSrcNum, KNL_NODE_H264_DEC))
			tNodeInfo = tKNL_GetNodeInfo(ubSrcNum, KNL_NODE_H264_DEC);
		ubisIfrm = (0 == ulKNL_GetVdoFrmIdx(tNodeInfo.ubCodecIdx))?TRUE:FALSE;
		ulTemp   = ulBUF_GetVdoMainBsFreeBuf(tBsBufMode[ubSrcNum], ubisIfrm);
	}
#else
	if(ubSrcNum == KNL_SRC_1_MAIN)
	{
		ulTemp = ulBUF_GetVdoMainBs0FreeBuf();
		if(ulTemp == BUF_FAIL)
		{
			//printd(DBG_ErrorLvl, "Err1 @ulKNL_GetBsBufAddr\r\n");
		}
	}
	else if(ubSrcNum == KNL_SRC_2_MAIN)
	{
		ulTemp = ulBUF_GetVdoMainBs1FreeBuf();
		if(ulTemp == BUF_FAIL)
		{
			//printd(DBG_ErrorLvl, "Err2 @ulKNL_GetBsBufAddr\r\n");
		}
	}
	else if(ubSrcNum == KNL_SRC_3_MAIN)
	{
		ulTemp = ulBUF_GetVdoMainBs2FreeBuf();
		if(ulTemp == BUF_FAIL)
		{
			//printd(DBG_ErrorLvl, "Err3 @ulKNL_GetBsBufAddr\r\n");
		}
	}
	else if(ubSrcNum == KNL_SRC_4_MAIN)
	{
		ulTemp = ulBUF_GetVdoMainBs3FreeBuf();
		if(ulTemp == BUF_FAIL)
		{
			//printd(DBG_ErrorLvl, "Err4 @ulKNL_GetBsBufAddr\r\n");
		}
	}
#endif	//! End of #ifdef S2019A
	else if(ubSrcNum == KNL_SRC_1_SUB)
	{
		ulTemp = ulBUF_GetVdoSubBs00FreeBuf();
		if(ulTemp == BUF_FAIL)
		{
			//printd(DBG_ErrorLvl, "Err5 @ulKNL_GetBsBufAddr\r\n");
		}
	}
	else if(ubSrcNum == KNL_SRC_2_SUB)
	{
		ulTemp = ulBUF_GetVdoSubBs10FreeBuf();
		if(ulTemp == BUF_FAIL)
		{
			//printd(DBG_ErrorLvl, "Err6 @ulKNL_GetBsBufAddr\r\n");
		}
	}
	else if(ubSrcNum == KNL_SRC_3_SUB)
	{
		ulTemp = ulBUF_GetVdoSubBs20FreeBuf();
		if(ulTemp == BUF_FAIL)
		{
			//printd(DBG_ErrorLvl, "Err7 @ulKNL_GetBsBufAddr\r\n");
		}
	}
	else if(ubSrcNum == KNL_SRC_4_SUB)
	{
		ulTemp = ulBUF_GetVdoSubBs30FreeBuf();
		if(ulTemp == BUF_FAIL)
		{
			//printd(DBG_ErrorLvl, "Err8 @ulKNL_GetBsBufAddr\r\n");
		}
	}
	else if(ubSrcNum == KNL_SRC_1_AUX)
	{
		ulTemp = ulBUF_GetVdoAuxBs0FreeBuf();
		if(ulTemp == BUF_FAIL)
		{
			//printd(DBG_ErrorLvl, "Err1 @ulKNL_GetBsBufAddr\r\n");
		}
	}
	else if(ubSrcNum == KNL_SRC_2_AUX)
	{
		ulTemp = ulBUF_GetVdoAuxBs1FreeBuf();
		if(ulTemp == BUF_FAIL)
		{
			//"Err2 @ulKNL_GetBsBufAddr\r\n");
		}
	}
	else if(ubSrcNum == KNL_SRC_3_AUX)
	{
		ulTemp = ulBUF_GetVdoAuxBs2FreeBuf();
		if(ulTemp == BUF_FAIL)
		{
			//printd(DBG_ErrorLvl, "Err3 @ulKNL_GetBsBufAddr\r\n");
		}
	}
	else if(ubSrcNum == KNL_SRC_4_AUX)
	{
		ulTemp = ulBUF_GetVdoAuxBs3FreeBuf();
		if(ulTemp == BUF_FAIL)
		{
			//printd(DBG_ErrorLvl, "Err4 @ulKNL_GetBsBufAddr\r\n");
		}
	}
//#if (defined(OP_AP) && (SENSOR_SOURCE_SELECT == LOCAL_SENSOR_SOURCE))
#if (defined(OP_AP) && defined(BSP_DVR_SDK))
	else if(ubSrcNum == KNL_SRC_STORAGE_LOCAL)
	{
#ifdef S2019A
		ubisIfrm = (0 == ulKNL_GetVdoFrmIdx(tNodeInfo.ubCodecIdx))?TRUE:FALSE;
		ulTemp   = ulBUF_GetVdoMainBsFreeBuf(tBsBufMode[ubSrcNum], ubisIfrm);
#else		
		ulTemp = ulBUF_GetVdoMainBs2FreeBuf();
#endif		
		if(ulTemp == BUF_FAIL)
		{
			//printd(DBG_ErrorLvl, "Err3 @ulKNL_GetBsBufAddr\r\n");
		}
	}
#endif
	osSemaphoreRelease(tKNL_BsBufCtrlSem);

	return ulTemp;
}

//------------------------------------------------------------------------------
uint8_t ubKNL_GetRtCommLinkStatus(uint8_t ubRole)
{
#if (defined(A7130) || defined(S2019A))
	if(ubRole == KNL_STA1)
	{
		return ubKNL_RtLinkStatus[0];
	}
	else if(ubRole == KNL_STA2)
	{
		return ubKNL_RtLinkStatus[1];
	}
	else if(ubRole == KNL_STA3)
	{
		return ubKNL_RtLinkStatus[2];
	}
	else if(ubRole == KNL_STA4)
	{
		return ubKNL_RtLinkStatus[3];
	}
	else if(ubRole == KNL_SLAVE_AP)
	{
		return ubKNL_RtLinkStatus[4];
	}
	else if(ubRole == KNL_MASTER_AP)
	{
		return ubKNL_RtLinkStatus[5];
	}
#endif

#ifdef RTC676x
	#ifdef OP_AP
#if defined(BSP_DVR_SDK)
	if(ubRole >= KNL_STA2)
		return 1;
#endif
	ubRole = ubKNL_GetStaInfo(KNL_ROLENUM, ubRole);
	if(ubRole == KNL_STA1)
	{
    	return rf_get_link_status(rf_get_remote_id(0));
	}
	else if(ubRole == KNL_STA2)
	{
    	return rf_get_link_status(rf_get_remote_id(1));
	}
	else if(ubRole == KNL_STA3)
	{
    	return rf_get_link_status(rf_get_remote_id(2));
	}
	else if(ubRole == KNL_STA4)
	{
    	return rf_get_link_status(rf_get_remote_id(3));
	}
	else if(ubRole == KNL_SLAVE_AP)
	{
		return ubKNL_RtLinkStatus[4];
	}
	else if(ubRole == KNL_MASTER_AP)
	{
		return ubKNL_RtLinkStatus[5];
	}	
	else
	{
		return 0;
	}
	#else	
	return rf_get_link_status(rf_get_remote_id(0));	
	#endif
#else
	return 0;
#endif	
}
//------------------------------------------------------------------------------
uint8_t ubKNL_GetCommLinkStatus(uint8_t ubRole)
{
	uint8_t ubTemp;	

	osMutexWait(tKNL_LinkSem, osWaitForever);
#if (defined(A7130) || defined(S2019A))
	if(ubRole == KNL_STA1)
	{		
		ubTemp = ubKNL_LinkStatus[0];
	}
	else if(ubRole == KNL_STA2)
	{		
		ubTemp = ubKNL_LinkStatus[1];
	}
	else if(ubRole == KNL_STA3)
	{		
		ubTemp = ubKNL_LinkStatus[2];
	}
	else if(ubRole == KNL_STA4)
	{		
		ubTemp = ubKNL_LinkStatus[3];
	}
	else if(ubRole == KNL_SLAVE_AP)
	{		
		ubTemp = ubKNL_LinkStatus[4];
	}
	else if(ubRole == KNL_MASTER_AP)
	{		
		ubTemp = ubKNL_LinkStatus[5];
	}
	else
	{
		printd(DBG_ErrorLvl, "Err @ubKNL_GetCommLinkStatus\r\n");		
		ubTemp = 0;
	}	
#endif

#ifdef RTC676x
	#ifdef BUC_CU	
#if defined(BSP_DVR_SDK)
		if(ubRole >= KNL_STA2)
		{
			osMutexRelease(tKNL_LinkSem);
			return 1;
		}
#endif
		
		ubRole = ubKNL_GetStaInfo(KNL_ROLENUM, ubRole);
		if(ubRole == KNL_STA1)
		{
	    	ubTemp = rf_get_link_status(rf_get_remote_id(0));
		}
		else if(ubRole == KNL_STA2)
		{
	    	ubTemp = rf_get_link_status(rf_get_remote_id(1));
		}
		else if(ubRole == KNL_STA3)
		{
	    	ubTemp = rf_get_link_status(rf_get_remote_id(2));
		}
		else if(ubRole == KNL_STA4)
		{
	    	ubTemp = rf_get_link_status(rf_get_remote_id(3));
		}
		else if(ubRole == KNL_SLAVE_AP)
		{
			ubTemp = ubKNL_LinkStatus[4];
		}
		else if(ubRole == KNL_MASTER_AP)
		{
			ubTemp = ubKNL_LinkStatus[5];
		}
		else
		{
			printd(DBG_ErrorLvl, "Err @ubKNL_GetCommLinkStatus\r\n");
			ubTemp = 0;
		}
	#else
		ubTemp = rf_get_link_status(rf_get_remote_id(0));
	#endif
#endif
	osMutexRelease(tKNL_LinkSem);
	
	return ubTemp;
}
//------------------------------------------------------------------------------
static void KNL_CommLinkMonitThread(void const *argument)
{
	LINK_REPORT tLinkRpt;
	uint8_t ubIdx;
	
	tLinkRpt = tLinkRpt;	//Avoid Warning
	ubIdx = ubIdx;

	while(1)
	{
	#if (defined(A7130) || defined(S2019A))
		//(1)Wait Event
        osMessageGet(KNL_LinkQ, &tLinkRpt, osWaitForever);
		if(tLinkRpt.tStatus == BB_LOST_LINK)
		{
		#ifndef S2019A
			printd(DBG_CriticalLvl, "(RT)Lost[%d]\r\n",tLinkRpt.tRole);
		#endif
			if(tLinkRpt.tRole == BB_STA1)
			{
				ubIdx = 0;
			}
			else if(tLinkRpt.tRole == BB_STA2)
			{
				ubIdx = 1;
			}
			else if(tLinkRpt.tRole == BB_STA3)
			{
				ubIdx = 2;
			}
			else if(tLinkRpt.tRole == BB_STA4)
			{
				ubIdx = 3;
			}
			else if(tLinkRpt.tRole == BB_SLAVE_AP)
			{
				ubIdx = 4;
			}
			else if(tLinkRpt.tRole == BB_MASTER_AP)
			{
				ubIdx = 5;
			}		

			
			#if (defined(OP_AP) && defined(BSP_DVR_SDK))
				if(ubIdx!=BB_STA2)
					ubKNL_RtLinkStatus[ubIdx] = BB_LOST_LINK;					
			#elif (defined(OP_AP) && (APP_DUAL_HOST_ENABLE == 1))
				if(ubIdx == BB_STA1)	
					ubKNL_RtLinkStatus[ubIdx] = BB_LOST_LINK;
			#else
				ubKNL_RtLinkStatus[ubIdx] = BB_LOST_LINK;
			#endif
					
		

		}
		else if(tLinkRpt.tStatus == BB_LINK)
		{
		#ifndef S2019A
			printd(DBG_CriticalLvl, "(RT)Link[%d]\r\n",tLinkRpt.tRole);
		#endif
			
			if(tLinkRpt.tRole == BB_STA1)
			{
				ubIdx = 0;
			}
			else if(tLinkRpt.tRole == BB_STA2)
			{
				ubIdx = 1;
			}
			else if(tLinkRpt.tRole == BB_STA3)
			{
				ubIdx = 2;
			}
			else if(tLinkRpt.tRole == BB_STA4)
			{
				ubIdx = 3;
			}
			else if(tLinkRpt.tRole == BB_SLAVE_AP)
			{
				ubIdx = 4;
			}
			else if(tLinkRpt.tRole == BB_MASTER_AP)
			{
				ubIdx = 5;
			}			
			ubKNL_RtLinkStatus[ubIdx] = BB_LINK;
		}
	#endif
	#ifdef RTC676x
		osDelay(1000);
	#endif 
	}
}
//------------------------------------------------------------------------------
static void KNL_CommLinkUpdateThread(void const *argument)
{
	KNL_PROCESS tProc;
	KNL_SRC tAdoSrcNum = KNL_SRC_NONE;
	uint32_t i,j,k;
	uint8_t ubLinkTemp[6][10];
	uint8_t ubSampleNum 	= 10;
	uint8_t ubLinkLoopCycle = 1;//10;
	uint8_t ubLinkTh    	= 1;//4;
	uint8_t ubLinkCnt   	= 0;
	uint16_t uwLinkPeriod	= 50;
	uint8_t ubSrcNumMap1,ubSrcNumMap2,ubSrcNumMap3;
	uint8_t ubKNL_SetLhFlag = FALSE;
#ifdef S2019A
	static uint8_t ubKNL_ActStpTxFlag[6] = {FALSE, FALSE, FALSE, FALSE, FALSE, FALSE};
	static uint8_t ubKNL_Cnt4StpTx[6] = {0, 0, 0, 0, 0, 0};
#endif

	tProc = tProc;
	tAdoSrcNum = tAdoSrcNum;
	ubSrcNumMap1 = ubSrcNumMap1;
	ubSrcNumMap2 = ubSrcNumMap2;
	ubSrcNumMap3 = ubSrcNumMap3;
	ubKNL_SetLhFlag	= ubKNL_SetLhFlag;
	for(i=0;i<6;i++)
	{
		for(j=0;j<ubSampleNum;j++)
		{
			ubLinkTemp[i][j] = BB_LOST_LINK;
		}
	}
	i = 0;
	//===========================
	while(1)
	{
		ubLinkTemp[0][i%ubSampleNum] = ubKNL_RtLinkStatus[0];
		ubLinkTemp[1][i%ubSampleNum] = ubKNL_RtLinkStatus[1];
		ubLinkTemp[2][i%ubSampleNum] = ubKNL_RtLinkStatus[2];
		ubLinkTemp[3][i%ubSampleNum] = ubKNL_RtLinkStatus[3];
		ubLinkTemp[4][i%ubSampleNum] = ubKNL_RtLinkStatus[4];
		ubLinkTemp[5][i%ubSampleNum] = ubKNL_RtLinkStatus[5];
		if((++i%ubLinkLoopCycle) == 0)
		{
			for(k=0;k<6;k++)
			{
				ubLinkCnt = 0;
				for(j=0;j<ubSampleNum;j++)
				{
					if(ubLinkTemp[k][j])
					{
						ubLinkCnt++;
					}
					if(ubLinkCnt >= ubLinkTh)
					{
						break;
					}
				}

				if(ubLinkCnt >= ubLinkTh)
				{
					#ifdef S2019A
					ubKNL_Cnt4StpTx[k]    = 0;
					ubKNL_ActStpTxFlag[k] = FALSE;
					#endif
					if(ubKNL_LinkStatus[k] == BB_LOST_LINK)
					{
						printd(DBG_CriticalLvl, "(STB)Link[%d]\r\n",k);

						if(TRUE == ubKNL_WakeUpFlag[k])
							KNL_WakeupDevice((KNL_ROLE)k, FALSE);

					#if (defined (VBM_BU) || defined (BIO_BU))
						if(k == KNL_MASTER_AP)
						{
							if(ubRC_GetFlg(0))
							{
								printd(DBG_CriticalLvl, "Rst RC[0]\r\n");
								H264_RcSetEN((H264_ENCODE_INDEX)0,H264_ENABLE,CBR,ulRC_GetFinalBitRate(0));
							}
							if(ubRC_GetFlg(1))
							{
								printd(DBG_CriticalLvl, "Rst RC[1]\r\n");
								H264_RcSetEN((H264_ENCODE_INDEX)1,H264_ENABLE,CBR,ulRC_GetFinalBitRate(1));
							}
							if(ubRC_GetFlg(2))
							{
								printd(DBG_CriticalLvl, "Rst RC[2]\r\n");
								H264_RcSetEN((H264_ENCODE_INDEX)2,H264_ENABLE,CBR,ulRC_GetFinalBitRate(2));
							}
							if(ubRC_GetFlg(3))
							{
								printd(DBG_CriticalLvl, "Rst RC[3]\r\n");
								H264_RcSetEN((H264_ENCODE_INDEX)3,H264_ENABLE,CBR,ulRC_GetFinalBitRate(3));
							}
							if(ubRC_GetFlg(0)||ubRC_GetFlg(1)||ubRC_GetFlg(2)||ubRC_GetFlg(3))
							{
								if((ubKNL_GetVdoFps() <= 5) && (H264_GetCurrentQP() > 3))
								{
									H264_ResetRateControl(H264_GetCurrentQP() - 3);
								}
								else
								{
									H264_ResetRateControl(H264_GetCurrentQP());	
								}
							}
						}
					#endif
					}
					if(FALSE == ubKNL_SetLhFlag)
					{
						ubLinkTh		= 4;
#if defined(BSP_DVR_SDK)                       
						ubLinkLoopCycle	= 6;
#elif (defined(OP_STA) && defined(RVCS_APP))
						sPRF_DrvMode_t tDrvMd = tsPRF_GetDrvMode();
						if (sPRF_APDIRECT_MODE == tDrvMd)  {
							ubLinkLoopCycle = 6;
							ubLinkTh		= 1;
						}
						else 
							ubLinkLoopCycle = 10;
#else
                        ubLinkLoopCycle	= 10;
#endif
						uwLinkPeriod    = 100;
						ubKNL_SetLhFlag = TRUE;
					}
					ubKNL_LinkStatus[k] = BB_LINK;
				}
				else
				{
					if(ubKNL_LinkStatus[k] == BB_LINK)
					{
					#if defined(VBM_PU) || defined(BIO_CU)
						if(tKNL_GetPlyMode() == KNL_AVG_PLY)
						{
							if(k == 0)
							{
								ubSrcNumMap1 = KNL_SRC_1_MAIN;
								ubSrcNumMap2 = KNL_SRC_1_SUB;
								ubSrcNumMap3 = KNL_SRC_1_AUX;
							}
							else if(k == 1)
							{
								ubSrcNumMap1 = KNL_SRC_2_MAIN;
								ubSrcNumMap2 = KNL_SRC_2_SUB;
								ubSrcNumMap3 = KNL_SRC_2_AUX;
							}
							else if(k == 2)
							{
								ubSrcNumMap1 = KNL_SRC_3_MAIN;
								ubSrcNumMap2 = KNL_SRC_3_SUB;
								ubSrcNumMap3 = KNL_SRC_3_AUX;
							}
							else if(k == 3)
							{
								ubSrcNumMap1 = KNL_SRC_4_MAIN;
								ubSrcNumMap2 = KNL_SRC_4_SUB;
								ubSrcNumMap3 = KNL_SRC_4_AUX;
							}
							if((ubKNL_ChkVdoFlowAct(ubSrcNumMap1)||ubKNL_ChkVdoFlowAct(ubSrcNumMap2)||ubKNL_ChkVdoFlowAct(ubSrcNumMap3)))
							{
								printd(DBG_Debug3Lvl, "Rst AvgPly[%d]\r\n",k);
								ubKNL_AvgPlyStartFlg[k] = 0;
								while(1)
								{
									if(osMessages(KNL_AvgPlyQ[k].Id))
									{
										osMessageGet(KNL_AvgPlyQ[k].Id, &tProc, 0);
										printd(DBG_Debug3Lvl, "SrcNum:%d _ BS_Adr:0x%x\r\n",tProc.ubSrcNum, tProc.ulDramAddr2);
										ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_DEC,tProc.ubSrcNum,tProc.ulDramAddr2);
									}
									else
									{
										printd(DBG_ErrorLvl, "Without AvgQ\r\n");
										break;
									}
								}
								osMessageReset(KNL_AvgPlyQ[k].Id);
							}
						}
					#endif
					#ifdef S2019A
						if(FALSE == ubKNL_ActStpTxFlag[k])
						{
							ubKNL_ActStpTxFlag[k] = TRUE;
							#ifdef OP_AP
							if(sPRF_DEVDRV_EN != tsPRF_GetDrvSts((sPRF_DevId_t)k))
								ubKNL_ActStpTxFlag[k] = FALSE;
							#endif
							ubKNL_Cnt4StpTx[k] = 0;
						}
					#else //! else of #ifdef S2019A
						if(TRUE == ubKNL_SetLhFlag)
						{
							for(j=0;j<ubSampleNum;j++)
								ubLinkTemp[k][j] = BB_LOST_LINK;
							ubLinkTh		= 1;
							ubLinkLoopCycle	= 2;
							uwLinkPeriod    = 50;
							ubKNL_SetLhFlag = FALSE;
						}					
						#if (defined(RTC676x) && defined(OP_AP) && TRXBW_RPT_EN)
						KNL_SetTrxBwRpt((KNL_ROLE)k, 0);
						#endif
						#ifdef A7130
						BB_ClearTxBuf(BB_TX_MASTER,BB_DATA_VIDEO);
						#endif
						printd(DBG_CriticalLvl, "(STB)Lost[%d]\r\n",k);
					#endif	//! End of #ifdef S2019A
					}
					#ifdef S2019A
					if((TRUE == ubKNL_ActStpTxFlag[k]) && (ubKNL_Cnt4StpTx[k]++ >= (2000/(uwLinkPeriod*ubLinkLoopCycle))))
					{
						uint8_t ubLostAct = TRUE, ubTmpId = 0;
						ubKNL_LinkStatus[k] = BB_LOST_LINK;
						#ifdef OP_AP
						for(ubTmpId = 0; ubTmpId < 4; ubTmpId++)
						{
							if((sPRF_DEVDRV_EN == tsPRF_GetDrvSts((sPRF_DevId_t)ubTmpId)) &&
							   (BB_LINK == ubKNL_LinkStatus[ubTmpId]))
							{
								ubLostAct = FALSE;
								break;
							}
						}
						#endif
						if(TRUE == ubLostAct)
						{
							if(TRUE == ubKNL_SetLhFlag)
							{
								for(ubTmpId = 0; ubTmpId < ubSampleNum; ubTmpId++)
									ubLinkTemp[k][ubTmpId] = BB_LOST_LINK;
								ubLinkTh		= 1;
								ubLinkLoopCycle	= 2;
								uwLinkPeriod    = 50;
								ubKNL_SetLhFlag = FALSE;
							}
							KNL_StopSPRFTxProcess(TRUE);
							sPRF_ClrTransMesh();
							if(ptKNL_BbFrmMonitCbFunc)
								ptKNL_BbFrmMonitCbFunc(0xFF);
						}
						ubKNL_Cnt4StpTx[k]	  = 0;
						ubKNL_ActStpTxFlag[k] = FALSE;
						printd(DBG_CriticalLvl, "(%d)(STB)Lost<%d>\r\n", k, ubLostAct);
					}
					#else
					ubKNL_LinkStatus[k] = BB_LOST_LINK;
					#endif					
				}
			}
			i = 0;
		}
		if(TRUE == ubKNL_StbLinkStsRrefFlag)
		{
			ubLinkLoopCycle = 1;
			ubLinkTh    	= 1;
			ubLinkCnt   	= 0;
			uwLinkPeriod	= 50;
			for(i=0;i<6;i++)
			{
				for(j=0;j<ubSampleNum;j++)
					ubLinkTemp[i][j] = BB_LOST_LINK;
				ubKNL_LinkStatus[i] = BB_LOST_LINK;
			}
			ubKNL_StbLinkStsRrefFlag = FALSE;
		}
		osDelay(uwLinkPeriod);
	}
}
//------------------------------------------------------------------------------
void KNL_ReleaseUsbdBuf(uint32_t ulBufAddr)
{
	if(0xFFFFFFFF == ulBufAddr)
	{
		BUF_ResetUsbdBuf();
	}
	else if(BUF_FAIL == ubBUF_ReleaseVdoUsbdBuf(ulBufAddr))
	{
		if(BUF_FAIL == ubBUF_ReleaseAdoUsbdBuf(ulBufAddr))
			printd(DBG_ErrorLvl, "Release Usbd Buf Err: 0x%X !\n", ulBufAddr);
	}
#if (defined(OP_STA) && (USBD_UVC_MJ_FMT == USBD_UVC_FMT) && USBD_ENABLE)
	else if(TRUE == ubKNL_GetHQImgCapEn())
	{
		uint8_t ubCapRet = TRUE;
		osMessagePut(osKNL_HQImgUvcQue, &ubCapRet, 0);
	}
#endif
}
//------------------------------------------------------------------------------
#if ((USBD_UVC_MJ_FMT == USBD_UVC_FMT) && USBD_ENABLE)
KNL_UsbdUvcRet_t tKNL_UpdateMjUvcImage(uint32_t ulYuvAddr, uint8_t ubSrcNum)
{
	KNL_UsbdUvcRet_t tUpdUvcRet = KNL_UVCO_OK;
	JPEG_FIFO_Addr_t tJpgFiFo;
	JPEG_ENC_INFO_t  tJpgEncInfo;
	JPEG_CODEC_FN_ES_t	tJpgCodecFnEs;
	uint32_t ulJpgAddr = 0, ulJpgSize = 0, ulFiFoSize = KNL_UVCMJ_BS_SIZE;
	uint16_t uwVdoHSize = 0, uwVdoVSize = 0;
	uint8_t ubJpgRet = JPEG_CODEC_OK;
	uint8_t ubCodecRetryNum = 0, ubCodecRetryCnt = 70;
	uint8_t *pJpgHeader, ubUvcPathMode;

	ubUvcPathMode = UVC_GetVdoFormat();
	if(USB_UVC_VS_FORMAT_MJPEG != ubUvcPathMode)
		return KNL_UVCO_FAIL;
#ifdef OP_STA
	if(TRUE == ubKNL_GetHQImgCapEn())
	{
		uwVdoHSize = tKNL_CapHQImg.uwHQ_H;
		uwVdoVSize = tKNL_CapHQImg.uwHQ_V;
		ulFiFoSize = KNL_UVCMJ_HQBS_SIZE;
		KNL_UpdateJpgHeader(uwVdoHSize, uwVdoVSize);
	}
	else
#endif
	{
		uwVdoHSize = uwKNL_GetVdoH(ubSrcNum);
		uwVdoVSize = uwKNL_GetVdoV(ubSrcNum);
		if(FALSE == ubUVC_CheckResolution(uwVdoHSize, uwVdoVSize))
			return KNL_UVCO_FAIL;
	}
	ulJpgAddr = ulBUF_GetVdoUsbdFreeBuf();
	if(BUF_FAIL == ulJpgAddr)
		return KNL_UVCO_FAIL;
	ulJpgAddr += KNL_MJ_BUF_ALIGN_1K;
	pJpgHeader = (uint8_t *)ulJpgAddr;
	pJpgHeader[(KNL_JPG_FRAMEHEADER_START+KNL_JPEG_HEADER_V_OFFSET)]  = (uint8_t)((uwVdoVSize >> 8) & 0xFF);
	pJpgHeader[(KNL_JPG_FRAMEHEADER_START+KNL_JPEG_HEADER_V_OFFSET+1)]  = (uwVdoVSize & 0xFF);
	pJpgHeader[(KNL_JPG_FRAMEHEADER_START+KNL_JPEG_HEADER_H_OFFSET)]  = (uint8_t)((uwVdoHSize >> 8) & 0xFF);
	pJpgHeader[(KNL_JPG_FRAMEHEADER_START+KNL_JPEG_HEADER_H_OFFSET+1)] = (uwVdoHSize & 0xFF);
	tJpgFiFo.ulJpeg_Buf_Start = ulJpgAddr + KNL_JPG_HEADER_SIZE;
	tJpgFiFo.ulJpeg_Buf_End	  = tJpgFiFo.ulJpeg_Buf_Start + (ulFiFoSize - KNL_MJ_BUF_ALIGN_1K - KNL_JPG_HEADER_SIZE);
	JPEG_Ring_FIFO_Setup(tJpgFiFo);
	JPEG_Set_Start_Address(ulYuvAddr, tJpgFiFo.ulJpeg_Buf_Start);
	tJpgEncInfo.uwH_ORI_SIZE = uwVdoHSize;
	tJpgEncInfo.uwH_SIZE	 = uwVdoHSize;
	tJpgEncInfo.uwV_SIZE	 = uwVdoVSize;
	tJpgEncInfo.uwH_START	 = 0;
	tJpgEncInfo.uwV_START	 = 0;
	tJpgEncInfo.ubJPG_Fmt 	 = KNL_UVCMJ_FORMAT;
	if(tJpgEncInfo.ubJPG_Fmt == JPEG_YUV422)
		pJpgHeader[KNL_JPG_FRAMEHEADER_START+KNL_JPEG_HEADER_FMT_OFFSET] = 0x21;
	else if(tJpgEncInfo.ubJPG_Fmt == JPEG_YUV420)
		pJpgHeader[KNL_JPG_FRAMEHEADER_START+KNL_JPEG_HEADER_FMT_OFFSET] = 0x22;
	
	//! Setup QP value
	JPEG_Set_QP_Value(KNL_UVCMJ_QP_VALUE);
	//! Update JPEG header Quant table
	JPEG_UpdateQuantTab2Header(&pJpgHeader[KNL_JPG_DQT_START], 5);

	tJpgCodecFnEs.tEM		  = JPEG_EM_NULL;
	tJpgCodecFnEs.pvEvent	  = NULL;
	tJpgCodecFnEs.tNotifyMode = JPEG_FN_USE_POLLING;
	JPEG_Encode_Setup(tJpgEncInfo, tJpgCodecFnEs);
	JPEG_Codec_Enable();
	while(1)
	{
		ubJpgRet = ubJPEG_ReportCodecStatus();
		if(JPEG_CODEC_PROCESS != ubJpgRet)
			break;
		if(ubCodecRetryNum++ >= ubCodecRetryCnt)
		{
			printd(DBG_ErrorLvl, "JPG Encode timeout !\n");
			JPEG_Codec_Disable();
			KNL_ReleaseUsbdBuf((ulJpgAddr - USBD_UVC_HEADER_LEN));
			return KNL_UVCO_FAIL;
		}
		osDelay(1);
//		TIMER_Delay_ms(1);
	}
	if(JPEG_CODEC_OK == ubJpgRet)
	{
		ulJpgSize = ulJPEG_Get_BS_Size();
		JPEG_Codec_Disable();

		for(uint8_t i=0;i<4;i++)
		{
			if(((uint8_t *)(ulJpgAddr+KNL_JPG_HEADER_SIZE+ulJpgSize-i-1))[0]== 0xD9)
			{				
				ulJpgSize -=i;				 
				break;
			}
		}
		
		printd(DBG_InfoLvl, "  JPG Bs Size: 0x%X[%d]\r\n", ulJpgSize, ubCodecRetryNum);
		if((ulJpgSize + KNL_JPG_HEADER_SIZE) > (ulFiFoSize - KNL_MJ_BUF_ALIGN_1K - KNL_JPG_HEADER_SIZE))
			printd(DBG_ErrorLvl, "JPG Bs size overflow\n");
		tUpdUvcRet = (FALSE == uvc_update_image((uint32_t *)ulJpgAddr, (ulJpgSize + KNL_JPG_HEADER_SIZE)))?KNL_UVCO_FAIL:KNL_UVCO_OK;
	}
	else
	{
		JPEG_Codec_Disable();
		tUpdUvcRet = KNL_UVCO_FAIL;
	}
	if(KNL_UVCO_OK != tUpdUvcRet)
		KNL_ReleaseUsbdBuf((ulJpgAddr - KNL_MJ_BUF_ALIGN_1K));

	return tUpdUvcRet;
}
#endif
//------------------------------------------------------------------------------
#if OP_AP
void KNL_ModifyUsbdViewType(uint8_t ubViewType)
{
	ubKNL_UsbdVdoViewType = ubViewType;
}
//------------------------------------------------------------------------------
uint16_t uwKNL_FrmWidth = 0;
KNL_UsbdUvcRet_t tKNL_UpdateBsUvcImage(uint32_t ulVdoAddr, uint32_t ulVdoSize)
{
	KNL_UsbdUvcRet_t tUpdUvcRet = KNL_UVCO_OK;
	uint32_t ulBsAddr = 0, ulBsSize= 0;
	uint32_t ulFrmIdx = 0;
	uint8_t ubUvcPathMode, ubFrmType;
	DMAC_RESULT tDmaResult = DMAC_OK;

	ubUvcPathMode = UVC_GetVdoFormat();
	if((USBD_COMPOSITE_MODE == tUSBD_GetClassMode()) && (TRUE == ubUSBD_ChkCompMscClass()))
	{
		uint32_t ulTimeStp1 = 0, ulTimeStp2 = 0;
		uint32_t ulRemindBsSize = 0;
		uint32_t ulBsSrcAddr = 0, ulBsDestAddr = 0;
		uint32_t ulUvcAuxSize = 0, ulSubFrmSize = 0;
		uint8_t ubSrcNum, ubRoleNum, ubIdx;
		uint8_t ubFrmSeq, ubNumOfSubData, ubSubIdx;

		if(USB_UVC_VS_FORMAT_FRAME_BASED != ubUvcPathMode)
			return KNL_UVCO_FAIL;
		ulUvcAuxSize   = KNL_USBDUVC_AUX_SIZE - UVC_OFS_CH_INFO;
		ulSubFrmSize   = USBDVDO_SUBFRAME_SIZE - KNL_USBDUVC_AUX_SIZE;
		ulBsSize 	   = ulVdoSize - KNL_AUX_INFO_LEN;
		ubNumOfSubData = ulBsSize / ulSubFrmSize;
		if(ulBsSize % ulSubFrmSize)
		{
			ulRemindBsSize = ulBsSize - (ubNumOfSubData * ulSubFrmSize);
			ubNumOfSubData++;
		}
        else
            ulRemindBsSize = ubNumOfSubData * ulSubFrmSize;
		ubSrcNum   = ubKNL_GetPktSrcNum(ulVdoAddr, ulVdoSize);
#if defined(BSP_DVR_SDK)
        if(ubKNL_GetSrcNumPosition((KNL_SRC)ubSrcNum) != KNL_LOCAL)
#endif
		ubRoleNum  = ubKNL_SrcNumMap(ubSrcNum);
		ulFrmIdx   = ulKNL_GetPktFrmIdx(ulVdoAddr, ulVdoSize);
		ubFrmType  = (ulFrmIdx == 0)?KNL_VDO_I_FRAME:KNL_VDO_P_FRAME;
		ulTimeStp1 = ulKNL_GetTimeStamp1(ulVdoAddr, ulVdoSize);
		ulTimeStp2 = ulKNL_GetTimeStamp2(ulVdoAddr, ulVdoSize);
		ubFrmSeq   = ubKNL_GetFrameSeq(ulVdoAddr, ulVdoSize);
		for(ubSubIdx = 0; ubSubIdx < ubNumOfSubData; ubSubIdx++)
		{
			ulBsAddr = ulBUF_GetVdoUsbdFreeBuf();
			if(BUF_FAIL == ulBsAddr)
				return KNL_UVCO_FAIL;
			memset((uint8_t *)ulBsAddr, 0, KNL_USBDUVC_AUX_SIZE);
			*((uint8_t *)(ulBsAddr + UVC_OFS_CH_INFO))	= (ubRoleNum + (ubKNL_UsbdVdoViewType * 6));
			*((uint8_t *)(ulBsAddr + UVC_OFS_AUX_INFO))	= ubFrmType;
			for(ubIdx = 0; ubIdx < 4; ubIdx++)
				*((uint8_t *)(ulBsAddr + UVC_OFS_TIME_STAMP + ubIdx)) = ((ulTimeStp1 >> (ubIdx * 8)) & 0xFF);
			for(ubIdx = 0; ubIdx < 4; ubIdx++)
				*((uint8_t *)(ulBsAddr + UVC_OFS_TIME_STAMP + ubIdx + 4)) = ((ulTimeStp2 >> (ubIdx * 8)) & 0xFF);
			*((uint8_t *)(ulBsAddr + UVC_OFS_NUM_SUB_FRAME)) 	 = ubNumOfSubData;
			*((uint8_t *)(ulBsAddr + UVC_OFS_SUB_FRAME_IDX)) 	 = ubSubIdx;
			ulBsSize = ((ubSubIdx + 1) == ubNumOfSubData)?ulRemindBsSize:ulSubFrmSize;
			*((uint8_t *)(ulBsAddr + UVC_OFS_SUB_FRAME_LEN)) 	 = ulBsSize & 0xFF;
			*((uint8_t *)(ulBsAddr + UVC_OFS_SUB_FRAME_LEN + 1)) = (ulBsSize >> 8) & 0xFF;
			*((uint8_t *)(ulBsAddr + UVC_OFS_TOTAL_FRAME_IDX))   = ubFrmSeq;
			*((uint8_t *)(ulBsAddr + UVC_OFS_RESERVED))   		 = 0;
			ulBsSrcAddr  = ulVdoAddr + (ubSubIdx * ulSubFrmSize);
			ulBsDestAddr = ulBsAddr + UVC_OFS_SUB_FRAME_DATA;
			tDmaResult   = tDMAC_MemCopy(ulBsSrcAddr, ulBsDestAddr, ulBsSize, NULL);
			if((DMAC_OK != tDmaResult) || (FALSE == uvc_update_image((uint32_t *)ulBsAddr, (ulBsSize + ulUvcAuxSize))))
			{
				KNL_ReleaseUsbdBuf(ulBsAddr);
				tUpdUvcRet = KNL_UVCO_FAIL;
			}
		}
	}
	else if((USBD_UVC_MODE == tUSBD_GetClassMode()) || (TRUE == ubUSBD_ChkCompUvcClass()))
	{
		static uint8_t ubKNL_UsbdUvcFmtFlag = FALSE;
		static uint8_t ubKNL_FrmCnt4UsbdUvc = 0;
		uint8_t ubPaddLen = 0;
		
		if((DISPLAY_1T1R != DISPLAY_MODE) || (USB_UVC_VS_FORMAT_FRAME_BASED != ubUvcPathMode) || (uwKNL_FrmWidth != UVC_GetVdoWidth()) )
		{
			uwKNL_FrmWidth = UVC_GetVdoWidth();
			ubKNL_UsbdUvcFmtFlag = FALSE;
			ubKNL_FrmCnt4UsbdUvc = 0;
			return KNL_UVCO_FAIL;
		}
		ulFrmIdx = ulKNL_GetPktFrmIdx(ulVdoAddr, ulVdoSize);
		if(FALSE == ubKNL_UsbdUvcFmtFlag)
		{
			ubFrmType  = (ulFrmIdx == 0)?KNL_VDO_I_FRAME:KNL_VDO_P_FRAME;
			if(KNL_VDO_I_FRAME != ubFrmType)
				return KNL_UVCO_RSTI;
			ubKNL_UsbdUvcFmtFlag = TRUE;
		}
		ulBsAddr = ulBUF_GetVdoUsbdFreeBuf();
		if(BUF_FAIL == ulBsAddr)
			return KNL_UVCO_FAIL;
		ulBsAddr += USBD_UVC_HEADER_LEN;
		ulBsSize  = ulKNL_GetFrameSz(ulVdoAddr, ulVdoSize);	//! ulVdoSize - KNL_AUX_INFO_LEN;
		ubPaddLen = ubKNL_GetPaddLen(ulVdoAddr, ulVdoSize);
		if(ubPaddLen)
			ulBsSize -= ubPaddLen;
		tDmaResult = tDMAC_MemCopy(ulVdoAddr, ulBsAddr, ulBsSize, NULL);
		if((DMAC_OK != tDmaResult) || (FALSE == uvc_update_image((uint32_t *)ulBsAddr, ulBsSize)))
		{
			KNL_ReleaseUsbdBuf((ulBsAddr - USBD_UVC_HEADER_LEN));
			tUpdUvcRet = KNL_UVCO_FAIL;
		}
		if(ubKNL_FrmCnt4UsbdUvc < 6)
		{
			if(++ubKNL_FrmCnt4UsbdUvc >= 6)
				return KNL_UVCO_RSTI;
		}
	}
	return tUpdUvcRet;
}
//------------------------------------------------------------------------------
KNL_SRC tKNL_RxVdoInProcess(uint8_t ubSta, uint32_t ulVdoAddr, uint32_t ulVdoSize)
{
	static uint32_t ulKNL_RecvPreFrmIdx[4]= {0,0,0,0};
	static uint8_t ubKNL_RecvChkSeqFlg[4] = {0,0,0,0};
	static uint8_t ubKNL_RecvPreVdoGop[4] = {0,0,0,0};
	static uint8_t ubKNL_RecvCnt[4]  = {0,0,0,0};
	static uint32_t ulKNL_RecvSum[4] = {0,0,0,0};
	static uint8_t ubKNL_TxRstIFlag = FALSE;
	static uint32_t ulKNL_OutPreFrmIdx[4]= {0,0,0,0};
	static uint8_t ubKNL_OutChkFlg = 1;
	KNL_SRC tRcvSrc = KNL_SRC_NONE;

    KNL_PROCESS tKNLInfo;
    KNL_FRAME_TYPE tKNL_RecvFrmType;
    uint16_t uwKNL_PktHSize = 0, uwKNL_PktVSize = 0;
    uint8_t ubSrcNum;
    uint8_t ubSrcNumMap;
    uint8_t ubOpMode;
    uint8_t ubVdoGop;       
    uint32_t ulGop;
    uint32_t ulTime;
    
    uint8_t ubOutSrc1 = 0;
    uint8_t ubOutSrc2 = 0;
    uint32_t ulOutAddr1 = 0;
    uint32_t ulOutAddr2 = 0;
    uint8_t ubMultiOutFlg = 0;
    uint32_t ulCurFrmIdx[4];
    uint8_t ubChkSeqOk[4]  = {1,1,1,1};
    uint8_t ubHqCapFlag = KNL_CAPHQ_DIS;
	uint8_t ubResPadd = 0;
	
#if APP_FS_FILE_LIST_STYLE	
    if((KNL_ThmShowInfo.ubEnFlg==1 || KNL_ThmShowInfo.ubDispRevertFlg == 1) && tKNL_GetRecordFunc()!=KNL_VIDEO_PLAY)
    {
        return (KNL_SRC)ubKNL_GetPktSrcNum(ulVdoAddr, ulVdoSize);
    }
#endif

#if APP_REC_FUNC_ENABLE
	if( KNL_VIDEO_PLAY != tKNL_GetRecordFunc())
#endif
	{
		//Reset the Status
		ubMultiOutFlg = 0;
		ulOutAddr1 = BUF_FAIL;
		ulOutAddr2 = BUF_FAIL;
		ubOutSrc1  = ubOutSrc1;
		ulOutAddr1 = ulOutAddr1;
	
		ubSrcNum 	= ubKNL_GetPktSrcNum(ulVdoAddr, ulVdoSize);
		tRcvSrc		= (KNL_SRC)ubSrcNum;
		ubSrcNumMap = ubKNL_SrcNumMap(ubSrcNum);
		ubOpMode 	= ubKNL_GetPktOpMode(ulVdoAddr, ulVdoSize);
		ulGop 		= ulKNL_GetPktGop(ulVdoAddr, ulVdoSize);
		ulTime 		= ulKNL_GetTimeStamp1(ulVdoAddr, ulVdoSize);
		ubVdoGop 	= ubKNL_GetPktVdoGop(ulVdoAddr, ulVdoSize);
#if (OP_AP && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
        KNL_GetTxFSInfo(ulVdoAddr, ulVdoSize);
        KNL_RP_SyncHdlr.ubFrmType = *(uint8_t*)(ulVdoAddr);
        KNL_RP_SyncHdlr.ubKnlSrcStaNum = ubSrcNumMap;
        // Receive Remote play frame in Rx preview mode. Stop Remote play. 
        if( KNL_RP_SyncHdlr.ubFrmType == 0xAA )
            goto RX_VDOINFO_ERR;
#endif
	
	#if (APP_DUAL_HOST_ENABLE == 1)
	#else	
		if((ubOpMode != ubKNL_GetOpMode()) || (ubSrcNumMap > KNL_STA4))
			goto RX_VDOINFO_ERR;
	#endif

		ulCurFrmIdx[ubSrcNumMap] = ulKNL_GetPktFrmIdx(ulVdoAddr, ulVdoSize);
		if((KNL_CAPHQ_EN == tKNL_CapHQImgSte) || (TRUE == ubKNL_AppResendIFrmFlg[ubSrcNumMap]))
		{
			ubKNL_RcvFirstIFrame[ubSrcNum] 	= 0;
			ubKNL_RecvChkSeqFlg[ubSrcNumMap]= 0;
			tKNLInfo.ubSrcNum     = ubSrcNum;
			tKNLInfo.ubTargetRole = ubSta;
			tKNLInfo.ubTwcCmd	  = TWC_RESEND_I_EXT;
			if(FALSE == ubKNL_VdoResendITwcFlg[tKNLInfo.ubTargetRole])
			{
				if(osMessagePut(KNL_TwcMonitQueue, &tKNLInfo, 0) == osErrorResource)
				{
					printd(DBG_ErrorLvl, "KNL_TwcMonitQ->Full !!!!\r\n");
				}
			}
			goto RX_VDOINFO_ERR;
		}

		uwKNL_PktHSize = ubKNL_GetPktHRes(ulVdoAddr, ulVdoSize);
		uwKNL_PktVSize = ubKNL_GetPktVRes(ulVdoAddr, ulVdoSize);
		if(USBD_UVC_H265_FMT == USBD_UVC_FMT)
		{
			ubResPadd = uwKNL_PktVSize % 16;
			if(ubResPadd)
				uwKNL_PktVSize += (16 - ubResPadd);
		}
#if defined(BUC_CU)		
#if (!defined(BSP_D_SNCC71_TP2915_AHD_RX_V3) || !defined(BSP_D_SNCC71_NVP6021_AHD_RX_V4))
		if((ubKNL_GetAhdCamTypeInf(ulVdoAddr, ulVdoSize) == 12) || (ubKNL_GetAhdCamTypeInf(ulVdoAddr, ulVdoSize) == 13))	//Camera is CVBS in
		{
			ubKNL_CamIsCvbs = 1;
			//printf("cvbs 3\r\n");
			if((uwKNL_GetVdoH(KNL_SRC_1_MAIN) != 640) || (uwKNL_GetVdoV(KNL_SRC_1_MAIN) != 480))
			{
				KNL_ROLE tKnlRole;

				tKnlRole = (KNL_ROLE)ubSta;
				
				KNL_SetVdoH(KNL_SRC_1_MAIN, 640);
				KNL_SetVdoV(KNL_SRC_1_MAIN, 480);
				//printf("cvbs 4\r\n");
				VDO_SwitchAhdType(KNL_DISP_SINGLE, &tKnlRole, 640, 480);
				//printf("cvbs 5\r\n");
				KNL_VdoDisplaySetting();		
				KNL_VdoDisplayParamUpdate();
				goto RX_VDOINFO_ERR;				
			}		
		}
		else
		{
			if((ubKNL_GetAhdCamTypeInf(ulVdoAddr, ulVdoSize) != 0xFF) && (ubKNL_CamIsCvbs == 1))
			{
				KNL_ROLE tKnlRole;

				tKnlRole = (KNL_ROLE)ubSta;
				ubKNL_CamIsCvbs = 0;
				KNL_SetVdoH(KNL_SRC_1_MAIN, VDO_MAIN_H_SIZE(VDO_DISP_TYPE));
				KNL_SetVdoV(KNL_SRC_1_MAIN, VDO_MAIN_V_SIZE(VDO_DISP_TYPE));
				//printf("cvbs 4\r\n");
				VDO_SwitchAhdType(KNL_DISP_SINGLE, &tKnlRole, VDO_MAIN_H_SIZE(VDO_DISP_TYPE), VDO_MAIN_V_SIZE(VDO_DISP_TYPE));
				//printf("cvbs 5\r\n");
				KNL_VdoDisplaySetting();		
				KNL_VdoDisplayParamUpdate();
				goto RX_VDOINFO_ERR;
			}		
			ubKNL_CamIsCvbs = 0;
		}			
#endif	
#endif		
		if(ubKNL_ChkVdoFlowAct(ubSrcNum) && ((uwKNL_PktHSize != uwKNL_GetVdoH(ubSrcNum)) || (uwKNL_PktVSize != uwKNL_GetVdoV(ubSrcNum))))
		{
			ubKNL_RcvFirstIFrame[ubSrcNum] = 0;
			ubKNL_RecvChkSeqFlg[ubSrcNumMap] = 0;
			tKNLInfo.ubSrcNum     = ubSrcNum;
			tKNLInfo.ubTargetRole = ubSta;
			tKNLInfo.ubTwcCmd	  = TWC_VDORES_SETTING;
			if((ubSrcNumMap <= KNL_STA4) && (FALSE == ubKNL_VdoResChgTwcFlg[ubSrcNumMap]))
			{
				if(osMessagePut(KNL_TwcMonitQueue, &tKNLInfo, 0) == osErrorResource)
				{
					printd(DBG_ErrorLvl, "KNL_TwcMonitQ->Full !!!!\r\n");
				}
				printd(DBG_CriticalLvl, "Res Chg Case[%d]\r\n",ubSrcNum);
			}
			#if  (defined(OP_AP) && ((defined(S2019A) && defined(RVCS_APP)) || defined(sWIFIBDG)))
			if((sPRF_BRIDGE_MODE == tKNL_sPRFDrvMd) && (FALSE == tKNL_ApBdgInfo.ubResChgFlag))
			{
				KNL_StopApBdgeProc();
				WiFiDt_Setup(ubKNL_GetVdoFps(), uwKNL_GetVdoH(ubSrcNum), uwKNL_GetVdoV(ubSrcNum), tKNL_Get_StreamType());
				tKNL_ApBdgInfo.ubResChgFlag = TRUE;
			}
			#endif
			goto RX_VDOINFO_ERR;
		}
		ubKNL_VdoResChgTwcFlg[ubSrcNumMap] = FALSE;
		tKNL_RecvFrmType = tKNL_GetFrameType(ulVdoAddr);
		if(KNL_ERR_FRAME == tKNL_RecvFrmType)
		{
			printd(DBG_ErrorLvl, "[%d]Err frame type\r\n", ubSrcNum);
			goto RX_VDO_RST_I;
		}
		printd(DBG_InfoLvl, "[%d]:H[%d]xV[%d]\r\n",ubSrcNum, uwKNL_PktHSize, uwKNL_PktVSize);
		printd(DBG_Debug2Lvl, "V[%d]:0x%x_M:%d_I:%d_G:%d_VG:%d_T:%d\r\n",ubSrcNum,ulVdoAddr,ubOpMode,ulCurFrmIdx[ubSrcNum],ulGop,ubVdoGop,ulTime);
		
		//printf("F[%d]\r\n",ulCurFrmIdx[ubSrcNum]);

		if(ubKNL_RecvChkSeqFlg[ubSrcNumMap])
		{
			if((ulCurFrmIdx[ubSrcNumMap] != 0) && (ulCurFrmIdx[ubSrcNumMap] != (ulKNL_RecvPreFrmIdx[ubSrcNumMap]+1)) && (ubVdoGop == ubKNL_RecvPreVdoGop[ubSrcNumMap]))
			{
				ubChkSeqOk[ubSrcNumMap] = 0;
			}
			else if((ulCurFrmIdx[ubSrcNumMap] != 0) && (ulCurFrmIdx[ubSrcNumMap] == (ulKNL_RecvPreFrmIdx[ubSrcNumMap]+1)) && (ubVdoGop != ubKNL_RecvPreVdoGop[ubSrcNumMap]))
			{
				ubChkSeqOk[ubSrcNumMap] = 2;
			}
		#ifdef S2019A
			else if((ulCurFrmIdx[ubSrcNum] == 0) && (tKNL_RecvFrmType == KNL_I_FRAME) && (ubKNL_RcvFirstIFrame[ubSrcNum]) && (ulKNL_RecvPreFrmIdx[ubSrcNumMap] == (ulKNL_GetVdoGop() - 1)))
			{
				ubKNL_RcvFirstIFrame[ubSrcNum] = 0;
			}
		#endif
			else if((ulCurFrmIdx[ubSrcNum] == 0) && (tKNL_RecvFrmType == KNL_I_FRAME) && (ubKNL_RcvFirstIFrame[ubSrcNum]) && (ulKNL_RecvPreFrmIdx[ubSrcNumMap] != (ulKNL_GetVdoGop() - 1)))
			{
				ubKNL_RcvFirstIFrame[ubSrcNum] = 0;
				if(TRUE == ubKNL_FrmLossFlag[ubSrcNumMap])
					ubKNL_FrmLossFlag[ubSrcNumMap] = FALSE;
				else
					ubKNL_TxRstIFlag = TRUE;
			}
			else
			{
				ubChkSeqOk[ubSrcNumMap] = 1;
			}
		}
		ulKNL_RecvPreFrmIdx[ubSrcNumMap] = ulCurFrmIdx[ubSrcNumMap];
		
		if(ubKNL_ChkVdoFlowAct(ubSrcNum) && (ubKNL_RcvFirstIFrame[ubSrcNum] == 0))
		{
			if(tKNL_RecvFrmType == KNL_I_FRAME)
			{
				ubKNL_VdoResendITwcFlg[ubSrcNumMap] = FALSE;
				ubKNL_AppResendIFrmFlg[ubSrcNumMap] = FALSE;
				ubKNL_RcvFirstIFrame[ubSrcNum] = 1;
				printd(DBG_CriticalLvl, "Find I[%d]\r\n",ubSrcNum);
				if(TRUE == ubKNL_WakeUpFlag[ubSrcNumMap])
					KNL_WakeupDevice((KNL_ROLE)ubSrcNumMap, FALSE);

				ubKNL_RecvChkSeqFlg[ubSrcNumMap] = 1;
				ubKNL_RecvPreVdoGop[ubSrcNumMap] = ubVdoGop;
				ulKNL_RecvPreFrmIdx[ubSrcNumMap] = 0;
				ubChkSeqOk[ubSrcNumMap] = 1;

				ubKNL_RecvCnt[ubSrcNumMap] = 0;
				ulKNL_RecvSum[ubSrcNumMap] = 0;

				ubKNL_AvgPlyStartFlg[ubSrcNumMap] = 0;
				ubKNL_AvgPlyCnt[ubSrcNumMap] = 0;

				ulKNL_InVdoFpsCnt[ubSrcNum] = ulKNL_InVdoFpsCntTemp[ubSrcNum];
				ulKNL_InVdoFpsCntTemp[ubSrcNum] = 0;

				ubHqCapFlag = ubKNL_GetHQCapFlag(ulVdoAddr, ulVdoSize);
			}
		}
		else if(ubKNL_ChkVdoFlowAct(ubSrcNum) && ubKNL_RcvFirstIFrame[ubSrcNum] && (ubChkSeqOk[ubSrcNumMap] == 0))
		{
			if(ulKNL_RecvPreFrmIdx[ubSrcNumMap] == ulCurFrmIdx[ubSrcNumMap])
				return KNL_SRC_NONE;
			printd(DBG_ErrorLvl, "[%d](Case1)Frm Seq->Fail,%d<>%d\r\n", ubSrcNum, ulKNL_RecvPreFrmIdx[ubSrcNumMap], ulCurFrmIdx[ubSrcNumMap]);
			if(ubSrcNumMap <= KNL_STA4)
			{
				ubKNL_RcvFirstIFrame[ubSrcNum] = 0;
				ubKNL_RecvChkSeqFlg[ubSrcNumMap] = 0;
				tKNLInfo.ubSrcNum     = ubSrcNum;
				tKNLInfo.ubTargetRole = ubSta;
				tKNLInfo.ubTwcCmd	  = TWC_RESEND_I_EXT;
				if(FALSE == ubKNL_VdoResendITwcFlg[tKNLInfo.ubTargetRole])
				{
					if(osMessagePut(KNL_TwcMonitQueue, &tKNLInfo, 0) == osErrorResource)
					{
						printd(DBG_ErrorLvl, "KNL_TwcMonitQ->Full !!!!\r\n");
					}
				}
			}
			if(pKNL_PerDbgFunc[0])
				pKNL_PerDbgFunc[0](PER_FRMSTS_RPT, ubSrcNumMap, FRM_LOSS_ERR);
			goto RX_VDOINFO_ERR;
		}
		else if(ubKNL_ChkVdoFlowAct(ubSrcNum) && ubKNL_RcvFirstIFrame[ubSrcNum] && (ubChkSeqOk[ubSrcNumMap] == 2))
		{
			ubKNL_RecvPreVdoGop[ubSrcNumMap] = ubVdoGop;
		}

		//Output Check Mechanism
		//======================================
		if(ulCurFrmIdx[ubSrcNumMap] == 0)
		{
			ubKNL_OutChkFlg = TRUE;
			ulKNL_OutPreFrmIdx[ubSrcNumMap] = 0;
		}
		else if(ulCurFrmIdx[ubSrcNumMap] == (ulKNL_OutPreFrmIdx[ubSrcNumMap]+1))
		{
			ubKNL_OutChkFlg = TRUE;
			ulKNL_OutPreFrmIdx[ubSrcNumMap] = ulCurFrmIdx[ubSrcNumMap];
		}
		else
		{
			ubKNL_OutChkFlg = FALSE;
			ulKNL_OutPreFrmIdx[ubSrcNumMap] = ulCurFrmIdx[ubSrcNumMap];
		}
		
		//if(ubKNL_ChkVdoFlowAct(ubSrcNum) && ubKNL_RcvFirstIFrame[ubSrcNum] && ubChkSeqOk[ubSrcNumMap])
		if(ubKNL_ChkVdoFlowAct(ubSrcNum) && ubKNL_RcvFirstIFrame[ubSrcNum] && ubChkSeqOk[ubSrcNumMap] && ubKNL_OutChkFlg)		
		{
			uint32_t ulVdoBsAddr = 0;

			if(!ubKNL_AvgPlyStartFlg[ubSrcNumMap])
			{
				ubKNL_AvgPlyCnt[ubSrcNumMap]++;
			}

			ulKNL_InVdoFpsCntTemp[ubSrcNum]++;
			ulKNL_RecvSum[ubSrcNumMap] = ulKNL_RecvSum[ubSrcNumMap] + ulVdoSize;
			ubKNL_RecvCnt[ubSrcNumMap]++;

			if(ubKNL_RecvCnt[ubSrcNumMap] == ubKNL_GetVdoFps())
			{
				printd(DBG_CriticalLvl, "TB[%d]:%d\n",ubSrcNum, ulKNL_RecvSum[ubSrcNumMap]/1024);
				ulKNL_InVdoFpsCnt[ubSrcNum] = ulKNL_InVdoFpsCntTemp[ubSrcNum];
				ulKNL_InVdoFpsCntTemp[ubSrcNum] = 0;
				ubKNL_RecvCnt[ubSrcNumMap] = 0;
				ulKNL_RecvSum[ubSrcNumMap] = 0;
			}

			//(2)Request Buffer to Temp
		#ifdef S2019A
			ulVdoBsAddr = ulVdoAddr;
		#else
			ulVdoBsAddr = ulKNL_GetBsBufAddr(ubSrcNum);
		#endif
			if(ulVdoBsAddr != BUF_FAIL)
			{
				DMAC_RESULT tDmaResult = DMAC_OK;

				if(ubSta <= KNL_STA4)
					ubKNL_VdoBsBusyCnt[ubSta] = 0;
				//(3)Check MultiOut Node
				if(ubKNL_ChkMultiOutNode(KNL_NODE_COMM_RX_VDO))
				{
					if(ubKNL_GetMultiInSrc(KNL_NODE_COMM_RX_VDO) == ubSrcNum)
					{
						ubMultiOutFlg = 1;
						ubOutSrc1 = ubKNL_GetMultiOutSrc(KNL_NODE_COMM_RX_VDO,0);
						ubOutSrc2 = ubKNL_GetMultiOutSrc(KNL_NODE_COMM_RX_VDO,1);
						if(ubOutSrc2 == KNL_SRC_1_AUX)
						{
							ulOutAddr2 = ulBUF_GetVdoAuxBs0FreeBuf();
							if(ulOutAddr2 == BUF_FAIL)
							{
								printd(DBG_ErrorLvl, "Err9 @%s\n", __func__);
							}
						}
						if(ubOutSrc2 == KNL_SRC_2_AUX)
						{
							ulOutAddr2 = ulBUF_GetVdoAuxBs1FreeBuf();
							if(ulOutAddr2 == BUF_FAIL)
							{
								printd(DBG_ErrorLvl, "Err10 @%s\n", __func__);
							}
						}
						if(ubOutSrc2 == KNL_SRC_3_AUX)
						{
							ulOutAddr2 = ulBUF_GetVdoAuxBs2FreeBuf();
							if(ulOutAddr2 == BUF_FAIL)
							{
								printd(DBG_ErrorLvl, "Err11 @%s\n", __func__);
							}
						}
						if(ubOutSrc2 == KNL_SRC_4_AUX)
						{
							ulOutAddr2 = ulBUF_GetVdoAuxBs3FreeBuf();
							if(ulOutAddr2 == BUF_FAIL)
							{
								printd(DBG_ErrorLvl, "Err12 @%s\n", __func__);
							}
						}
					}
				}

			#ifndef S2019A
				//(4)Copy BB's Buffer to Kernel
				//Copy Data to Src1
				tDmaResult = tDMAC_MemCopy(ulVdoAddr, ulVdoBsAddr, ulVdoSize, NULL);
			#endif
				if(DMAC_OK == tDmaResult)
				{
					uint32_t ulChkSz = 0;

					ulChkSz = ulVdoSize;
					tKNLInfo.ulSize = ulVdoSize;                       
					//(5)Get Source Side Information
					tKNLInfo.ubSrcNum	= ubSrcNum;
					tKNLInfo.ulTime     = ulTime; 

					if(ubKNL_ChkDebugPkt(ulVdoBsAddr, ulChkSz) == 1)
					{
						//MultiOut Process
						if(ubMultiOutFlg)
						{
							//Copy Data to Src2
							tDMAC_MemCopy(ulVdoBsAddr,ulOutAddr2,ulChkSz,NULL);
						}

						//(7)Send Queue to Next Node
						if(ubMultiOutFlg == 0)	//Single Out Case
						{
							if(tKNL_GetPlyMode() == KNL_NORMAL_PLY)
							{
								tKNLInfo.ulDramAddr2    = ulVdoBsAddr;
								tKNLInfo.ubCurNode      = KNL_NODE_COMM_RX_VDO;
								tKNLInfo.ubNextNode     = ubKNL_GetNextNode(ubSrcNum,KNL_NODE_COMM_RX_VDO);
								tKNLInfo.ulIdx			= ulCurFrmIdx[ubSrcNumMap];
								tKNLInfo.ubHqCapFlag  	= ubHqCapFlag;
							#ifdef S2019A
								tKNLInfo.ulsFrmTm   	= ulKNL_GetTxVsyncFrmTm(ulVdoAddr, ulVdoSize);
								#if (defined(OP_AP) && defined(RVCS_APP))
								if(sPRF_BRIDGE_MODE == tKNL_sPRFDrvMd)
								{
									if(!ubKNL_ApBdgRxProc(sPRF_VDO_PKT, (KNL_SRC)ubSrcNum, ulVdoAddr, ulVdoSize))
										goto RX_VDO_RST_I;
								}
								#endif
							#endif
								#if (LCD_PANEL == LCD_NO_PANEL)
								if(UVC_GetVdoFormat() == USB_UVC_VS_FORMAT_FRAME_BASED )
								{

								}
								else 
								#endif
								if(osMessagePut(KNL_VdoCodecProcQueue, &tKNLInfo, 0) == osErrorResource)								
								{
									ubKNL_ReleaseBsBufAddr(KNL_NODE_COMM_RX_VDO, ubSrcNum, tKNLInfo.ulDramAddr2);
									printd(DBG_ErrorLvl, "KNL_Q->Full !!!\r\n");
								}
							#if (defined(OP_AP) && defined(S2019A))
								sPRF_FrameRptFunc((sPRF_DevId_t)ubSrcNumMap);
								osMessagePut(osKNL_sPrfFrmQue, &ubSrcNumMap, 0);
							#endif
								if(pKNL_PerDbgFunc[0])
								{
									if(TRUE == ubKNL_TxRstIFlag)
										pKNL_PerDbgFunc[0](PER_FRMSTS_RPT, ubSrcNumMap, FRM_TXBUF_ERR);
									ubKNL_TxRstIFlag = FALSE;
									pKNL_PerDbgFunc[0](PER_FRMSEQ_RPT, ubSrcNumMap, ulCurFrmIdx[ubSrcNumMap]);
								}
							}
							else if(tKNL_GetPlyMode() == KNL_AVG_PLY)
							{
								if((ubKNL_AvgPlyCnt[ubSrcNumMap] >= ubKNL_GetStartPlyNum()) && (!ubKNL_AvgPlyStartFlg[ubSrcNumMap]))
								{
									ubKNL_AvgPlyStartFlg[ubSrcNumMap] = 1;
								}
								tKNLInfo.ubSrcNum       = ubSrcNumMap;
								tKNLInfo.ulDramAddr2    = ulVdoBsAddr;
								tKNLInfo.ubCurNode      = KNL_NODE_COMM_RX_VDO;
								tKNLInfo.ubNextNode     = ubKNL_GetNextNode(ubSrcNum,KNL_NODE_COMM_RX_VDO);
								if(osMessagePut(KNL_AvgPlyQ[ubSrcNumMap].Id, &tKNLInfo, 0) == osErrorResource)
								{
									ubKNL_ReleaseBsBufAddr(KNL_NODE_COMM_RX_VDO, ubSrcNum, tKNLInfo.ulDramAddr2);
									printd(DBG_ErrorLvl, "KNL_Q->Full !!!\r\n");
								}
							}
						}
						else if(ubMultiOutFlg)	//Multiple Out Case
						{
							KNL_NODE_INFO tNodeInfo;

							tNodeInfo = tKNL_GetNodeInfo(ubSrcNum,KNL_NODE_COMM_RX_VDO);
							tNodeInfo = tKNL_GetNodeInfo(ubSrcNum,tNodeInfo.ubNextNode);
							if((tNodeInfo.ubNextNode == KNL_NODE_NONE)||(tNodeInfo.ubNextNode == KNL_NODE_END))
							{
								ubKNL_ReleaseBsBufAddr(KNL_NODE_COMM_RX_VDO, ubSrcNum, ulVdoBsAddr);
							}
							else
							{
								//Src1
								tKNLInfo.ubSrcNum       = ubSrcNum;
								tKNLInfo.ulDramAddr2    = ulVdoBsAddr;
								tKNLInfo.ubCurNode      = KNL_NODE_COMM_RX_VDO;
								tKNLInfo.ubNextNode     = ubKNL_GetNextNode(ubSrcNum,KNL_NODE_COMM_RX_VDO);
								if(osMessagePut(KNL_VdoCodecProcQueue, &tKNLInfo, 0) == osErrorResource)
								{
									ubKNL_ReleaseBsBufAddr(KNL_NODE_COMM_RX_VDO, ubSrcNum, tKNLInfo.ulDramAddr2);
									printd(DBG_ErrorLvl, "KNL_Q->Full !!!\r\n");
								}
							}

							//Src2
							tKNLInfo.ubSrcNum       = ubOutSrc2;
							tKNLInfo.ulDramAddr2    = ulOutAddr2;
							tKNLInfo.ubCurNode      = KNL_NODE_COMM_RX_VDO;
							tKNLInfo.ubNextNode     = ubKNL_GetNextNode(ubOutSrc2,KNL_NODE_COMM_RX_VDO);
							if(osMessagePut(KNL_VdoCodecProcQueue, &tKNLInfo, 0) == osErrorResource)
							{
								ubKNL_ReleaseBsBufAddr(KNL_NODE_COMM_RX_VDO, ubSrcNum, tKNLInfo.ulDramAddr2);
								printd(DBG_ErrorLvl, "KNL_Q->Full !!!\r\n");
							}
						}
					}
					else
					{
						ubKNL_ReleaseBsBufAddr(KNL_NODE_COMM_RX_VDO, ubSrcNum, ulVdoBsAddr);
						printd(DBG_ErrorLvl, "Err13 @%s\n", __func__);
					}
				}
				else
				{
					ubKNL_ReleaseBsBufAddr(KNL_NODE_COMM_RX_VDO, ubSrcNum, ulVdoBsAddr);
					printd(DBG_ErrorLvl, "DMA NRDY @%s !\n", __func__);
				}
			}
			else
			{
				printf("\r\n  vErr3\r\n");
				goto RX_VDO_RST_I;
//				if((!ubKNL_ChkImgRdy()) && (ubSta <= KNL_STA4))
//				{
//					printd(DBG_ErrorLvl, "Busy[%d]:%d\r\n", ubSta, ubSrcNum);
//					ubKNL_VdoBsBusyCnt[ubSta]++;
//				}
			}
			//! UVC
			if(KNL_UVCO_RSTI == tKNL_UpdateBsUvcImage(ulVdoAddr, ulVdoSize))
			{
				if(ubSrcNumMap <= KNL_STA4)
				{
					ubKNL_RcvFirstIFrame[ubSrcNum] 	 = 0;
					ubKNL_RecvChkSeqFlg[ubSrcNumMap] = 0;
					tKNLInfo.ubSrcNum     = ubSrcNum;
					tKNLInfo.ubTargetRole = ubSta;
					tKNLInfo.ubTwcCmd	  = TWC_RESEND_I_EXT;
					if(FALSE == ubKNL_VdoResendITwcFlg[tKNLInfo.ubTargetRole])
					{
						if(osMessagePut(KNL_TwcMonitQueue, &tKNLInfo, 0) == osErrorResource)
						{
							printd(DBG_ErrorLvl, "KNL_TwcMonitQ->Full !!!!\r\n");
						}
					}
				}
			}
			if(UVC_GetVdoFormat() == USB_UVC_VS_FORMAT_FRAME_BASED )
			{
				ubKNL_ReleaseBsBufAddr(KNL_NODE_COMM_RX_VDO, ubSrcNum, tKNLInfo.ulDramAddr2);	
			}
			
		}
		else
		{
RX_VDO_RST_I:
			if((ubKNL_ChkVdoFlowAct(ubSrcNum)) && (ubSrcNumMap <= KNL_STA4))
			{
				tKNLInfo.ubRstVdoGrp = ubKNL_RstVdoGrpFlag;
				if(TRUE == ubKNL_RstVdoGrpFlag)
					ubKNL_RstVdoGrpFlag = FALSE;		
				ubKNL_RcvFirstIFrame[ubSrcNum] 	 = 0;
				ubKNL_RecvChkSeqFlg[ubSrcNumMap] = 0;
				tKNLInfo.ubSrcNum     = ubSrcNum;
				tKNLInfo.ubTargetRole = ubSta;
				tKNLInfo.ubTwcCmd	  = TWC_RESEND_I_EXT;
				if(FALSE == ubKNL_VdoResendITwcFlg[tKNLInfo.ubTargetRole])
				{
					if(osMessagePut(KNL_TwcMonitQueue, &tKNLInfo, 0) == osErrorResource)
					{
						printd(DBG_ErrorLvl, "KNL_TwcMonitQ->Full !!!!\r\n");
					}
				}
			}
RX_VDOINFO_ERR:
			printd(DBG_InfoLvl, "[%d]R(%d),[%d:%d:%d],[%d:%d]\r\n", ubSrcNum, ubKNL_ChkVdoFlowAct(ubSrcNum), ubKNL_RcvFirstIFrame[ubSrcNum], ubChkSeqOk[ubSrcNumMap], ubKNL_OutChkFlg, ubOpMode, ubKNL_GetOpMode());	//!DBG_Debug2Lvl
			tRcvSrc = KNL_SRC_NONE;
		}
	}
#if (OP_AP && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
	else if(KNL_VIDEO_PLAY == tKNL_GetRecordFunc() && tKNL_GetPlayDestFld() == KNL_SIM_FLD )
    {
		//Reset the Status
		ubMultiOutFlg = 0;
		ulOutAddr1 = BUF_FAIL;
		ulOutAddr2 = BUF_FAIL;
		ubOutSrc1  = ubOutSrc1;
		ulOutAddr1 = ulOutAddr1;
	
		ubSrcNum 	= ubKNL_GetPktSrcNum(ulVdoAddr, ulVdoSize);
		tRcvSrc		= (KNL_SRC)ubSrcNum;
		ubSrcNumMap = ubKNL_SrcNumMap(ubSrcNum);
		ubOpMode 	= ubKNL_GetPktOpMode(ulVdoAddr, ulVdoSize);
		ulGop 		= ulKNL_GetPktGop(ulVdoAddr, ulVdoSize);
		ulTime 		= ulKNL_GetTimeStamp1(ulVdoAddr, ulVdoSize);
		ubVdoGop 	= ubKNL_GetPktVdoGop(ulVdoAddr, ulVdoSize);

        KNL_GetTxFSInfo(ulVdoAddr, ulVdoSize);
        KNL_RP_SyncHdlr.ubFrmType = *(uint8_t*)(ulVdoAddr);
        if( KNL_RP_SyncHdlr.ubFrmType == 0xAA)
            KNL_RP_SyncHdlr.ubStartPlayFg = 1;
        else
        {
            // Active detect at remote play frame. Rx in play mode,but Tx not, rx stop play
            if( KNL_RP_SyncHdlr.ubStartPlayFg == 1)
            {
                KNL_RP_SyncHdlr.ubStartPlayFg = 0;
                KNL_VideoPlayStop();
            }
            goto RX_VDOINFO_ERR;
        }
        *(uint8_t*)(ulVdoAddr) = 0x0;
        *(uint8_t *)(ulVdoAddr+1) = 0x0;
		*(uint8_t *)(ulVdoAddr+2) = 0x0;
		*(uint8_t *)(ulVdoAddr+3) = 0x1;
	
		if((ubOpMode != ubKNL_GetOpMode()) || (ubSrcNumMap > KNL_STA4))
			goto RX_VDOINFO_ERR1;

		ulCurFrmIdx[ubSrcNumMap] = ulKNL_GetPktFrmIdx(ulVdoAddr, ulVdoSize);

		uwKNL_PktHSize = ubKNL_GetPktHRes(ulVdoAddr, ulVdoSize);
		uwKNL_PktVSize = ubKNL_GetPktVRes(ulVdoAddr, ulVdoSize);
		
		ubKNL_VdoResChgTwcFlg[ubSrcNumMap] = FALSE;
		tKNL_RecvFrmType = tKNL_GetFrameType(ulVdoAddr);
		printd(DBG_InfoLvl, "[%d]:H[%d]xV[%d]\r\n",ubSrcNum, uwKNL_PktHSize, uwKNL_PktVSize);
		printd(DBG_Debug2Lvl, "V[%d]:0x%x_M:%d_I:%d_G:%d_VG:%d_T:%d\r\n",ubSrcNum,ulVdoAddr,ubOpMode,ulCurFrmIdx[ubSrcNum],ulGop,ubVdoGop,ulTime);
		
		if(ubKNL_ChkVdoFlowAct(ubSrcNum) && (ubKNL_RcvFirstIFrame[ubSrcNum] == 0))
		{
			if(tKNL_RecvFrmType == KNL_I_FRAME)
			{
				ubKNL_VdoResendITwcFlg[ubSrcNumMap] = FALSE;
				ubKNL_AppResendIFrmFlg[ubSrcNumMap] = FALSE;
				ubKNL_RcvFirstIFrame[ubSrcNum] = 1;
				printd(DBG_CriticalLvl, "Find I[%d]\r\n",ubSrcNum);
				if(TRUE == ubKNL_WakeUpFlag[ubSrcNumMap])
					KNL_WakeupDevice((KNL_ROLE)ubSrcNumMap, FALSE);

				ubChkSeqOk[ubSrcNumMap] = 1;

				ubKNL_RecvCnt[ubSrcNumMap] = 0;
				ulKNL_RecvSum[ubSrcNumMap] = 0;

				ubKNL_AvgPlyStartFlg[ubSrcNumMap] = 0;
				ubKNL_AvgPlyCnt[ubSrcNumMap] = 0;

				ulKNL_InVdoFpsCnt[ubSrcNum] = ulKNL_InVdoFpsCntTemp[ubSrcNum];
				ulKNL_InVdoFpsCntTemp[ubSrcNum] = 0;

				ubHqCapFlag = ubKNL_GetHQCapFlag(ulVdoAddr, ulVdoSize);
			}
		}

		if(ubKNL_ChkVdoFlowAct(ubSrcNum) && ubKNL_RcvFirstIFrame[ubSrcNum] && ubChkSeqOk[ubSrcNumMap] )		
		{
			uint32_t ulVdoBsAddr = 0;

			if(!ubKNL_AvgPlyStartFlg[ubSrcNumMap])
			{
				ubKNL_AvgPlyCnt[ubSrcNumMap]++;
			}

			ulKNL_InVdoFpsCntTemp[ubSrcNum]++;
			ulKNL_RecvSum[ubSrcNumMap] = ulKNL_RecvSum[ubSrcNumMap] + ulVdoSize;
			ubKNL_RecvCnt[ubSrcNumMap]++;

			if(ubKNL_RecvCnt[ubSrcNumMap] == ubKNL_GetVdoFps())
			{
				printd(DBG_CriticalLvl, "TB[%d]:%d\n",ubSrcNum, ulKNL_RecvSum[ubSrcNumMap]/1024);
				ulKNL_InVdoFpsCnt[ubSrcNum] = ulKNL_InVdoFpsCntTemp[ubSrcNum];
				ulKNL_InVdoFpsCntTemp[ubSrcNum] = 0;
				ubKNL_RecvCnt[ubSrcNumMap] = 0;
				ulKNL_RecvSum[ubSrcNumMap] = 0;
			}

			//(2)Request Buffer to Temp
		#ifdef S2019A
			ulVdoBsAddr = ulVdoAddr;
		#else
			ulVdoBsAddr = ulKNL_GetBsBufAddr(ubSrcNum);
		#endif
			if(ulVdoBsAddr != BUF_FAIL)
			{
				DMAC_RESULT tDmaResult = DMAC_OK;

				if(ubSta <= KNL_STA4)
					ubKNL_VdoBsBusyCnt[ubSta] = 0;
				//(3)Check MultiOut Node
				if(ubKNL_ChkMultiOutNode(KNL_NODE_COMM_RX_VDO))
				{
					if(ubKNL_GetMultiInSrc(KNL_NODE_COMM_RX_VDO) == ubSrcNum)
					{
						ubMultiOutFlg = 1;
						ubOutSrc1 = ubKNL_GetMultiOutSrc(KNL_NODE_COMM_RX_VDO,0);
						ubOutSrc2 = ubKNL_GetMultiOutSrc(KNL_NODE_COMM_RX_VDO,1);
						if(ubOutSrc2 == KNL_SRC_1_AUX)
						{
							ulOutAddr2 = ulBUF_GetVdoAuxBs0FreeBuf();
							if(ulOutAddr2 == BUF_FAIL)
							{
								printd(DBG_ErrorLvl, "Err9 @%s\n", __func__);
							}
						}
						if(ubOutSrc2 == KNL_SRC_2_AUX)
						{
							ulOutAddr2 = ulBUF_GetVdoAuxBs1FreeBuf();
							if(ulOutAddr2 == BUF_FAIL)
							{
								printd(DBG_ErrorLvl, "Err10 @%s\n", __func__);
							}
						}
						if(ubOutSrc2 == KNL_SRC_3_AUX)
						{
							ulOutAddr2 = ulBUF_GetVdoAuxBs2FreeBuf();
							if(ulOutAddr2 == BUF_FAIL)
							{
								printd(DBG_ErrorLvl, "Err11 @%s\n", __func__);
							}
						}
						if(ubOutSrc2 == KNL_SRC_4_AUX)
						{
							ulOutAddr2 = ulBUF_GetVdoAuxBs3FreeBuf();
							if(ulOutAddr2 == BUF_FAIL)
							{
								printd(DBG_ErrorLvl, "Err12 @%s\n", __func__);
							}
						}
					}
				}

			#ifndef S2019A
				//(4)Copy BB's Buffer to Kernel
				//Copy Data to Src1
				tDmaResult = tDMAC_MemCopy(ulVdoAddr, ulVdoBsAddr, ulVdoSize, NULL);
			#endif
				if(DMAC_OK == tDmaResult)
				{
					uint32_t ulChkSz = 0;

					ulChkSz = ulVdoSize;
					tKNLInfo.ulSize = ulVdoSize;                       
					//(5)Get Source Side Information
					tKNLInfo.ubSrcNum	= ubSrcNum;
					tKNLInfo.ulTime     = ulTime; 

					if(ubKNL_ChkDebugPkt(ulVdoBsAddr, ulChkSz) == 1)
					{
						//MultiOut Process
						if(ubMultiOutFlg)
						{
							//Copy Data to Src2
							tDMAC_MemCopy(ulVdoBsAddr,ulOutAddr2,ulChkSz,NULL);
						}

						//(7)Send Queue to Next Node
						if(ubMultiOutFlg == 0)	//Single Out Case
						{
							if(tKNL_GetPlyMode() == KNL_NORMAL_PLY)
							{
								tKNLInfo.ulDramAddr2    = ulVdoBsAddr;
								tKNLInfo.ubCurNode      = KNL_NODE_COMM_RX_VDO;
								tKNLInfo.ubNextNode     = ubKNL_GetNextNode(ubSrcNum,KNL_NODE_COMM_RX_VDO);
								tKNLInfo.ulIdx			= ulCurFrmIdx[ubSrcNumMap];
								tKNLInfo.ubHqCapFlag  	= ubHqCapFlag;
							#ifdef S2019A
								tKNLInfo.ulsFrmTm   	= ulKNL_GetTxVsyncFrmTm(ulVdoAddr, ulVdoSize);
							#endif
								if(osMessagePut(KNL_VdoCodecProcQueue, &tKNLInfo, 0) == osErrorResource)
								{
									ubKNL_ReleaseBsBufAddr(KNL_NODE_COMM_RX_VDO, ubSrcNum, tKNLInfo.ulDramAddr2);
									printd(DBG_ErrorLvl, "KNL_Q->Full !!!\r\n");
								}
							#if (defined(OP_AP) && defined(S2019A))
								sPRF_FrameRptFunc((sPRF_DevId_t)ubSrcNumMap);
								osMessagePut(osKNL_sPrfFrmQue, &ubSrcNumMap, 0);
							#endif
								if(pKNL_PerDbgFunc[0])
								{
									if(TRUE == ubKNL_TxRstIFlag)
										pKNL_PerDbgFunc[0](PER_FRMSTS_RPT, ubSrcNumMap, FRM_TXBUF_ERR);
									ubKNL_TxRstIFlag = FALSE;
									pKNL_PerDbgFunc[0](PER_FRMSEQ_RPT, ubSrcNumMap, ulCurFrmIdx[ubSrcNumMap]);
								}
							}
							else if(tKNL_GetPlyMode() == KNL_AVG_PLY)
							{
								if((ubKNL_AvgPlyCnt[ubSrcNumMap] >= ubKNL_GetStartPlyNum()) && (!ubKNL_AvgPlyStartFlg[ubSrcNumMap]))
								{
									ubKNL_AvgPlyStartFlg[ubSrcNumMap] = 1;
								}
								tKNLInfo.ubSrcNum       = ubSrcNumMap;
								tKNLInfo.ulDramAddr2    = ulVdoBsAddr;
								tKNLInfo.ubCurNode      = KNL_NODE_COMM_RX_VDO;
								tKNLInfo.ubNextNode     = ubKNL_GetNextNode(ubSrcNum,KNL_NODE_COMM_RX_VDO);
								if(osMessagePut(KNL_AvgPlyQ[ubSrcNumMap].Id, &tKNLInfo, 0) == osErrorResource)
								{
									ubKNL_ReleaseBsBufAddr(KNL_NODE_COMM_RX_VDO, ubSrcNum, tKNLInfo.ulDramAddr2);
									printd(DBG_ErrorLvl, "KNL_Q->Full !!!\r\n");
								}
							}
						}
						else if(ubMultiOutFlg)	//Multiple Out Case
						{
							KNL_NODE_INFO tNodeInfo;

							tNodeInfo = tKNL_GetNodeInfo(ubSrcNum,KNL_NODE_COMM_RX_VDO);
							tNodeInfo = tKNL_GetNodeInfo(ubSrcNum,tNodeInfo.ubNextNode);
							if((tNodeInfo.ubNextNode == KNL_NODE_NONE)||(tNodeInfo.ubNextNode == KNL_NODE_END))
							{
								ubKNL_ReleaseBsBufAddr(KNL_NODE_COMM_RX_VDO, ubSrcNum, ulVdoBsAddr);
							}
							else
							{
								//Src1
								tKNLInfo.ubSrcNum       = ubSrcNum;
								tKNLInfo.ulDramAddr2    = ulVdoBsAddr;
								tKNLInfo.ubCurNode      = KNL_NODE_COMM_RX_VDO;
								tKNLInfo.ubNextNode     = ubKNL_GetNextNode(ubSrcNum,KNL_NODE_COMM_RX_VDO);
								if(osMessagePut(KNL_VdoCodecProcQueue, &tKNLInfo, 0) == osErrorResource)
								{
									ubKNL_ReleaseBsBufAddr(KNL_NODE_COMM_RX_VDO, ubSrcNum, tKNLInfo.ulDramAddr2);
									printd(DBG_ErrorLvl, "KNL_Q->Full !!!\r\n");
								}
							}

							//Src2
							tKNLInfo.ubSrcNum       = ubOutSrc2;
							tKNLInfo.ulDramAddr2    = ulOutAddr2;
							tKNLInfo.ubCurNode      = KNL_NODE_COMM_RX_VDO;
							tKNLInfo.ubNextNode     = ubKNL_GetNextNode(ubOutSrc2,KNL_NODE_COMM_RX_VDO);
							if(osMessagePut(KNL_VdoCodecProcQueue, &tKNLInfo, 0) == osErrorResource)
							{
								ubKNL_ReleaseBsBufAddr(KNL_NODE_COMM_RX_VDO, ubSrcNum, tKNLInfo.ulDramAddr2);
								printd(DBG_ErrorLvl, "KNL_Q->Full !!!\r\n");
							}
						}
					}
					else
					{
						ubKNL_ReleaseBsBufAddr(KNL_NODE_COMM_RX_VDO, ubSrcNum, ulVdoBsAddr);
						printd(DBG_ErrorLvl, "Err13 @%s\n", __func__);
					}
				}
				else
				{
					ubKNL_ReleaseBsBufAddr(KNL_NODE_COMM_RX_VDO, ubSrcNum, ulVdoBsAddr);
					printd(DBG_ErrorLvl, "DMA NRDY @%s !\n", __func__);
				}
			}
			else
			{
				printf("\r\n  vErr3\r\n");
				goto RX_VDOINFO_ERR1;
			}
			//! UVC
			if(KNL_UVCO_RSTI == tKNL_UpdateBsUvcImage(ulVdoAddr, ulVdoSize))
			{
				if(ubSrcNumMap <= KNL_STA4)
				{
					ubKNL_RcvFirstIFrame[ubSrcNum] 	 = 0;
					tKNLInfo.ubSrcNum     = ubSrcNum;
					tKNLInfo.ubTargetRole = ubSta;
					tKNLInfo.ubTwcCmd	  = TWC_RESEND_I_EXT;
					if(FALSE == ubKNL_VdoResendITwcFlg[tKNLInfo.ubTargetRole])
					{
						if(osMessagePut(KNL_TwcMonitQueue, &tKNLInfo, 0) == osErrorResource)
						{
							printd(DBG_ErrorLvl, "KNL_TwcMonitQ->Full !!!!\r\n");
						}
					}
				}
			}
		}
		else
		{
RX_VDOINFO_ERR1:
			printd(DBG_InfoLvl, "[%d]R(%d),[%d:%d:%d],[%d:%d]\r\n", ubSrcNum, ubKNL_ChkVdoFlowAct(ubSrcNum), ubKNL_RcvFirstIFrame[ubSrcNum], ubChkSeqOk[ubSrcNumMap], ubKNL_OutChkFlg, ubOpMode, ubKNL_GetOpMode());	//!DBG_Debug2Lvl
			tRcvSrc = KNL_SRC_NONE;
		}
	}
#endif
	return tRcvSrc;
}
//------------------------------------------------------------------------------
static void KNL_CommVdoRxMonitThread(void const *argument)
{
	RX_DON Don;

	while(1)
	{
		//(1)Wait Event
        osMessageGet(KNL_QueRxVdo, &Don, osWaitForever);
#if APP_REC_FUNC_ENABLE
#if (APP_PLAY_REMOTE_ENABLE)
        if(tKNL_GetRecordFunc() == KNL_VIDEO_PLAY && tKNL_GetPlayDestFld() == KNL_REAL_FLD)
#else
        if(tKNL_GetRecordFunc() == KNL_VIDEO_PLAY)
#endif
        {
		#ifdef A7130
			BB_RxBufRelease(Don.Type, Don.tSTA);
		#endif
		#ifdef S2019A
			KNL_SRC tRcvSrc;

			tRcvSrc = (ptKNL_VdoRoleMap2SrcNum)?ptKNL_VdoRoleMap2SrcNum(KNL_MAIN_PATH, (KNL_ROLE)Don.tSTA):(KNL_SRC)(KNL_SRC_1_MAIN + Don.tSTA);
			ubKNL_ReleaseBsBufAddr(KNL_NODE_COMM_RX_VDO, tRcvSrc, Don.ulAddr);
		#endif
		#ifdef RTC676x
			if(RELEASE_BUF_METHOD == RELEASE_BUF_QUE)
			{	
				if(Don.tSTA == BB_GET_STA1)
					ubBUF_ReleaseVdoPacketize0Buf(Don.ulAddr);
				else if(Don.tSTA == BB_GET_STA2)
					ubBUF_ReleaseVdoPacketize1Buf(Don.ulAddr);
				else if(Don.tSTA == BB_GET_STA3)
					ubBUF_ReleaseVdoPacketize2Buf(Don.ulAddr);
				else if(Don.tSTA == BB_GET_STA4)
					ubBUF_ReleaseVdoPacketize3Buf(Don.ulAddr);
			}
		#endif
			
        }
		else
#endif
#ifdef A7130
        if(/*Don.ubGetCrc != ubBB_GetCrcReport(Don.ulAddr,Don.ulCrcLen)*/0)
		{
			KNL_PROCESS tKNLInfo;
			uint8_t ubSrcNum;
			uint8_t ubSrcNumMap;

			ubSrcNum 	= ubKNL_GetPktSrcNum(Don.ulAddr,Don.ulSize);
#if defined(BSP_DVR_SDK)
            if(ubKNL_GetSrcNumPosition((KNL_SRC)ubSrcNum) != KNL_LOCAL)
#endif
			ubSrcNumMap = ubKNL_SrcNumMap(ubSrcNum);
			if(ubSrcNumMap <= KNL_STA4)
			{
				ubKNL_RcvFirstIFrame[ubSrcNum] = 0;
				tKNLInfo.ubSrcNum     = ubSrcNum;
				tKNLInfo.ubTargetRole = Don.tSTA;
				tKNLInfo.ubTwcCmd	  = TWC_RESEND_I_EXT;
				if(FALSE == ubKNL_VdoResendITwcFlg[tKNLInfo.ubTargetRole])
				{
					if(osMessagePut(KNL_TwcMonitQueue, &tKNLInfo, 0) == osErrorResource)
					{
						printd(DBG_ErrorLvl, "KNL_TwcMonitQ->Full !!!!\r\n");
					}
				}
			}
			else
			{
				if(FALSE == ubKNL_VdoChkSrcNumFlg[Don.tSTA])
					ubKNL_VdoChkSrcNumFlg[Don.tSTA] = TRUE;
			}
			printd(DBG_ErrorLvl, "(Case2)Frm Seq->Fail[%d][%d_%d]\r\n", ubSrcNum, Don.tSTA, Don.Type);
			BB_RxBufRelease(Don.Type, Don.tSTA);
		}
		else
#endif
		{
			KNL_SRC tRcvSrc = KNL_SRC_NONE;

			if(APP_TUNINGMODE_ON == APP_GetTuningToolMode())
			{
				 tRcvSrc = KNL_SRC_NONE;
			}
			else
			{				
				tRcvSrc = tKNL_RxVdoInProcess(Don.tSTA, Don.ulAddr, Don.ulSize);
				tRcvSrc = tRcvSrc;
			}
#ifdef A7130
			BB_RxBufRelease(Don.Type, Don.tSTA);
#endif
#ifdef S2019A
			if(KNL_SRC_NONE == tRcvSrc)
			{
				tRcvSrc = (ptKNL_VdoRoleMap2SrcNum)?ptKNL_VdoRoleMap2SrcNum(KNL_MAIN_PATH, (KNL_ROLE)Don.tSTA):(KNL_SRC)(KNL_SRC_1_MAIN + Don.tSTA);
				ubKNL_ReleaseBsBufAddr(KNL_NODE_COMM_RX_VDO, tRcvSrc, Don.ulAddr);
			}
#endif
		#ifdef RTC676x
			if(RELEASE_BUF_METHOD == RELEASE_BUF_QUE)
			{
				if(Don.tSTA == BB_GET_STA1)
					ubBUF_ReleaseVdoPacketize0Buf(Don.ulAddr);
				else if(Don.tSTA == BB_GET_STA2)
					ubBUF_ReleaseVdoPacketize1Buf(Don.ulAddr);
				else if(Don.tSTA == BB_GET_STA3)
					ubBUF_ReleaseVdoPacketize2Buf(Don.ulAddr);
				else if(Don.tSTA == BB_GET_STA4)
					ubBUF_ReleaseVdoPacketize3Buf(Don.ulAddr);
			}
		#endif			
			
		}
	}
}
//------------------------------------------------------------------------------
void KNL_UpdateUsbdAdoData(uint32_t ulAdoPcmAddr, uint32_t ulAdoPcmSize, ADO_SAMPLERATE SampleRate, ADO_CHANNEL_MODE Channel)
{
	uint32_t ulUsbdAdoAddr = 0;
	uint32_t ulUvcAuxSize = UVC_OFS_SUB_FRAME_DATA - UVC_OFS_CH_INFO;

	ulUsbdAdoAddr = ulAdoPcmAddr - UVC_OFS_SUB_FRAME_DATA;
	
	if(!ulAdoPcmSize)
    {
        if((tUSBD_GetClassMode() == USBD_COMPOSITE_MODE) && (TRUE == ubUSBD_ChkCompMscClass())) 
            ubBUF_ReleaseAdoUsbdBuf(ulUsbdAdoAddr); 
        else
            ubBUF_ReleaseAdoUsbdBuf(ulUsbdAdoAddr - UAC_OFS_DATAGAP); 
        return;
    }
	if((tUSBD_GetClassMode() == USBD_COMPOSITE_MODE) && (TRUE == ubUSBD_ChkCompMscClass())) 
	{
		if(!ulAdoPcmSize)
		{
			uint8_t *pSrcNum = (uint8_t *)ulUsbdAdoAddr;

			ubBUF_ReleaseAdoUsbdBuf(ulUsbdAdoAddr);
			printd(DBG_ErrorLvl, "\n	[%d]Drop ado frame\n", pSrcNum[12]);
			return;
		}
		*((uint8_t *)(ulUsbdAdoAddr + UVC_OFS_SUB_FRAME_LEN)) 	  = ulAdoPcmSize & 0xFF;
		*((uint8_t *)(ulUsbdAdoAddr + UVC_OFS_SUB_FRAME_LEN + 1)) = (ulAdoPcmSize >> 8) & 0xFF;
	   
		//! USBD Send	  
		if(FALSE == uvc_update_image((uint32_t *)ulUsbdAdoAddr, (ulAdoPcmSize + ulUvcAuxSize)))
		  KNL_ReleaseUsbdBuf(ulUsbdAdoAddr); 
		printd(DBG_InfoLvl, "  {%d}\n", *((uint8_t *)(ulUsbdAdoAddr + UVC_OFS_CH_INFO)));
	}
	#if (defined(OP_AP) && (APP_USBD_COMPOSITE_MODE & USBD_MULTI_UAC))
	else if(ubUacStartFlag)
    {    
		
		ADO_Queue_INFO tAdoInfo;  
        tAdoInfo.SrcAddr = ulAdoPcmAddr;
        tAdoInfo.SrcSize = ulAdoPcmSize;
		if(ulAdoPcmSize)
		{		
			if(osMessagePut(osKNL_UsbdUacQue, &tAdoInfo, 0) != osOK)
			{
				KNL_ReleaseUsbdBuf(ulUsbdAdoAddr - UAC_OFS_DATAGAP);
			}
		}

    }
	#endif
    else
    { 
        if((tUSBD_GetClassMode() == USBD_COMPOSITE_MODE) && (TRUE == ubUSBD_ChkCompMscClass())) 
    		ubBUF_ReleaseAdoUsbdBuf(ulUsbdAdoAddr);
		else
		    ubBUF_ReleaseAdoUsbdBuf(ulUsbdAdoAddr - UAC_OFS_DATAGAP);
    } 
}
//------------------------------------------------------------------------------
#if (defined(OP_AP) && (APP_USBD_COMPOSITE_MODE & USBD_MULTI_UAC))
static void KNL_UsbdIsoInProcThread(void const *argument)     //Sent Data to USBD(PC ISO IN)
{
	ADO_Queue_INFO tAdoInfo;  
	
	uint32_t ulSentAudioSize;
	uint32_t ulRealAudioAddr;
	uint32_t ulRealAudioSize;
	static uint8_t ubKNL_UsbdIsoInRemainSize = 0;	
	static uint8_t ubKNL_UsbdIsoInRemainBuf[192];	

	while(1)
	{    		
		osMessageGet(osKNL_UsbdUacQue, &tAdoInfo, osWaitForever);  
	
		if(osMessages(osKNL_UsbdUacQue))
			printd(DBG_InfoLvl,"UAC Q%d \n",osMessages(osKNL_UsbdUacQue));

		ulRealAudioAddr = tAdoInfo.SrcAddr - ubKNL_UsbdIsoInRemainSize;	
		ulRealAudioSize = tAdoInfo.SrcSize + ubKNL_UsbdIsoInRemainSize; 	

		memcpy((uint8_t *)ulRealAudioAddr, ubKNL_UsbdIsoInRemainBuf, ubKNL_UsbdIsoInRemainSize);

		ubKNL_UsbdIsoInRemainSize = ulRealAudioSize%96;			//96
		memcpy( ubKNL_UsbdIsoInRemainBuf,(uint8_t *)ulRealAudioAddr+ulRealAudioSize - ubKNL_UsbdIsoInRemainSize, ubKNL_UsbdIsoInRemainSize);
		ulRealAudioSize -=	ubKNL_UsbdIsoInRemainSize;	
		ulSentAudioSize = 0;	
		do
		{
			if( (ulRealAudioSize - ulSentAudioSize) > 3072)		//3072 = 96*32
			{					
				usbd_uac_drv_do_record((uint8_t *)ulRealAudioAddr + ulSentAudioSize,3072); 
				ulSentAudioSize += 3072;		
			}
			else
			{
				usbd_uac_drv_do_record((uint8_t *)ulRealAudioAddr + ulSentAudioSize,ulRealAudioSize- ulSentAudioSize); 				
				ulSentAudioSize = ulRealAudioSize;
			}
		}
		while(ulRealAudioSize - ulSentAudioSize > 0);				
		KNL_ReleaseUsbdBuf(tAdoInfo.SrcAddr - UVC_OFS_SUB_FRAME_DATA - UAC_OFS_DATAGAP);
    }
}
//------------------------------------------------------------------------------
uint8_t *ubIsoOutbuf;
uint32_t ulIsoOutTotalWrSz = 0;
uint32_t ulIsoOutTotalRdSz = 0;
void KNL_RecvAdoDataFromUac(uint8_t *pAdoData, uint16_t uwAdoSize);
static void KNL_UsbdIsoOutProcThread(void const *argument)	//Get Data from USBD(PC ISO out)
{
	uint32_t ulIsoOutSz;
	uint32_t ulPcmForEncSz;
#if (ADO_ENC_TYPE==AUDIO32_ENC)
	ulPcmForEncSz = 3840;
#elif (ADO_ENC_TYPE==SW_AAC_ENC)
	ulPcmForEncSz = ulADO_BufTh[tKNL_AdoInfo.BufTh.Adc];//ulADO_AAC_GetEncUnitSize(0);
#elif (ADO_ENC_TYPE==SW_ALAW_ENC)
    ulPcmForEncSz = ulADO_BufTh[tKNL_AdoInfo.BufTh.Adc];//ulADO_AAC_GetEncUnitSize(0);
#endif
	ubIsoOutbuf = (uint8_t*)osMalloc(ulPcmForEncSz*2);
	while(1)
	{
        ulIsoOutSz  = usbd_uac_drv_do_play(ubIsoOutbuf+ulIsoOutTotalWrSz , ulPcmForEncSz);
        if(ulIsoOutSz == 0)
			osDelay(10);
        else
        {
            ulIsoOutTotalWrSz += ulIsoOutSz;
            if(ulIsoOutTotalWrSz >ulPcmForEncSz)
            {        
                ulIsoOutTotalWrSz -= ulPcmForEncSz;
                KNL_RecvAdoDataFromUac(ubIsoOutbuf ,ulPcmForEncSz); 
                memcpy(ubIsoOutbuf,ubIsoOutbuf+ulPcmForEncSz,ulIsoOutTotalWrSz);
            }
        }
    }
}
#endif
//------------------------------------------------------------------------------
uint32_t ulKNL_SetUsbdAdoPktInfo(uint32_t ulAdoAddr, uint32_t ulAdoSize)
{
	uint32_t ulAdoPktAddr = 0, ulTimeStp1, ulTimeStp2;
	uint8_t ubSrcNum, ubRoleNum, ubFrmSeq, ubIdx;

	ulAdoPktAddr = ulBUF_GetAdoUsbdFreeBuf();
	if(BUF_FAIL == ulAdoPktAddr)
	{
#if (defined(OP_AP) && (APP_USBD_COMPOSITE_MODE & USBD_MULTI_UAC))	
		printd(DBG_ErrorLvl,"Drop USB Ado Buf\n");
		BUF_Reset(BUF_USBD_ADO);
		osMessageReset(osKNL_UsbdUacQue);
		ulAdoPktAddr = ulBUF_GetAdoUsbdFreeBuf();
		if(BUF_FAIL == ulAdoPktAddr)
#endif		
			return 0;
	}
	ubSrcNum   = ubKNL_GetPktSrcNum(ulAdoAddr, ulAdoSize);
#if defined(BSP_DVR_SDK)
    if(ubKNL_GetSrcNumPosition((KNL_SRC)ubSrcNum) != KNL_LOCAL)
#endif
	ubRoleNum  = ubKNL_SrcNumMap(ubSrcNum);
	ulTimeStp1 = ulKNL_GetTimeStamp1(ulAdoAddr, ulAdoSize);
	ulTimeStp2 = ulKNL_GetTimeStamp2(ulAdoAddr, ulAdoSize);
	ubFrmSeq   = ubKNL_GetFrameSeq(ulAdoAddr, ulAdoSize);
	*((uint8_t *)(ulAdoPktAddr + UVC_OFS_CH_INFO))	= ubRoleNum;
	*((uint8_t *)(ulAdoPktAddr + UVC_OFS_AUX_INFO)) = KNL_ADO_FRAME;
	for(ubIdx = 0; ubIdx < 4; ubIdx++)
		*((uint8_t *)(ulAdoPktAddr + UVC_OFS_TIME_STAMP + ubIdx)) = ((ulTimeStp1 >> (ubIdx * 8)) & 0xFF);
	for(ubIdx = 0; ubIdx < 4; ubIdx++)
		*((uint8_t *)(ulAdoPktAddr + UVC_OFS_TIME_STAMP + ubIdx + 4)) = ((ulTimeStp2 >> (ubIdx * 8)) & 0xFF);
	*((uint8_t *)(ulAdoPktAddr + UVC_OFS_NUM_SUB_FRAME))   = 1;
	*((uint8_t *)(ulAdoPktAddr + UVC_OFS_SUB_FRAME_IDX))   = 0;
	*((uint8_t *)(ulAdoPktAddr + UVC_OFS_TOTAL_FRAME_IDX)) = ubFrmSeq;
if((tUSBD_GetClassMode() == USBD_COMPOSITE_MODE) && (TRUE == ubUSBD_ChkCompMscClass())) 
	return ulAdoPktAddr;
else
	return ulAdoPktAddr + UAC_OFS_DATAGAP;
	
}
//------------------------------------------------------------------------------
void KNL_RecvAdoDataFromApp(uint8_t *pAdoData, uint32_t ulLBA, uint32_t ulLBA_Cnt)
{
	uint32_t ulPcmAddr, ulSrcAddr;
	uint16_t uwAdoSize;
	uint8_t ubAuxInfo, ubChInfo;
	DMAC_RESULT tDmaResult = DMAC_OK;
	KNL_PROCESS tProcess;

    if(ulLBA)
		return;
	if(!ubKNL_UsbdAdoEncAct)
		return;
	ubAuxInfo 		= *((uint8_t *)(pAdoData + 0));
	ubChInfo  		= *((uint8_t *)(pAdoData + 1));
	uwAdoSize		= *((uint8_t *)(pAdoData + 4)) + (*((uint8_t *)(pAdoData + 5)) << 8);
	if(KNL_ADO_FRAME != (ubAuxInfo & 0x07))
		return;
	ulPcmAddr = ulBUF_GetAdoUsbdFreeBuf();
	if(BUF_FAIL == ulPcmAddr)
		return;
	ulSrcAddr = (uint32_t)((pAdoData + KNL_USBDMSC_AUX_SIZE));
	tDmaResult = tDMAC_MemCopy(ulSrcAddr, ulPcmAddr, uwAdoSize, NULL);
	if(DMAC_OK != tDmaResult)
	{
		ubBUF_ReleaseAdoUsbdBuf(ulPcmAddr);
		printd(DBG_ErrorLvl, "DMA NRDY @%s !\n", __func__);
		return;
	}
	if(ptKNL_AdoRoleMap2SrcNum)
	{
		KNL_SRC tAdoSrcNum;

		tAdoSrcNum = ptKNL_AdoRoleMap2SrcNum(KNL_SUB_PATH, (KNL_ROLE)ubChInfo);
		if(KNL_SRC_NONE == tAdoSrcNum)
		{
			printd(DBG_ErrorLvl, "Err Src Num @%s !\n", __func__);
			ubBUF_ReleaseAdoUsbdBuf(ulPcmAddr);
			return;
		}
		if((ubKNL_GetRole() == KNL_SLAVE_AP) || (ubKNL_GetRole() == KNL_MASTER_AP))
		{
		#if (defined(A7130))
			uint8_t ubRxVdo_Path, ubTxAdo_Path;

			ubRxVdo_Path = ubBB_GetRxVdoDataPath();
			ubTxAdo_Path = tAdoSrcNum % 4;
			BB_SetDataPath((TXADO)ubTxAdo_Path, BB_RX_ADO_ALL_STA, (PAYLOAD_PATH)ubRxVdo_Path);
		#endif
		#if (defined(RTC676x))
			uint8_t ubRxVdo_Path, ubTxAdo_Path;
			ubRxVdo_Path = ubBB_GetRxVdoDataPath();
			ubTxAdo_Path = tAdoSrcNum % 4;
			BB_SetDataPath((TXADO)ubTxAdo_Path, BB_RX_ADO_ALL_STA, (PAYLOAD_PATH)ubRxVdo_Path);
		#endif	
		}
		tProcess.ubSrcNum	 = tAdoSrcNum;
		tProcess.ubCurNode	 = KNL_NODE_MSC_ADO;
		tProcess.ubNextNode	 = KNL_NODE_MSC_ADO;
		tProcess.ulDramAddr1 = ulPcmAddr;
		tProcess.ulDramAddr2 = 0;
		tProcess.ulSize		 = uwAdoSize;
		if(osMessagePut(KNL_AdoCodecProcQueue, &tProcess, 0) >= osEventTimeout)
			printd(DBG_ErrorLvl, "KNL_ADO Q->Full !!!!\r\n");
	}
}
//------------------------------------------------------------------------------
#if (defined(OP_AP) && (APP_USBD_COMPOSITE_MODE & USBD_MULTI_UAC))
void KNL_RecvAdoDataFromUac(uint8_t *pAdoData, uint16_t uwAdoSize)
{
	uint32_t ulPcmAddr, ulSrcAddr;
	uint8_t ubChInfo;
	DMAC_RESULT tDmaResult = DMAC_OK;
	KNL_PROCESS tProcess;

	ulPcmAddr = ulBUF_GetAdoUsbdFreeBuf();
	if(BUF_FAIL == ulPcmAddr)
		return;
	ulSrcAddr = (uint32_t)pAdoData;
	tDmaResult = tDMAC_MemCopy(ulSrcAddr, ulPcmAddr, uwAdoSize, NULL);
	if(DMAC_OK != tDmaResult)
	{
		ubBUF_ReleaseAdoUsbdBuf(ulPcmAddr);
		printd(DBG_ErrorLvl, "DMA NRDY @%s !\n", __func__);
		return;
	}
	if(ptKNL_AdoRoleMap2SrcNum)
	{
		KNL_SRC tAdoSrcNum;
ubChInfo = 0;
		tAdoSrcNum = ptKNL_AdoRoleMap2SrcNum(KNL_SUB_PATH, (KNL_ROLE)ubChInfo);
		if(KNL_SRC_NONE == tAdoSrcNum)
		{
			printd(DBG_ErrorLvl, "Err Src Num @%s !\n", __func__);
			ubBUF_ReleaseAdoUsbdBuf(ulPcmAddr);
			return;
		}
		if((ubKNL_GetRole() == KNL_SLAVE_AP) || (ubKNL_GetRole() == KNL_MASTER_AP))
		{
		#if (defined(A7130))
			uint8_t ubRxVdo_Path, ubTxAdo_Path;

			ubRxVdo_Path = ubBB_GetRxVdoDataPath();
			ubTxAdo_Path = tAdoSrcNum % 4;
			BB_SetDataPath((TXADO)ubTxAdo_Path, BB_RX_ADO_ALL_STA, (PAYLOAD_PATH)ubRxVdo_Path);
		#endif		
					
		#if (defined(RTC676x))
			uint8_t ubRxVdo_Path, ubTxAdo_Path;

			ubRxVdo_Path = ubBB_GetRxVdoDataPath();
			ubTxAdo_Path = tAdoSrcNum % 4;
			BB_SetDataPath((TXADO)ubTxAdo_Path, BB_RX_ADO_ALL_STA, (PAYLOAD_PATH)ubRxVdo_Path);
		#endif
		}
		tProcess.ubSrcNum	 = tAdoSrcNum;
		tProcess.ubCurNode	 = KNL_NODE_MSC_ADO;
		tProcess.ubNextNode	 = KNL_NODE_MSC_ADO;
		tProcess.ulDramAddr1 = ulPcmAddr;
		tProcess.ulDramAddr2 = 0;
		tProcess.ulSize		 = uwAdoSize;
		if(osMessagePut(KNL_AdoCodecProcQueue, &tProcess, 0) >= osEventTimeout)
			printd(DBG_ErrorLvl, "KNL_ADO Q->Full !!!!\r\n");
	}
}
#endif
//------------------------------------------------------------------------------
void KNL_ActiveUsbdAdoEncFlag(uint8_t ubAct)
{
	ubKNL_UsbdAdoEncAct = ubAct;
	if(!ubKNL_UsbdAdoEncAct)
		ubKNL_UsbdAdoEncStFlag = TRUE;
}
#endif
#if defined(OP_AP)
//------------------------------------------------------------------------------
void KNL_RecvUsbdUvcSetImageInf(uint16_t uwHsize,uint16_t uwVsize)
{
	#if defined(BUC_CU)	
	KNL_ROLE tKNL_Role[2];	
	tKNL_Role[0] = KNL_STA1;
	#endif	
	if(USBD_UVC_H265_FMT == USBD_UVC_FMT)
	{
		uwKNL_FrmWidth = 0;
	}
	else
	{
		uwKNL_FrmWidth = 0;
		if(uwVsize%16)
			uwVsize = uwVsize/16*16+16;
	}
	#if defined(BUC_CU)	
	VDO_SwitchAhdType(KNL_DISP_SINGLE,tKNL_Role,uwHsize,uwVsize);
	#endif
	KNL_UpdateJpgHeader(uwHsize, uwVsize);
	BUF_Reset(BUF_USBD_VDO);
	BUF_Reset(BUF_ADO_DAC0);
	printf("UVC_MessageReset !!!!\r\n");
}
#endif
//------------------------------------------------------------------------------
void KNL_AdoRxRecSendQProcess(uint8_t ubSrcNum, uint32_t ulTimeStamp, uint32_t ulDramAddr, uint32_t ulSize)
{
#if APP_REC_FUNC_ENABLE
	REC_INFO RecAdoInfo;
	
	if(ulTimeStamp!=0)
	{
		RecAdoInfo.ubCh        = ubSrcNum;
		RecAdoInfo.ulTimeStamp = ulTimeStamp;
		RecAdoInfo.ulDramAddr  = ulDramAddr;
		RecAdoInfo.ulSize      = ulSize;

	if(RecAdoInfo.ulTimeStamp < ulKNL_PreAdoTimeStamp[RecAdoInfo.ubCh])
		RecAdoInfo.ubRestartFg = 1;
	else
		RecAdoInfo.ubRestartFg = 0;
		ulKNL_PreAdoTimeStamp[RecAdoInfo.ubCh] = RecAdoInfo.ulTimeStamp;
		
		RecAdoInfo.ubCmd = REC_CMD_AUDEXT;
		RecAdoInfo.ubPictureType = 0;
		if(!ubREC_SendADOQueue(&RecAdoInfo))
			printf("SendADOQueue Fail: %s: %d\n\r", __FILE__, __LINE__);
	}
#endif
}
//------------------------------------------------------------------------------
uint8_t ubKNL_AdoRemoteRecordingProcess(uint8_t ubSrcNum, uint32_t ulSrcAddr, uint32_t ulSize)
{
	uint8_t ubFlag = 1;
#if APP_REC_FUNC_ENABLE
	
	if( ADO_GetRemoteRecordPathStatus() == ADO_ON )
	{
#if(ADO_ENC_TYPE==AUDIO32_ENC)
		ubFlag = ubADO_RemoteRecordingPathHandle(0, ubSrcNum, ulSrcAddr, ulSize, KNL_AdoRxRecSendQProcess);
#elif(ADO_ENC_TYPE==SW_AAC_ENC)
		ubFlag = ubADO_RemoteRecordingPathHandle(1, ubSrcNum, ulSrcAddr, ulSize, KNL_AdoRxRecSendQProcess);
#endif
	}
#endif
	return ubFlag;
}
//------------------------------------------------------------------------------
void KNL_AdoLocalRecSendQProcess(uint32_t ulTimestamp, uint32_t ulSrcAddr, uint32_t ulSize)
{
#if defined(BSP_DVR_SDK)
    static uint8_t ubAdoFrmCnt = 0;
	
	ubAdoFrmCnt = ubAdoFrmCnt;	//Avoid Warning
#endif
#if APP_REC_FUNC_ENABLE
	if( ADO_GetLocalRecordPathStatus() == ADO_ON )
	{
		REC_INFO RecAdoInfo;
#if defined(BSP_DVR_SDK)
#if (defined(OP_AP))
		RecAdoInfo.ubCh        = 1;
#else
        RecAdoInfo.ubCh        = 0;
#endif
#else
		RecAdoInfo.ubCh        = 0;
#endif		
		RecAdoInfo.ulTimeStamp = ulTimestamp;
		RecAdoInfo.ulSize      = ulSize;
		RecAdoInfo.ulDramAddr  = ulSrcAddr;
		RecAdoInfo.ubRestartFg = 0;
		RecAdoInfo.ubCmd = REC_CMD_AUDEXT;
		RecAdoInfo.ubPictureType = 0;
		if(!ubREC_SendADOQueue(&RecAdoInfo))
			printf("SendADOQueue Fail: %s: %d\n\r", __FILE__, __LINE__);
#if (defined(OP_STA)&&defined(APP_TXREC_STREAM_SEL)&&(APP_TXREC_STREAM_SEL==2))
        RecAdoInfo.ubCh        = 1;
        if(!ubREC_SendADOQueue(&RecAdoInfo))
            printf("SendADOQueue Fail: %s: %d\n\r", __FILE__, __LINE__);
#endif        
	}
#endif
}
//------------------------------------------------------------------------------
static void KNL_CommAdoRxMonitThread(void const *argument)
{		
	KNL_PROCESS tKNLInfo;
	RX_DON Don;
	uint8_t ubSrcNum;
	uint32_t ulRealSz;
#ifndef S2019A
	uint32_t ulTemp;
#endif
	// ADO
	//=================================
	//| STA1       -> KNL_SRC_1_MAIN  |
	//| STA2       -> KNL_SRC_2_MAIN  |
	//| STA3       -> KNL_SRC_3_MAIN  |
	//| STA4       -> KNL_SRC_4_MAIN  |
	//| AP(Master) -> KNL_SRC_1_AUX   |
	//| AP(Slave)  -> KNL_SRC_2_AUX   |
	//=================================	

	while(1)
	{
		//(1)Wait Event
		osMessageGet(KNL_QueRxAdo, &Don, osWaitForever);
		//printd(DBG_Debug3Lvl, "A[%d]:0x%x\r\n",Don.tSTA,Don.ulSize);

#if (APP_REC_FUNC_ENABLE && OP_AP)
#if (APP_PLAY_REMOTE_ENABLE)
        if(tKNL_GetRecordFunc() == KNL_VIDEO_PLAY && tKNL_GetPlayDestFld() == KNL_REAL_FLD)
#else
        if(tKNL_GetRecordFunc() == KNL_VIDEO_PLAY)
#endif
        {
		#ifdef A7130        
			BB_RxBufRelease(Don.Type,Don.tSTA);
		#endif
		#ifdef S2019A
			ubKNL_ReleaseSPRFRxBufAddr(KNL_ADO_PKT, Don.tSTA, Don.ulAddr);
		#endif
			
		#ifdef RTC676x
			if(RELEASE_BUF_METHOD == RELEASE_BUF_QUE)
			{
				if(Don.tSTA == BB_GET_STA1)
					ubBUF_ReleaseAdoPacketize0Buf(Don.ulAddr);
				else if(Don.tSTA == BB_GET_STA2)
					ubBUF_ReleaseAdoPacketize1Buf(Don.ulAddr);
				else if(Don.tSTA == BB_GET_STA3)
					ubBUF_ReleaseAdoPacketize2Buf(Don.ulAddr);
				else if(Don.tSTA == BB_GET_STA4)
					ubBUF_ReleaseAdoPacketize3Buf(Don.ulAddr);
			}
		#endif
        }
		else 
#endif
	#if A7130
		if(Don.ubGetCrc != ubBB_GetCrcReport(Don.ulAddr,Don.ulCrcLen))
		{
			printd(DBG_ErrorLvl, " Ado Crc->Fail[%d][%d_%d]\r\n", ubKNL_SrcNumMap(ubKNL_GetPktSrcNum(Don.ulAddr,Don.ulSize)), Don.tSTA, Don.Type);
		#ifdef A7130
			BB_RxBufRelease(Don.Type,Don.tSTA);
		#endif
		}
	#else
		if(0)
		{
		}
	#endif
		else if( ADO_GetIpReadyStatus() == ADO_IP_READY )
        {
            ubSrcNum = ubKNL_GetPktSrcNum(Don.ulAddr,Don.ulSize);

#if (APP_REC_FUNC_ENABLE && OP_AP)
            if(ubKNL_SrcNumMap(ubSrcNum) != 0xFF)
            {
                // ado recording process
                ulRealSz = ulKNL_GetAdoPktSZ(Don.ulAddr,Don.ulSize); 

                if(Don.ulSize < ulRealSz)
                {
                    printf("Err BbAdoSz1:0x%x_%x_%x\r\n",ulRealSz,Don.ulAddr,Don.ulSize);  
                }
                if(ubKNL_AdoRemoteRecordingProcess(ubKNL_SrcNumMap(ubSrcNum), Don.ulAddr, ulRealSz)==0)
				{
				#ifdef A7130
					BB_RxBufRelease(Don.Type,Don.tSTA);
				#endif
				#ifdef S2019A
					ubKNL_ReleaseSPRFRxBufAddr(KNL_ADO_PKT, Don.tSTA, Don.ulAddr);
				#endif
					
				#ifdef RTC676x
					if(RELEASE_BUF_METHOD == RELEASE_BUF_QUE)
					{
						if(Don.tSTA == BB_GET_STA1)
							ubBUF_ReleaseAdoPacketize0Buf(Don.ulAddr);
						else if(Don.tSTA == BB_GET_STA2)
							ubBUF_ReleaseAdoPacketize1Buf(Don.ulAddr);
						else if(Don.tSTA == BB_GET_STA3)
							ubBUF_ReleaseAdoPacketize2Buf(Don.ulAddr);
						else if(Don.tSTA == BB_GET_STA4)
							ubBUF_ReleaseAdoPacketize3Buf(Don.ulAddr);
					}
				#endif
					continue;
				}
            }
#endif

            if((ubKNL_ChkAdoFlowAct(ubSrcNum)) || ((tUSBD_GetClassMode() == USBD_COMPOSITE_MODE) && (TRUE == ubUSBD_ChkCompMscClass())) || (tADO_GetMixMode() == ADO_ON))
            {
			#ifdef S2019A
				#if (defined(OP_AP) && defined(RVCS_APP))
				if(sPRF_BRIDGE_MODE == tKNL_sPRFDrvMd)
					ubKNL_ApBdgRxProc(sPRF_ADO_PKT, (KNL_SRC)ubSrcNum, Don.ulAddr, Don.ulSize);
				#endif
				ulRealSz = ulKNL_GetAdoPktSZ(Don.ulAddr, Don.ulSize);
				printd(DBG_Debug3Lvl, "Real-Sz:0x%x\r\n", ulRealSz);
				tKNLInfo.ubSrcNum    = ubSrcNum;
				tKNLInfo.ulDramAddr2 = Don.ulAddr;
				tKNLInfo.ulSize		 = Don.ulSize;
				tKNLInfo.ubCurNode   = KNL_NODE_COMM_RX_ADO;
				tKNLInfo.ubNextNode  = ubKNL_GetNextNode(ubSrcNum, KNL_NODE_COMM_RX_ADO);
				if(osMessagePut(KNL_AdoCodecProcQueue, &tKNLInfo, 0) == osErrorResource)
				{
					ubKNL_ReleaseSPRFRxBufAddr(KNL_ADO_PKT, Don.tSTA, Don.ulAddr);
					printd(DBG_ErrorLvl, "KNL_ADO Q->Full !!!\r\n");
				}
			#else
                //(2)Request Buffer to Temp
                if(ubKNL_SrcNumMap(ubSrcNum) == 0)
                {
                    ulTemp = ulBUF_GetDac0FreeBuf();
                }
                else if(ubKNL_SrcNumMap(ubSrcNum) == 1)
                {
                    ulTemp = ulBUF_GetDac1FreeBuf();
                }
                else if(ubKNL_SrcNumMap(ubSrcNum) == 2)
                {
                    ulTemp = ulBUF_GetDac2FreeBuf();
                }
                else if(ubKNL_SrcNumMap(ubSrcNum) == 3)
                {
                    ulTemp = ulBUF_GetDac3FreeBuf();
                }
				else
				{
					ulTemp = BUF_FAIL;
				}

                if(ulTemp == BUF_FAIL)
                {
                    printd(DBG_ErrorLvl, "[%d]BUF_ADO Err !!!\r\n", ubSrcNum);
				#ifdef A7130
					BB_RxBufRelease(Don.Type,Don.tSTA);
				#endif
				#ifdef RTC676x
					if(RELEASE_BUF_METHOD == RELEASE_BUF_QUE)
					{
						if(Don.tSTA == BB_GET_STA1)
							ubBUF_ReleaseAdoPacketize0Buf(Don.ulAddr);
						else if(Don.tSTA == BB_GET_STA2)
							ubBUF_ReleaseAdoPacketize1Buf(Don.ulAddr);
						else if(Don.tSTA == BB_GET_STA3)
							ubBUF_ReleaseAdoPacketize2Buf(Don.ulAddr);
						else if(Don.tSTA == BB_GET_STA4)
							ubBUF_ReleaseAdoPacketize3Buf(Don.ulAddr);
					}
				#endif
                }
                else
                {
					DMAC_RESULT tDmaResult = DMAC_OK;

                    tDmaResult = tDMAC_MemCopy((uint32_t)Don.ulAddr,(uint32_t)ulTemp,Don.ulSize,NULL);
					if(DMAC_OK == tDmaResult)
					{
						//(4-1)Check Real-Size Information
						ulRealSz = ulKNL_GetAdoPktSZ(ulTemp, Don.ulSize);
						printd(DBG_Debug3Lvl, "Real-Sz:0x%x\r\n", ulRealSz);

						//(5)Send Queue to Next Node
						tKNLInfo.ubSrcNum    = ubSrcNum;
						tKNLInfo.ulDramAddr2 = ulTemp;
						tKNLInfo.ulSize		 = Don.ulSize;
						tKNLInfo.ubCurNode   = KNL_NODE_COMM_RX_ADO;
						tKNLInfo.ubNextNode  = ubKNL_GetNextNode(ubSrcNum,KNL_NODE_COMM_RX_ADO);
//							KNL_DacBufProcess(tKNLInfo);
						if(osMessagePut(KNL_AdoCodecProcQueue, &tKNLInfo, 0) == osErrorResource)
						{
							ubBUF_ReleaseDac0Buf(tKNLInfo.ulDramAddr2);
							printd(DBG_ErrorLvl, "KNL_ADO Q->Full !!!\r\n");
						}
						#if (!defined(S2019A) && defined(OP_AP) && defined(sWIFIBDG))
						if(sPRF_BRIDGE_MODE == tKNL_sPRFDrvMd)
							ubKNL_ApBdgRxProc(sPRF_ADO_PKT, (KNL_SRC)ubSrcNum, Don.ulAddr, Don.ulSize);
						#endif
					}

					//(4-2)Release BB Buffer
				#ifdef A7130
					BB_RxBufRelease(Don.Type,Don.tSTA);
				#endif
					
				#ifdef RTC676x
					if(RELEASE_BUF_METHOD == RELEASE_BUF_QUE)
					{
						if(Don.tSTA == BB_GET_STA1)
							ubBUF_ReleaseAdoPacketize0Buf(Don.ulAddr);
						else if(Don.tSTA == BB_GET_STA2)
							ubBUF_ReleaseAdoPacketize1Buf(Don.ulAddr);
						else if(Don.tSTA == BB_GET_STA3)
							ubBUF_ReleaseAdoPacketize2Buf(Don.ulAddr);
						else if(Don.tSTA == BB_GET_STA4)
							ubBUF_ReleaseAdoPacketize3Buf(Don.ulAddr);
					}
				#endif

					if( DMAC_OK != tDmaResult )
					{
						if(ubKNL_SrcNumMap(ubSrcNum) == 0)
						{
							ubBUF_ReleaseDac0Buf(ulTemp);
						}
						else if(ubKNL_SrcNumMap(ubSrcNum) == 1)
						{
							ubBUF_ReleaseDac1Buf(ulTemp);
						}
						else if(ubKNL_SrcNumMap(ubSrcNum) == 2)
						{
							ubBUF_ReleaseDac2Buf(ulTemp);
						}
						else if(ubKNL_SrcNumMap(ubSrcNum) == 3)
						{
							ubBUF_ReleaseDac3Buf(ulTemp);
						}
						if(DMAC_OK != tDmaResult)
							printd(DBG_ErrorLvl, "DMA NRDY @%s\n", __func__);
					}
                }
			#endif
            }
            else
            {
			#ifdef A7130             
				BB_RxBufRelease(Don.Type,Don.tSTA);
			#endif
			#ifdef S2019A
				ubKNL_ReleaseSPRFRxBufAddr(KNL_ADO_PKT, Don.tSTA, Don.ulAddr);
			#endif
				
			#ifdef RTC676x
				if(RELEASE_BUF_METHOD == RELEASE_BUF_QUE)
				{
					if(Don.tSTA == BB_GET_STA1)
						ubBUF_ReleaseAdoPacketize0Buf(Don.ulAddr);
					else if(Don.tSTA == BB_GET_STA2)
						ubBUF_ReleaseAdoPacketize1Buf(Don.ulAddr);
					else if(Don.tSTA == BB_GET_STA3)
						ubBUF_ReleaseAdoPacketize2Buf(Don.ulAddr);
					else if(Don.tSTA == BB_GET_STA4)
						ubBUF_ReleaseAdoPacketize3Buf(Don.ulAddr);
				}
			#endif
            }
        }
        else
        {
		#ifdef A7130        
			BB_RxBufRelease(Don.Type,Don.tSTA);
		#endif
		#ifdef S2019A
			ubKNL_ReleaseSPRFRxBufAddr(KNL_ADO_PKT, Don.tSTA, Don.ulAddr);
		#endif
			
		#ifdef RTC676x
			if(RELEASE_BUF_METHOD == RELEASE_BUF_QUE)
			{
				if(Don.tSTA == BB_GET_STA1)
					ubBUF_ReleaseAdoPacketize0Buf(Don.ulAddr);
				else if(Don.tSTA == BB_GET_STA2)
					ubBUF_ReleaseAdoPacketize1Buf(Don.ulAddr);
				else if(Don.tSTA == BB_GET_STA3)
					ubBUF_ReleaseAdoPacketize2Buf(Don.ulAddr);
				else if(Don.tSTA == BB_GET_STA4)
					ubBUF_ReleaseAdoPacketize3Buf(Don.ulAddr);
			}
		#endif
        }
	}
}
//------------------------------------------------------------------------------
//void KNL_UpdateJpgHeader(void)
void KNL_UpdateJpgHeader(uint16_t uwH,uint16_t uwV)
{
#if (APP_PHOTOGRAPH_FUNC_ENABLE || (((USBD_UVC_MODE == USBD_DEFU_CLASS) || (USBD_COMPOSITE_MODE == USBD_DEFU_CLASS)) && (USBD_UVC_MJ_FMT == USBD_UVC_FMT) && USBD_ENABLE))
#if !((defined(BSP_DVR_SDK) && defined(OP_STA))||(defined(BSP_RVCS_SDK)&&defined(OP_STA)))
    uint8_t i;
#endif
	uint8_t *pJpgHeader;
	uint8_t ubJpgSoi[KNL_JPG_SOI_SIZE]={ 0xFF, 0xD8 };

	uint8_t ubJpgExif[4] = { 0xFF, 0xE1, 0xFB, 0xFC };
	ubJpgExif[2] = (KNL_JPG_EXIF_SIZE-2>>8)&0xFF;		//-2:exif header	
	ubJpgExif[3] = KNL_JPG_EXIF_SIZE-2&0xFF;
	
	uint8_t ubJpgFrameHeader[KNL_JPG_FRAMEHEADER_SIZE] = {
		0xFF, 0xC0, 0x00, 0x11, 0x08, 0x02, 0xd0, 0x05, 0x00, 0x03, 0x01, 0x22, 0x00, 0x02, 
		0x11, 0x01, 0x03, 0x11, 0x01};
	uint8_t ubJpgAPP1Header[4] = { 0xFF, 0xEF, 0x01, 0xB3 };
	uint8_t ubJpgDQTHeader[KNL_JPG_DQT_SIZE] = {
		0xFF, 0xDB, 0x00, 0x84, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,		
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xC4,
		0x01, 0xA2, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x01,
		0x00, 0x03, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x10, 0x00, 0x02, 0x01,
		0x03, 0x03, 0x02, 0x04, 0x03, 0x05, 0x05, 0x04, 0x04, 0x00, 0x00, 0x01, 0x7D, 0x01, 0x02, 0x03,
		0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14,
		0x32, 0x81, 0x91, 0xA1, 0x08, 0x23, 0x42, 0xB1, 0xC1, 0x15, 0x52, 0xD1, 0xF0, 0x24, 0x33, 0x62,
		0x72, 0x82, 0x09, 0x0A, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x34,
		0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x53, 0x54,
		0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x73, 0x74,
		0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x92, 0x93,
		0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA,
		0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8,
		0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5,
		0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0x11,
		0x00, 0x02, 0x01, 0x02, 0x04, 0x04, 0x03, 0x04, 0x07, 0x05, 0x04, 0x04, 0x00, 0x01, 0x02, 0x77,
		0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71,
		0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xA1, 0xB1, 0xC1, 0x09, 0x23, 0x33, 0x52, 0xF0,
		0x15, 0x62, 0x72, 0xD1, 0x0A, 0x16, 0x24, 0x34, 0xE1, 0x25, 0xF1, 0x17, 0x18, 0x19, 0x1A, 0x26,
		0x27, 0x28, 0x29, 0x2A, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
		0x49, 0x4A, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,
		0x69, 0x6A, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
		0x88, 0x89, 0x8A, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0xA2, 0xA3, 0xA4, 0xA5,
		0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xC2, 0xC3,
		0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA,
		0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8,
		0xF9, 0xFA, 0xFF, 0xDA, 0x00, 0x0C, 0x03, 0x01, 0x00, 0x02, 0x11, 0x03, 0x11, 0x00, 0x3F, 0x00
		};
#endif
#if APP_PHOTOGRAPH_FUNC_ENABLE
	ubJpgFrameHeader[KNL_JPEG_HEADER_H_OFFSET] 		= (uwH & 0xFF00L)>>8;
	ubJpgFrameHeader[KNL_JPEG_HEADER_H_OFFSET+1]	= uwH & 0x00FFL;	
	ubJpgFrameHeader[KNL_JPEG_HEADER_V_OFFSET] 		= (uwV & 0xFF00L)>>8;
	ubJpgFrameHeader[KNL_JPEG_HEADER_V_OFFSET+1]	= uwV & 0x00FFL;
#if (defined(BSP_DVR_SDK) || (defined(BSP_RVCS_SDK)&&defined(OP_STA)) )
	{
        pJpgHeader = (uint8_t *)ulKNL_JPGAddr;
		memset(pJpgHeader, 0, KNL_JPG_HEADER_SIZE);
		memcpy(pJpgHeader, ubJpgSoi, KNL_JPG_SOI_SIZE);
		memcpy(&pJpgHeader[KNL_JPG_EXIF_START], ubJpgExif, sizeof(ubJpgExif));
		memcpy(&pJpgHeader[KNL_JPG_FRAMEHEADER_START], ubJpgFrameHeader, KNL_JPG_FRAMEHEADER_SIZE);
		memcpy(&pJpgHeader[KNL_JPG_APP1_START], ubJpgAPP1Header, sizeof(ubJpgAPP1Header));
		memcpy(&pJpgHeader[KNL_JPG_DQT_START], ubJpgDQTHeader, KNL_JPG_DQT_SIZE);
	}
#else
	for(i = 0; i < ubKNL_GetMaxStaNum(); i++)
	{
        pJpgHeader = (uint8_t *)ulKNL_JPGAddr[i];
		memset(pJpgHeader, 0, KNL_JPG_HEADER_SIZE);
		memcpy(pJpgHeader, ubJpgSoi, KNL_JPG_SOI_SIZE);
		memcpy(&pJpgHeader[KNL_JPG_EXIF_START], ubJpgExif, sizeof(ubJpgExif));
		memcpy(&pJpgHeader[KNL_JPG_FRAMEHEADER_START], ubJpgFrameHeader, KNL_JPG_FRAMEHEADER_SIZE);
		memcpy(&pJpgHeader[KNL_JPG_APP1_START], ubJpgAPP1Header, sizeof(ubJpgAPP1Header));
		memcpy(&pJpgHeader[KNL_JPG_DQT_START], ubJpgDQTHeader, KNL_JPG_DQT_SIZE);
	}
#endif	
#endif
#if ((USBD_UVC_MJ_FMT == USBD_UVC_FMT) && USBD_ENABLE)
	#ifdef OP_AP
	if((DISPLAY_1T1R == DISPLAY_MODE) && ((USBD_UVC_MODE == tUSBD_GetClassMode()) || (TRUE == ubUSBD_ChkCompUvcClass())))
	{
		for(i = 0; i < KNL_UVC_MJBUF_NUM; i++)
	#else
	if((KNL_TUNINGMODE_OFF == KNL_GetTuningToolMode() && ((USBD_UVC_MODE == tUSBD_GetClassMode()) || (TRUE == ubUSBD_ChkCompUvcClass()))))
	{
		for(i = 0; i < ((TRUE == ubKNL_GetHQImgCapEn())?1:KNL_UVC_MJBUF_NUM); i++)
	#endif
		{
			pJpgHeader = (uint8_t *)ulBUF_GetVdoUsbdFreeBuf();
			memset(&pJpgHeader[KNL_MJ_BUF_ALIGN_1K], 0, KNL_JPG_HEADER_SIZE);
			memcpy(&pJpgHeader[KNL_MJ_BUF_ALIGN_1K], ubJpgSoi, KNL_JPG_SOI_SIZE);
			memcpy(&pJpgHeader[KNL_MJ_BUF_ALIGN_1K+KNL_JPG_EXIF_START], ubJpgExif, sizeof(ubJpgExif));
			memcpy(&pJpgHeader[KNL_MJ_BUF_ALIGN_1K+KNL_JPG_FRAMEHEADER_START], ubJpgFrameHeader, KNL_JPG_FRAMEHEADER_SIZE);
			memcpy(&pJpgHeader[KNL_MJ_BUF_ALIGN_1K+KNL_JPG_APP1_START], ubJpgAPP1Header, sizeof(ubJpgAPP1Header));
			memcpy(&pJpgHeader[KNL_MJ_BUF_ALIGN_1K+KNL_JPG_DQT_START], ubJpgDQTHeader, KNL_JPG_DQT_SIZE);
		}
		BUF_ResetUsbdBuf();
	}
#endif
}

#if ((defined(OP_AP) && defined(BSP_DVR_SDK)) || (!defined(BSP_DVR_SDK)))
//------------------------------------------------------------------------------
static void KNL_JpegMonitThread(void const *argument)
{		
	KNL_PROCESS tJpegMonitProc;		
	JPEG_CODEC_INFO_t tJpegInfo;
#if defined(BSP_DVR_SDK)
	uint8_t ubNextNode,ubNextNode2,ubNextNode3;	
#else
	uint8_t ubNextNode;	
#endif	
	uint8_t ubInfo_PreNode;
	uint8_t ubInfo_PreSrc;
	uint8_t ubInfo_Action;
	uint32_t ulInfo_YuvAddr;
	uint32_t ulInfo_BsAddr;
	uint32_t ulInfo_Size;	

	while(1)
	{
        osMessageGet(KNL_QueueJpegMonit, &tJpegInfo, osWaitForever);

		//(1)Update Information First
		ubInfo_PreNode 	= ubKNL_JpegPreNode;
		ubInfo_PreSrc	= ubKNL_JpegSrc;
		ubInfo_Action	= tJpegInfo.tJPEG_CodecMode;
		ulInfo_YuvAddr	= tJpegInfo.ulJPEG_YUVAddr;
		ulInfo_BsAddr	= tJpegInfo.ulJPEG_BsAddr;
		ulInfo_Size		= tJpegInfo.ulJPEG_BsSize;

		//(2)Release JPEG Codec
		osSemaphoreRelease(JPEG_CodecSem);

		//PhotoGraph
		#if APP_PHOTOGRAPH_FUNC_ENABLE
		switch(tKNL_GetRecordFunc())
		{
			case KNL_PHOTO_CAPTURE:
				KNL_PhotoCaptureFinFunc(ubInfo_PreNode, ubInfo_PreSrc, ulInfo_Size);
				ubInfo_PreNode = KNL_NODE_NONE;
				continue;
			case KNL_PHOTO_PLAY:
				KNL_PhotoPlayFinFunc();
				ubInfo_PreNode = KNL_NODE_NONE;
				break;
			default:
				break;
		}
		#endif

		/*
		printd(DBG_Debug3Lvl, "JPEG_Action:%d\r\n",ubInfo_Action);
		printd(DBG_Debug3Lvl, "JPEGc_YuvAddr:0x%x\r\n",ulInfo_YuvAddr);
		printd(DBG_Debug3Lvl, "JPEG_BsAddr:0x%x\r\n",ulInfo_BsAddr);
		printd(DBG_Debug3Lvl, "JPEG_Size:0x%x\r\n",ulInfo_Size);
		*/
		if((ubInfo_Action == 1) && (ubInfo_PreNode == KNL_NODE_JPG_DEC1))
		{
			KNL_SetNodeState(ubInfo_PreSrc,KNL_NODE_JPG_DEC1,KNL_NODE_STOP);			
			printd(DBG_Debug3Lvl, "J->D1[%d]:0x%x_0x%x_0x%x\r\n",ubInfo_PreSrc,ulInfo_YuvAddr,ulInfo_BsAddr,ulInfo_Size);
		}
		else if((ubInfo_Action == 1) && (ubInfo_PreNode == KNL_NODE_JPG_DEC2))
		{
			KNL_SetNodeState(ubInfo_PreSrc,KNL_NODE_JPG_DEC2,KNL_NODE_STOP);
			printd(DBG_Debug3Lvl, "J->D2[%d]:0x%x_0x%x_0x%x\r\n",ubInfo_PreSrc,ulInfo_YuvAddr,ulInfo_BsAddr,ulInfo_Size);
		}
		else if((ubInfo_Action == 0) && (ubInfo_PreNode == KNL_NODE_JPG_ENC))
		{
			KNL_SetNodeState(ubInfo_PreSrc,KNL_NODE_JPG_ENC,KNL_NODE_STOP);
			printd(DBG_Debug3Lvl, "J->E[%d]:0x%x_0x%x_0x%x\r\n",ubInfo_PreSrc,ulInfo_YuvAddr,ulInfo_BsAddr,ulInfo_Size);
		}

		//(3)Release BS Buffer
		if((ubInfo_PreNode == KNL_NODE_JPG_DEC1) || (ubInfo_PreNode == KNL_NODE_JPG_DEC2))
		{			
			ubKNL_ReleaseBsBufAddr(ubInfo_PreNode,ubInfo_PreSrc,ulInfo_BsAddr);
		}

		//(4)To Next Node
		if(ubKNL_ChkVdoFlowAct(ubInfo_PreSrc))
		{
			ubNextNode = ubKNL_GetNextNode(ubInfo_PreSrc,ubInfo_PreNode);
#if !defined(BSP_DVR_SDK)
			if(ubNextNode == KNL_NODE_LCD)
			{
				KNL_ActiveLcdDispBuf(ubInfo_PreSrc);
			}
#else
			ubNextNode2 = ubKNL_GetNextNode(ubInfo_PreSrc,KNL_NODE_JPG_BS);
			if(ubNextNode == KNL_NODE_LCD)
			{
				//KNL_ActiveLcdDispBuf(ubInfo_PreSrc);
				KNL_ActiveLcdDispBuf(KNL_SRC_2_MAIN);	//justin 2019.07.29
			}
			else if(ubNextNode2 == KNL_NODE_JPG_DEC1)
			{
				//Next Node
				tJpegMonitProc.ubSrcNum     = ubInfo_PreSrc;
				tJpegMonitProc.ubCurNode    = KNL_NODE_JPG_BS;			
				tJpegMonitProc.ubNextNode   = ubKNL_GetNextNode(ubInfo_PreSrc,KNL_NODE_JPG_BS);
				
				ubNextNode3 = ubKNL_GetNextNode(ubInfo_PreSrc,KNL_NODE_JPG_DEC1);
				if(ubNextNode3 == KNL_NODE_LCD)
				{					
					//tJpegMonitProc.ulDramAddr1  = ulKNL_GetLcdDispAddr(KNL_SRC_2_MAIN);					
					tJpegMonitProc.ulDramAddr2  = ulInfo_BsAddr;
				}
                if(osMessagePut(KNL_VdoCodecProcQueue, &tJpegMonitProc, 0) == osErrorResource)
				{		
					printd(DBG_ErrorLvl, "KNL_Q->Full !!!!\r\n");
				}
			}
#endif			
			else
			{
				//Next Node
				tJpegMonitProc.ubSrcNum     = ubInfo_PreSrc;
				tJpegMonitProc.ubCurNode    = ubInfo_PreNode;			
				tJpegMonitProc.ubNextNode   = ubKNL_GetNextNode(ubInfo_PreSrc,ubInfo_PreNode);	
				tJpegMonitProc.ulDramAddr1  = ulInfo_YuvAddr;			
				tJpegMonitProc.ulDramAddr2  = ulInfo_BsAddr;
                if(osMessagePut(KNL_VdoCodecProcQueue, &tJpegMonitProc, 0) == osErrorResource)
				{		
					printd(DBG_ErrorLvl, "KNL_Q->Full !!!!\r\n");
				}
			}
		}
	}
}
#endif

//------------------------------------------------------------------------------
void KNL_ResetDecoder(uint8_t ubSrcNum)
{
	KNL_NODE_INFO tNodeInfo;

	osMessageReset(KNL_VdoCodecProcQueue);
	IMG_ClearImgMsgQueue();
	if(ubKNL_ExistNode(ubSrcNum, KNL_NODE_H264_DEC))
	{
		tNodeInfo = tKNL_GetNodeInfo(ubSrcNum, KNL_NODE_H264_DEC);
		if(tNodeInfo.ubCodecIdx == DECODE_0)
		{
			KNL_ImgDecInit(DECODE_0,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
		}
		else if(tNodeInfo.ubCodecIdx == DECODE_1)
		{
			KNL_ImgDecInit(DECODE_1,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
		}
		else if(tNodeInfo.ubCodecIdx == DECODE_2)
		{
			KNL_ImgDecInit(DECODE_2,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
		}
		else if(tNodeInfo.ubCodecIdx == DECODE_3)
		{
			KNL_ImgDecInit(DECODE_3,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
		}
	}
}

//------------------------------------------------------------------------------
void KNL_ResetEncoder(uint8_t ubSrcNum)
{
#if (defined(OP_STA) || defined(OP_AP) && (defined(BSP_DVR_SDK)))
	KNL_NODE_INFO tNodeInfo;

	SEN_SetIspOutEn(FALSE);
	SEN_SetDetectVideoState(0);
	osMessageReset(KNL_VdoInProcQueue);
	osMessageReset(KNL_VdoCodecProcQueue);
	IMG_ClearImgMsgQueue();
	if(ubSEN_GetActiveFlg(SENSOR_PATH1))
		BUF_Reset(BUF_SEN_1_YUV);
#if !(defined(OP_AP) && defined(BSP_DVR_SDK))
	if(ubSEN_GetActiveFlg(SENSOR_PATH2))
		BUF_Reset(BUF_SEN_2_YUV);
#endif
	if(ubSEN_GetActiveFlg(SENSOR_PATH3))
		BUF_Reset(BUF_SEN_3_YUV);
	if(ubKNL_ExistNode(ubSrcNum, KNL_NODE_H264_ENC))
	{
		tNodeInfo = tKNL_GetNodeInfo(ubSrcNum, KNL_NODE_H264_ENC);
		if(tNodeInfo.ubCodecIdx == ENCODE_0)
		{
			KNL_ImgEncInit(ENCODE_0,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
		}
		else if(tNodeInfo.ubCodecIdx == ENCODE_1)
		{
			KNL_ImgEncInit(ENCODE_1,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
		}
		else if(tNodeInfo.ubCodecIdx == ENCODE_2)
		{
			KNL_ImgEncInit(ENCODE_2,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
		}
		else if(tNodeInfo.ubCodecIdx == ENCODE_3)
		{
			KNL_ImgEncInit(ENCODE_3,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV);
		}
	}
	SEN_SetIspOutEn(TRUE);
    SEN_SetDetectVideoState(1);
#endif
}

//------------------------------------------------------------------------------
void KNL_RecoveryImgCodec(void)
{
	KNL_ROLE tKNL_Role;
	KNL_SRC tSrcNum = KNL_SRC_NONE;

	for(tKNL_Role = KNL_STA1; tKNL_Role <= KNL_STA4; tKNL_Role++)
	{
		tSrcNum = (KNL_SRC)(KNL_SRC_1_MAIN + tKNL_Role);
		ubKNL_VdoFlowActiveFlg[tSrcNum] = 0;
		KNL_VdoSuspend(tSrcNum);
		BUF_Reset((BUF_VDO_MAIN_BS0 + tKNL_Role));
	}
#if (defined(OP_AP) && defined(BSP_DVR_SDK))
	ubKNL_VdoFlowActiveFlg[KNL_SRC_STORAGE_LOCAL] = 0;
	KNL_VdoSuspend(KNL_SRC_STORAGE_LOCAL);
	BUF_Reset(BUF_VDO_MAIN_BS2);
#endif
	H264_Reset();
	for(tKNL_Role = KNL_STA1; tKNL_Role <= KNL_STA4; tKNL_Role++)
	{
		tSrcNum = (KNL_SRC)(KNL_SRC_1_MAIN + tKNL_Role);
		KNL_ResetDecoder(tSrcNum);
	}
#if (defined(OP_AP) && defined(BSP_DVR_SDK))
	KNL_ResetEncoder(KNL_SRC_STORAGE_LOCAL);
#endif
	osSemaphoreRelease(tKNL_ImgSem);
	ubKNL_ImgRdy = 1;
	osSemaphoreRelease(osKNL_H264CdcWaitSem);
}

//------------------------------------------------------------------------------
void KNL_RestartImgCodec(void)
{
	KNL_ROLE tKNL_Role;
	KNL_SRC tSrcNum = KNL_SRC_NONE;	

	H264_Reset();
	for(tKNL_Role = KNL_STA1; tKNL_Role <= KNL_STA4; tKNL_Role++)
	{
		tSrcNum = (KNL_SRC)(KNL_SRC_1_MAIN + tKNL_Role);
		KNL_VdoStop(tSrcNum);
		KNL_ResetDecoder(tSrcNum);
		BUF_Reset((BUF_VDO_MAIN_BS0 + tKNL_Role));
	}
#if (defined(OP_AP) && defined(BSP_DVR_SDK))
	KNL_VdoStop(KNL_SRC_STORAGE_LOCAL);
	KNL_ResetEncoder(KNL_SRC_STORAGE_LOCAL);
	BUF_Reset(BUF_VDO_MAIN_BS2);
#endif
	if(TRUE == KNL_SwDispInfo.ubSetupFlag)
	{
		KNL_DISP_TYPE tDispType;
		uint8_t ubVdoNum = 2, ubIdx;

		tDispType = tKNL_GetDispType();
		ubVdoNum = (KNL_DISP_SINGLE == tDispType)?1:
		           ((KNL_DISP_3T_2L1R == tDispType) || (KNL_DISP_3T_1L2R == tDispType) ||
		            (KNL_DISP_3T_2T1B == tDispType) || (KNL_DISP_3T_1T2B == tDispType) ||
		            (KNL_DISP_3T_3COL == tDispType))?3:2;
		for(ubIdx = 0; ubIdx < ubVdoNum; ubIdx++)
			KNL_VdoStart(KNL_SwDispInfo.tSrcNum[ubIdx]);
	}
	else
	{
		for(tKNL_Role = KNL_STA1; tKNL_Role <= KNL_STA4; tKNL_Role++)
			KNL_VdoStart((KNL_SRC_1_MAIN + tKNL_Role));
	}
#if (defined(OP_AP) && defined(BSP_DVR_SDK))
	KNL_VdoStart(KNL_SRC_STORAGE_LOCAL);
#endif
}

//------------------------------------------------------------------------------
void KNL_RestartDataPath(uint8_t ubRole)
{
	KNL_SRC tSrcNum = KNL_SRC_NONE;

	if(ptKNL_VdoRoleMap2SrcNum)
		tSrcNum = ptKNL_VdoRoleMap2SrcNum(KNL_MAIN_PATH, (KNL_ROLE)ubRole);
	if(KNL_SRC_NONE != tSrcNum)
	{
		KNL_VdoStop(tSrcNum);
		ubKNL_WaitNodeFinish(tSrcNum);
		if(TRUE == ubKNL_WakeUpFlag[ubRole])
			KNL_WakeupDevice((KNL_ROLE)ubRole, FALSE);
		osDelay(200);
		KNL_VdoStart(tSrcNum);
	}
}

//------------------------------------------------------------------------------
static void KNL_SysMonitThread(void const *argument)
{
#if OP_AP
	KNL_ROLE tKNL_Role;
	uint8_t ubSysErrFlg1 	   = FALSE;
	uint8_t ubSysIChkCnt[4]    = {0, 0, 0, 0};
	uint8_t ubSysVResChkCnt[4] = {0, 0, 0, 0};
	uint8_t ubSysIfChkCnt[4]   = {0, 0, 0, 0};
#endif

#ifdef RTC676x	
#if APP_RTC676X_BRIDGE_COEXISTENCE_ENABLE	
	uint32_t ulSysCnt = 0;
#endif
#endif

#if OP_AP
#ifdef RTC676x
#if APP_RTC676X_BRIDGE_COEXISTENCE_ENABLE	
	uint8_t ubExpCh;
#endif
#endif
#endif
	
	while(1)
	{
#if OP_AP
		ubSysErrFlg1 = FALSE;
		for(tKNL_Role = KNL_STA1; tKNL_Role <= KNL_STA4; tKNL_Role++)
		{
			if(TRUE == ubKNL_VdoChkSrcNumFlg[tKNL_Role])
				ubSysErrFlg1 = TRUE;
			if(ubKNL_VdoBsBusyCnt[tKNL_Role] >= 2)
			{
				printd(DBG_Debug1Lvl, "BS Busy[%d]", tKNL_Role);
				KNL_RestartDataPath(tKNL_Role);
				ubKNL_VdoBsBusyCnt[tKNL_Role] = 0;
			}
			if(TRUE == ubKNL_VdoResendITwcFlg[tKNL_Role])
			{
				if(++ubSysIChkCnt[tKNL_Role] >= 2)
				{
					ubKNL_VdoResendITwcFlg[tKNL_Role] = FALSE;
					ubSysIChkCnt[tKNL_Role] = 0;
				}
			}
			else
				ubSysIChkCnt[tKNL_Role] = 0;
			if(TRUE == ubKNL_VdoResChgTwcFlg[tKNL_Role])
			{
				if(++ubSysVResChkCnt[tKNL_Role] >= 2)
				{
					ubKNL_VdoResChgTwcFlg[tKNL_Role] = FALSE;
					ubSysVResChkCnt[tKNL_Role] = 0;
				}
			} 
			else
				ubSysVResChkCnt[tKNL_Role] = 0;
			if(TRUE == ubKNL_AppResendIFrmFlg[tKNL_Role])
			{
				if(++ubSysIfChkCnt[tKNL_Role] >= 2)
				{
					ubKNL_AppResendIFrmFlg[tKNL_Role] = FALSE;
					ubSysIfChkCnt[tKNL_Role] = 0;
				}
			}
			else
				ubSysIfChkCnt[tKNL_Role] = 0;
		}
		if(TRUE == ubKNL_ImgBusyFlg)
		{
			KNL_SRC tSrcNum;
			printd(DBG_Debug1Lvl, "Decode/Encode Busy !\n");
			KNL_RecoveryImgCodec();
			if(TRUE == KNL_SwDispInfo.ubSetupFlag)
			{
				KNL_DISP_TYPE tDispType;
				uint8_t ubVdoNum = 2, ubIdx;
				tDispType = tKNL_GetDispType();
				ubVdoNum = (KNL_DISP_SINGLE == tDispType)?1:
						   ((KNL_DISP_3T_2L1R == tDispType) || (KNL_DISP_3T_1L2R == tDispType) ||
							(KNL_DISP_3T_2T1B == tDispType) || (KNL_DISP_3T_1T2B == tDispType) ||
						    (KNL_DISP_3T_3COL == tDispType))?3:
				            (KNL_DISP_QUAD == tDispType)?4:2;
				for(ubIdx = 0; ubIdx < ubVdoNum; ubIdx++)
				{
					tSrcNum = KNL_SwDispInfo.tSrcNum[ubIdx];
					KNL_VdoResume(tSrcNum);
					ubKNL_VdoFlowActiveFlg[tSrcNum] = 1;
				}
			}
			else
			{
				for(tKNL_Role = KNL_STA1; tKNL_Role <= KNL_STA4; tKNL_Role++)
				{
					tSrcNum = (KNL_SRC)(KNL_SRC_1_MAIN + tKNL_Role);
					KNL_VdoResume(tSrcNum);
					ubKNL_VdoFlowActiveFlg[tSrcNum] = 1;
				}
			}
		#if (defined(OP_AP) && defined(BSP_DVR_SDK))
			KNL_VdoResume(KNL_SRC_STORAGE_LOCAL);
			ubKNL_VdoFlowActiveFlg[KNL_SRC_STORAGE_LOCAL] = 1;
		#endif
			ubKNL_ImgBusyFlg = FALSE;
		}
		if(TRUE == ubSysErrFlg1)
		{
			for(tKNL_Role = KNL_STA1; tKNL_Role <= KNL_STA4; tKNL_Role++)
			{
				if(TRUE == ubKNL_VdoChkSrcNumFlg[tKNL_Role])
				{
					KNL_RestartDataPath(tKNL_Role);
					ubKNL_VdoChkSrcNumFlg[tKNL_Role] = FALSE;
				}
			}
		}
	#ifdef RTC676x	
	#if APP_RTC676X_BRIDGE_COEXISTENCE_ENABLE
		ulSysCnt++;		
		if((ulSysCnt > 25) && ((ulSysCnt % 5) == 0))	//Over 5 Sec & Per Sec
		{			
		#if (FREQ_TABLE_NUM == 2)
			if(uwsPRF_GetWorkChFreq() >= FREQ_MID_FOR_NUM2)			
			{
				ubExpCh = 0xF0;//Using Table[0]	
			#if FREQ_SEL_DBG_EN		
				printf("[P3]CurWiFiCh:%d -> Select Table[0]\r\n",uwsPRF_GetWorkChFreq());				
			#endif
			}	
			else
			{
				ubExpCh = 0xF2;//Using Table[2]				
			#if FREQ_SEL_DBG_EN	
				printf("[P3]CurWiFiCh:%d -> Select Table[2]\r\n",uwsPRF_GetWorkChFreq());				
			#endif
			}			
			
			if(ubExpCh != ubKNL_GetFreqTableInSf())
			{
				printf("Change CH !!!\r\n");
				KNL_ModifyFreqTableProcess(ubExpCh);
				if(ubExpCh == 0xF0)
				{					
					KNL_SetFreqTableInSf(0xF0);
					KNL_SetFreqTable(0xF0);
					PAIR_IdTable.ubSelectCh = 0xF0;
					PAIR_SaveId();					
				}
				else if(ubExpCh == 0xF2)
				{					
					KNL_SetFreqTableInSf(0xF2);
					KNL_SetFreqTable(0xF2);
					PAIR_IdTable.ubSelectCh = 0xF2;
					PAIR_SaveId();					
				}				
			}	
		#endif		
		#if (FREQ_TABLE_NUM == 3)
			if(uwsPRF_GetWorkChFreq() <= FREQ_P1_FOR_NUM3)
			{
				ubExpCh = 0xF0;//Using Table[0]	
			#if FREQ_SEL_DBG_EN		
				printf("[P3]CurWiFiCh:%d -> Select Table[0]\r\n",uwsPRF_GetWorkChFreq());
			#endif
			}	
			else if(uwsPRF_GetWorkChFreq() <= FREQ_P2_FOR_NUM3)
			{
				ubExpCh = 0xF1;//Using Table[1]				
			#if FREQ_SEL_DBG_EN
				printf("[P3]CurWiFiCh:%d -> Select Table[1]\r\n",uwsPRF_GetWorkChFreq());
			#endif
			}	
			else
			{
				ubExpCh = 0xF2;//Using Table[2]			
			#if FREQ_SEL_DBG_EN	
				printf("[P3]CurWiFiCh:%d -> Select Table[2]\r\n",uwsPRF_GetWorkChFreq());
			#endif
			}			
			
			if(ubExpCh != ubKNL_GetFreqTableInSf())
			{
				printf("Change CH !!!\r\n");
				KNL_ModifyFreqTableProcess(ubExpCh);
				if(ubExpCh == 0xF0)
				{					
					KNL_SetFreqTableInSf(0xF0);
					KNL_SetFreqTable(0xF0);
					PAIR_IdTable.ubSelectCh = 0xF0;
					PAIR_SaveId();					
				}
				else if(ubExpCh == 0xF1)
				{					
					KNL_SetFreqTableInSf(0xF1);
					KNL_SetFreqTable(0xF1);
					PAIR_IdTable.ubSelectCh = 0xF1;
					PAIR_SaveId();					
				}
				else if(ubExpCh == 0xF2)
				{					
					KNL_SetFreqTableInSf(0xF2);
					KNL_SetFreqTable(0xF2);
					PAIR_IdTable.ubSelectCh = 0xF2;
					PAIR_SaveId();					
				}				
			}	
		#endif		
		}
	#endif	
	#endif	
		osDelay(200);
#else			
		
	#if APP_RTC676X_BRIDGE_COEXISTENCE_ENABLE
		ulSysCnt++;		
		
		if((!ubPAIR_GetInPairIngFlg()) && (ulSysCnt > TRY_FT_AFTER_POWER_ON))
		{			
			if(ubKNL_FreqKeepCnt == 0)
			{
				if(!rf_get_link_status(rf_get_remote_id(0)))
				{
				#if (FREQ_TABLE_NUM == 2)
					if(ubKNL_FreqTableSel == 0xF0)
					{				
						ubKNL_FreqTableSel = 0xF2;
						printf("Try FT[2]\r\n");				
						rf_setopt(RF_OPT_FREQTABLE, frequency_table_Ch2,80);			
					}					
					else if(ubKNL_FreqTableSel == 0xF2)
					{				
						ubKNL_FreqTableSel = 0xF0;
						printf("Try FT[0]\r\n");					
						rf_setopt(RF_OPT_FREQTABLE, frequency_table_Ch0,80);				
					}
				#endif
				#if (FREQ_TABLE_NUM == 3)	
					if(ubKNL_FreqTableSel == 0xF0)
					{				
						ubKNL_FreqTableSel = 0xF1;
						printf("Try FT[1]\r\n");				
						rf_setopt(RF_OPT_FREQTABLE, frequency_table_Ch1,80);			
					}
					else if(ubKNL_FreqTableSel == 0xF1)
					{				
						ubKNL_FreqTableSel = 0xF2;
						printf("Try FT[2]\r\n");					
						rf_setopt(RF_OPT_FREQTABLE, frequency_table_Ch2,80);				
					}	
					else if(ubKNL_FreqTableSel == 0xF2)
					{				
						ubKNL_FreqTableSel = 0xF0;
						printf("Try FT[0]\r\n");					
						rf_setopt(RF_OPT_FREQTABLE, frequency_table_Ch0,80);				
					}
				#endif
				}
				else
				{
					if((ubKNL_FreqTableSel == 0xF0) && (ubKNL_GetFreqTableInSf() != 0xF0))
					{							
						printf("[P1]Update Id Information @SysMonit\r\n");
						printf("Ori-FreqTableInSf:0x%x\r\n",ubKNL_GetFreqTableInSf());						
						
						KNL_SetFreqTableInSf(0xF0);
						KNL_SetFreqTable(0xF0);
						PAIR_IdTable.ubSelectCh = 0xF0;
						PAIR_SaveId();
						
						printf("New-FreqTableInSf:0x%x\r\n",ubKNL_GetFreqTableInSf());
					}
					else if((ubKNL_FreqTableSel == 0xF1) && (ubKNL_GetFreqTableInSf() != 0xF1))
					{						
						printf("[P2]Update Id Information @SysMonit\r\n");
						printf("Ori-FreqTableInSf:0x%x\r\n",ubKNL_GetFreqTableInSf());
						
						KNL_SetFreqTableInSf(0xF1);
						KNL_SetFreqTable(0xF1);
						PAIR_IdTable.ubSelectCh = 0xF1;
						PAIR_SaveId();
						
						printf("New-FreqTableInSf:0x%x\r\n",ubKNL_GetFreqTableInSf());
					}
					else if((ubKNL_FreqTableSel == 0xF2) && (ubKNL_GetFreqTableInSf() != 0xF2))
					{						
						printf("[P3]Update Id Information @SysMonit\r\n");
						printf("Ori-FreqTableInSf:0x%x\r\n",ubKNL_GetFreqTableInSf());
						
						KNL_SetFreqTableInSf(0xF2);
						KNL_SetFreqTable(0xF2);
						PAIR_IdTable.ubSelectCh = 0xF2;
						PAIR_SaveId();
						
						printf("New-FreqTableInSf:0x%x\r\n",ubKNL_GetFreqTableInSf());
					}
				}
			}
			else
			{			
				ubKNL_FreqKeepCnt--;
				printf("KC:%d\r\n",ubKNL_FreqKeepCnt);
			}
		}
		else
		{
			ubKNL_FreqKeepCnt = KEEP_CNT_AFTER_PAIR;	//Keep Counter for "Ater Pairing"
		}
			
		osDelay(1000);
	#else
		osDelay(5000);
	#endif
#endif
	}
}

#ifdef A7130
//------------------------------------------------------------------------------
static void KNL_BbFrmMonitThread(void const *argument)
{
	uint8_t ubBbFrmStatus;
	KNL_ROLE tKNL_LinkRole[(BB_MASTER_AP+1)] = {[BB_STA1] 	   = KNL_STA1,
												[BB_STA2] 	   = KNL_STA2,
												[BB_STA3] 	   = KNL_STA3,
												[BB_STA4] 	   = KNL_STA4,
												[BB_SLAVE_AP]  = KNL_SLAVE_AP,
												[BB_MASTER_AP] = KNL_MASTER_AP};
	while(1)
	{
		osMessageGet(KNL_QueBbFrmOk, &ubBbFrmStatus, osWaitForever);
		if((KNL_CAPHQ_TXRDY == tKNL_CapHQImgSte) &&
		   (KNL_MASTER_AP == tKNL_LinkRole[ubBbFrmStatus]))
			tKNL_CapHQImgSte = KNL_CAPHQ_DIS;
		ulKNL_FrmTRxNumTemp[tKNL_LinkRole[ubBbFrmStatus]]++;
		if(ptKNL_BbFrmMonitCbFunc)
			ptKNL_BbFrmMonitCbFunc(ubBbFrmStatus);
    }
}
#endif

//------------------------------------------------------------------------------
void KNL_SetBbFrmMonitCbFunc(pvKNL_BbFrmOkCbFunc BbFrmOkCbFunc)
{
	ptKNL_BbFrmMonitCbFunc = BbFrmOkCbFunc;
}

#if 1
//justin 2019.08.01
//======================================================================================
#if 0   // Test FS Write Speed
uint32_t ulTestWRIdx=0;
#endif

//------------------------------------------------------------------------------
void KNL_ImgMonitorFunc(struct IMG_RESULT ReceiveResult)
{	
	uint8_t ubBsSzValidFlg = 1;
	KNL_PROCESS tImgProc;
	KNL_NODE_INFO tNodeInfo;
	static uint32_t ulSubDr[60];
	static uint32_t ulRefreshCnt = 0;
	static uint32_t ulFrmIdx[4] = {0, 0, 0 , 0};
	static uint8_t ubKNL_ImgStsFlg = FALSE;
	static uint8_t ubPreFps = 0;
	uint32_t ulBsSz;
	uint32_t ulGop;
	uint32_t ulRtDr = 0;//Bit-Rate
	uint8_t ubNextNode;
	uint8_t ubPreNode;
	uint8_t ubTemp;
	uint8_t ubSrcNum;
	uint8_t ubTrigType;
	uint8_t ubIdxMap;
	uint8_t i;
	ubPreFps = ubPreFps;	//Avoid Warning
    
//#if (APP_REC_FUNC_ENABLE && OP_AP)
//    REC_INFO RecInfo;
//#endif
    
	if(FALSE == ubKNL_ImgStsFlg)
	{
		ubPreFps = ubKNL_GetVdoFps();
		for(i=0;i<30;i++)
			ulSubDr[i] = 0;
		ubKNL_ImgStsFlg = TRUE;
	}
	//Encode Process
	//========================================================================
	if(ReceiveResult.H264Result->Type == H264_ENCODE)
	{		
		
		//(1)Update Information First (SrcNum/BS Size)
#if defined(BSP_DVR_SDK)
		ulKNL_H264EncCntTemp[ubKNL_ImgSrc]++;
#endif		
		ubSrcNum = ubKNL_ImgSrc;		
		
		KNL_SetNodeState(ubSrcNum,KNL_NODE_H264_ENC,KNL_NODE_STOP);
		ulBsSz = ReceiveResult.H264Result->Size;//ulH264_GetStreamSize();
	
		//==============================================================		
		if(ReceiveResult.H264Result->EncodeStream == ENCODE_0)
		{
			ubIdxMap = 0;
		}
		else if(ReceiveResult.H264Result->EncodeStream == ENCODE_1)
		{
			ubIdxMap = 1;
		}
		else if(ReceiveResult.H264Result->EncodeStream == ENCODE_2)
		{
			ubIdxMap = 2;
		}
		else if(ReceiveResult.H264Result->EncodeStream == ENCODE_3)
		{
			ubIdxMap = 3;
		}
		ulFrmIdx[ubIdxMap] = ReceiveResult.H264Result->ulFrmIdx;
		if(ulFrmIdx[ubIdxMap] == 0)
		{
			ubKNL_VdoGroupIdx[ubIdxMap]++;
		}
		ulGop = ReceiveResult.H264Result->ulGop;

		ubKNL_Qp[ubIdxMap] = H264_GetCurrentQP();

#ifndef S2019A
		if(ubKNL_ResetIFlg[ubSrcNum])
        {
//            printf("ResetIFlg %d\r\n",ulGop);
            ubKNL_ResetIFlg[ubSrcNum] = 0;           
			if(ReceiveResult.H264Result->ulFrmIdx != 0)
            {
                tNodeInfo = tKNL_GetNodeInfo(ubSrcNum,KNL_NODE_H264_ENC);
                H264_ResetIPCnt((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx);
            }
        }
		ulKNL_CurFrmIdx[ubIdxMap] = ulFrmIdx[ubIdxMap];
#endif

		if((ulFrmIdx[ubIdxMap]%ubKNL_GetVdoFps()) == (ubKNL_GetVdoFps()-1))
		{
			ulRefreshCnt++;
		}

#ifndef S2019A
		//Work-Around for QP = 0
		//====================================
		if(H264_GetCurrentQP() == 0)
		{
			printf("Case2\r\n");
			printf("QP Err1\r\n");
			printf("QP Err2\r\n");
			printf("QP Err3\r\n");
			printf("Restart System !!!\r\n");
			SYS_Reboot();		
		}
#endif
		//printd(DBG_Debug3Lvl, "BS[%d]_Q:%d_S:%d\r\n",ulFrmIdx[ubIdxMap],H264_GetCurrentQP(),ulBsSz/1024);		
		
#if defined(OP_STA)
#if defined(BSP_DVR_SDK)
//		if(ulFrmIdx[ubIdxMap] == 0)
//			printf("BS[%d]_Q:%d_S:%d\r\n",ulFrmIdx[ubIdxMap],H264_GetCurrentQP(),ulBsSz/1024);
#endif
#endif

#ifndef S2019A
		//For Report
		if((ulFrmIdx[ubIdxMap] % ubKNL_GetVdoFps()) == 0)
		{
			ulKNL_VdoOutAccCntTemp[ubIdxMap] = 0;
		}
#endif

		if(ReceiveResult.H264Result->EncodeStream == ENCODE_0)
		{
			ulKNL_VdoOutAccCntTemp[0] += (ulBsSz*8);
		}
		else if(ReceiveResult.H264Result->EncodeStream == ENCODE_1)
		{
			ulKNL_VdoOutAccCntTemp[1] += (ulBsSz*8);
		}
		else if(ReceiveResult.H264Result->EncodeStream == ENCODE_2)
		{
			ulKNL_VdoOutAccCntTemp[2] += (ulBsSz*8);
		}
		else if(ReceiveResult.H264Result->EncodeStream == ENCODE_3)
		{
			ulKNL_VdoOutAccCntTemp[3] += (ulBsSz*8);
		}

		ulSubDr[ulFrmIdx[ubIdxMap] % ubKNL_GetVdoFps()] = (ulBsSz*8);
		if((ulFrmIdx[ubIdxMap] % ubKNL_GetVdoFps()) == (ubKNL_GetVdoFps()-1))
		{
			ulRtDr = 0;
			for(i=0;i<ubKNL_GetVdoFps();i++)
			{
				ulRtDr = ulRtDr + ulSubDr[i];
			}
//			printd(DBG_CriticalLvl, "== RtDr:%d KB ==\r\n",ulRtDr/8192);
#ifndef S2019A
			ulKNL_VdoOutAccCnt[ubIdxMap] = ulKNL_VdoOutAccCntTemp[ubIdxMap];
			ulKNL_VdoOutAccCntTemp[ubIdxMap] = 0;
#endif
		}

		//(2)Release Buffer
		ubPreNode = ubKNL_GetPreNode(ubSrcNum,KNL_NODE_H264_ENC);
		if(ubPreNode == KNL_NODE_SEN_YUV_BUF)
		{
#if OP_STA				
			if(SEN_Get16MCvbsAddress() == ReceiveResult.H264Result->YuvAddr)
			{
				ubTemp = ubBUF_ReleaseSenYuvBuf((SEN->STR1_STA << 8)/*ReceiveResult.YuvAddr*/);
			}
			else
			{			
				ubTemp = ubBUF_ReleaseSenYuvBuf(ReceiveResult.H264Result->YuvAddr/*ReceiveResult.YuvAddr*/);
			}
#else
			ubTemp = ubBUF_ReleaseSenYuvBuf(ReceiveResult.H264Result->YuvAddr/*ReceiveResult.YuvAddr*/);
#endif			
			if(ubTemp != BUF_OK)
			{
				printd(DBG_ErrorLvl, "Err2 @%s[0x%X]\n", __func__, ReceiveResult.H264Result->YuvAddr);
			}
		}
#ifdef S2019A
		tImgProc.ulsFrmTm = ulKNL_H264EncReport(ubSrcNum, ulBsSz, ulFrmIdx[ubIdxMap]);
#endif
		//(3)Post-Process
	#if (defined(RTC676x) || defined(A7130))
		ubNextNode = ubKNL_GetNextNode(ubSrcNum,KNL_NODE_H264_ENC);
		if(ubNextNode == KNL_NODE_VDO_BS_BUF1)
		{			
			if(ulKNL_GetBsBufSz(ubSrcNum) < (ulBsSz+MAX_AUX_SZ))
			{				
				ubBsSzValidFlg = 0;
				printf("Over Allocate Size !!!!:%d,%d KB\r\n",ulFrmIdx[ubIdxMap],ulBsSz/1024);
			}		
		}
	#endif	
		if(((ubKNL_ChkVdoFlowAct(ubSrcNum)) && (!ubKNL_ResetIFlg[ubSrcNum]) && ubBsSzValidFlg) ||	//! if(ubKNL_ChkVdoFlowAct(ubSrcNum))
			(KNL_GetTuningToolMode() == KNL_TUNINGMODE_ON))
		{
			tImgProc.ulDramAddr1	= ReceiveResult.H264Result->YuvAddr;//ReceiveResult.YuvAddr;
			tImgProc.ulDramAddr2	= ReceiveResult.H264Result->BSAddr;	//BS Buffer Address
			tImgProc.ubSrcNum		= ubSrcNum;
			tImgProc.ubCurNode		= KNL_NODE_H264_ENC;
			tImgProc.ubNextNode 	= ubKNL_GetNextNode(ubSrcNum,KNL_NODE_H264_ENC);
			tImgProc.ulSize 		= ulBsSz;
			tImgProc.ubCodecIdx		= ubIdxMap;
			tImgProc.ulIdx			= ulFrmIdx[ubIdxMap];
			tImgProc.ubVdoGop		= ubKNL_VdoGroupIdx[ubIdxMap];
			tImgProc.ulGop			= ulGop;
#ifdef S2019A
			tImgProc.ulSize 		= ulKNL_AddEncImgInfo(tImgProc);
#endif
#if (OP_STA && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
            tImgProc.ubEvent        = 0;
#endif
#if ( defined(BSP_DVR_SDK) && USBD_ENABLE)
		if(APP_TUNINGMODE_ON == APP_GetTuningToolMode())
		{
			ubKNL_UpdateUvcImage(tImgProc, KNL_NODE_H264_ENC);
		}
#endif	
#if (APP_REC_FUNC_ENABLE && OP_STA)     //by configure source
            #if defined(BSP_DVR_SDK)
			if(ubSrcNum != KNL_SRC_STORAGE_LOCAL)
            #endif
			{
				uint8_t ubNextNode, ubRelRdyFlg = FALSE;
				ubNextNode = ubKNL_GetNextNode(ubSrcNum, KNL_NODE_VDO_BS_BUF1);
				if((ubREC_GetRecordMode() != REC_MODE_TIMELAPSE) && (ubREC_SrcModeGet() == REC_SRCMODE_CFG) && ((ubPLY_GetOpMode() == PLY_MODE_R) || (ubPLY_GetOpMode() == PLY_MODE_PR)))
				{
					KNL_StrgRecInfo_t tStrgRecInfo;

					#if (defined(VDO_SUBPATH_ENABLE)&&(VDO_SUBPATH_ENABLE!=0)&&defined(APP_TXREC_STREAM_SEL)&&(APP_TXREC_STREAM_SEL==1))
					if( ubSrcNum >= KNL_SRC_1_AUX && ubSrcNum <= KNL_SRC_4_AUX)
                    #elif (defined(VDO_SUBPATH_ENABLE)&&(VDO_SUBPATH_ENABLE!=0)&&defined(APP_TXREC_STREAM_SEL)&&(APP_TXREC_STREAM_SEL==2))
                    if( ubSrcNum <= KNL_SRC_4_AUX)
					#else
					if(ubSrcNum <= KNL_SRC_4_MAIN)
					#endif
					{
					    #if (defined(VDO_SUBPATH_ENABLE)&&(VDO_SUBPATH_ENABLE!=0)&&defined(APP_TXREC_STREAM_SEL)&&(APP_TXREC_STREAM_SEL==1))
						    tStrgRecInfo.tRecInfo.ubCh = 0;
                        #elif (defined(VDO_SUBPATH_ENABLE)&&(VDO_SUBPATH_ENABLE!=0)&&defined(APP_TXREC_STREAM_SEL)&&(APP_TXREC_STREAM_SEL==2))
                            if(ubSrcNum <= KNL_SRC_4_MAIN)
                                tStrgRecInfo.tRecInfo.ubCh = 0;
                            else
                                tStrgRecInfo.tRecInfo.ubCh = 1;
                        #else
                            tStrgRecInfo.tRecInfo.ubCh = 0;
                        #endif
						tStrgRecInfo.tRecInfo.ubRestartFg = 0;
						if(tKNL_GetFrameType(ReceiveResult.H264Result->BSAddr) == KNL_I_FRAME)
						{
							tStrgRecInfo.tRecInfo.ubPictureType = REC_I_VFRM;
						}
						else
						{
							tStrgRecInfo.tRecInfo.ubPictureType = REC_P_VFRM;
						}
						tStrgRecInfo.tRecInfo.ulDramAddr = ReceiveResult.H264Result->BSAddr;
						tStrgRecInfo.tRecInfo.ulSize = ulBsSz;
						tStrgRecInfo.tRecInfo.ulTimeStamp = KNL_TIMER_Get1ms();
						tStrgRecInfo.tRecInfo.ubCmd = REC_CMD_VIDEXT;
						if(tStrgRecInfo.tRecInfo.ulTimeStamp < ulPreVdoTimeStamp[ubSrcNum])
							tStrgRecInfo.tRecInfo.ubRestartFg = 1;
						else
							tStrgRecInfo.tRecInfo.ubRestartFg = 0;
						ulPreVdoTimeStamp[ubSrcNum] = tStrgRecInfo.tRecInfo.ulTimeStamp;
						tStrgRecInfo.ubSrcNum  = ubSrcNum;
						tStrgRecInfo.ubNode    = KNL_NODE_H264_ENC;
						tStrgRecInfo.ubRelease = ubRelRdyFlg = (KNL_NODE_VDO_REC == ubNextNode)?TRUE:FALSE;
						if(osMessagePut(osKNL_StrgRecQue, &tStrgRecInfo, 0) != osOK)
						{
							ubRelRdyFlg = FALSE;
							printd(DBG_ErrorLvl, "REC_SRCMODE_CFG->Full !!!!\r\n");
						}
					}
				}
				if(KNL_NODE_VDO_REC == ubNextNode)
				{
					if(FALSE == ubRelRdyFlg)
						ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_ENC, ubSrcNum, ReceiveResult.H264Result->BSAddr);
					osSemaphoreRelease(tKNL_ImgSem);
					ubKNL_ImgRdy = 1;
					osSemaphoreRelease(osKNL_H264CdcWaitSem);
					return;
				}
			}
#endif	//! End of #if (APP_REC_FUNC_ENABLE && OP_STA)
#if !defined(BSP_DVR_SDK)
			if(osMessagePut(KNL_VdoCodecProcQueue, &tImgProc, 0) != osOK)
			{
				ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_ENC,ubSrcNum,ReceiveResult.H264Result->BSAddr);
				printd(DBG_ErrorLvl, "KNL_Q->Full !!!!\r\n");
			}
#else
        	if (ubSrcNum != KNL_SRC_STORAGE_LOCAL)
            {
				if(osMessagePut(KNL_VdoCodecProcQueue, &tImgProc, 0) != osOK)
				{
					ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_ENC,ubSrcNum,ReceiveResult.H264Result->BSAddr);
					printd(DBG_ErrorLvl, "KNL_Q->Full !!!!\r\n");
				}
            }
        	else
            {
				uint8_t ubRelRdyFlg = FALSE;
#if (APP_REC_FUNC_ENABLE && OP_AP)	//by configure source
				 if((ubREC_SrcModeGet() == REC_SRCMODE_CFG) && ((ubPLY_GetOpMode() == PLY_MODE_R) || (ubPLY_GetOpMode() == PLY_MODE_PR)))
				 {
					KNL_StrgRecInfo_t tStrgLocInfo;

					tStrgLocInfo.tRecInfo.ubCh = 1;
					tStrgLocInfo.tRecInfo.ubRestartFg = 0;
					if(tKNL_GetFrameType(tImgProc.ulDramAddr2) == KNL_I_FRAME)
						tStrgLocInfo.tRecInfo.ubPictureType = REC_I_VFRM;
					else
						tStrgLocInfo.tRecInfo.ubPictureType = REC_P_VFRM;
					tStrgLocInfo.tRecInfo.ulDramAddr = tImgProc.ulDramAddr2;
					tStrgLocInfo.tRecInfo.ulSize = tImgProc.ulSize;
					tStrgLocInfo.tRecInfo.ulTimeStamp = KNL_TIMER_Get1ms();
					tStrgLocInfo.tRecInfo.ubCmd = REC_CMD_VIDEXT;
					if(tStrgLocInfo.tRecInfo.ulTimeStamp < ulPreVdoTimeStamp[tImgProc.ubSrcNum])
						tStrgLocInfo.tRecInfo.ubRestartFg = 1;
					else
						tStrgLocInfo.tRecInfo.ubRestartFg = 0;
					ulPreVdoTimeStamp[tImgProc.ubSrcNum] = tStrgLocInfo.tRecInfo.ulTimeStamp;
					tStrgLocInfo.ubSrcNum  = ubSrcNum;
					tStrgLocInfo.ubNode    = KNL_NODE_H264_ENC;
					tStrgLocInfo.ubRelease = ubRelRdyFlg = TRUE;
					if(osMessagePut(osKNL_StrgRecQue, &tStrgLocInfo, 0) != osOK)
					{
						ubRelRdyFlg = FALSE;
						printd(DBG_ErrorLvl, "REC_SRCMODE_CFG->Full !!!!\r\n");
					}
				 }
#endif	//! End of #if (APP_REC_FUNC_ENABLE && OP_AP)
				if(FALSE == ubRelRdyFlg)
					ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_ENC,ubSrcNum,ReceiveResult.H264Result->BSAddr);
            }
#endif	//! End of #if !defined(BSP_DVR_SDK)
		}
		else
		{
			ubTemp = ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_ENC,ubSrcNum,ReceiveResult.H264Result->BSAddr);
			if(ubTemp != BUF_OK)
			{
				printd(DBG_ErrorLvl, "Err3 @%s[0x%X]\n", __func__, ReceiveResult.H264Result->BSAddr);
			}
		}

//	#if !(defined(BSP_DVR_SDK))
#if !(defined(OP_AP) && defined(BSP_DVR_SDK))
	#ifdef S2019A
	if(ubRC_GetFlg(ubIdxMap))
	{
		uint8_t ubFpsUpdFlag = FALSE;

		ubFpsUpdFlag = (((ulFrmIdx[ubIdxMap] % ubKNL_GetVdoFps()) == (ubKNL_GetVdoFps()-1)) && (ulRefreshCnt >= ubRC_GetRefreshRate(0)))?TRUE:FALSE;
		KNL_ImgRateCtrlFlow(ubSrcNum, ubIdxMap, ubFpsUpdFlag);
		if(TRUE == ubFpsUpdFlag)
			ulRefreshCnt = 0;
	}
	#else
		if(ubRC_GetFlg(ubIdxMap) && ((ulFrmIdx[ubIdxMap]% ubKNL_GetVdoFps()) == (ubKNL_GetVdoFps()-1)) && (ulRefreshCnt >= ubRC_GetRefreshRate(0)))
		{
			ulRefreshCnt = 0;
			//printd(DBG_Debug3Lvl, "Rst RC1\r\n");

			tNodeInfo = tKNL_GetNodeInfo(ubSrcNum,KNL_NODE_H264_ENC);
			if(ubKNL_ResetIFlg[ubSrcNum])
			{
				ubKNL_ResetIFlg[ubSrcNum] = 0;
				H264_ResetIPCnt((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx);
			}
			if(ubPreFps != ubRC_GetFps())
			{
				//printd(DBG_Debug3Lvl, "Rst RC11\r\n");
				ubPreFps = ubRC_GetFps();
				if(ReceiveResult.H264Result->EncodeStream == ENCODE_0)
				{
					H264_EncodeInit((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV,ulBUF_GetBlkBufAddr(0,BUF_IMG_ENC),ubRC_GetFps(),ulKNL_GetVdoGop());//DECODE[0]
				}
				else if(ReceiveResult.H264Result->EncodeStream == ENCODE_1)
				{
					H264_EncodeInit((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV,ulBUF_GetBlkBufAddr(1,BUF_IMG_ENC),ubRC_GetFps(),ulKNL_GetVdoGop());//DECODE[0]
				}
				else if(ReceiveResult.H264Result->EncodeStream == ENCODE_2)
				{
					H264_EncodeInit((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV,ulBUF_GetBlkBufAddr(2,BUF_IMG_ENC),ubRC_GetFps(),ulKNL_GetVdoGop());//DECODE[0]
				}
				else if(ReceiveResult.H264Result->EncodeStream == ENCODE_3)
				{
					H264_EncodeInit((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV,ulBUF_GetBlkBufAddr(3,BUF_IMG_ENC),ubRC_GetFps(),ulKNL_GetVdoGop());//DECODE[0]
				}
			}			
			H264_RcSetEN((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,H264_ENABLE,CBR,ulRC_GetFinalBitRate(tNodeInfo.ubCodecIdx));
			if((ubKNL_GetVdoFps() <= 5) && (H264_GetCurrentQP() > 3))
			{
				H264_ResetRateControl(H264_GetCurrentQP() - 3);
			}
			else
			{
				H264_ResetRateControl(H264_GetCurrentQP());	
			}
			
			//printf("Q:%d->%d:%d\r\n",H264_GetCurrentQP(),ubRC_GetFinalMinQp(tNodeInfo.ubCodecIdx),ubRC_GetFinalMaxQp(tNodeInfo.ubCodecIdx));
			
			H264_SetRCParameter((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,ulRC_GetFinalBitRate(tNodeInfo.ubCodecIdx),ubKNL_GetVdoFps());
			H264_SetMaxQP((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,ubRC_GetFinalMaxQp(tNodeInfo.ubCodecIdx));
			H264_SetMinQP((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,ubRC_GetFinalMinQp(tNodeInfo.ubCodecIdx));
		}
		else if(ubRC_GetFlg(ubIdxMap) && (ubRC_GetUpdateFlg(ubIdxMap)))
		{
			RC_SetUpdateFlg(ubIdxMap,0);

			ulRefreshCnt = 0;
			//printd(DBG_Debug3Lvl, "Rst RC2\r\n");

			tNodeInfo = tKNL_GetNodeInfo(ubSrcNum,KNL_NODE_H264_ENC);
			if(ubKNL_ResetIFlg[ubSrcNum])
			{
				ubKNL_ResetIFlg[ubSrcNum] = 0;
				H264_ResetIPCnt((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx);
			}
			if(ubPreFps != ubRC_GetFps())
			{
				//printd(DBG_Debug3Lvl, "Rst RC22\r\n");
				ubPreFps = ubRC_GetFps();
				H264_SetFrameRate((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,ubRC_GetFps());
			}
			H264_RcSetEN((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,H264_ENABLE,CBR,ulRC_GetFinalBitRate(tNodeInfo.ubCodecIdx));
			if((ubKNL_GetVdoFps() <= 5) && (H264_GetCurrentQP() > 3))
			{
				H264_ResetRateControl(H264_GetCurrentQP() - 3);
			}
			else
			{
				H264_ResetRateControl(H264_GetCurrentQP());
			}
			H264_SetRCParameter((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,ulRC_GetFinalBitRate(tNodeInfo.ubCodecIdx),ubKNL_GetVdoFps());
			H264_SetMaxQP((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,ubRC_GetFinalMaxQp(tNodeInfo.ubCodecIdx));
			H264_SetMinQP((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,ubRC_GetFinalMinQp(tNodeInfo.ubCodecIdx));
		}
	#endif //! End of #ifdef S2019A
#endif	//! End of #if !(defined(OP_AP) && defined(BSP_DVR_SDK))

		//(4)Release IMG/H264
		osSemaphoreRelease(tKNL_ImgSem);
		ubKNL_ImgRdy = 1;	//Codec Ready
		osSemaphoreRelease(osKNL_H264CdcWaitSem);
		printd(DBG_Debug3Lvl, "H->EOK\r\n");
	}
	//Decode Process
	//========================================================================
	else if(ReceiveResult.H264Result->Type == H264_DECODE)
	{
#if (defined(OP_AP) && defined(S2019A))
		if(!ubKNL_H264DecReport(ubKNL_ImgSrc, ReceiveResult.H264Result))
		{
			KNL_SetNodeState(ubKNL_ImgSrc, KNL_NODE_H264_DEC, KNL_NODE_STOP);
			KNL_RestartImgCodec();
			goto RELEASE_IMGDEC_SRC;
		}
#endif
#if defined(BSP_DVR_SDK)
		ulKNL_H264DecCntTemp[ubKNL_ImgSrc]++;
#endif
		#if (APP_REC_FUNC_ENABLE && OP_AP)
		if((ubREC_SrcModeGet() == REC_SRCMODE_DSP) && ((ubPLY_GetOpMode() == PLY_MODE_R) || (ubPLY_GetOpMode() == PLY_MODE_PR)) )
		{
			KNL_StrgRecInfo_t tStrgRecInfo;

			tStrgRecInfo.tRecInfo.ubCh = ubKNL_ImgSrc;
			tStrgRecInfo.tRecInfo.ubRestartFg = 0;
			if(tKNL_GetFrameType(ReceiveResult.H264Result->BSAddr) == KNL_I_FRAME)
			{
				tStrgRecInfo.tRecInfo.ubPictureType = REC_I_VFRM;
			}
			else
			{
				tStrgRecInfo.tRecInfo.ubPictureType = REC_P_VFRM;
			}
			tStrgRecInfo.tRecInfo.ulDramAddr = ReceiveResult.H264Result->BSAddr;
			tStrgRecInfo.tRecInfo.ulSize = ulKNL_ImgSize;
			tStrgRecInfo.tRecInfo.ulTimeStamp = ulKNL_ImgTime;
			tStrgRecInfo.tRecInfo.ubCmd = REC_CMD_VIDEXT;
			if(tStrgRecInfo.tRecInfo.ulTimeStamp < ulPreVdoTimeStamp[ubKNL_ImgSrc])
				tStrgRecInfo.tRecInfo.ubRestartFg = 1;
			else
				tStrgRecInfo.tRecInfo.ubRestartFg = 0;					
			ulPreVdoTimeStamp[ubKNL_ImgSrc] = tStrgRecInfo.tRecInfo.ulTimeStamp;
			tStrgRecInfo.ubSrcNum  = ubSrcNum;
			tStrgRecInfo.ubNode    = KNL_NODE_H264_DEC;
			tStrgRecInfo.ubRelease = FALSE;
			if(osMessagePut(osKNL_StrgRecQue, &tStrgRecInfo, 0) != osOK)
				printd(DBG_ErrorLvl, "REC_SRCMODE_DSP->Full !!!!\r\n");
		}
		#endif

		//(1)Update SrcNum
		ubSrcNum = ubKNL_ImgSrc;
		KNL_SetNodeState(ubSrcNum,KNL_NODE_H264_DEC,KNL_NODE_STOP);

		//(2)Release Buffer
		//--------------------------------------------------------------
#if APP_FS_FILE_LIST_STYLE
		if(KNL_ThmShowInfo.ubEnFlg==0 || tKNL_GetRecordFunc()==KNL_VIDEO_PLAY)
#endif
        {
    		ubPreNode = ubKNL_GetPreNode(ubSrcNum,KNL_NODE_H264_DEC);
    		if((ubPreNode == KNL_NODE_VDO_BS_BUF1) || (ubPreNode == KNL_NODE_VDO_BS_BUF2))
    		{
    			ubTemp = ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_DEC,ubSrcNum,ReceiveResult.H264Result->BSAddr);
    			if(ubTemp != BUF_OK)
    				printd(DBG_ErrorLvl, "Err4 @%s[0x%X]\n", __func__, ReceiveResult.H264Result->BSAddr);
    		}
		}

		if(H264_FAIL == ReceiveResult.H264Result->Result)
		{
			printf("H264 Event Fail !!!!(%d)\r\n",ubKNL_ImgSrc);
		#if (APP_DUAL_HOST_ENABLE == 1)
			KNL_SetUvcChkFlg(0,1);
			KNL_SetUvcChkFlg(1,1);
		#endif
			KNL_RestartImgCodec();
		}
		else
			printd(DBG_Debug3Lvl, "[%d]H->DOK\r\n", ubSrcNum);

		#if (defined(OP_AP) && (USBD_UVC_MJ_FMT == USBD_UVC_FMT) && USBD_ENABLE)
		static uint32_t ulRawCnt = 0;
		if((DISPLAY_1T1R == DISPLAY_MODE) && (USBD_UVC_MODE == tUSBD_GetClassMode())||(TRUE == ubUSBD_ChkCompUvcClass()))
		{
			uint8_t ubUvcPathMode;
			ulRawCnt++;

			ubUvcPathMode = UVC_GetVdoFormat();
		    if(USB_UVC_VS_FORMAT_MJPEG == ubUvcPathMode)
			{
				if(KNL_CAPHQ_RXRDY == tKNL_CapHQImgSte)
					USBD_doSnapShotUseStillImageCapture();
				tKNL_UpdateMjUvcImage(ReceiveResult.H264Result->YuvAddr, ubSrcNum);
				if(KNL_DISP_ROTATE_90 == tKNL_GetDispRotate())
				{
					KNL_ResetLcdChannel();
					if(KNL_CAPHQ_RXRDY == tKNL_CapHQImgSte)
					tKNL_CapHQImgSte = KNL_CAPHQ_DIS;
					goto RELEASE_IMGDEC_SRC;
				}
			}
//			else if((USB_UVC_VS_FORMAT_UNCOMPRESSED == ubUvcPathMode) && ( (ulRawCnt%3) || (ulRawCnt%30 == 0) ) )		// 3 4  6
			else if((USB_UVC_VS_FORMAT_UNCOMPRESSED == ubUvcPathMode) && (ulRawCnt%2 || ulRawCnt%7 == 0) )
			{			
				uint8_t *pRawAddr,*pSourceRawAddr,*pSourceRawAddr2;
				uint32_t ulRawAddr;				
				uint32_t ulTimeLog;
				
				ulRawAddr = ulBUF_GetVdoUsbdFreeBuf();				
				pRawAddr = (uint8_t *)ulRawAddr;
				ulTimeLog = KNL_TIMER_Get1ms();
				if(BUF_FAIL == ulRawAddr)
					printf( "ulRawAddr BUF_FAIL ");
				else
				{	
					uint32_t ulSram = 0x10100000;
					uint32_t ulIn = 0,ulOut = 0;
					uint16_t j=0,k =0,l =0;

					pSourceRawAddr = (uint8_t *)ulSram;
					pRawAddr = (uint8_t *)(ulSram+23040);

					for(uint32_t X=0 ; X< 20; X++)			//15*12*2 = 360 ,20*12*2 = 480
					{				
						memcpy((uint8_t *)ulSram,(uint8_t *)(ReceiveResult.H264Result->YuvAddr+ ulIn),23040);
						j = 0;		//in
						l = 0;
						k = 0;		//out	

						for(uint32_t Y=0 ; Y< 12; Y++)
						{	
							for(uint32_t Z=0 ; Z< 160 ; Z++)
							{										
								pRawAddr = (uint8_t *)(0x10105A00+k);
								pSourceRawAddr = (uint8_t *)(ulSram+j);
								pSourceRawAddr2 = (uint8_t *)(ulSram+l);
								pRawAddr[0] = pSourceRawAddr[0];
								pRawAddr[1] = pRawAddr[1281] = pSourceRawAddr[4];
								pRawAddr[2] = pSourceRawAddr[1];
								pRawAddr[3] = pRawAddr[1283]  = pSourceRawAddr[5];
								pRawAddr[4] = pSourceRawAddr[2];
								pRawAddr[5] = pRawAddr[1285]  = pSourceRawAddr[6];
								pRawAddr[6] = pSourceRawAddr[3];
								pRawAddr[7] = pRawAddr[1287]  = pSourceRawAddr[7];	
								pRawAddr[1280] = pSourceRawAddr2[1280];
								pRawAddr[1282] = pSourceRawAddr2[1281];
								pRawAddr[1284] = pSourceRawAddr2[1282];
								pRawAddr[1286] = pSourceRawAddr2[1283];
								j += 8;		//in
								l += 4;
								k += 8;		//out	
							}
							j += 640;		//in
							l += 1280;
							k += 1280;		//out
						}									
						memcpy((uint8_t *)(ulRawAddr + ulOut),(uint8_t *)(ulSram+23040),30720);
						ulIn +=23040;
						ulOut+=30720;
					}

					pRawAddr = (uint8_t *)ulRawAddr;
					printd(DBG_InfoLvl, "R%d ", KNL_TIMER_Get1ms()-ulTimeLog);						
//					uvc_update_image((uint32_t *)pRawAddr, 640*360*2);		//640*360	
					uvc_update_image((uint32_t *)pRawAddr, 640*480*2);		//640*480
					
				}		
				goto RELEASE_IMGDEC_SRC;				
			}				
			tKNL_CapHQImgSte = KNL_CAPHQ_DIS;
		}
		#endif

		//(3)Post-Process
		ubNextNode = ubKNL_GetNextNode(ubSrcNum, KNL_NODE_H264_DEC);
		if(ubKNL_ChkVdoFlowAct(ubSrcNum))
		{
			tNodeInfo = tKNL_GetNodeInfo(ubSrcNum, KNL_NODE_H264_DEC);
#if defined(BSP_DVR_SDK)
			if((KNL_PHOTO_CAPTURE == tKNL_GetRecordFunc()) && (ubSrcNum == ubKNL_GetRecordCapSrc()) && (ubKNL_GetLocalSnapshotProc()==0))
#else
			if((KNL_PHOTO_CAPTURE == tKNL_GetRecordFunc()) && (ubSrcNum == ubKNL_GetRecordCapSrc()))
#endif
			{
#if defined(BSP_DVR_SDK)
			    if(osSemaphoreWait(JPEG_CodecSem, osWaitForever) == osOK)
                    osSemaphoreRelease(JPEG_CodecSem);
#endif
                KNL_SetRecordCapSrc(0xFF);
                ubKNL_JpegPreNode = KNL_NODE_H264_DEC;
                ubKNL_JpegSrc 	  = ubSrcNum;
#if !(defined(BSP_DVR_SDK) || (defined(BSP_RVCS_SDK)&&defined(OP_STA)&& APP_PHOTOGRAPH_FUNC_ENABLE) )
                ubKNL_JPEGEncode(JPEG_YUV420, JPEG_FN_USE_ISR, tNodeInfo.uwVdoH, tNodeInfo.uwVdoV, ReceiveResult.H264Result->YuvAddr,
                                 (ulKNL_JPGAddr[(ubKNL_SrcNumMap(ubSrcNum))] + KNL_JPG_HEADER_SIZE));
#else
                ubKNL_JPEGEncode(JPEG_YUV420, JPEG_FN_USE_ISR, tNodeInfo.uwVdoH, tNodeInfo.uwVdoV, ReceiveResult.H264Result->YuvAddr,
                                 (ulKNL_JPGAddr + KNL_JPG_HEADER_SIZE));
#endif
                return;
			}
			else if((KNL_PHOTO_PLAY != tKNL_GetRecordFunc()) && (JPG_LCDCH_DISABLE == tKNL_GetJpegLcdChCtrl()) &&
				    (ubNextNode == KNL_NODE_LCD))
			{
				if(KNL_DISP_H == tKNL_GetDispType())
				{
					if(((tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)  && ((ubKNL_GetDispSrc(KNL_DISP_LOCATION1) == ubSrcNum) || (ubKNL_GetDispSrc(KNL_DISP_LOCATION4) == ubSrcNum))) ||
					   ((tKNL_GetDispRotate() == KNL_DISP_ROTATE_90) && ((ubKNL_GetDispSrc(KNL_DISP_LOCATION2) == ubSrcNum) || (ubKNL_GetDispSrc(KNL_DISP_LOCATION3) == ubSrcNum))))
					{
						if(KNL_OK != tKNL_StartUpImageMergeForDispH(ubSrcNum))
							goto RELEASE_IMGDEC_SRC;
						if((tKNL_GetDispRotate() == KNL_DISP_ROTATE_90) &&
						   ((ubKNL_GetDispSrc(KNL_DISP_LOCATION2) == ubSrcNum) || (ubKNL_GetDispSrc(KNL_DISP_LOCATION3) == ubSrcNum)))
							return;
					}
				}
				else if((((tKNL_GetDispType() == KNL_DISP_3T_2L1R) || (tKNL_GetDispType() == KNL_DISP_3T_1L2R)) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)) ||
					    (((tKNL_GetDispType() == KNL_DISP_3T_2T1B) || (tKNL_GetDispType() == KNL_DISP_3T_1T2B)) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0))  ||
				        (( tKNL_GetDispType() == KNL_DISP_3T_3COL) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)))
				{
					KNL_DISP_LOCATION tDispLocate;
					tDispLocate = tKNL_SearchSrcLocation(ubSrcNum);
					if((KNL_DISP_LOCATION2 == tDispLocate) || (KNL_DISP_LOCATION3 == tDispLocate))
					{
						if(KNL_OK != tKNL_StartUpImageMergeForTrip(ubSrcNum))
							goto RELEASE_IMGDEC_SRC;
						return;
					}
				}
				#ifdef BUC_CU
				else if((TRUE == ubKNL_BbPathAct) && (TRUE == KNL_SwDispInfo.ubSetupFlag))
				{
					switch(tKNL_GetDispType())
					{
						case KNL_DISP_SINGLE:
							if(KNL_SwDispInfo.tSrcNum[0] != ubSrcNum)
								goto RELEASE_IMGDEC_SRC;
							break;
						case KNL_DISP_DUAL_C:
						case KNL_DISP_DUAL_U:
#if defined(BSP_DVR_SDK)
						case KNL_DISP_PIP_0:
#endif
							if((KNL_SwDispInfo.tSrcNum[0] != ubSrcNum) && (KNL_SwDispInfo.tSrcNum[1] != ubSrcNum))
								goto RELEASE_IMGDEC_SRC;
							break;
						default:
							break;
					}
				}
				#endif
#if (APP_DOORPHONE_ENABLE==1)                
                if(ubKNK_VideoOnOffFg[(ubKNL_SrcNumMap(ubSrcNum))]==1)
#endif                
                    KNL_ActiveLcdDispBuf(ubSrcNum);
#if APP_FS_FILE_LIST_STYLE
                if( KNL_ThmShowInfo.ubEnFlg==1 && tKNL_GetRecordFunc()!=KNL_VIDEO_PLAY)
                {
                    if(KNL_ThmShowInfo.osThrdID != NULL)
                        osSignalSet(KNL_ThmShowInfo.osThrdID, osKNL_ShowingThmSignal);
                }
#endif
			}
			else
			{
				tImgProc.ulDramAddr1	= ReceiveResult.H264Result->YuvAddr;
				tImgProc.ubSrcNum		= ubSrcNum;
				tImgProc.ubCurNode		= KNL_NODE_H264_DEC;
				tImgProc.ubNextNode 	= ubNextNode;
				tImgProc.ulSize			= ((uint32_t)uwKNL_GetVdoH(ubSrcNum))*((uint32_t)uwKNL_GetVdoV(ubSrcNum))*1.5;
				if(osMessagePut(KNL_VdoCodecProcQueue, &tImgProc, 0) == osErrorResource)
				{
					ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_DEC,ubSrcNum,ReceiveResult.H264Result->BSAddr);
					printd(DBG_ErrorLvl, "KNL_Q->Full !!!!\r\n");
				}
			}
		}
RELEASE_IMGDEC_SRC:
		//(4)Release IMG/H264
		osSemaphoreRelease(tKNL_ImgSem);
		ubKNL_ImgRdy = 1;	//Codec Ready
		osSemaphoreRelease(osKNL_H264CdcWaitSem);
	}
	//Merge Process
	//========================================================================
	else
	{
		if(tKNL_GetDispType() == KNL_DISP_H)
		{
			if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)
			{
				//(0)Update Info First
				ubSrcNum = ubKNL_ImgTrigSrc;
				ubTrigType = ubKNL_ImgTrigType;

				//(1)Release IMG/H264
				osSemaphoreRelease(tKNL_ImgSem);
				ubKNL_ImgRdy = 1;	//Codec Ready
				osSemaphoreRelease(osKNL_H264CdcWaitSem);
				printd(DBG_Debug1Lvl, "IMG->MOK\r\n");

				//(2)To Next Node
				if(ubTrigType == KNL_IMG_MERGE_H)
				{
					KNL_SetNodeState(ubSrcNum,KNL_NODE_IMG_MERGE_H,KNL_NODE_STOP);
					tImgProc.ubCurNode 	= KNL_NODE_IMG_MERGE_H;
					ubNextNode = ubKNL_GetNextNode(ubSrcNum,KNL_NODE_IMG_MERGE_H);
				}
				tImgProc.ubSrcNum	= ubSrcNum;
				tImgProc.ubNextNode = ubNextNode;

				if(ubKNL_ChkVdoFlowAct(ubSrcNum))
				{
					if(ubNextNode == KNL_NODE_LCD)
					{
						KNL_ActiveLcdDispBuf(ubSrcNum);
					}
					else
					{
						osMessagePut(KNL_VdoCodecProcQueue, &tImgProc, 0);
					}
				}
			}
			else if(tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)
			{
				ubSrcNum = ubKNL_ImgTrigSrc;
				if(ubKNL_ChkVdoFlowAct(ubSrcNum))
				{
					ubNextNode = ubKNL_GetNextNode(ubSrcNum, KNL_NODE_H264_DEC);
					if(ubNextNode == KNL_NODE_LCD)
					{
						KNL_ActiveLcdDispBuf(ubSrcNum);
					}
				}
				osSemaphoreRelease(tKNL_ImgSem);
				ubKNL_ImgRdy = 1;
				osSemaphoreRelease(osKNL_H264CdcWaitSem);
			}
		}
		else if((((tKNL_GetDispType() == KNL_DISP_3T_2L1R) || (tKNL_GetDispType() == KNL_DISP_3T_1L2R)) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)) ||
		        (((tKNL_GetDispType() == KNL_DISP_3T_2T1B) || (tKNL_GetDispType() == KNL_DISP_3T_1T2B)) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0))  ||
		        (( tKNL_GetDispType() == KNL_DISP_3T_3COL) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)))
		{
			ubSrcNum = ubKNL_ImgTrigSrc;
			if(ubKNL_ChkVdoFlowAct(ubSrcNum))
			{
				ubNextNode = ubKNL_GetNextNode(ubSrcNum, KNL_NODE_H264_DEC);
				if(ubNextNode == KNL_NODE_LCD)
				{
					KNL_ActiveLcdDispBuf(ubSrcNum);
				}
			}
			osSemaphoreRelease(tKNL_ImgSem);
			ubKNL_ImgRdy = 1;
			osSemaphoreRelease(osKNL_H264CdcWaitSem);
		}
	}
}

//------------------------------------------------------------------------------
#else

static void KNL_ImgMonitThread(void const *argument)
{
	struct IMG_RESULT ReceiveResult;
	KNL_PROCESS tImgProc;
	uint8_t ubNextNode;
	uint8_t ubPreNode;
	uint8_t ubTemp;	
	uint8_t ubSrcNum;	
	uint8_t ubTrigType;
	uint32_t ulBsSz;
	uint32_t ulFrmIdx[4];
	uint32_t ulGop;
//	struct H264_ENCODE *codec;
	uint32_t ulRefreshCnt = 0;
	KNL_NODE_INFO tNodeInfo;
	uint8_t ubIdxMap;

	uint8_t i;
	uint32_t ulSubDr[30];
	uint32_t ulRtDr = 0;//Bit-Rate

	uint8_t ubPreFps;

	ubPreFps = ubKNL_GetVdoFps();

	for(i=0;i<30;i++)
	{
		ulSubDr[i] = 0;
	}

	while(1)
	{
        osMessageGet(IMG_EventQueue, &ReceiveResult, osWaitForever);
        //Encode Process
        //========================================================================
        if(ReceiveResult.H264Result->Type == H264_ENCODE)
        {
            //(1)Update Information First (SrcNum/BS Size)
            ubSrcNum = ubKNL_ImgSrc;
            KNL_SetNodeState(ubSrcNum,KNL_NODE_H264_ENC,KNL_NODE_STOP);
            ulBsSz = ReceiveResult.H264Result->Size;	//ulH264_GetStreamSize();
			if(ReceiveResult.H264Result->EncodeStream == ENCODE_0)
			{
				ubIdxMap = 0;
			}
			else if(ReceiveResult.H264Result->EncodeStream == ENCODE_1)
			{
				ubIdxMap = 1;
			}
			else if(ReceiveResult.H264Result->EncodeStream == ENCODE_2)
			{
				ubIdxMap = 2;
			}
			else if(ReceiveResult.H264Result->EncodeStream == ENCODE_3)
			{
				ubIdxMap = 3;
			}
			ulFrmIdx[ubIdxMap] = ReceiveResult.H264Result->ulFrmIdx;
			if(ulFrmIdx[ubIdxMap] == 0)
			{
				ubKNL_VdoGroupIdx[ubIdxMap]++;
			}
			ulGop	= ReceiveResult.H264Result->ulGop;
			ubKNL_Qp[ubIdxMap] = H264_GetCurrentQP();

			ulKNL_CurFrmIdx[ubIdxMap] = ulFrmIdx[ubIdxMap];
			if((ulFrmIdx[ubIdxMap]%ubKNL_GetVdoFps()) == (ubKNL_GetVdoFps()-1))
			{
				ulRefreshCnt++;
			}

			//printd(DBG_Debug3Lvl, "BS[%d]_Q:%d_S:%d\r\n",ulFrmIdx[ubIdxMap],H264_GetCurrentQP(),ulBsSz/1024);

			//For Report
			if((ulFrmIdx[ubIdxMap] % ubKNL_GetVdoFps()) == 0)
			{
				ulKNL_VdoOutAccCntTemp[ubIdxMap] = 0;
			}

			if(ReceiveResult.H264Result->EncodeStream == ENCODE_0)
			{
				ulKNL_VdoOutAccCntTemp[0] += (ulBsSz*8);
			}
			else if(ReceiveResult.H264Result->EncodeStream == ENCODE_1)
			{
				ulKNL_VdoOutAccCntTemp[1] += (ulBsSz*8);
			}
			else if(ReceiveResult.H264Result->EncodeStream == ENCODE_2)
			{
				ulKNL_VdoOutAccCntTemp[2] += (ulBsSz*8);
			}
			else if(ReceiveResult.H264Result->EncodeStream == ENCODE_3)
			{
				ulKNL_VdoOutAccCntTemp[3] += (ulBsSz*8);
			}

			ulSubDr[ulFrmIdx[ubIdxMap] % ubKNL_GetVdoFps()] = (ulBsSz*8);
			if((ulFrmIdx[ubIdxMap] % ubKNL_GetVdoFps()) == (ubKNL_GetVdoFps()-1))
			{
				ulRtDr = 0;
				for(i=0;i<ubKNL_GetVdoFps();i++)
				{
					ulRtDr = ulRtDr + ulSubDr[i];
				}
				printd(DBG_Debug2Lvl, "== RtDr:%d KB ==\r\n",ulRtDr/8192);
				ulKNL_VdoOutAccCnt[ubIdxMap] = ulKNL_VdoOutAccCntTemp[ubIdxMap];
				ulKNL_VdoOutAccCntTemp[ubIdxMap] = 0;
			}

            //(2)Release Buffer
            ubPreNode = ubKNL_GetPreNode(ubSrcNum,KNL_NODE_H264_ENC);
            if(ubPreNode == KNL_NODE_SEN_YUV_BUF)
            {
#if OP_STA				
				if(SEN_Get16MCvbsAddress() == ReceiveResult.H264Result->YuvAddr)
				{
					ubTemp = ubBUF_ReleaseSenYuvBuf((SEN->STR1_STA << 8)/*ReceiveResult.YuvAddr*/);
				}
				else
				{		
					ubTemp = ubBUF_ReleaseSenYuvBuf(ReceiveResult.H264Result->YuvAddr/*ReceiveResult.YuvAddr*/);
				}
#else
				ubTemp = ubBUF_ReleaseSenYuvBuf(ReceiveResult.H264Result->YuvAddr/*ReceiveResult.YuvAddr*/);
#endif
                if(ubTemp != BUF_OK)
                {
                    printd(DBG_ErrorLvl, "Err2 @%s[0x%X]\n", __func__, ReceiveResult.H264Result->YuvAddr);
                }
            }

            //(3)Post-Process
            if(ubKNL_ChkVdoFlowAct(ubSrcNum))
            {
                tImgProc.ulDramAddr1	= ReceiveResult.H264Result->YuvAddr;//ReceiveResult.YuvAddr;
                tImgProc.ulDramAddr2	= ReceiveResult.H264Result->BSAddr;	//BS Buffer Address
                tImgProc.ubSrcNum		= ubSrcNum;			
                tImgProc.ubCurNode		= KNL_NODE_H264_ENC;						
                tImgProc.ubNextNode 	= ubKNL_GetNextNode(ubSrcNum,KNL_NODE_H264_ENC);												
                tImgProc.ulSize 		= ulBsSz;
				tImgProc.ubCodecIdx		= ubIdxMap;
				tImgProc.ulIdx			= ulFrmIdx[ubIdxMap];
				tImgProc.ubVdoGop		= ubKNL_VdoGroupIdx[ubIdxMap];
				tImgProc.ulGop			= ulGop;
#if !defined(BSP_DVR_SDK)
                if(osMessagePut(KNL_VdoCodecProcQueue, &tImgProc, 0) != osOK)
                {
					ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_ENC,ubSrcNum,ReceiveResult.H264Result->BSAddr);
                    printd(DBG_ErrorLvl, "KNL_Q->Full !!!!\r\n");
                }
				else
					printd(DBG_Debug1Lvl, "E->OK\n");
#else
			#if (ubSrcNum != KNL_SRC_STORAGE_LOCAL)	
                if(osMessagePut(KNL_VdoCodecProcQueue, &tImgProc, 0) != osOK)
                {
					ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_ENC,ubSrcNum,ReceiveResult.H264Result->BSAddr);
                    printd(DBG_ErrorLvl, "KNL_Q->Full !!!!\r\n");
                }
				else
					printd(DBG_Debug1Lvl, "E->OK\n");
			#else 
				ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_ENC,ubSrcNum,ReceiveResult.H264Result->BSAddr);
			#endif									
#endif			
            }
			else
			{
				ubTemp = ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_ENC,ubSrcNum,ReceiveResult.H264Result->BSAddr);
				if(ubTemp != BUF_OK)
                {
                    printd(DBG_ErrorLvl, "Err3 @%s[0x%X]\n", __func__, ReceiveResult.H264Result->BSAddr);
                }
			}
			
			if(ubRC_GetFlg(ubIdxMap) && ((ulFrmIdx[ubIdxMap]% ubKNL_GetVdoFps()) == (ubKNL_GetVdoFps()-1)) && (ulRefreshCnt >= ubRC_GetRefreshRate(0)))
			{
				ulRefreshCnt = 0;
				//printd(DBG_Debug3Lvl, "Rst RC1\r\n");

				tNodeInfo = tKNL_GetNodeInfo(ubSrcNum,KNL_NODE_H264_ENC);
			#ifndef S2019A
				if(ubKNL_ResetIFlg)
				{
					ubKNL_ResetIFlg = 0;
					H264_ResetIPCnt((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx);
				}
			#endif
				if(ubPreFps != ubRC_GetFps())
				{					
					//printd(DBG_Debug3Lvl, "Rst RC11\r\n");
					
					ubPreFps = ubRC_GetFps();
					if(ReceiveResult.H264Result->EncodeStream == ENCODE_0)
					{				
						H264_EncodeInit((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV,ulBUF_GetBlkBufAddr(0,BUF_IMG_ENC),ubRC_GetFps(),ulKNL_GetVdoGop());//DECODE[0]
					}
					else if(ReceiveResult.H264Result->EncodeStream == ENCODE_1)
					{				
						H264_EncodeInit((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV,ulBUF_GetBlkBufAddr(1,BUF_IMG_ENC),ubRC_GetFps(),ulKNL_GetVdoGop());//DECODE[0]
					}
					else if(ReceiveResult.H264Result->EncodeStream == ENCODE_2)
					{				
						H264_EncodeInit((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV,ulBUF_GetBlkBufAddr(2,BUF_IMG_ENC),ubRC_GetFps(),ulKNL_GetVdoGop());//DECODE[0]
					}
					else if(ReceiveResult.H264Result->EncodeStream == ENCODE_3)
					{				
						H264_EncodeInit((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,tNodeInfo.uwVdoH,tNodeInfo.uwVdoV,ulBUF_GetBlkBufAddr(3,BUF_IMG_ENC),ubRC_GetFps(),ulKNL_GetVdoGop());//DECODE[0]
					}
				}
				
				H264_RcSetEN((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,H264_ENABLE,CBR,ulRC_GetFinalBitRate(tNodeInfo.ubCodecIdx));
				
				if((ubKNL_GetVdoFps() <= 5) && (H264_GetCurrentQP() > 3))
				{
					H264_ResetRateControl(H264_GetCurrentQP() - 3);				
				}
				else
				{
					H264_ResetRateControl(H264_GetCurrentQP());	
				}
				
				H264_SetRCParameter((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,ulRC_GetFinalBitRate(tNodeInfo.ubCodecIdx),ubKNL_GetVdoFps());				
			}
			else if(ubRC_GetFlg(ubIdxMap) && (ubRC_GetUpdateFlg(ubIdxMap)))
			{
				RC_SetUpdateFlg(ubIdxMap,0);
				
				ulRefreshCnt = 0;
				//printd(DBG_Debug3Lvl, "Rst RC2\r\n");
				
				tNodeInfo = tKNL_GetNodeInfo(ubSrcNum,KNL_NODE_H264_ENC);	
			#ifndef S2019A	
				if(ubKNL_ResetIFlg)
				{
					ubKNL_ResetIFlg = 0;						
					H264_ResetIPCnt((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx);
				}				
			#endif
				if(ubPreFps != ubRC_GetFps())
				{					
					//printd(DBG_Debug3Lvl, "Rst RC22\r\n");					
					ubPreFps = ubRC_GetFps();					
					H264_SetFrameRate((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,ubRC_GetFps());					
				}				
				H264_RcSetEN((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,H264_ENABLE,CBR,ulRC_GetFinalBitRate(tNodeInfo.ubCodecIdx));
				if((ubKNL_GetVdoFps() <= 5) && (H264_GetCurrentQP() > 3))
				{
					H264_ResetRateControl(H264_GetCurrentQP() - 3);				
				}
				else
				{
					H264_ResetRateControl(H264_GetCurrentQP());	
				}
				H264_SetRCParameter((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx,ulRC_GetFinalBitRate(tNodeInfo.ubCodecIdx),ubKNL_GetVdoFps());				
			}
			
			//(4)Release IMG/H264
			osSemaphoreRelease(tKNL_ImgSem);
            ubKNL_ImgRdy = 1;	//Codec Ready
			printd(DBG_Debug3Lvl, "H->EOK\r\n");
        }
        //Decode Process
        //========================================================================
        else if(ReceiveResult.H264Result->Type == H264_DECODE)
        {
			//(1)Update SrcNum
            ubSrcNum = ubKNL_ImgSrc;
            KNL_SetNodeState(ubSrcNum,KNL_NODE_H264_DEC,KNL_NODE_STOP);

            //(2)Release Buffer
            //-------------------------------------------------------------
            ubPreNode = ubKNL_GetPreNode(ubSrcNum,KNL_NODE_H264_DEC);
            if((ubPreNode == KNL_NODE_VDO_BS_BUF1) || (ubPreNode == KNL_NODE_VDO_BS_BUF2))
            {
                ubTemp = ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_DEC,ubSrcNum,ReceiveResult.H264Result->BSAddr);
                if(ubTemp != BUF_OK)
                {
                    printd(DBG_ErrorLvl, "Err4 @%s[0x%X]\n", __func__, ReceiveResult.H264Result->BSAddr);
                }
            }

			if(H264_FAIL == ReceiveResult.H264Result->Result)
			{
				printf("H264 Event Fail !!!!\r\n");
				KNL_RestartImgCodec();
			}
			else
				printd(DBG_Debug3Lvl, "H->DOK\r\n");

            //(3)Post-Process
            ubNextNode = ubKNL_GetNextNode(ubSrcNum,KNL_NODE_H264_DEC);

            if(ubKNL_ChkVdoFlowAct(ubSrcNum))
            {
                if(ubNextNode == KNL_NODE_LCD)
                {
                    KNL_ActiveLcdDispBuf(ubSrcNum);
                }
                else
                {
                    tImgProc.ulDramAddr1	= ReceiveResult.H264Result->YuvAddr;
                    tImgProc.ubSrcNum		= ubSrcNum;
                    tImgProc.ubCurNode		= KNL_NODE_H264_DEC;
                    tImgProc.ubNextNode 	= ubNextNode;
                    tImgProc.ulSize			= ((uint32_t)uwKNL_GetVdoH(ubSrcNum))*((uint32_t)uwKNL_GetVdoV(ubSrcNum))*1.5;
                    if(osMessagePut(KNL_VdoCodecProcQueue, &tImgProc, 0) == osErrorResource)
					{
						ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_DEC,ubSrcNum,ReceiveResult.H264Result->BSAddr);
						printd(DBG_ErrorLvl, "KNL_Q->Full !!!!\r\n");
					}
                }
            }

			//(4)Release IMG/H264
			osSemaphoreRelease(tKNL_ImgSem);
			ubKNL_ImgRdy = 1;	//Codec Ready
        }
        //Merge Process
        //========================================================================
        else
        {
            //(0)Update Info First
            ubSrcNum = ubKNL_ImgTrigSrc;
            ubTrigType = ubKNL_ImgTrigType;
            
            //(1)Release IMG/H264
			osSemaphoreRelease(tKNL_ImgSem);
            ubKNL_ImgRdy = 1;	//Codec Ready
			printd(DBG_Debug1Lvl, "IMG->MOK\r\n");
                
            //(2)To Next Node
            if(ubTrigType == KNL_IMG_MERGE_H)
            {
                KNL_SetNodeState(ubSrcNum,KNL_NODE_IMG_MERGE_H,KNL_NODE_STOP);					
                tImgProc.ubCurNode 	= KNL_NODE_IMG_MERGE_H;
                ubNextNode = ubKNL_GetNextNode(ubSrcNum,KNL_NODE_IMG_MERGE_H);
            }				
            tImgProc.ubSrcNum	= ubSrcNum;						
            tImgProc.ubNextNode = ubNextNode;				
            
            if(ubKNL_ChkVdoFlowAct(ubSrcNum))
            {
                if(ubNextNode == KNL_NODE_LCD)
                {
                    KNL_ActiveLcdDispBuf(ubSrcNum);
                }
                else
                {
                    osMessagePut(KNL_VdoCodecProcQueue, &tImgProc, 0);
                }
            }
        }
    }	
}
#endif
//------------------------------------------------------------------------------
void KNL_SetVdoCodec(uint8_t ubVdoCodec)
{
	tKNL_Info.ubVdoCodec = ubVdoCodec;
}

uint8_t ubKNL_GetVdoCodec(void)
{
	return tKNL_Info.ubVdoCodec;
}

//------------------------------------------------------------------------------
void KNL_SetVdoH(uint8_t ubSrcNum,uint16_t uwVdoH)
{
    //printf("@@@KNL_SetVdoH %d %d\n",ubSrcNum,uwVdoH);
	tKNL_Info.uwVdoH[ubSrcNum] = uwVdoH;
}
//------------------------------------------------------------------------------
uint16_t uwKNL_GetVdoH(uint8_t ubSrcNum)
{
	if(ubSrcNum == KNL_SRC_NONE)
	{
		return 0;
	}
	return tKNL_Info.uwVdoH[ubSrcNum];
}
//------------------------------------------------------------------------------
void KNL_SetVdoV(uint8_t ubSrcNum,uint16_t uwVdoV)
{
    //printf("@@@KNL_SetVdoV %d %d\n",ubSrcNum,uwVdoV);
	tKNL_Info.uwVdoV[ubSrcNum] = uwVdoV;
}
//------------------------------------------------------------------------------
uint16_t uwKNL_GetVdoV(uint8_t ubSrcNum)
{
	if(ubSrcNum == KNL_SRC_NONE)
	{
		return 0;
	}
	return tKNL_Info.uwVdoV[ubSrcNum];
}

//------------------------------------------------------------------------------
void KNL_AdoStart(uint8_t ubSrcNum)
{
	if(ubKNL_ExistNode(ubSrcNum,KNL_NODE_ADC))
	{
		if((ubKNL_GetRole() == KNL_SLAVE_AP) || (ubKNL_GetRole() == KNL_MASTER_AP))
		{
		#if (defined(A7130))
			uint8_t ubRxVdo_Path;
			uint8_t ubTxAdo_Path;

			ubRxVdo_Path = ubBB_GetRxVdoDataPath();
			ubTxAdo_Path = ubSrcNum % 4;
			BB_SetDataPath((TXADO)ubTxAdo_Path,BB_RX_ADO_ALL_STA,(PAYLOAD_PATH)ubRxVdo_Path);
		#endif
		#if (defined(RTC676x))
			uint8_t ubRxVdo_Path;
			uint8_t ubTxAdo_Path;

			ubRxVdo_Path = ubBB_GetRxVdoDataPath();
			ubTxAdo_Path = ubSrcNum % 4;
			BB_SetDataPath((TXADO)ubTxAdo_Path,BB_RX_ADO_ALL_STA,(PAYLOAD_PATH)ubRxVdo_Path);
		#endif
		}
		KNL_AdcStart();
	}	
	if(ubKNL_ExistNode(ubSrcNum,KNL_NODE_DAC)||ubKNL_ExistNode(ubSrcNum,KNL_NODE_DAC_BUF)||ubKNL_ExistNode(ubSrcNum,KNL_NODE_COMM_RX_ADO))
	{
		KNL_DacStart(ubSrcNum);
	}
}
//------------------------------------------------------------------------------
void KNL_AdoStop(uint8_t ubSrcNum)
{
	if(ubKNL_ExistNode(ubSrcNum,KNL_NODE_ADC))
	{
		KNL_AdcStop();
	}	
	if(ubKNL_ExistNode(ubSrcNum,KNL_NODE_DAC)||ubKNL_ExistNode(ubSrcNum,KNL_NODE_DAC_BUF)||ubKNL_ExistNode(ubSrcNum,KNL_NODE_COMM_RX_ADO))
	{
		KNL_DacStop(ubSrcNum);
	}	
}
//------------------------------------------------------------------------------
void KNL_AdoResume(uint8_t ubSrcNum)
{
	if(ubKNL_ExistNode(ubSrcNum, KNL_NODE_ADC))
	{
		ubKNL_AdcFlowActiveFlg = 1;
	}
}
//------------------------------------------------------------------------------
void KNL_AdoSuspend(uint8_t ubSrcNum)
{
	if(ubKNL_ExistNode(ubSrcNum, KNL_NODE_ADC))
	{
		ubKNL_AdcFlowActiveFlg = 0;
		BUF_Reset(BUF_ADO_ADC);
	}
}
//------------------------------------------------------------------------------
void KNL_AdcStart(void)
{
	if(ubKNL_AdcFlowActiveFlg)
		return;
	ubKNL_AdcFlowActiveFlg = 1;
	ADO_AdcStart();
}
//------------------------------------------------------------------------------
void KNL_AdcStop(void)
{
	//======== Pre-Process ========
	ubKNL_AdcFlowActiveFlg = 0;
#if defined(BSP_DVR_SDK)
    if(!((ubPLY_GetOpMode() == PLY_MODE_R) || (ubPLY_GetOpMode() == PLY_MODE_PR)))
        ADO_AdcStop();
#else
    ADO_AdcStop();
#endif
	//======== Transient ==========
	//Timer_Delay_ms(500);

	//======== Post-Process =======
	BUF_Reset(BUF_ADO_ADC);
}
//------------------------------------------------------------------------------
void KNL_DacStart(uint8_t ubSrcNum)
{
	ubKNL_DacFlowActiveFlg[ubSrcNum] = 1;
}
//------------------------------------------------------------------------------
void KNL_DacStop(uint8_t ubSrcNum)
{
	ubKNL_DacFlowActiveFlg[ubSrcNum] = 0;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_WaitNodeFinish(uint8_t ubSrcNum)
{
	while(1)
	{
		if(ubSrcNum == KNL_SRC_NONE)
			return 0;

		if(ubKNL_ChkNodeFinish(ubSrcNum))
		{
			printd(DBG_CriticalLvl, "Src[%d]->Done\r\n", ubSrcNum);
			break;
		}
		else
		{
			osDelay(10);
		}
	}
	return 1;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_ChkNodeFinish(uint8_t ubSrcNum)
{
	KNL_PROCESS tProc;
	static uint8_t ubKNL_ChkNodeCnt = 0;
	uint8_t ubSrcNumMap;
	uint8_t ubDecNode = 0;
#ifdef OP_AP
	uint8_t ubChkNum = 4;
	KNL_SRC	tSrc, tSrcS;

#if defined(BSP_DVR_SDK)
	ubChkNum = 1;
#endif

	tSrcS = (KNL_SRC)ubSrcNum;
	for(tSrc = tSrcS; tSrc < (tSrcS + ubChkNum); tSrc++)
	{
		ubSrcNum = tSrcS;
#endif

	ubSrcNumMap = ubKNL_SrcNumMap(ubSrcNum);
	//AvgPly Related
	if(tKNL_GetPlyMode() == KNL_AVG_PLY)
	{
		while(1)
		{
			if(osMessages(KNL_AvgPlyQ[ubSrcNumMap].Id))
			{
				osMessageGet(KNL_AvgPlyQ[ubSrcNumMap].Id, &tProc, 0);
				ubKNL_ReleaseBsBufAddr(KNL_NODE_H264_DEC,ubSrcNumMap,tProc.ulDramAddr2);
			}
			else
			{
				ubKNL_AvgPlyCnt[ubSrcNumMap] = 0;
				ubKNL_AvgPlyStartFlg[ubSrcNumMap] = 0;
				break;
			}
		}
	}   
	
	//IMG,H264 Related
	ubDecNode = ubKNL_ExistNode(ubSrcNum, KNL_NODE_H264_DEC);
	if(ubKNL_ExistNode(ubSrcNum,KNL_NODE_H264_ENC)||ubKNL_ExistNode(ubSrcNum,KNL_NODE_H264_DEC)||ubKNL_ExistNode(ubSrcNum,KNL_NODE_IMG_MERGE_BUF)||ubKNL_ExistNode(ubSrcNum,KNL_NODE_IMG_MERGE_H))
	{
		if(ubKNL_ChkImgRdy() == 0)
		{
			if((ubKNL_ChkNodeCnt++ >= 30) && (ubDecNode))
				KNL_RecoveryImgCodec();
			else
				return 0;
		}
		if(ubDecNode)
			osDelay(50);
	}
	ubKNL_ChkNodeCnt = 0;

		//JPEG Related
		if(ubKNL_ExistNode(ubSrcNum,KNL_NODE_JPG_ENC)||ubKNL_ExistNode(ubSrcNum,KNL_NODE_JPG_DEC1)||ubKNL_ExistNode(ubSrcNum,KNL_NODE_JPG_DEC2))
		{
			if(osSemaphoreWait(JPEG_CodecSem, 0) == osOK)
			{
				osSemaphoreRelease(JPEG_CodecSem);
			}
			else
			{
				return 0;
			}
		}

		//SEN Related
		if(ubKNL_ExistNode(ubSrcNum,KNL_NODE_SEN))
		{
			if(ubKNL_ChkSenStateChangeDone() == 0)
			{
				return 0;
			}
		}
#ifdef OP_AP
	}
#endif
	return 1;
}
//------------------------------------------------------------------------------
void KNL_SetTRXPathActivity(void)
{
#if (defined(A7130))
	uint8_t ubTxAdo_Path;

	ubKNL_BbPathAct = TRUE;
	ubTxAdo_Path	= ubBB_GetTxAdoDataPath();
	BB_SetDataPath((TXADO)ubTxAdo_Path, BB_RX_ADO_ALL_STA, BB_OPEN_ALL_PAYLOAD);
#elif (defined(RTC676x))
	uint8_t ubTxAdo_Path;

	ubKNL_BbPathAct = TRUE;
	ubTxAdo_Path	= ubBB_GetTxAdoDataPath();
	BB_SetDataPath((TXADO)ubTxAdo_Path, BB_RX_ADO_ALL_STA, BB_OPEN_ALL_PAYLOAD);
#else
	ubKNL_BbPathAct = TRUE;
#endif
}
//------------------------------------------------------------------------------
void KNL_DisManuCtrlTRXPath(void)
{
	ubKNL_BbPathAct = FALSE;
}
//------------------------------------------------------------------------------
void KNL_VdoStart(uint8_t ubSrcNum)
{
	KNL_NODE_INFO tNodeInfo;
	uint16_t i;
	uint8_t ubSrcNumMap;
#if (defined(OP_AP) && defined(A7130))
	uint8_t ubRxVdo_OriPath,ubRxVdo_NewPath;
	uint8_t ubTxAdo_Path;
#endif	
	
	ubSrcNumMap = ubSrcNumMap;	//Avoid Warning

#if defined(BSP_DVR_SDK)
    //printf("KNL_VdoStart %d\n",ubSrcNum);

	if(ubKNL_GetSrcNumPosition((KNL_SRC)ubSrcNum) == KNL_REMOTE)
	{
	    ubSrcNumMap = ubKNL_SrcNumMap(ubSrcNum);
#else
	ubSrcNumMap = ubKNL_SrcNumMap(ubSrcNum);
	if(ubSrcNumMap <= KNL_STA4)
	{
#endif		
		ubKNL_VdoFlowActiveFlg[ubSrcNum] = 1;
		ubKNL_RcvFirstIFrame[ubSrcNum]	 = 0;

		for(i = 0; i < 256; i++)
		{
			if(ubKNL_ExistNode(ubSrcNum,i))
			{
				tKNL_NodeState[ubSrcNum][i] = KNL_NODE_START;
			}
		}

		if(ubKNL_ExistNode(ubSrcNum,KNL_NODE_H264_ENC))
		{
			tNodeInfo = tKNL_GetNodeInfo(ubSrcNum,KNL_NODE_H264_ENC);
			H264_ResetIPCnt((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx);
			ulKNL_CurFrmIdx[(H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx] = 0;
		}

		if(ubKNL_ExistNode(ubSrcNum,KNL_NODE_SEN))
		{
			KNL_SenStart(ubSrcNum);
		}
#ifdef S2019A
		if(ubKNL_ExistNode(ubSrcNum,KNL_NODE_COMM_TX_VDO) || ubKNL_ExistNode(ubSrcNum,KNL_NODE_COMM_RX_VDO) ||
		   ubKNL_ExistNode(ubSrcNum,KNL_NODE_COMM_TX_ADO) || ubKNL_ExistNode(ubSrcNum,KNL_NODE_COMM_RX_ADO))
		{
			sPRF_DevId_t tDevId[] = {
									  [KNL_STA1] = sPRF_STA1,
									  [KNL_STA2] = sPRF_STA2,
									  [KNL_STA3] = sPRF_STA3,
									  [KNL_STA4] = sPRF_STA4};
		#ifdef OP_AP
			KNL_RecordFunc_t tRecAct = tKNL_GetRecordFunc();
			if(KNL_VIDEO_PLAY == tRecAct && tKNL_GetPlayDestFld() == KNL_REAL_FLD)
				return;
		#endif
			sPRF_DrvOpen(tDevId[ubSrcNumMap]);
		}
#endif
#if (defined(OP_AP) && defined(A7130))
		if(ubKNL_ExistNode(ubSrcNum,KNL_NODE_COMM_TX_VDO) || ubKNL_ExistNode(ubSrcNum,KNL_NODE_COMM_RX_VDO) ||
		   ubKNL_ExistNode(ubSrcNum,KNL_NODE_COMM_TX_ADO) || ubKNL_ExistNode(ubSrcNum,KNL_NODE_COMM_RX_ADO))
		{
			ubRxVdo_OriPath = ubBB_GetRxVdoDataPath();
			ubTxAdo_Path	= ubBB_GetTxAdoDataPath();
			if(TRUE == ubKNL_BbPathAct)
			{
				ubRxVdo_OriPath = BB_PAYLOAD_NONE;
				ubKNL_BbPathAct = FALSE;
			}
			if(ubSrcNumMap == 0)
			{
				ubRxVdo_NewPath = ubRxVdo_OriPath | BB_OPEN_STA1_PAYLOAD;
			}
			else if(ubSrcNumMap == 1)
			{
				ubRxVdo_NewPath = ubRxVdo_OriPath | BB_OPEN_STA2_PAYLOAD;
			}
			else if(ubSrcNumMap == 2)
			{
				ubRxVdo_NewPath = ubRxVdo_OriPath | BB_OPEN_STA3_PAYLOAD;
			}
			else if(ubSrcNumMap == 3)
			{
				ubRxVdo_NewPath = ubRxVdo_OriPath | BB_OPEN_STA4_PAYLOAD;
			}
			BB_SetDataPath((TXADO)ubTxAdo_Path,BB_RX_ADO_ALL_STA,(PAYLOAD_PATH)ubRxVdo_NewPath);
		}
#endif
	}
#if defined(BSP_DVR_SDK)
    else if(ubKNL_GetSrcNumPosition((KNL_SRC)ubSrcNum) == KNL_LOCAL)
	{
		ubKNL_VdoFlowActiveFlg[ubSrcNum] = 1;		

		for(i = 0; i < 256; i++)
		{
			if(ubKNL_ExistNode(ubSrcNum,i))
			{
				tKNL_NodeState[ubSrcNum][i] = KNL_NODE_START;
			}
		}

		if(ubKNL_ExistNode(ubSrcNum,KNL_NODE_H264_ENC))
		{
			tNodeInfo = tKNL_GetNodeInfo(ubSrcNum,KNL_NODE_H264_ENC);
			H264_ResetIPCnt((H264_ENCODE_INDEX)tNodeInfo.ubCodecIdx);
		}

		if(ubKNL_ExistNode(ubSrcNum,KNL_NODE_SEN))
		{
			KNL_SenStart(ubSrcNum);
		}	
	}
	else
	{
		ubKNL_VdoFlowActiveFlg[ubSrcNum] = 1;
	}
#endif
} 
//------------------------------------------------------------------------------
void KNL_VdoStop(uint8_t ubSrcNum)
{
	uint16_t i;
	uint8_t ubSrcNumMap;
#if (defined(OP_AP) && defined(A7130))
	uint8_t ubRxVdo_OriPath,ubRxVdo_NewPath;
	uint8_t ubTxAdo_Path;
#endif	

	ubSrcNumMap = ubKNL_SrcNumMap(ubSrcNum);
	if(ubSrcNumMap <= KNL_STA4)
	{
		ubKNL_VdoFlowActiveFlg[ubSrcNum] 	= 0;
		ubKNL_RcvFirstIFrame[ubSrcNum]	 	= 0;
		ubKNL_VdoResendITwcFlg[ubSrcNumMap] = FALSE;
		ubKNL_VdoResChgTwcFlg[ubSrcNumMap]  = FALSE;
		ubKNL_AppResendIFrmFlg[ubSrcNumMap]	= FALSE;
		for(i = 0; i < 256; i++)
		{
			tKNL_NodeState[ubSrcNum][i] = KNL_NODE_STOP;
		}
#ifdef S2019A
		if(ubKNL_ExistNode(ubSrcNum,KNL_NODE_COMM_TX_VDO) || ubKNL_ExistNode(ubSrcNum,KNL_NODE_COMM_RX_VDO) ||
		   ubKNL_ExistNode(ubSrcNum,KNL_NODE_COMM_TX_ADO) || ubKNL_ExistNode(ubSrcNum,KNL_NODE_COMM_RX_ADO))
		{
			sPRF_DevId_t tDevId[] = {
									  [KNL_STA1] = sPRF_STA1,
									  [KNL_STA2] = sPRF_STA2,
									  [KNL_STA3] = sPRF_STA3,
									  [KNL_STA4] = sPRF_STA4
									};
		#ifdef OP_AP
			KNL_RecordFunc_t tRecAct = tKNL_GetRecordFunc();
			if((TRUE == ubKNL_BbPathAct) && (KNL_VIDEO_PLAY != tRecAct))
				return;
		#endif
			sPRF_DrvClose(tDevId[ubSrcNumMap]);
		}
#endif
#if (defined(OP_AP) && defined(A7130))
		if(ubKNL_ExistNode(ubSrcNum,KNL_NODE_COMM_TX_VDO) || ubKNL_ExistNode(ubSrcNum,KNL_NODE_COMM_RX_VDO) ||
		   ubKNL_ExistNode(ubSrcNum,KNL_NODE_COMM_TX_ADO) || ubKNL_ExistNode(ubSrcNum,KNL_NODE_COMM_RX_ADO))
		{
			KNL_RecordFunc_t tRecAct = tKNL_GetRecordFunc();

			if((TRUE == ubKNL_BbPathAct) && (KNL_VIDEO_PLAY != tRecAct))
				return;
			if((!ubKNL_ChkDacFlowAct((uint8_t)ubSrcNum)) || (KNL_VIDEO_PLAY == tRecAct))
			{
				ubRxVdo_OriPath = ubBB_GetRxVdoDataPath();
				ubTxAdo_Path	= ubBB_GetTxAdoDataPath();
				if(ubSrcNumMap == 0)
				{
					ubRxVdo_NewPath = ubRxVdo_OriPath & 0xFE;
				}
				else if(ubSrcNumMap == 1)
				{
					ubRxVdo_NewPath = ubRxVdo_OriPath & 0xFD;
				}
				else if(ubSrcNumMap == 2)
				{
					ubRxVdo_NewPath = ubRxVdo_OriPath & 0xFB;
				}
				else if(ubSrcNumMap == 3)
				{
					ubRxVdo_NewPath = ubRxVdo_OriPath & 0xF7;
				}
				BB_SetDataPath((TXADO)ubTxAdo_Path,BB_RX_ADO_ALL_STA,(PAYLOAD_PATH)ubRxVdo_NewPath);
			}
		}
#endif
		ubKNL_VdoFlowActiveFlg[ubSrcNum] = 0;
		KNL_VdoSuspend(ubSrcNum);
		if(ubKNL_ExistNode(ubSrcNum, KNL_NODE_VDO_BS_BUF1))
		{
			BUF_Reset((BUF_VDO_MAIN_BS0 + ubSrcNumMap));
		}
#ifdef RTC676x
		if(KNL_VdoPacketizeQue != NULL)
			osMessageReset(KNL_VdoPacketizeQue);
		BUF_Reset(BUF_VDO_PACKETIZE_BIG);
		BUF_Reset(BUF_VDO_PACKETIZE_SMALL);
		if(KNL_AdoPacketizeQue != NULL)
			osMessageReset(KNL_AdoPacketizeQue);
		BUF_Reset(BUF_ADO_PACKETIZE);
#endif			
	}
}
//------------------------------------------------------------------------------
void KNL_VdoSuspend(uint8_t ubSrcNum)
{
	uint16_t i;
	uint8_t ubRole;

	for(i = 0; i < 256; i++)
		tKNL_NodeState[ubSrcNum][i] = KNL_NODE_STOP;
	ubKNL_RcvFirstIFrame[ubSrcNum]   = 0;
	ulKNL_OutVdoFpsCnt[ubSrcNum]     = 0;
	ulKNL_OutVdoFpsCntTemp[ubSrcNum] = 0;
	ulKNL_InVdoFpsCnt[ubSrcNum]      = 0;
	ulKNL_InVdoFpsCntTemp[ubSrcNum]  = 0;
#if defined(BSP_DVR_SDK)
    if(ubKNL_GetSrcNumPosition((KNL_SRC)ubSrcNum) == KNL_REMOTE)
#endif
    {
    	ubRole = ubKNL_SrcNumMap(ubSrcNum);
    	ulKNL_VdoOutAccCnt[ubRole] 		 = 0;
    	ulKNL_VdoOutAccCntTemp[ubRole] 	 = 0;
    	ulKNL_FrmTRxNum[ubRole]		 	 = 0;
    	ulKNL_FrmTRxNumTemp[ubRole]	 	 = 0;
    	ubKNL_VdoResendITwcFlg[ubRole] 	 = FALSE;
    	ubKNL_VdoResChgTwcFlg[ubRole]  	 = FALSE;
    	ubKNL_AppResendIFrmFlg[ubRole] 	 = FALSE;
    }
}
//------------------------------------------------------------------------------
void KNL_VdoResume(uint8_t ubSrcNum)
{
	uint16_t i;

	for(i = 0; i < 256; i++)
	{
		if(ubKNL_ExistNode(ubSrcNum, i))
			tKNL_NodeState[ubSrcNum][i] = KNL_NODE_START;
	}
}
//------------------------------------------------------------------------------
void KNL_SenStart(uint8_t ubSrcNum)
{
#if (defined(OP_STA) || defined(BSP_DVR_SDK))
	uint32_t ulTemp;
	if(ubSEN_GetPathSrc(SENSOR_PATH1) == ubSrcNum)
	{
		if(!ubSEN_GetActiveFlg(SENSOR_PATH1))
		{
			BUF_Reset(BUF_SEN_1_YUV);
			ulTemp = ulBUF_GetSen1YuvFreeBuf();
			SEN_SetPathAddr(SENSOR_PATH1,ulTemp);
			SEN_SetActiveFlg(SENSOR_PATH1,1);
			SEN_SetPathState(SENSOR_PATH1, 1);
			SEN->VIDEO_STR_EN_1 = 1;
		}
	}
	else if(ubSEN_GetPathSrc(SENSOR_PATH2) == ubSrcNum)
	{
		if(!ubSEN_GetActiveFlg(SENSOR_PATH2))
		{
			BUF_Reset(BUF_SEN_2_YUV);
			ulTemp = ulBUF_GetSen2YuvFreeBuf();
			SEN_SetPathAddr(SENSOR_PATH2,ulTemp);
			SEN_SetActiveFlg(SENSOR_PATH2,1);
			SEN_SetPathState(SENSOR_PATH2, 1);
			SEN->VIDEO_STR_EN_2 = 1;
		}
	}
	else if(ubSEN_GetPathSrc(SENSOR_PATH3) == ubSrcNum)
	{
		if(!ubSEN_GetActiveFlg(SENSOR_PATH3))
		{
			BUF_Reset(BUF_SEN_3_YUV);
			ulTemp = ulBUF_GetSen3YuvFreeBuf();
			SEN_SetPathAddr(SENSOR_PATH3,ulTemp);
			SEN_SetActiveFlg(SENSOR_PATH3,1);
			SEN_SetPathState(SENSOR_PATH3, 1);
			SEN->VIDEO_STR_EN_3 = 1;
		}
	}

	if(!ubKNL_SenStartFlg)
	{
/*
        SEN_SetPathAddr(ISP_3DNR, ulBUF_GetBlkBufAddr(0, BUF_ISP_3DNR_IP));
        SEN_SetPathAddr(ISP_MD_W0, ulBUF_GetBlkBufAddr(0, BUF_ISP_MD_W0_IP));
        SEN_SetPathAddr(ISP_MD_W1, ulBUF_GetBlkBufAddr(0, BUF_ISP_MD_W1_IP));
        SEN_SetPathAddr(ISP_MD_W2, ulBUF_GetBlkBufAddr(0, BUF_ISP_MD_W2_IP));
*/
		SEN_UpdatePathAddr();
		SEN_SetStateChangeFlg(1);
		//SEN_SetFirstOutFlg(1);
		SEN_SetIspOutEn(TRUE);
		ubKNL_SenStartFlg = 1;
	}
#endif
}
//------------------------------------------------------------------------------
void KNL_SenStop(uint8_t ubSrcNum)
{	
	uint8_t ubOffFlg = 0;	

	ubOffFlg = ubOffFlg;
#if (defined(OP_STA) || (defined(OP_AP) && defined(BSP_DVR_SDK)))
	if(ubSEN_GetPathSrc(SENSOR_PATH1) == ubSrcNum)
	{
		SEN_SetActiveFlg(SENSOR_PATH1,0);
	}
	else if(ubSEN_GetPathSrc(SENSOR_PATH2) == ubSrcNum)
	{
		SEN_SetActiveFlg(SENSOR_PATH2,0);
	}
	else if(ubSEN_GetPathSrc(SENSOR_PATH3) == ubSrcNum)
	{
		SEN_SetActiveFlg(SENSOR_PATH3,0);
	}
	ubOffFlg = 1;
	if(ubSEN_GetActiveFlg(SENSOR_PATH1))
	{
		ubOffFlg = 0;
	}
	if(ubSEN_GetActiveFlg(SENSOR_PATH2))
	{
		ubOffFlg = 0;
	}
	if(ubSEN_GetActiveFlg(SENSOR_PATH3))
	{
		ubOffFlg = 0;
	}
	if(ubOffFlg)
	{
		ubKNL_SenStartFlg = 0;
#if defined(BSP_DVR_SDK)
		SEN_SetIspOutEn(FALSE);
#endif	
	}
#endif
}
//------------------------------------------------------------------------------
void KNL_ImgStabNotifyFunc(void)
{
#if (defined(OP_STA) || (defined(OP_AP) && defined(BSP_DVR_SDK)))
    SEN_SetFrameRate(SENSOR_PATH1, ubKNL_GetVdoFps());
#if (defined(OP_AP) && defined(BSP_DVR_SDK))
	//SEN_SetFrameRate(SENSOR_PATH2, ubKNL_GetVdoFps());
	SEN_SetFrameRate(SENSOR_PATH2, HD_RES_FPS_LP);
#endif
#if (defined(OP_STA)&&(defined(BSP_VBM_SDK)||defined(BSP_RVCS_SDK))&&defined(VDO_SUBPATH_ENABLE)&&(VDO_SUBPATH_ENABLE!=0))
    SEN_SetFrameRate(SENSOR_PATH2, HD_SUB_RES_FPS);
#elif(defined(OP_STA)&&defined(BSP_DVR_SDK)&&defined(VDO_SUBPATH_ENABLE)&&(VDO_SUBPATH_ENABLE!=0))
    SEN_SetFrameRate(SENSOR_PATH2, HD_SUB_RES_FPS);
#endif
	SEN_SetFirstOutFlg(0);
#endif
}
//------------------------------------------------------------------------------
uint8_t ubKNL_ChkSenStateChangeDone(void)
{
#if (defined(OP_STA) || (defined(OP_AP) && defined(BSP_DVR_SDK)))
	return (!ubSEN_GetStateChangeFlg());
#else
	return 1;
#endif
}
//------------------------------------------------------------------------------
void KNL_SDUpgradeFwFunc(void)
{
	FWU_UpgResult_t tFwuUpgRet;

	KNL_Stop();
	tFwuUpgRet = FWU_SdUpgradeStart(ulBUF_GetFreeAddr());
	printd(DBG_CriticalLvl, "\r\nFW Upgrade %s\r\n", (FWU_UPG_SUCCESS == tFwuUpgRet)?"Success":"Fail !");
	if(FWU_UPG_SUCCESS != tFwuUpgRet)
	{
		KNL_ReStart();
		return;
	}
	SYS_Reboot();
}
//------------------------------------------------------------------------------
void KNL_SoftwareDelay_ms(uint32_t ulms)
{
	uint32_t Time;
	Time = KNL_TIMER_Get1ms();
	while(1)
	{
		if(KNL_TIMER_Get1ms()-Time > ulms)
			break;
	}
}
//------------------------------------------------------------------------------
uint8_t ubKNL_JPEGEncode(JPEG_CODEC_FMT_t tEncodeFmt, JPEG_CODEC_FN_MODE_t tEncodeNotify, uint16_t uwH, uint16_t uwV, uint32_t ulVdoAddr, uint32_t ulJpgAddr)
{
	JPEG_FIFO_Addr_t 	tJpgFiFo;
	JPEG_ENC_INFO_t 	tJpgEncInfo;
	JPEG_CODEC_FN_ES_t	tJpgCodecFnEs;
	uint8_t ubJpgRet = JPEG_PASS;
#if (defined(BSP_DVR_SDK) || (defined(BSP_RVCS_SDK)&&defined(OP_STA)&& APP_PHOTOGRAPH_FUNC_ENABLE))
    uint8_t *pJpgHeader;
#endif

	tJpgFiFo.ulJpeg_Buf_Start	= ulJpgAddr;
#if (defined(OP_AP) && defined(BSP_DVR_SDK))
	if(ubSEN_CaptureScaleUpGet() == 1)
	    tJpgFiFo.ulJpeg_Buf_End		= ulJpgAddr + KNL_JPG_BS_BIGSIZE;
	else
#endif
	    tJpgFiFo.ulJpeg_Buf_End		= ulJpgAddr + KNL_JPG_BS_SIZE;
	JPEG_Ring_FIFO_Setup(tJpgFiFo);

	JPEG_Set_Start_Address(ulVdoAddr,ulJpgAddr);

	tJpgEncInfo.uwH_ORI_SIZE		= uwH;
	tJpgEncInfo.uwH_SIZE			= uwH;
	tJpgEncInfo.uwV_SIZE			= uwV;
	tJpgEncInfo.uwH_START			= 0;
	tJpgEncInfo.uwV_START			= 0;
	tJpgEncInfo.ubJPG_Fmt 			= tEncodeFmt;

    	JPEG_Set_QP_Value(ubKNL_GetJpegQp());
#if (defined(BSP_DVR_SDK) || (defined(BSP_RVCS_SDK)&&defined(OP_STA)&& APP_PHOTOGRAPH_FUNC_ENABLE))
    pJpgHeader = (uint8_t *)ulJpgAddr - KNL_JPG_HEADER_SIZE;
	if(tJpgEncInfo.ubJPG_Fmt == JPEG_YUV422)
		pJpgHeader[KNL_JPG_FRAMEHEADER_START+KNL_JPEG_HEADER_FMT_OFFSET] = 0x21;
	else if(tJpgEncInfo.ubJPG_Fmt == JPEG_YUV420)
		pJpgHeader[KNL_JPG_FRAMEHEADER_START+KNL_JPEG_HEADER_FMT_OFFSET] = 0x22;
    JPEG_UpdateQuantTab2Header(&pJpgHeader[KNL_JPG_DQT_START], 5);
#endif

	tJpgCodecFnEs.tEM				= (TRUE == tKNL_JpegSigProc.ubProcFlag)?JPEG_SEMAPHORE:JPEG_QUEUE;
	tJpgCodecFnEs.pvEvent			= (TRUE == tKNL_JpegSigProc.ubProcFlag)?&tKNL_JpegSigProc.osWaitSem:&KNL_QueueJpegMonit;
	tJpgCodecFnEs.tNotifyMode		= tEncodeNotify;
	JPEG_Encode_Setup(tJpgEncInfo, tJpgCodecFnEs);

	JPEG_Codec_Enable();

	if(tJpgCodecFnEs.tNotifyMode ==  JPEG_FN_USE_POLLING)
	{
		uint8_t ubCodecRetryNum = 0, ubCodecRetryCnt = 150;
		while(1)
		{
			if(JPEG_CODEC_PROCESS != ubJPEG_ReportCodecStatus())
				break;
			if(ubCodecRetryNum++ >= ubCodecRetryCnt)
			{
				printd(DBG_ErrorLvl, "JPG Encode timeout !\n");
				ubJpgRet = JPEG_FAIL;
				break;
			}
			//TIMER_Delay_ms(1);//osDelay(10);
			KNL_SoftwareDelay_ms(1);
		}
#if ((defined(OP_AP) && defined(BSP_DVR_SDK)))
		if(((uwH == VDO_LOCAL_STORAGE_H_SIZE) && (uwV == VDO_LOCAL_STORAGE_V_SIZE)) || (ubSEN_CaptureScaleUpGet() == 1))
			KNL_SetLocalSnapShotSz(ulJPEG_Get_BS_Size());
#endif
#if (defined(BSP_RVCS_SDK)&&defined(OP_STA)&& APP_PHOTOGRAPH_FUNC_ENABLE)
        KNL_SetLocalSnapShotSz(ulJPEG_Get_BS_Size());
#endif
		JPEG_Codec_Disable();
		osSemaphoreRelease(JPEG_CodecSem);
		printd(DBG_Debug3Lvl, "Size{JPEG}:0x%x @ WAIT Mode\r\n", ulJPEG_Get_BS_Size());
	}
	return ubJpgRet;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_JPEGDecode(KNL_NODE_INFO *pKNL_NodeInfo, JPEG_CODEC_FMT_t tDecodeFmt, JPEG_CODEC_FN_MODE_t tDecodeNotify, uint16_t uwH, uint16_t uwV, uint32_t ulVdoAddr, uint32_t ulJpgAddr)
{
	JPEG_FIFO_Addr_t 	tJpgFiFo;
	JPEG_DEC_INFO_t 	tJpgDecInfo;
	JPEG_CODEC_FN_ES_t	tJpgCodecFnEs;
	uint8_t ubJpgRet = JPEG_PASS;

	tJpgFiFo.ulJpeg_Buf_Start		= ulJpgAddr;
	tJpgFiFo.ulJpeg_Buf_End			= ulJpgAddr + KNL_JPG_BS_SIZE;
	JPEG_Ring_FIFO_Setup(tJpgFiFo);

	JPEG_Set_Start_Address(ulVdoAddr,ulJpgAddr);

	tJpgDecInfo.uwH_ORI_SIZE		= uwH;
	tJpgDecInfo.uwH_SIZE			= uwH;
	tJpgDecInfo.uwV_SIZE			= uwV;
	tJpgDecInfo.uwQP				= ubKNL_GetJpegQp();
	tJpgDecInfo.ubJPG_Fmt 			= tDecodeFmt;
	
	//justin 2019.07.24
	//justin 2019.08.05
	//tJpgDecInfo.ubJPG_ScaleMode		= 0;
	//tJpgDecInfo.ubJPG_ScaleMode		= 1;	//PIP
	tJpgDecInfo.ubJPG_ScaleMode		= pKNL_NodeInfo->ubJpgScale;		//LCD_DISP_2T_V,KNL_DISP_DUAL_C		= 1,			//!< 1 Top,1 Bottom
	
	//tJpgDecInfo.ubJPG_Mirror		= (pKNL_NodeInfo->ubHMirror)?JPEG_H_MIRROR:(pKNL_NodeInfo->ubVMirror)?JPEG_V_MIRROR:JPEG_MIRROR_DISABLE;
	//tJpgDecInfo.ubJPG_Mirror		= 3;
#if defined(BSP_DVR_SDK)
#if APP_FS_FILE_LIST_STYLE
	if(KNL_ThmShowInfo.ubShowingThmFlg==0)
		tJpgDecInfo.ubJPG_Mirror    = (pKNL_NodeInfo->ubHMirror)+(pKNL_NodeInfo->ubVMirror<<1);
	else if(KNL_ThmShowInfo.ubShowingThmFlg==1)
		tJpgDecInfo.ubJPG_Mirror    = (pKNL_NodeInfo->ubHMirror)?JPEG_H_MIRROR:(pKNL_NodeInfo->ubVMirror)?JPEG_V_MIRROR:JPEG_MIRROR_DISABLE;
#else
	tJpgDecInfo.ubJPG_Mirror        = (pKNL_NodeInfo->ubHMirror)+(pKNL_NodeInfo->ubVMirror<<1);
#endif
#else
	tJpgDecInfo.ubJPG_Mirror		= (pKNL_NodeInfo->ubHMirror)?JPEG_H_MIRROR:(pKNL_NodeInfo->ubVMirror)?JPEG_V_MIRROR:JPEG_MIRROR_DISABLE;
#endif	
	
	tJpgDecInfo.ubJPG_Rotate		= (pKNL_NodeInfo->ubRotate)?JPEG_ROT_90Deg:JPEG_ROT_DISABLE;

	tJpgCodecFnEs.tEM				= (TRUE == tKNL_JpegSigProc.ubProcFlag)?JPEG_SEMAPHORE:JPEG_QUEUE;
	tJpgCodecFnEs.pvEvent			= (TRUE == tKNL_JpegSigProc.ubProcFlag)?&tKNL_JpegSigProc.osWaitSem:&KNL_QueueJpegMonit;
	tJpgCodecFnEs.tNotifyMode       = tDecodeNotify;
	JPEG_Decode_Setup(tJpgDecInfo, tJpgCodecFnEs);

	JPEG_Codec_Enable();

	if(tJpgCodecFnEs.tNotifyMode == JPEG_FN_USE_POLLING)
	{
		uint8_t ubCodecRetryNum = 0, ubCodecRetryCnt = 150;
		while(1)
		{
			if(JPEG_CODEC_PROCESS != ubJPEG_ReportCodecStatus())
				break;
			if(ubCodecRetryNum++ >= ubCodecRetryCnt)
			{
				printd(DBG_ErrorLvl, "JPG Decode timeout !\n");
				ubJpgRet = JPEG_FAIL;
				break;
			}
			//TIMER_Delay_ms(1);//osDelay(10);
			KNL_SoftwareDelay_ms(1);
		}
		JPEG_Codec_Disable();
		osSemaphoreRelease(JPEG_CodecSem);
	}
	return ubJpgRet;
}
//------------------------------------------------------------------------------
void KNL_SetVdoRoleInfoCbFunc(pvRoleMap2Src VdoRoleMap_cb)
{
	ptKNL_VdoRoleMap2SrcNum = VdoRoleMap_cb;
}
//------------------------------------------------------------------------------
void KNL_SetAdoRoleInfoCbFunc(pvRoleMap2Src AdoRoleMap_cb)
{
	ptKNL_AdoRoleMap2SrcNum = AdoRoleMap_cb;
}
//------------------------------------------------------------------------------
uint8_t KNL_GetRssiValue(KNL_ROLE tKNL_Role)
{
#ifdef A7130
	GET_RSSI_ROLE tBB_RssiRole[6] = {[KNL_STA1] 	 = BB_GET_STA1_RSSI,
								     [KNL_STA2] 	 = BB_GET_STA2_RSSI,
									 [KNL_STA3] 	 = BB_GET_STA3_RSSI,
								     [KNL_STA4] 	 = BB_GET_STA4_RSSI,
									 [KNL_SLAVE_AP]  = BB_GET_SLAVE_AP_RSSI,
									 [KNL_MASTER_AP] = BB_GET_MASTER_AP_RSSI};
	return ubBB_GetRssiValue(tBB_RssiRole[tKNL_Role]);
#else
	return 200;
#endif
}
//------------------------------------------------------------------------------
uint8_t KNL_GetPerValue(KNL_ROLE tKNL_Role)
{
#ifdef A7130
	GET_PER_ROLE tBB_PerRole[6] = 	{[KNL_STA1] 	 = BB_GET_STA1_PER,
								     [KNL_STA2] 	 = BB_GET_STA2_PER,
									 [KNL_STA3] 	 = BB_GET_STA3_PER,
								     [KNL_STA4] 	 = BB_GET_STA4_PER,
									 [KNL_SLAVE_AP]  = BB_GET_SLAVE_AP_PER,
									 [KNL_MASTER_AP] = BB_GET_MASTER_AP_PER};
	return (100 - ubBB_GetPer(BB_HEAD_PER, tBB_PerRole[tKNL_Role]));
#endif
#ifdef RTC676x
	uint8_t ubPerValue = 0;
#if !TRXBW_RPT_EN
	uint8_t ubCurFps;

	if(!ubKNL_TargetFps)
		KNL_SetTargetFps(ubKNL_GetVdoFps());
	ubCurFps   = (ubKNL_OutFps[tKNL_Role] > ubKNL_TargetFps)?ubKNL_TargetFps:ubKNL_OutFps[tKNL_Role];
	ubPerValue = ((float)ubCurFps / (float)ubKNL_TargetFps) * 100;
#else
	uint32_t ulTargetBwRpt, ulCurBwRpt = 0;
	uint8_t ubMaxSlotNum = ubKNL_GetTRXSlotNum();

	ulTargetBwRpt = (1 == ubMaxSlotNum)?436:(2 == ubMaxSlotNum)?218:(4 == ubMaxSlotNum)?109:0;
	#ifdef OP_AP
	ulCurBwRpt = ulKNL_GetTrxBwRpt(tKNL_Role);
	#else
	ulCurBwRpt = ulRTC676x_GetRtBw(0) / 1024;
	#endif
	ulCurBwRpt = (ulTargetBwRpt)?(ulCurBwRpt > ulTargetBwRpt)?ulTargetBwRpt:ulCurBwRpt:0;
	ubPerValue = ((float)ulCurBwRpt / (float)ulTargetBwRpt) * 100;
#endif
	return ubPerValue;
#endif
#ifdef S2019A
	sPRF_DevId_t tTxId[] = {
							[KNL_STA1] = sPRF_STA1,
							[KNL_STA2] = sPRF_STA2,
							[KNL_STA3] = sPRF_STA3,
							[KNL_STA4] = sPRF_STA4,
						   };
	if(tKNL_Role > KNL_STA4)
		return 0;
	return 100 - tsPRF_GetPER(tTxId[tKNL_Role]);
#endif
}
//------------------------------------------------------------------------------
#if (defined(RTC676x) && TRXBW_RPT_EN)
#ifdef OP_AP
void KNL_SetTrxBwRpt(KNL_ROLE tRole, uint32_t ulBw)
{
	osMutexWait(osKNL_TrxBwMutex, osWaitForever);
	ulKNL_TrxBwRpt[tRole] = ulBw;
	osMutexRelease(osKNL_TrxBwMutex);
	printd(DBG_InfoLvl, "   [%d]TX BW: %d\n", tRole, ulKNL_TrxBwRpt[tRole]);
}
//------------------------------------------------------------------------------
uint32_t ulKNL_GetTrxBwRpt(KNL_ROLE tRole)
{
	uint32_t ulBw = 0;
	osMutexWait(osKNL_TrxBwMutex, osWaitForever);
	ulBw = ulKNL_TrxBwRpt[tRole];
	osMutexRelease(osKNL_TrxBwMutex);
	return ulBw;
}
#endif
//------------------------------------------------------------------------------
void KNL_TrxBwRptFunc(TWC_TAG GetSta, uint8_t *pData)
{
#ifdef OP_AP
	uint32_t ulBw = 0;

	if(pData[0] != GetSta)
		return;
	ulBw = (pData[1] << 24) + (pData[2] << 16) + (pData[3] << 8) + pData[4];
	KNL_SetTrxBwRpt((KNL_ROLE)GetSta, ulBw);
#endif
}
#endif
//------------------------------------------------------------------------------
void KNL_SetTargetFps(uint8_t ubFps)
{
	ubKNL_TargetFps = ubFps;
	printd(DBG_Debug3Lvl, "Target FPS: %d\n", ubKNL_TargetFps);
}
//------------------------------------------------------------------------------
void KNL_EnableWORFunc(void)
{
#if (defined(A7130) && !defined(BSP_D_SN93712_VBM_TX_V2)) 
	uint8_t ubKNL_PsValue = 0;

	if(ubKNL_WorSts)
		osDelay(50);
	ubKNL_PsValue  = wRTC_ReadUserRam(RTC_RECORD_PWRSTS_ADDR);
	ubKNL_PsValue &= 0xF;
	ubKNL_PsValue |= RTC_PS_WOR_TAG;
	RTC_WriteUserRam(RTC_RECORD_PWRSTS_ADDR, ubKNL_PsValue);
	RTC_SetGPO_0(0, RTC_PullDownEnable);
	ubRTC_GetGPI_0(RTC_PullDownDisable);
	RTC_WakeupByGPI0Enable();
	BB_EnableWOR(96, 53);
	RTC_PowerDisable();
#endif
}
//------------------------------------------------------------------------------
void KNL_DisableWORFunc(void)
{
#ifdef A7130
	uint8_t ubKNL_PsValue = 0;

	ubKNL_PsValue  = wRTC_ReadUserRam(RTC_RECORD_PWRSTS_ADDR);
	ubKNL_PsValue &= 0xF;
	RTC_WriteUserRam(RTC_RECORD_PWRSTS_ADDR, ubKNL_PsValue);
	RTC_WakeupByGPI0Disable();
#endif
}
//------------------------------------------------------------------------------
uint8_t KNL_WakeupDevice(KNL_ROLE tKNL_Role, uint8_t ubMode)
{
#ifdef A7130
#if (APP_DOORPHONE_ENABLE==0)
	LINK_ROLE tBB_LinkRole[KNL_MAX_ROLE] = {[KNL_STA1] = BB_STA1,
								            [KNL_STA2] = BB_STA2,
								            [KNL_STA3] = BB_STA3,
								            [KNL_STA4] = BB_STA4,
								            [KNL_MASTER_AP] = BB_MASTER_AP};
#else
	LINK_ROLE tBB_LinkRole[KNL_MAX_ROLE] = {[KNL_STA1] = BB_T2R_W_STA1,
								            [KNL_STA2] = BB_T2R_W_STA2,
								            [KNL_STA3] = BB_T2R_W_STA3,
								            [KNL_STA4] = BB_T2R_W_STA4,
								            [KNL_MASTER_AP] = BB_MASTER_AP};
#endif
#ifdef OP_AP
	if(BB_ENABLE_ALL_STA_WAKEUP == tKNL_WorMode)
	{
		if((FALSE == ubKNL_WakeUpFlag[KNL_MASTER_AP]) && (TRUE == ubMode))
		{
			BB_SetWakeUp(TRUE, 0xFF);
			ubKNL_WakeUpFlag[KNL_MASTER_AP] = TRUE;
		}
		else if((TRUE == ubKNL_WakeUpFlag[KNL_MASTER_AP]) && (FALSE == ubMode))
		{
			BB_SetWakeUp(FALSE, 0xFF);
			ubKNL_WakeUpFlag[KNL_MASTER_AP] = FALSE;
		}
		return TRUE;
	}
	if(tKNL_Role > KNL_STA4)
#endif
#ifdef OP_STA
	if(tKNL_Role != KNL_MASTER_AP)
#endif
		return FALSE;
	if((FALSE == ubMode) && (FALSE == ubKNL_WakeUpFlag[tKNL_Role]))
		return TRUE;
	BB_SetWakeUp(ubMode, tBB_LinkRole[tKNL_Role]);
	ubKNL_WakeUpFlag[tKNL_Role] = ubMode;
#ifdef OP_STA
	if(ubMode)
		BB_ClearTxBuf(BB_TX_MASTER,BB_DATA_VIDEO);
#endif
	printd(DBG_Debug3Lvl, "  >WakeUp %s[%X]\n", (ubMode)?"?":"", tBB_LinkRole[tKNL_Role]);
#endif
	return TRUE;
}
//------------------------------------------------------------------------------
#ifdef A7130
void KNL_SetWORMode(SET_WOR_MODE tWorMode)
{
	tKNL_WorMode = tWorMode;
}
//------------------------------------------------------------------------------
SET_WOR_MODE tKNL_GetWORMode(void)
{
	return tKNL_WorMode;
}
#endif
//------------------------------------------------------------------------------
void KNL_TurnOnTuningTool(void)
{
#if (defined(OP_STA) || defined(BSP_DVR_SDK))
	IQ_SetupTuningToolMode(KNL_TUNINGMODE_ON);
	tKNL_TuningMode = KNL_TUNINGMODE_ON;
#endif
}
//------------------------------------------------------------------------------
void KNL_TurnOffTuningTool(void)
{
#ifdef OP_STA
	SEN_SetUvcPathFlag(0);
	IQ_SetupTuningToolMode(KNL_TUNINGMODE_OFF);
	tKNL_TuningMode = KNL_TUNINGMODE_OFF;
#endif
}
//------------------------------------------------------------------------------
KNL_TuningMode_t KNL_GetTuningToolMode(void)
{
#if (defined(OP_AP)&& !defined(BSP_DVR_SDK) || !USBD_ENABLE)	
	tKNL_TuningMode = KNL_TUNINGMODE_OFF;
#endif
	return tKNL_TuningMode;
}
//------------------------------------------------------------------------------
KNL_Status_t tKNL_EnJpegLcdCh(KNL_JpgLcdChCtrl_t tJpgLcdChCtrl)
{
	uint8_t ubCodecRetryCnt = 18;

	for(;;)
	{
		if(ubKNL_ChkImgRdy())
			break;
		if(!--ubCodecRetryCnt)
		{
			printd(DBG_ErrorLvl, "H->D NRDY@%s\r\n", __func__);
			return KNL_ERR;
		}
		osDelay(10);
	}
	osMutexWait(osKNL_JpgLcdChMutex, osWaitForever);
	tKNL_JpgLcdChCtrl = tJpgLcdChCtrl;
	switch(ubKNL_GetOpMode())
	{
		case KNL_OPMODE_VBM_1T:
		case KNL_OPMODE_BUC_1T:
			if(BUF_FREE == ulBUF_GetBlkBufAddr(0, BUF_RESV_YUV))
				BUF_BufInit(BUF_RESV_YUV, 1, ((VDO_MAIN_H_SIZE(VDO_DISP_TYPE) * VDO_MAIN_V_SIZE(VDO_DISP_TYPE) * 3) >> 1), 0);
			break;
		case KNL_OPMODE_VBM_4T:
		case KNL_OPMODE_BUC_4T:
			if(((KNL_DISP_SINGLE == tKNL_GetDispType()) || (KNL_DISP_H == tKNL_GetDispType())) &&
				(BUF_FREE == ulBUF_GetBlkBufAddr(0, BUF_RESV_YUV)))
				BUF_BufInit(BUF_RESV_YUV, 1, ((VDO_MAIN_H_SIZE(VDO_DISP_TYPE) * VDO_MAIN_V_SIZE(VDO_DISP_TYPE) * 3) >> 1), 0);
			break;
		default:
			break;
	}
	osMutexRelease(osKNL_JpgLcdChMutex);

	return KNL_OK;
}
//------------------------------------------------------------------------------
KNL_JpgLcdChCtrl_t tKNL_GetJpegLcdChCtrl(void)
{
	KNL_JpgLcdChCtrl_t tJpgLcdChCtrl;

	osMutexWait(osKNL_JpgLcdChMutex, osWaitForever);
	tJpgLcdChCtrl = tKNL_JpgLcdChCtrl;
	osMutexRelease(osKNL_JpgLcdChMutex);

	return tJpgLcdChCtrl;
}
//------------------------------------------------------------------------------
KNL_Status_t tKNL_ChkSdCardSts(void)
{
	KNL_Status_t tSdCardSts = KNL_ErrorNoCard;
	FS_MEDIA_RDY_ACC tChkSd;
	uint8_t ubFsTimeout = 30;
	
	if(tKNL_FsMediaInfo.MediaType[tKNL_FsMediaInfo.MediaSel]==FS_MEDIA_TYPE_SD)
	{
		if(!ubSD_ChkCardIn(tSD_GetDevIF()))
			return KNL_ErrorNoCard;
	}
	while(1)
	{
		tChkSd = FS_ChkMediaRdy(tKNL_FsMediaInfo.MediaSel);
		if(FS_MEDIA_NOT_RDY != tChkSd)
			break;
		osDelay(100);
		if(!--ubFsTimeout)
		{
			printd(DBG_ErrorLvl, "SD Card not ready !\n");
			return KNL_ErrorTimeout;
		}
	}
	tSdCardSts = (FS_MEDIA_GET_INFO_FAIL == tChkSd)?KNL_ErrorFsFmt:
			     (FS_MEDIA_RE_PLUGIN == tChkSd)?KNL_ErrorCardNRdy:KNL_OK;
	return tSdCardSts;
}
//------------------------------------------------------------------------------
uint32_t ulKNL_GetResvDecAddr(void)
{
	uint32_t ulDecAddr = 0;
#if KNL_LCD_FUNC_ENABLE
	KNL_DISP_TYPE tDispType;

	tDispType = tKNL_GetDispType();
	switch(ubKNL_GetOpMode())
	{
		case KNL_OPMODE_VBM_4T:
		case KNL_OPMODE_BUC_4T:
		{
			LCD_CH_TYP tLcdCh;

			tLcdCh    = ((FALSE == ubKNL_BbPathAct) && ((KNL_DISP_DUAL_C == tDispType) || (KNL_DISP_DUAL_U == tDispType)))?LCD_CH1:LCD_CH0;
			ulDecAddr = (LCD_CH0 == tLcdCh)?ulBUF_GetBlkBufAddr(0, BUF_RESV_YUV):pLCD_GetLcdChBufInfor(tLcdCh)->ulBufAddr;
			break;
		}
		case KNL_OPMODE_VBM_2T:
		case KNL_OPMODE_BUC_2T_1L1R:
		case KNL_OPMODE_BUC_2T_1T1B:
			ulDecAddr = pLCD_GetLcdChBufInfor(LCD_CH1)->ulBufAddr;
			break;
		default:
			ulDecAddr = ulBUF_GetBlkBufAddr(0, BUF_RESV_YUV);
			break;
	}
#endif
	return ulDecAddr;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_SearchCapSrcNum(uint8_t ubSrcNum)
{
#if APP_PHOTOGRAPH_FUNC_ENABLE
	uint8_t i;
    if(KNL_RECORDFUNC_DISABLE != tKNL_GetRecordFunc())
        return FALSE; 
	for(i = 0; i < ubKNL_GetMaxStaNum(); i++)
	{
		if(tKNL_RecordAct.ubPhotoCapSrc[i] == ubSrcNum)
		{
			if((KNL_DISP_H == tKNL_GetDispType()) && (!ulKNL_GetResvDecAddr()))
				return FALSE;
			tKNL_RecordAct.ubPhotoCapSrc[i] = KNL_SRC_NONE;
            KNL_SetRecordCapSrc(ubSrcNum);
			KNL_SetRecordFunc(KNL_PHOTO_CAPTURE);
			return TRUE;
		}
	}
#endif
	return FALSE;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_UpdateCapSrcNumFin(uint8_t ubSrcNum)
{
	uint8_t ubRet = TRUE;
#if APP_PHOTOGRAPH_FUNC_ENABLE
	uint8_t i;

	for(i = 0; i < ubKNL_GetMaxStaNum(); i++)
	{
		if(tKNL_RecordAct.ubPhotoCapSrc[i] == ubSrcNum)
			tKNL_RecordAct.ubPhotoCapSrc[i] = KNL_SRC_NONE;
		else if(tKNL_RecordAct.ubPhotoCapSrc[i] != KNL_SRC_NONE)
			ubRet = FALSE;
	}
#endif
	return ubRet;
}
//------------------------------------------------------------------------------
#if APP_PHOTOGRAPH_FUNC_ENABLE
KNL_Status_t tKNL_WriteCaptureFile(uint8_t ubSrcNum, uint32_t ulCapSize)
{
	FS_KNL_CRE_PROCESS_t tKNL_FsProc;
	FS_SEND_Q_STATUS tKNL_FsSendQStatus;
	FS_FILE_SUB_HIDN_INFO_t tKNL_JpgHidInfo;
	uint8_t ubFsTimeout;
	uint32_t ulWriteSize = 0;
#if ((!APP_FS_ROLLING_FILE_NAME) && (BSP_RTC_TIMER_SEL == RTC_TIMER_INTERNAL))
	static RTC_Calendar_t tKNL_Rtc, tKNL_LastRtc = {0, 0, 0, 0, 0, 0};
#elif ((!APP_FS_ROLLING_FILE_NAME) && (BSP_RTC_TIMER_SEL == RTC_TIMER_EXTERNAL))
	static RTC_PCF85063A_Calendar_t tKNL_Rtc, tKNL_LastRtc = {0, 0, 0, 0, 0, 0, 0, 0};
#endif

	tKNL_FsProc.MediaSel          = tKNL_FsMediaInfo.MediaSel;
	tKNL_FsProc.SrcNum      	  = FS_JPG_SRC_0;
	tKNL_FsProc.ubRecGroupFileNum = 4;
#if APP_FS_ROLLING_FILE_NAME
	tKNL_FsProc.FileName.ubLen = 8;
	ulKNL_LatestFileNameLen = ulFS_GetLatestFileName(tKNL_FsMediaInfo.MediaSel, &cKNL_LatestFileName[0]);
	FS_FileNameHandle(tKNL_FsMediaInfo.MediaSel, tKNL_FsProc.FileName.chName, tKNL_FsProc.FileName.ubLen, cKNL_LatestFileName, ulKNL_LatestFileNameLen);
	memcpy(cKNL_LatestFileName, tKNL_FsProc.FileName.chName, tKNL_FsProc.FileName.ubLen);
#else
	wRTC_GETCALENDAR(&tKNL_Rtc);
	if((tKNL_Rtc.uwYear == tKNL_LastRtc.uwYear) && (tKNL_Rtc.ubMonth == tKNL_LastRtc.ubMonth) &&
	   (tKNL_Rtc.ubDate == tKNL_LastRtc.ubDate) && (tKNL_Rtc.ubHour  == tKNL_LastRtc.ubHour) &&
	   (tKNL_Rtc.ubMin  == tKNL_LastRtc.ubMin)  && (tKNL_Rtc.ubSec   == tKNL_LastRtc.ubSec))
    {
        if(ubKNL_CaptureBurstCnt[ubSrcNum] == 0)
        {
            tKNL_FsProc.FileName.ubLen = 21;
            snprintf(tKNL_FsProc.FileName.chName, tKNL_FsProc.FileName.ubLen+1, "PIC_%04d%02d%02d_%02d%02d%02d_%01d", 
            tKNL_Rtc.uwYear,tKNL_Rtc.ubMonth,tKNL_Rtc.ubDate,
            tKNL_Rtc.ubHour,tKNL_Rtc.ubMin,tKNL_Rtc.ubSec,
            ubSrcNum);
        }
        else
        {    
            tKNL_FsProc.FileName.ubLen = 22;
            snprintf(tKNL_FsProc.FileName.chName, tKNL_FsProc.FileName.ubLen+1, "PIC_%04d%02d%02d_%02d%02d%02d_%01d%01d", 
            tKNL_Rtc.uwYear,tKNL_Rtc.ubMonth,tKNL_Rtc.ubDate,
            tKNL_Rtc.ubHour,tKNL_Rtc.ubMin,tKNL_Rtc.ubSec,
            ubSrcNum,ubKNL_CaptureBurstCnt[ubSrcNum]%10); 
        }
    }
    else
    {
        memset(ubKNL_CaptureBurstCnt,0,KNL_SRC_NUM);
        tKNL_FsProc.FileName.ubLen = 21;
        snprintf(tKNL_FsProc.FileName.chName, tKNL_FsProc.FileName.ubLen+1, "PIC_%04d%02d%02d_%02d%02d%02d_%01d", 
        tKNL_Rtc.uwYear,tKNL_Rtc.ubMonth,tKNL_Rtc.ubDate,
            tKNL_Rtc.ubHour,tKNL_Rtc.ubMin,tKNL_Rtc.ubSec,
            ubSrcNum);
    }
    ubKNL_CaptureBurstCnt[ubSrcNum] ++;
    tKNL_LastRtc = tKNL_Rtc;
#endif
	memcpy(tKNL_FsProc.FileName.chExt, "JPG", 3);
	tKNL_FsProc.uwGroupIdx = tKNL_RecordAct.uwRecordGroupIdx;
    printd(DBG_InfoLvl, "	Photo[%d][Sz:%d][Gp:%d]:[%s].JPG\n", ubSrcNum, ulCapSize ,tKNL_FsProc.uwGroupIdx, tKNL_FsProc.FileName.chName);
	tKNL_FsProc.FileAttr = FILE_ATTR_READ_ONLY;
	if(tKNL_FsMediaInfo.MediaType[tKNL_FsMediaInfo.MediaSel]==FS_MEDIA_TYPE_SD)
	{
#if APP_FS_CUSTOMER1_PATH_ENABLE
		tKNL_FsProc.FilePath = FILE_PATH6;
#else
		tKNL_FsProc.FilePath = FILE_PATH_DEFAULT;
#endif
	}
	else if(tKNL_FsMediaInfo.MediaType[tKNL_FsMediaInfo.MediaSel]==FS_MEDIA_TYPE_SF)
	{
		tKNL_FsProc.FilePath = FILE_PATH2;
	}
	tKNL_FsSendQStatus = FS_CreateFile(&tKNL_FsProc);
	if(tKNL_FsSendQStatus != FS_SEND_Q_SUCCESS)
		printd(DBG_ErrorLvl, "\n\r=== ERROR_Create File:%d ERROR ===\n\r", tKNL_FsSendQStatus);
	ubFsTimeout = 150;
	while(FS_ChkCreateStatus(tKNL_FsMediaInfo.MediaSel, FS_JPG_SRC_0) != FS_REC_CREATE_OK)
	{
		osDelay(20);
		if(!--ubFsTimeout)
		{
			printd(DBG_ErrorLvl, "Create File Err !!\n");
			return KNL_ERR;
		}
		if(FS_ChkMediaExist(tKNL_FsMediaInfo.MediaSel) == FS_MEDIA_OUT)
		{
			printd(DBG_ErrorLvl, "KNL Write Capture File -> fail![line=%d]\n",__LINE__);
			return KNL_ERR;
		}
		if(FS_ChkMediaRdy(tKNL_FsMediaInfo.MediaSel)!=FS_MEDIA_RDY)
		{
			printd(DBG_ErrorLvl, "KNL Write Capture File -> fail![line=%d]\n",__LINE__);
			return KNL_ERR;
		}
	}

    ulCapSize += KNL_JPG_HEADER_SIZE;
	while(ulCapSize > ulWriteSize )
	{
#if !(defined(BSP_DVR_SDK) || (defined(BSP_RVCS_SDK)&&defined(OP_STA)) )
        if((ulCapSize - ulWriteSize) >= 0x10000)
            tKNL_FsSendQStatus = FS_WriteFile(tKNL_FsMediaInfo.MediaSel, FS_JPG_SRC_0, ulKNL_JPGAddr[ubKNL_SrcNumMap(ubSrcNum)]+ ulWriteSize, 0x10000,NULL);
        else
            tKNL_FsSendQStatus = FS_WriteFile(tKNL_FsMediaInfo.MediaSel, FS_JPG_SRC_0, ulKNL_JPGAddr[ubKNL_SrcNumMap(ubSrcNum)]+ ulWriteSize, ulCapSize - ulWriteSize, NULL);
#else
        if((ulCapSize - ulWriteSize) >= 0x10000)
            tKNL_FsSendQStatus = FS_WriteFile(tKNL_FsMediaInfo.MediaSel, FS_JPG_SRC_0, ulKNL_JPGAddr+ ulWriteSize, 0x10000,NULL);
        else
            tKNL_FsSendQStatus = FS_WriteFile(tKNL_FsMediaInfo.MediaSel, FS_JPG_SRC_0, ulKNL_JPGAddr+ ulWriteSize, ulCapSize - ulWriteSize, NULL);
#endif
        
        if(tKNL_FsSendQStatus == FS_SEND_Q_SUCCESS)
            ulWriteSize += 0x10000;
        else
        {
            //printd(DBG_ErrorLvl, "FS WriteFile osDelay\n");
            osDelay(20);  
        }
		if(FS_ChkMediaRdy(tKNL_FsMediaInfo.MediaSel)!=FS_MEDIA_RDY)
		{
			printd(DBG_ErrorLvl, "KNL Write Capture File -> fail![line=%d]\n",__LINE__);
			return KNL_ERR;
		}
	}	

	tKNL_JpgHidInfo.ubEvent = 0;
	tKNL_JpgHidInfo.ubSrcLocate[0] = ubSrcNum;
	tKNL_JpgHidInfo.ubSrcLocate[1] = 0;
	tKNL_JpgHidInfo.ubSrcLocate[2] = 0;
	tKNL_JpgHidInfo.ubSrcLocate[3] = 0;
	
	FS_CloseFile(tKNL_FsMediaInfo.MediaSel, FS_JPG_SRC_0, &tKNL_JpgHidInfo);
	ubFsTimeout = 150;
	while(FS_ChkCloseStatus(tKNL_FsMediaInfo.MediaSel, FS_JPG_SRC_0) != FS_REC_CLOSED_OK)
	{
		osDelay(20);
		if(!--ubFsTimeout)
		{
			printd(DBG_ErrorLvl, "Close File Err !!\n");
			return KNL_ERR;
		}
		if(FS_ChkMediaExist(tKNL_FsMediaInfo.MediaSel) == FS_MEDIA_OUT)
		{
			printd(DBG_ErrorLvl, "KNL Write Capture File -> fail![line=%d]\n",__LINE__);
			return KNL_ERR;
		}
		if(FS_ChkMediaRdy(tKNL_FsMediaInfo.MediaSel)!=FS_MEDIA_RDY)
		{
			printd(DBG_ErrorLvl, "KNL Write Capture File -> fail![line=%d]\n",__LINE__);
			return KNL_ERR;
		}
	}

	return KNL_OK;
}
//------------------------------------------------------------------------------
KNL_Status_t tKNL_ReadCaptureFile(KNL_RecordAct_t *pPhotoInfo)
{
	uint32_t ulJpgAddr  = 0, ulJpgSize = 0;
	uint8_t ubFsTimeout;
	
	ubFsTimeout = 30;
#if !(defined(BSP_DVR_SDK) || (defined(BSP_RVCS_SDK)&&defined(OP_STA) && APP_PLAY_REMOTE_ENABLE) )
	ulJpgAddr = ulKNL_JPGAddr[0];
#else
    ulJpgAddr = ulKNL_JPGAddr;
#endif
	ulJpgSize = pPhotoInfo->tPhotoPlayInfo.ulFileSize;
    if(FS_ReadFile(tKNL_FsMediaInfo.MediaSel, ulJpgAddr, pPhotoInfo->tPhotoPlayInfo.SrcNum, pPhotoInfo->tPhotoPlayInfo.ulFirstClus, pPhotoInfo->tPhotoPlayInfo.NoFatChainFlag, 0, ulJpgSize) == FS_SEND_Q_SUCCESS)
    {
		while(FS_ChkReadStatus(tKNL_FsMediaInfo.MediaSel, pPhotoInfo->tPhotoPlayInfo.SrcNum) != FS_PLY_READ_OK)
		{
			osDelay(100);
			if(!--ubFsTimeout)
			{
				printd(DBG_ErrorLvl, "Read JPG file Fail !!\n");
				return KNL_ErrorTimeout;
			}
		}
    }
	else
		return KNL_ErrorTimeout;
	osDelay(20);
	return KNL_OK;	
}
//------------------------------------------------------------------------------
uint8_t ubKNL_PhotoExifUpdate(uint8_t ubCapSrc, uint8_t *pExif, uint32_t ulSize)
{
    uint8_t *pJpgHeader;

    if(ulSize > KNL_JPG_EXIF_SIZE)
        return 0;
    
#if !(defined(BSP_DVR_SDK) || (defined(BSP_RVCS_SDK)&&defined(OP_STA)))
    pJpgHeader      = (uint8_t *)ulKNL_JPGAddr[ubKNL_SrcNumMap(ubCapSrc)];
#else
    pJpgHeader      = (uint8_t *)ulKNL_JPGAddr;
#endif
    memcpy(&pJpgHeader[KNL_JPG_EXIF_START+4], pExif, ulSize);
    return 1;
}
//------------------------------------------------------------------------------
void KNL_PhotoCaptureFinFunc(uint8_t ubCapNode, uint8_t ubCapSrc, uint32_t ulCapSize)
{
	KNL_Status_t tPhotoCapRet;
	KNL_NODE_INFO tNodeInfo;
	uint8_t *pJpgHeader, ubCapFlag;
	
	//normal looping setting
	KNL_FS_NormalLoopingOnSetting(tKNL_FsMediaInfo.MediaSel);
	
	tNodeInfo 		= tKNL_GetNodeInfo(ubCapSrc, ubCapNode);
#if !(defined(BSP_DVR_SDK) || (defined(BSP_RVCS_SDK)&&defined(OP_STA)))
	pJpgHeader 		= (uint8_t *)ulKNL_JPGAddr[ubKNL_SrcNumMap(ubCapSrc)];
	JPEG_UpdateQuantTab2Header(&pJpgHeader[KNL_JPG_DQT_START], 5);
#else
    pJpgHeader 		= (uint8_t *)ulKNL_JPGAddr;
#endif
    ubKNL_PhotoExifUpdate(ubCapSrc,NULL,NULL);
#if (defined(OP_AP) && defined(BSP_DVR_SDK))
	if(ubSEN_CaptureScaleUpGet() == 1)
	{
		pJpgHeader[(KNL_JPG_FRAMEHEADER_START+KNL_JPEG_HEADER_V_OFFSET)] = (uint8_t)((KNL_SCALE_CAP_HEIGHT >> 8) & 0xFF);
		pJpgHeader[(KNL_JPG_FRAMEHEADER_START+KNL_JPEG_HEADER_V_OFFSET+1)]   = (KNL_SCALE_CAP_HEIGHT & 0xFF);
		pJpgHeader[(KNL_JPG_FRAMEHEADER_START+KNL_JPEG_HEADER_H_OFFSET)]   = (uint8_t)((KNL_SCALE_CAP_WIDTH >> 8) & 0xFF);
		pJpgHeader[(KNL_JPG_FRAMEHEADER_START+KNL_JPEG_HEADER_H_OFFSET+1)]  = (KNL_SCALE_CAP_WIDTH & 0xFF);
	}
	else
#endif
	{
		pJpgHeader[(KNL_JPG_FRAMEHEADER_START+KNL_JPEG_HEADER_V_OFFSET)]   = (uint8_t)((tNodeInfo.uwVdoV >> 8) & 0xFF);
		pJpgHeader[(KNL_JPG_FRAMEHEADER_START+KNL_JPEG_HEADER_V_OFFSET+1)]   = (tNodeInfo.uwVdoV & 0xFF);
		pJpgHeader[(KNL_JPG_FRAMEHEADER_START+KNL_JPEG_HEADER_H_OFFSET)]   = (uint8_t)((tNodeInfo.uwVdoH >> 8) & 0xFF);
		pJpgHeader[(KNL_JPG_FRAMEHEADER_START+KNL_JPEG_HEADER_H_OFFSET+1)]  = (tNodeInfo.uwVdoH & 0xFF);	
	}
	ubCapFlag = ubKNL_UpdateCapSrcNumFin(ubCapSrc);
	if(KNL_NODE_H264_DEC == ubCapNode)
	{
		osSemaphoreRelease(tKNL_ImgSem);
		ubKNL_ImgRdy = 1;
		osSemaphoreRelease(osKNL_H264CdcWaitSem);
	}
	tPhotoCapRet = tKNL_WriteCaptureFile(ubCapSrc, ulCapSize);
    KNL_SetRecordFunc(KNL_RECORDFUNC_DISABLE);   
#if (defined(BSP_DVR_SDK) || (defined(BSP_RVCS_SDK)&&defined(OP_STA)) )
    KNL_LocalSnapshotRelease();
#endif
    if((TRUE == ubCapFlag) && (KNL_OK == tPhotoCapRet))
    {
#if (APP_REC_FUNC_ENABLE && OP_STA)
        osSignalSet(KNL_TxRecThreadId, ulKNL_CapSignal);
#else
		osSignalSet(osKNL_RecordThreadId, ulKNL_CapSignal);//osKNL_CapFinSignal
#endif		
    }
#if (defined(OP_AP) && defined(BSP_DVR_SDK))
	if(ubSEN_CaptureScaleUpGet() == 1)
	{
		KNL_ROLE tPlayRole = KNL_STA1;
	    KNL_SRC tVdoSrcNum;
	    KNL_UpdateJpgHeader(1280,720);
	    KNL_ResetVdoProc();
		H264_Reset();    
	    SEN_CaptureScaleUp(0,NULL);
	    SEN_SetOutResolution(SENSOR_PATH1, VDO_LOCAL_STORAGE_H_SIZE, VDO_LOCAL_STORAGE_V_SIZE);
	    for (tPlayRole = KNL_STA1; tPlayRole < DISPLAY_MODE; tPlayRole++)
	    {
	        tVdoSrcNum = (KNL_SRC)(KNL_SRC_1_MAIN + tPlayRole);
	        KNL_VdoStart(tVdoSrcNum);
	    }    
	    KNL_VdoStart(KNL_SRC_PREVIEW_LOCAL);
	    KNL_VdoStart(KNL_SRC_STORAGE_LOCAL);
	    KNL_SenStart(KNL_SRC_STORAGE_LOCAL);
	    KNL_SenStart(KNL_SRC_PREVIEW_LOCAL);
	}
#endif
}
//------------------------------------------------------------------------------
void KNL_PhotoCaptureFunc(void)
{
	osEvent osKNL_PhotoGraphFinSig;
	KNL_Status_t tKNL_PhotoSts;
	KNL_DISP_TYPE tDispType;
	uint8_t ubCapSrcNum, i;
#if (defined(OP_AP) && defined(BSP_DVR_SDK))
	if(ubKNL_GetPhotoLocRes() == 1)	// Check UI 8M/12M Setting
	{
    	KNL_ROLE tPlayRole = KNL_STA1;
    	KNL_SRC tVdoSrcNum;
    	for(tPlayRole = KNL_STA1; tPlayRole < DISPLAY_MODE; tPlayRole++)
    	{
        	tVdoSrcNum = (KNL_SRC)(KNL_SRC_1_MAIN + tPlayRole);
        	KNL_VdoStop(tVdoSrcNum);
    	}
	    ubKNL_WaitNodeFinish(KNL_SRC_1_MAIN);
    
#if (defined(S2019A))
        sPRF_KeepAlive(TRUE);
#endif

	    KNL_VdoStop(KNL_SRC_PREVIEW_LOCAL);
	    KNL_VdoStop(KNL_SRC_STORAGE_LOCAL);
	    KNL_SenStop(KNL_SRC_PREVIEW_LOCAL);
	    KNL_SenStop(KNL_SRC_STORAGE_LOCAL);
	    SEN_CaptureScaleUp(1,ulBUF_GetBlkBufAddr(0,BUF_IMG_DEC));
		SEN_SetOutResolution(SENSOR_PATH1, KNL_SCALE_CAP_WIDTH, KNL_SCALE_CAP_HEIGHT);
	    if(ubSEN_GetPathSrc(SENSOR_PATH1) == KNL_SRC_STORAGE_LOCAL)
    	{
    		if(!ubSEN_GetActiveFlg(SENSOR_PATH1))
    		{
    			BUF_Reset(BUF_SEN_1_YUV);
    			SEN_SetPathAddr(SENSOR_PATH1,ulBUF_GetBlkBufAddr(0,BUF_IMG_DEC));
    			SEN_SetActiveFlg(SENSOR_PATH1,1);
    			SEN_SetPathState(SENSOR_PATH1, 1);
    			SEN->VIDEO_STR_EN_1 = 1;
    		}
    	}
		SEN_UpdatePathAddr();
		SEN_SetStateChangeFlg(1);
		SEN_SetIspOutEn(TRUE);
		ubKNL_SenStartFlg = 1;
	}
#endif
    KNL_UpdateJpgHeader(1280,720);

	tDispType = tKNL_GetDispType();
	for(i = 0; i < ubKNL_GetMaxStaNum(); i++)
		tKNL_RecordAct.ubPhotoCapSrc[i] = KNL_SRC_NONE;
	tKNL_RecordAct.uwRecordGroupIdx = uwFS_GetLatestGroupIdx(tKNL_FsMediaInfo.MediaSel, FS_JPG_SRC_0) + 1;
    if(tKNL_RecordAct.uwRecordGroupIdx >= uwFS_GetMaxRollingGroupIdxNum(tKNL_FsMediaInfo.MediaSel)) tKNL_RecordAct.uwRecordGroupIdx = 0;
	ubCapSrcNum = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[0]:ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
#if defined(BSP_DVR_SDK)
    tKNL_RecordAct.ubPhotoCapSrc[0] = (ubKNL_GetSrcNumPosition((KNL_SRC)ubCapSrcNum) == KNL_LOCAL)? KNL_SRC_STORAGE_LOCAL:
                                        ((KNL_SRC_NONE != ubCapSrcNum) && (BB_LINK == ubKNL_GetCommLinkStatus(ubKNL_SrcNumMap(ubCapSrcNum))))?ubCapSrcNum:KNL_SRC_NONE;
    if(ubKNL_GetPhotoLocRes() == 1 && tKNL_RecordAct.ubPhotoCapSrc[0] != KNL_SRC_STORAGE_LOCAL)
        tKNL_RecordAct.ubPhotoCapSrc[0] = KNL_SRC_NONE;
#else
	tKNL_RecordAct.ubPhotoCapSrc[0] = ((KNL_SRC_NONE != ubCapSrcNum) && (BB_LINK == ubKNL_GetCommLinkStatus(ubKNL_SrcNumMap(ubCapSrcNum))))?ubCapSrcNum:KNL_SRC_NONE;
#endif
	if(KNL_DISP_SINGLE != tDispType)
	{
		ubCapSrcNum = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[1]:ubKNL_GetDispSrc(KNL_DISP_LOCATION2);
#if defined(BSP_DVR_SDK)
		tKNL_RecordAct.ubPhotoCapSrc[1] = (ubKNL_GetSrcNumPosition((KNL_SRC)ubCapSrcNum) == KNL_LOCAL)? KNL_SRC_STORAGE_LOCAL:
                                            ((KNL_SRC_NONE != ubCapSrcNum) && (BB_LINK == ubKNL_GetCommLinkStatus(ubKNL_SrcNumMap(ubCapSrcNum))))?ubCapSrcNum:KNL_SRC_NONE;
        if(ubKNL_GetPhotoLocRes() == 1 && tKNL_RecordAct.ubPhotoCapSrc[1] != KNL_SRC_STORAGE_LOCAL)
            tKNL_RecordAct.ubPhotoCapSrc[1] = KNL_SRC_NONE;
#else
		tKNL_RecordAct.ubPhotoCapSrc[1] = ((KNL_SRC_NONE != ubCapSrcNum) && (BB_LINK == ubKNL_GetCommLinkStatus(ubKNL_SrcNumMap(ubCapSrcNum))))?ubCapSrcNum:KNL_SRC_NONE;
#endif								
	}
	switch(tDispType)
	{
		case KNL_DISP_QUAD:
		case KNL_DISP_H:
			ubCapSrcNum = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[2]:ubKNL_GetDispSrc(KNL_DISP_LOCATION3);
#if defined(BSP_DVR_SDK)
			tKNL_RecordAct.ubPhotoCapSrc[2] = (ubKNL_GetSrcNumPosition((KNL_SRC)ubCapSrcNum) == KNL_LOCAL)? KNL_SRC_STORAGE_LOCAL :
			                                    ((KNL_SRC_NONE != ubCapSrcNum) && (BB_LINK == ubKNL_GetCommLinkStatus(ubKNL_SrcNumMap(ubCapSrcNum))))?ubCapSrcNum:KNL_SRC_NONE;
            if(ubKNL_GetPhotoLocRes() == 1 && tKNL_RecordAct.ubPhotoCapSrc[2] != KNL_SRC_STORAGE_LOCAL)
                tKNL_RecordAct.ubPhotoCapSrc[2] = KNL_SRC_NONE;
#else
			tKNL_RecordAct.ubPhotoCapSrc[2] = ((KNL_SRC_NONE != ubCapSrcNum) && (BB_LINK == ubKNL_GetCommLinkStatus(ubKNL_SrcNumMap(ubCapSrcNum))))?ubCapSrcNum:KNL_SRC_NONE;
#endif													
			ubCapSrcNum = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[3]:ubKNL_GetDispSrc(KNL_DISP_LOCATION4);
#if defined(BSP_DVR_SDK)
			tKNL_RecordAct.ubPhotoCapSrc[3] = (ubKNL_GetSrcNumPosition((KNL_SRC)ubCapSrcNum) == KNL_LOCAL)? KNL_SRC_STORAGE_LOCAL:
                                                ((KNL_SRC_NONE != ubCapSrcNum) && (BB_LINK == ubKNL_GetCommLinkStatus(ubKNL_SrcNumMap(ubCapSrcNum))))?ubCapSrcNum:KNL_SRC_NONE;
            if(ubKNL_GetPhotoLocRes() == 1 && tKNL_RecordAct.ubPhotoCapSrc[3] != KNL_SRC_STORAGE_LOCAL)
                tKNL_RecordAct.ubPhotoCapSrc[3] = KNL_SRC_NONE;
#else
			tKNL_RecordAct.ubPhotoCapSrc[3] = ((KNL_SRC_NONE != ubCapSrcNum) && (BB_LINK == ubKNL_GetCommLinkStatus(ubKNL_SrcNumMap(ubCapSrcNum))))?ubCapSrcNum:KNL_SRC_NONE;
#endif													
			break;
		case KNL_DISP_3T_2L1R:
		case KNL_DISP_3T_1L2R:
		case KNL_DISP_3T_2T1B:
		case KNL_DISP_3T_1T2B:
		case KNL_DISP_3T_3COL:
			ubCapSrcNum = (TRUE == KNL_SwDispInfo.ubSetupFlag)?KNL_SwDispInfo.tSrcNum[2]:ubKNL_GetDispSrc(KNL_DISP_LOCATION3);
			tKNL_RecordAct.ubPhotoCapSrc[2] = ((KNL_SRC_NONE != ubCapSrcNum) && (BB_LINK == ubKNL_GetCommLinkStatus(ubKNL_SrcNumMap(ubCapSrcNum))))?ubCapSrcNum:KNL_SRC_NONE;
			tKNL_RecordAct.ubPhotoCapSrc[3] = KNL_SRC_NONE;
			break;
		case KNL_DISP_SINGLE:
			tKNL_RecordAct.ubPhotoCapSrc[1] = KNL_SRC_NONE;
			break;
		default:
			break;
	}
    ulKNL_CapSignal++;
	if(tKNL_FsMediaInfo.MediaType[tKNL_FsMediaInfo.MediaSel]==FS_MEDIA_TYPE_SD)
	{
		osKNL_PhotoGraphFinSig = osSignalWait(ulKNL_CapSignal, 4000);
	}
	else if(tKNL_FsMediaInfo.MediaType[tKNL_FsMediaInfo.MediaSel]==FS_MEDIA_TYPE_SF)
	{
		osKNL_PhotoGraphFinSig = osSignalWait(ulKNL_CapSignal, 6000);
	}
	tKNL_PhotoSts = ((osKNL_PhotoGraphFinSig.status == osEventSignal) &&
					 (osKNL_PhotoGraphFinSig.value.signals == ulKNL_CapSignal))?KNL_OK:KNL_ErrorTimeout;
	if(KNL_OK != tKNL_PhotoSts)
	{
		if(ubKNL_ExistNode(tKNL_RecordAct.ubPhotoCapSrc[0], KNL_NODE_H264_DEC))
		{
			osSemaphoreRelease(tKNL_ImgSem);
			ubKNL_ImgRdy = 1;
			osSemaphoreRelease(osKNL_H264CdcWaitSem);
		}
		JPEG_Codec_Disable();
		osSemaphoreRelease(JPEG_CodecSem);
		KNL_SetRecordFunc(KNL_RECORDFUNC_DISABLE);
	}
	else
		KNL_ResetSortingResult();
	if(tKNL_RecordAct.pRecordStsNtyCb)
		tKNL_RecordAct.pRecordStsNtyCb(tKNL_PhotoSts);
}
//------------------------------------------------------------------------------
#if (defined(BSP_RVCS_SDK)&&defined(OP_STA)&&APP_PHOTOGRAPH_FUNC_ENABLE)
KNL_SRC KNL_CamSnapshotSrcGet(void)
{
    if(APP_TXREC_SNAPSHOT_SRC == 0)
        return KNL_SRC_1_MAIN;
    else if(APP_TXREC_SNAPSHOT_SRC == 1)
        return KNL_SRC_1_AUX;
    else
        return KNL_SRC_1_MAIN;
}

void KNL_CamPhotoCaptureFunc(void)
{
	osEvent osKNL_PhotoGraphFinSig;
	KNL_Status_t tKNL_PhotoSts;
	uint8_t i;

    KNL_UpdateJpgHeader(1280,720);

	for(i = 0; i < ubKNL_GetMaxStaNum(); i++)
		tKNL_RecordAct.ubPhotoCapSrc[i] = KNL_SRC_NONE;
	tKNL_RecordAct.uwRecordGroupIdx = uwFS_GetLatestGroupIdx(tKNL_FsMediaInfo.MediaSel, FS_JPG_SRC_0) + 1;
    if(tKNL_RecordAct.uwRecordGroupIdx >= uwFS_GetMaxRollingGroupIdxNum(tKNL_FsMediaInfo.MediaSel)) tKNL_RecordAct.uwRecordGroupIdx = 0;

    tKNL_RecordAct.ubPhotoCapSrc[0] = KNL_CamSnapshotSrcGet();
    tKNL_RecordAct.ubPhotoCapSrc[1] = KNL_SRC_NONE;
	
    ulKNL_CapSignal++;
	if(tKNL_FsMediaInfo.MediaType[tKNL_FsMediaInfo.MediaSel]==FS_MEDIA_TYPE_SD)
	{
		osKNL_PhotoGraphFinSig = osSignalWait(ulKNL_CapSignal, 4000);
	}
	else if(tKNL_FsMediaInfo.MediaType[tKNL_FsMediaInfo.MediaSel]==FS_MEDIA_TYPE_SF)
	{
		osKNL_PhotoGraphFinSig = osSignalWait(ulKNL_CapSignal, 6000);
	}
	tKNL_PhotoSts = ((osKNL_PhotoGraphFinSig.status == osEventSignal) &&
					 (osKNL_PhotoGraphFinSig.value.signals == ulKNL_CapSignal))?KNL_OK:KNL_ErrorTimeout;
	if(KNL_OK != tKNL_PhotoSts)
	{
		JPEG_Codec_Disable();
		osSemaphoreRelease(JPEG_CodecSem);
		KNL_SetRecordFunc(KNL_RECORDFUNC_DISABLE);
	}
	else
		KNL_ResetSortingResult();
	if(tKNL_RecordAct.pRecordStsNtyCb)
		tKNL_RecordAct.pRecordStsNtyCb(tKNL_PhotoSts);
}
#endif
//------------------------------------------------------------------------------
uint32_t ulKNL_PhotoLcdDisplaySetup(uint16_t uwPhotoHSize, uint16_t uwPhotoVSize)
{
#if KNL_LCD_FUNC_ENABLE
	LCD_INFOR_TYP tLcdParam;
	LCD_CALBUF_TYP	tLcdBufCalInfo;

	if(LCD_JPEG_ENABLE == tLCD_GetJpegDecoderStatus())
		tLCD_JpegDecodeDisable();
	KNL_ResetLcdChannel();
	tLcdBufCalInfo.ubChMax = 1;
	tLcdBufCalInfo.tInput[0].bJpegEn = FALSE;
#if defined(BSP_DVR_SDK)
	tLcdBufCalInfo.tInput[0].uwHSize = uwPhotoHSize;
	tLcdBufCalInfo.tInput[0].uwVSize = uwPhotoVSize;
#else
	tLcdBufCalInfo.tInput[0].uwHSize = uwLCD_GetLcdHoSize();
	tLcdBufCalInfo.tInput[0].uwVSize = uwLCD_GetLcdVoSize();
#endif
	tLcdBufCalInfo.tAlign = LCD_BUF_1024BYTES_ALIG;
	ulLCD_CalLcdBufSize(&tLcdBufCalInfo);
	LCD_SetLcdBufAddr(ulBUF_GetBlkBufAddr(0, BUF_LCD_IP));
	tLcdParam.tDispType = LCD_DISP_1T;
	tLcdParam.ubChNum = 1;
	tLcdParam.tChRes[0].uwCropHstart = 0;
	tLcdParam.tChRes[0].uwCropVstart = 0;
	tLcdParam.uwLcdOutputHsize = uwLCD_GetLcdHoSize();
	tLcdParam.uwLcdOutputVsize = uwLCD_GetLcdVoSize();
	tLcdParam.tChRes[0].uwChInputHsize = (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)?uwPhotoHSize:uwPhotoVSize;
	tLcdParam.tChRes[0].uwChInputVsize = (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)?uwPhotoVSize:uwPhotoHSize;
	tLcdParam.tChRes[0].uwCropHsize = tLcdParam.tChRes[0].uwChInputHsize;
	tLcdParam.tChRes[0].uwCropVsize = tLcdParam.tChRes[0].uwChInputVsize;
	tLCD_CropScale(&tLcdParam);
	pKNL_LcdPlayBuf = pLCD_GetLcdChBufInfor(LCD_CH0);
#endif
	return pKNL_LcdPlayBuf->ulBufAddr;
}
//------------------------------------------------------------------------------
void KNL_PhotoLcdDisplayOn(void)
{
#if KNL_LCD_FUNC_ENABLE
	LCD_SetChBufReady(pKNL_LcdPlayBuf);
	LCD_ChEnable(LCD_CH0);
#endif
}
//------------------------------------------------------------------------------
void KNL_PhotoLcdDisplayOFF(void)
{
#if KNL_LCD_FUNC_ENABLE
	KNL_ResetLcdChannel();
#if !APP_FS_FILE_LIST_STYLE
	ulKNL_CalLcdBufSz();
#endif
	if(KNL_DISP_H == tKNL_GetDispType())
		KNL_CreateBlackDmyPat(ulBUF_GetBlkBufAddr(0, BUF_IMG_MERGE), (ulKNL_GetImgMergeBufSz()+((tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)?KNL_JPG_BS_SIZE:0)));
	else if((((KNL_DISP_3T_2L1R == tKNL_GetDispType()) || (KNL_DISP_3T_1L2R == tKNL_GetDispType())) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)) ||
		    (((KNL_DISP_3T_2T1B == tKNL_GetDispType()) || (KNL_DISP_3T_1T2B == tKNL_GetDispType())) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0))  ||
	         ((KNL_DISP_3T_3COL == tKNL_GetDispType()) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)))
		KNL_CreateBlackDmyPat(ulBUF_GetBlkBufAddr(0, BUF_IMG_MERGE), ulKNL_GetImgMergeBufSz());
	ubKNL_LcdDispParamActiveFlg = 1;
#endif    
}
//------------------------------------------------------------------------------
void KNL_PhotoPlayFinFunc(void)
{
	osSignalSet(osKNL_RecordThreadId, osKNL_PhotoPlyFinSignal);
}
//------------------------------------------------------------------------------
void KNL_PhotoPlayFunc(KNL_RecordAct_t *pPhotoInfo)
{
	osEvent osKNL_PhotoGraphFinSig;
	KNL_Status_t tKNL_PhotoSts;
	KNL_NODE_INFO tPhotoPlayNodeInfo;
	uint32_t ulVdoYuvAddr = 0, ulJpgBsAddr = 0;
	uint16_t uwJpgHSize = 0, uwJpgVSize = 0;
	uint8_t *pJpgAddr;

	KNL_SetRecordFunc(KNL_PHOTO_PLAY);
	if(KNL_OK != tKNL_ReadCaptureFile(pPhotoInfo))
		goto PHOTOPLAY_ERR;
	osDelay(100);
#if !(defined(BSP_DVR_SDK) || (defined(BSP_RVCS_SDK)&&defined(OP_STA)&&APP_PLAY_REMOTE_ENABLE) )
	pJpgAddr   = (uint8_t *)ulKNL_JPGAddr[0];
#else
    pJpgAddr   = (uint8_t *)ulKNL_JPGAddr;
#endif
	uwJpgVSize = (pJpgAddr[(KNL_JPG_FRAMEHEADER_START+KNL_JPEG_HEADER_V_OFFSET)] << 8) + pJpgAddr[(KNL_JPG_FRAMEHEADER_START+KNL_JPEG_HEADER_V_OFFSET+1)];
	uwJpgHSize = (pJpgAddr[(KNL_JPG_FRAMEHEADER_START+KNL_JPEG_HEADER_H_OFFSET)] << 8) + pJpgAddr[(KNL_JPG_FRAMEHEADER_START+KNL_JPEG_HEADER_H_OFFSET+1)];

    if(uwJpgHSize >= 3840 || uwJpgVSize >= 2160)
        goto PHOTOPLAY_ERR;
	
	memset(&tPhotoPlayNodeInfo, 0, sizeof(KNL_NODE_INFO));
#if !(defined(BSP_DVR_SDK) || (defined(BSP_RVCS_SDK)&&defined(OP_STA)&&APP_PLAY_REMOTE_ENABLE) )
	tPhotoPlayNodeInfo.ubVMirror = (tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)?JPEG_V_MIRROR:JPEG_MIRROR_DISABLE;
	ulVdoYuvAddr = ulKNL_PhotoLcdDisplaySetup(uwJpgHSize, uwJpgVSize);
	ulJpgBsAddr  = ulKNL_JPGAddr[0] + KNL_JPG_HEADER_SIZE;
#else
	tPhotoPlayNodeInfo.ubVMirror = (tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)?0:0;
	ulVdoYuvAddr = ulKNL_PhotoLcdDisplaySetup(uwJpgHSize, uwJpgVSize);
	ulJpgBsAddr  = ulKNL_JPGAddr + KNL_JPG_HEADER_SIZE;	
#endif	
	tPhotoPlayNodeInfo.ubJpgScale = 0;
	ubKNL_JPEGDecode(&tPhotoPlayNodeInfo, JPEG_YUV420, JPEG_FN_USE_ISR, uwJpgHSize, uwJpgVSize, ulVdoYuvAddr, ulJpgBsAddr);
	osKNL_PhotoGraphFinSig = osSignalWait(osKNL_PhotoPlyFinSignal, 1000);
	tKNL_PhotoSts = ((osKNL_PhotoGraphFinSig.status == osEventSignal) &&
					 (osKNL_PhotoGraphFinSig.value.signals == osKNL_PhotoPlyFinSignal))?KNL_OK:KNL_ErrorTimeout;
	if(KNL_OK != tKNL_PhotoSts)
		goto PHOTOPLAY_ERR;
	if(KNL_DISP_ROTATE_90 == tKNL_GetDispRotate())
	{
		ubKNL_JPEGEncode(JPEG_YUV420, JPEG_FN_USE_ISR, uwJpgHSize, uwJpgVSize, ulVdoYuvAddr, ulJpgBsAddr);
		osKNL_PhotoGraphFinSig = osSignalWait(osKNL_PhotoPlyFinSignal, 1000);
		tKNL_PhotoSts = ((osKNL_PhotoGraphFinSig.status == osEventSignal) &&
						 (osKNL_PhotoGraphFinSig.value.signals == osKNL_PhotoPlyFinSignal))?KNL_OK:KNL_ErrorTimeout;
		if(KNL_OK != tKNL_PhotoSts)
			goto PHOTOPLAY_ERR;
		tPhotoPlayNodeInfo.ubHMirror = JPEG_H_MIRROR;
#if defined(BSP_DVR_SDK)
        tPhotoPlayNodeInfo.ubVMirror = 1;
#endif	
		tPhotoPlayNodeInfo.ubRotate  = JPEG_ROT_90Deg;
		tPhotoPlayNodeInfo.ubJpgScale = 0;
		ubKNL_JPEGDecode(&tPhotoPlayNodeInfo, JPEG_YUV420, JPEG_FN_USE_ISR, uwJpgHSize, uwJpgVSize, ulVdoYuvAddr, ulJpgBsAddr);
		osKNL_PhotoGraphFinSig = osSignalWait(osKNL_PhotoPlyFinSignal, 1000);
		tKNL_PhotoSts = ((osKNL_PhotoGraphFinSig.status == osEventSignal) &&
						 (osKNL_PhotoGraphFinSig.value.signals == osKNL_PhotoPlyFinSignal))?KNL_OK:KNL_ErrorTimeout;
		if(KNL_OK != tKNL_PhotoSts)
			goto PHOTOPLAY_ERR;
	}
	KNL_PhotoLcdDisplayOn();
	if(pPhotoInfo->pRecordStsNtyCb)
		pPhotoInfo->pRecordStsNtyCb(KNL_OK);
	return;
PHOTOPLAY_ERR:
	KNL_SetRecordFunc(KNL_RECORDFUNC_DISABLE);
	if(pPhotoInfo->pRecordStsNtyCb)
		pPhotoInfo->pRecordStsNtyCb(KNL_ErrorTimeout);
}
#endif
//------------------------------------------------------------------------------
#if APP_REC_FUNC_ENABLE
KNL_Status_t KNL_VideoRecStop(KNL_RecordFunc_t tRecordFunc, uint8_t ubFlag)
{
	KNL_Status_t tRecStsRpt = KNL_OK;
    uint8_t ubRet=1;

	if((KNL_RECORDFUNC_LOOP != tRecordFunc) && (KNL_RECORDFUNC_MANU != tRecordFunc))
		return KNL_OK;

    if((ubFlag != 1))   
        ubRet = ubREC_Stop();
    
    if( ubRet )
    {
        KNL_ResetSortingResult();
        FS_LoopingOff(tKNL_FsMediaInfo.MediaSel, LOOPING_EMG);
        FS_LoopingOff(tKNL_FsMediaInfo.MediaSel, LOOPING_TIMELAPS);
        FS_LoopingOff(tKNL_FsMediaInfo.MediaSel, LOOPING_NORMAL);
        FS_LoopingOff(tKNL_FsMediaInfo.MediaSel, LOOPING_CUST1_VIDEO);
        FS_LoopingOff(tKNL_FsMediaInfo.MediaSel, LOOPING_CUST1_PHOTO);
        ADO_RemoteRecordPathSwitch(ADO_OFF);
#if defined(BSP_DVR_SDK)
#ifdef OP_AP
        ADO_AdcStop();
#endif
        ADO_LocalRecordPathSwitch(ADO_OFF, NONE, NULL);
#if APP_REC_FUNC_ADO_MIX_ENABLE
		ADO_LocalRecMixRemoteSwitch(7, 7, ADO_OFF);
#endif
#endif
        printd(DBG_CriticalLvl, "  Rec Stop !\r\n");
        tRecStsRpt = KNL_VDOREC_STOP;
    }
    else
    {
        printd(DBG_ErrorLvl, "Rec Stop Timeout !\r\n");
        tRecStsRpt = KNL_VDOREC_STOP_TIMEOUT;
    }    
	tKNL_RecordAct.tRecordSts = KNL_RECORDING_STOP;
	return tRecStsRpt;
}
//------------------------------------------------------------------------------
EREC_TIME_LAPSE KNL_TimelapseStatus = REC_TIMELAPSE_OFF;
void KNL_VideoRecFunc(KNL_RecordAct_t *pVideoInfo)
{
	KNL_Status_t tRecStsRpt = KNL_VDOREC_START;
	KNL_RecordFunc_t tRecordFunc;

	tRecordFunc = tKNL_GetRecordFunc();
    if((KNL_RECORDING_START == tKNL_RecordAct.tRecordSts) &&
	   ((KNL_RECORDFUNC_LOOP == tRecordFunc) || (KNL_RECORDFUNC_MANU == tRecordFunc)))
    {
		tRecStsRpt = KNL_VideoRecStop(pVideoInfo->tRecordFunc,pVideoInfo->ubRecOnceStopCBFlag);
		KNL_SetRecordFunc(KNL_RECORDFUNC_DISABLE);
    }
    else if(pVideoInfo->tRecordFunc == KNL_RECORDFUNC_LOOP)
    {
#if OP_AP    
        ADO_RemoteRecordPathSwitch(ADO_ON);
#endif

#if (defined(BSP_DVR_SDK) || (OP_STA&&APP_REC_FUNC_ENABLE))
        printf("ADORecPathSW1\n");
#if(APP_ADO_FUNC_ENABLE==1)     
        ADO_AdcStart();
#if(ADO_ENC_TYPE==AUDIO32_ENC)
		ADO_LocalRecordPathSwitch(ADO_ON, ALAW, KNL_AdoLocalRecSendQProcess);
#elif(ADO_ENC_TYPE==SW_AAC_ENC)
		ADO_LocalRecordPathSwitch(ADO_ON, AAC, KNL_AdoLocalRecSendQProcess);
#endif
#if APP_REC_FUNC_ADO_MIX_ENABLE
		ADO_LocalRecMixRemoteSwitch(7, 7, ADO_ON);
#endif
#else
        ADO_LocalRecordPathSwitch(ADO_OFF, NONE, NULL); 
#if APP_REC_FUNC_ADO_MIX_ENABLE
		ADO_LocalRecMixRemoteSwitch(7, 7, ADO_OFF);
#endif
#endif        
#endif
		
#if (OP_STA&&APP_REC_FUNC_ENABLE)
        KNL_RecFileFormatConfigInit();
#endif
		//normal looping setting
		KNL_FS_NormalLoopingOnSetting(tKNL_FsMediaInfo.MediaSel);

#if (OP_STA&&APP_REC_FUNC_ENABLE)
        REC_TimeSet(1,60);  // Reset cnt, 0:record time def  
#else
        REC_TimeSet(1,0);	// Reset cnt, 0:record time def
#endif
        REC_EventInfoSet(REC_EVENT_NORMAL);
        ubREC_Continue();
        KNL_SetRecordFunc(KNL_RECORDFUNC_LOOP);
		tKNL_RecordAct.tRecordSts = KNL_RECORDING_START;
		printd(DBG_CriticalLvl, "  Rec Start\r\n");
    }
    else if(pVideoInfo->tRecordFunc == KNL_RECORDFUNC_MANU)
    {
		uint8_t ubRecRpt = 1;
#if OP_AP 
        ADO_RemoteRecordPathSwitch(ADO_ON);
#endif
#if (defined(BSP_DVR_SDK) || (OP_STA&&APP_REC_FUNC_ENABLE))
        printf("ADORecPathSW2\n");
#if(APP_ADO_FUNC_ENABLE==1)     
        ADO_AdcStart();
#if(ADO_ENC_TYPE==AUDIO32_ENC)
		ADO_LocalRecordPathSwitch(ADO_ON, ALAW, KNL_AdoLocalRecSendQProcess);
#elif(ADO_ENC_TYPE==SW_AAC_ENC)
		ADO_LocalRecordPathSwitch(ADO_ON, AAC, KNL_AdoLocalRecSendQProcess);
#endif
#if APP_REC_FUNC_ADO_MIX_ENABLE
		ADO_LocalRecMixRemoteSwitch(7, 7, ADO_ON);
#endif
#else
        ADO_LocalRecordPathSwitch(ADO_OFF, NONE, NULL); 
#if APP_REC_FUNC_ADO_MIX_ENABLE
		ADO_LocalRecMixRemoteSwitch(7, 7, ADO_OFF);
#endif
#endif
#endif

#if (OP_STA&&APP_REC_FUNC_ENABLE)
        KNL_RecFileFormatConfigInit();
#endif
		//normal looping setting
		KNL_FS_NormalLoopingOnSetting(tKNL_FsMediaInfo.MediaSel);

        if(pVideoInfo->tREC_TmLapse == REC_TIMELAPSE_ON)
        {
			FS_LoopingOn(tKNL_FsMediaInfo.MediaSel, LOOPING_TIMELAPS, 2000);
            ubREC_TimeLapseConfig(1,1,1);
            REC_TimeSet(1,1800);
        }
        else
		{
			FS_LoopingOff(tKNL_FsMediaInfo.MediaSel, LOOPING_TIMELAPS);
#if (OP_STA&&APP_REC_FUNC_ENABLE)
            REC_TimeSet(1,60);
#else
            REC_TimeSet(1,0);	// Reset cnt, record 1min
#endif            
		}
		KNL_TimelapseStatus = (EREC_TIME_LAPSE)pVideoInfo->tREC_TmLapse;
        REC_EventInfoSet(REC_EVENT_NORMAL);
        ubRecRpt = ubREC_Once();
		if(ubRecRpt)
		{
			KNL_SetRecordFunc(KNL_RECORDFUNC_MANU);
			tKNL_RecordAct.tRecordSts = KNL_RECORDING_START;
			printd(DBG_CriticalLvl, "  Rec Start\r\n");
		}
		else
			tRecStsRpt = KNL_VDOREC_STOP;
    }
	if(pVideoInfo->pRecordStsNtyCb)
		pVideoInfo->pRecordStsNtyCb(tRecStsRpt);
}
//------------------------------------------------------------------------------
void KNL_CreateSrcNumPool(uint8_t *pSrcNumPool)
{
	KNL_ROLE tRole;
	uint8_t ubMainSrc[4] = {KNL_SRC_1_MAIN, KNL_SRC_2_MAIN, KNL_SRC_3_MAIN, KNL_SRC_4_MAIN};
	uint8_t ubMainIdx = 0;

	for(tRole = KNL_STA1; tRole <= KNL_STA4; tRole++)
	{
		if(KNL_SRC_NONE != pSrcNumPool[tRole])
			ubMainSrc[pSrcNumPool[tRole]] = KNL_SRC_NONE;
	}
	for(tRole = KNL_STA1; tRole <= KNL_STA4; tRole++)
	{
		if(KNL_SRC_NONE == pSrcNumPool[tRole])
		{
			for(ubMainIdx = 0; ubMainIdx < 4; ubMainIdx++)
			{
				if(KNL_SRC_NONE != ubMainSrc[ubMainIdx])
				{
					pSrcNumPool[tRole]   = ubMainSrc[ubMainIdx];
					ubMainSrc[ubMainIdx] = KNL_SRC_NONE;
					break;
				}
			}
		}
	}
}
//------------------------------------------------------------------------------
void KNL_DispSetup4VideoPlay(KNL_SrcLocateMap_t tPlaySrcLoc, KNL_RecordAct_t *pVideoInfo, uint16_t *pVdoH_Size, uint16_t *pVdoV_Size)
{
#if OP_AP
	KNL_NODE tKNL_PlayPath[2][5] = { {KNL_NODE_REC_PLAY, KNL_NODE_VDO_BS_BUF1, KNL_NODE_H264_DEC, KNL_NODE_LCD, KNL_NODE_END},
	                                {KNL_NODE_COMM_RX_VDO, KNL_NODE_VDO_BS_BUF1, KNL_NODE_H264_DEC, KNL_NODE_LCD, KNL_NODE_END}};
	uint8_t ubDecIdx[4] = {DECODE_0, DECODE_1, DECODE_2, DECODE_3};
	KNL_NODE_INFO tKNL_PlayNodeInfo = {0};
	KNL_SCALE tKNL_DecScaleParam;
	KNL_ROLE tPlayRole = KNL_STA1;
	KNL_SRC  tPlaySrcPool[4] = {KNL_SRC_NONE, KNL_SRC_NONE, KNL_SRC_NONE, KNL_SRC_NONE}, tVdoSrcNum;
	uint16_t uwVdoH_Size, uwVdoV_Size;
	uint8_t ubNodeNum, ubNodeIdx;
	uint8_t ubPlayActNum = ubKNL_VdoPlayActNum;

#if (APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)	
    if(pVideoInfo->tSimFolder == KNL_SIM_FLD)
        ubPlayActNum = 4;
#endif
	for(tPlayRole = KNL_STA1; tPlayRole < ubPlayActNum; tPlayRole++)
		tPlaySrcPool[tPlayRole] = tPlaySrcLoc.tSrcNum[tPlayRole];
	KNL_CreateSrcNumPool((uint8_t *)&tPlaySrcPool[0]);
	for(tPlayRole = KNL_STA1; tPlayRole < ubPlayActNum; tPlayRole++)
		tPlaySrcLoc.tSrcNum[tPlayRole] = tPlaySrcPool[tPlayRole];
	KNL_VdoPathReset();
    memset(ubKNL_VdoPlayActCh,0,4);
	tPlayRole = KNL_STA1;
#if (APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)	
    if(pVideoInfo->tSimFolder == KNL_SIM_FLD)
        tPlayRole = ubKNL_GetTXFldRole(pVideoInfo->uwSimFldSelIdx);
#endif
	for(; tPlayRole < ubPlayActNum; tPlayRole++)
	{
		tVdoSrcNum  = tPlaySrcPool[tPlayRole];
		uwVdoH_Size = pVdoH_Size[tPlayRole];
		uwVdoV_Size = pVdoV_Size[tPlayRole];
		if((((KNL_DISP_3T_2L1R == pVideoInfo->tPlayDispTye) || (KNL_DISP_3T_1L2R == pVideoInfo->tPlayDispTye)) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)) ||
		   (((KNL_DISP_3T_2T1B == pVideoInfo->tPlayDispTye) || (KNL_DISP_3T_1T2B == pVideoInfo->tPlayDispTye)) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0))  ||
	       ((KNL_DISP_3T_3COL == pVideoInfo->tPlayDispTye) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)))
			tKNL_DecScaleParam = (uwVdoH_Size > 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1;
		else if(KNL_DISP_ROTATE_90 == tKNL_GetDispRotate())
			tKNL_DecScaleParam = (KNL_DISP_H == pVideoInfo->tPlayDispTye)?(uwVdoH_Size > 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1:KNL_SCALE_X1;
		else
			tKNL_DecScaleParam = (KNL_DISP_H == pVideoInfo->tPlayDispTye)?(uwVdoH_Size > 1024)?KNL_SCALE_X0P25:KNL_SCALE_X0P5:KNL_SCALE_X1;
		KNL_SetVdoH(tVdoSrcNum, uwVdoH_Size);
		KNL_SetVdoV(tVdoSrcNum, uwVdoV_Size);
		ubNodeNum  = (sizeof tKNL_PlayPath[pVideoInfo->tSimFolder]) / sizeof(KNL_NODE);
		for(ubNodeIdx = 0; ubNodeIdx < ubNodeNum; ubNodeIdx++)
		{
			tKNL_PlayNodeInfo.ubPreNode		= (0 == ubNodeIdx)?KNL_NODE_NONE:tKNL_PlayPath[pVideoInfo->tSimFolder][ubNodeIdx-1];
			tKNL_PlayNodeInfo.ubCurNode 	= tKNL_PlayPath[pVideoInfo->tSimFolder][ubNodeIdx];
			tKNL_PlayNodeInfo.ubNextNode 	= (ubNodeNum == (ubNodeIdx+1))?KNL_NODE_NONE:tKNL_PlayPath[pVideoInfo->tSimFolder][ubNodeIdx+1];
			tKNL_PlayNodeInfo.ubCodecIdx 	= ubDecIdx[tPlayRole];
			tKNL_PlayNodeInfo.uwVdoH		= (tKNL_PlayNodeInfo.ubCurNode == KNL_NODE_END)?0:uwVdoH_Size;
			tKNL_PlayNodeInfo.uwVdoV		= (tKNL_PlayNodeInfo.ubCurNode == KNL_NODE_END)?0:uwVdoV_Size;
			tKNL_PlayNodeInfo.ubRotate		= (tKNL_PlayNodeInfo.ubCurNode == KNL_NODE_H264_DEC)?tKNL_GetDispRotate():0;
			tKNL_PlayNodeInfo.ubHScale		= (tKNL_PlayNodeInfo.ubCurNode == KNL_NODE_END)?0:tKNL_DecScaleParam;
			tKNL_PlayNodeInfo.ubVScale		= (tKNL_PlayNodeInfo.ubCurNode == KNL_NODE_END)?0:tKNL_DecScaleParam;
			ubKNL_SetVdoPathNode(tVdoSrcNum, ubNodeIdx, tKNL_PlayNodeInfo);
		}
        ubKNL_VdoPlayActCh[tPlayRole] = 1;
#if (APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)		
        if(pVideoInfo->tSimFolder == KNL_SIM_FLD)
            break;
#endif
	}
	tPlaySrcLoc.ubSetupFlag = ((KNL_DISP_SINGLE  == pVideoInfo->tPlayDispTye) ||
							   (KNL_DISP_DUAL_C  == pVideoInfo->tPlayDispTye) || (KNL_DISP_DUAL_U  == pVideoInfo->tPlayDispTye) ||
	                           (KNL_DISP_3T_2L1R == pVideoInfo->tPlayDispTye) || (KNL_DISP_3T_1L2R == pVideoInfo->tPlayDispTye) ||
				               (KNL_DISP_3T_2T1B == pVideoInfo->tPlayDispTye) || (KNL_DISP_3T_1T2B == pVideoInfo->tPlayDispTye) ||
				               (KNL_DISP_3T_3COL == pVideoInfo->tPlayDispTye))?TRUE:FALSE;
	tPlaySrcLoc.ubDispBufChgFlag = TRUE;
	KNL_ModifyDispType(pVideoInfo->tPlayDispTye, tPlaySrcLoc);
#if (APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)	
    if(pVideoInfo->tSimFolder == KNL_SIM_FLD)
    {
        KNL_NODE_INFO tNodeInfo;
        KNL_ImageDecodeSetup((KNL_SRC)tPlaySrcLoc.tSrcNum[ubKNL_GetTXFldRole(pVideoInfo->uwSimFldSelIdx)]);
        KNL_VdoStart((KNL_SRC)tPlaySrcLoc.tSrcNum[ubKNL_GetTXFldRole(pVideoInfo->uwSimFldSelIdx)]);
#if defined(A7130)        
        KNL_TXBBStart(ubKNL_GetTXFldRole(pVideoInfo->uwSimFldSelIdx));
#endif        
        tNodeInfo = tKNL_GetNodeInfo((KNL_SRC)tPlaySrcLoc.tSrcNum[ubKNL_GetTXFldRole(pVideoInfo->uwSimFldSelIdx)], KNL_NODE_H264_DEC);
        ubKNL_InitH264DecFlg[tNodeInfo.ubCodecIdx] = 1;
    }
    else
#endif
    {
    	for(tPlayRole = KNL_STA1; tPlayRole < pVideoInfo->ubPlayFileNum; tPlayRole++)
    	{
    	    KNL_NODE_INFO tNodeInfo;
    		KNL_ImageDecodeSetup(tPlaySrcLoc.tSrcNum[tPlayRole]);
    		KNL_VdoStart(tPlaySrcLoc.tSrcNum[tPlayRole]);
    		tNodeInfo = tKNL_GetNodeInfo((KNL_SRC)tPlaySrcLoc.tSrcNum[tPlayRole], KNL_NODE_H264_DEC);
            ubKNL_InitH264DecFlg[tNodeInfo.ubCodecIdx] = 1;
    	}
    }
#elif (OP_STA && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
    KNL_NODE tKNL_PlayPath[] = {KNL_NODE_REC_PLAY, KNL_NODE_VDO_BS_BUF1, KNL_NODE_COMM_TX_VDO, KNL_NODE_END};
    uint8_t ubDecIdx[4] = {DECODE_0, DECODE_1, DECODE_2, DECODE_3};
    KNL_NODE_INFO tKNL_PlayNodeInfo = {0};
    KNL_SCALE tKNL_DecScaleParam;
    KNL_ROLE tPlayRole = KNL_STA1;
    KNL_SRC  tPlaySrcPool[4] = {KNL_SRC_NONE, KNL_SRC_NONE, KNL_SRC_NONE, KNL_SRC_NONE}, tVdoSrcNum;
    uint16_t uwVdoH_Size, uwVdoV_Size;
    uint8_t ubNodeNum, ubNodeIdx;

    for(tPlayRole = KNL_STA1; tPlayRole < ubKNL_VdoPlayActNum; tPlayRole++)
        tPlaySrcPool[tPlayRole] = tPlaySrcLoc.tSrcNum[tPlayRole];
    KNL_CreateSrcNumPool((uint8_t *)&tPlaySrcPool[0]);
    for(tPlayRole = KNL_STA1; tPlayRole < ubKNL_VdoPlayActNum; tPlayRole++)
        tPlaySrcLoc.tSrcNum[tPlayRole] = tPlaySrcPool[tPlayRole];
    KNL_VdoPathReset();
    memset(ubKNL_VdoPlayActCh,0,4);
    for(tPlayRole = KNL_STA1; tPlayRole < ubKNL_VdoPlayActNum; tPlayRole++)
    {
        tVdoSrcNum  = tPlaySrcPool[tPlayRole];
        uwVdoH_Size = pVdoH_Size[tPlayRole];
        uwVdoV_Size = pVdoV_Size[tPlayRole];
        if(KNL_DISP_ROTATE_90 == tKNL_GetDispRotate())
            tKNL_DecScaleParam = (KNL_DISP_H == pVideoInfo->tPlayDispTye)?(uwVdoH_Size > 1024)?KNL_SCALE_X0P5:KNL_SCALE_X1:KNL_SCALE_X1;
        else
            tKNL_DecScaleParam = (KNL_DISP_H == pVideoInfo->tPlayDispTye)?(uwVdoH_Size > 1024)?KNL_SCALE_X0P25:KNL_SCALE_X0P5:KNL_SCALE_X1;
        KNL_SetVdoH(tVdoSrcNum, uwVdoH_Size);
        KNL_SetVdoV(tVdoSrcNum, uwVdoV_Size);
        ubNodeNum  = (sizeof tKNL_PlayPath) / sizeof(KNL_NODE);
        for(ubNodeIdx = 0; ubNodeIdx < ubNodeNum; ubNodeIdx++)
        {
            tKNL_PlayNodeInfo.ubPreNode     = (0 == ubNodeIdx)?KNL_NODE_NONE:tKNL_PlayPath[ubNodeIdx-1];
            tKNL_PlayNodeInfo.ubCurNode     = tKNL_PlayPath[ubNodeIdx];
            tKNL_PlayNodeInfo.ubNextNode    = (ubNodeNum == (ubNodeIdx+1))?KNL_NODE_NONE:tKNL_PlayPath[ubNodeIdx+1];
            tKNL_PlayNodeInfo.ubCodecIdx    = ubDecIdx[tPlayRole];
            tKNL_PlayNodeInfo.uwVdoH        = (tKNL_PlayNodeInfo.ubCurNode == KNL_NODE_END)?0:uwVdoH_Size;
            tKNL_PlayNodeInfo.uwVdoV        = (tKNL_PlayNodeInfo.ubCurNode == KNL_NODE_END)?0:uwVdoV_Size;
            tKNL_PlayNodeInfo.ubRotate      = (tKNL_PlayNodeInfo.ubCurNode == KNL_NODE_H264_DEC)?tKNL_GetDispRotate():0;
            tKNL_PlayNodeInfo.ubHScale      = (tKNL_PlayNodeInfo.ubCurNode == KNL_NODE_END)?0:tKNL_DecScaleParam;
            tKNL_PlayNodeInfo.ubVScale      = (tKNL_PlayNodeInfo.ubCurNode == KNL_NODE_END)?0:tKNL_DecScaleParam;
            ubKNL_SetVdoPathNode(tVdoSrcNum, ubNodeIdx, tKNL_PlayNodeInfo);
        }
        ubKNL_VdoPlayActCh[tPlayRole] = 1;
    }
    tPlaySrcLoc.ubSetupFlag = TRUE;
    tPlaySrcLoc.ubDispBufChgFlag = TRUE;

#if (defined(BUC_CU) && (!defined(S2019A)))
    KNL_VdoCodecProcOff();
#endif
	BUF_ResetFreeAddr();
	KNL_BufInit();
#if (defined(BUC_CU) && (!defined(S2019A)))
    KNL_VdoCodecProcOn();
#endif

    for(tPlayRole = KNL_STA1; tPlayRole < pVideoInfo->ubPlayFileNum; tPlayRole++)
    {
        KNL_VdoStart(tPlaySrcLoc.tSrcNum[tPlayRole]);
    }
#endif
}
//------------------------------------------------------------------------------
KNL_PlayAct_t KNL_PlayInfo;

void KNL_VideoPlayFunc(KNL_RecordAct_t *pVideoInfo)
{
#if OP_AP
	FS_FILE_HIDDEN_INFO_t PlayBackFileInfo[4];
	uint8_t	ubPlayFileNum = 0xFF;
	uint8_t ubPlyRet = 0;
	uint8_t ubFileIdx;
	KNL_SrcLocateMap_t tPlaySrcLoc;
	KNL_ROLE tPlayRole;
	KNL_SRC tVdoSrcNum;
	uint16_t uwPlayRes_H[4] = {0, 0, 0, 0}, uwPlayRes_V[4] = {0, 0, 0, 0};
	uint8_t ubDualViewSwpFlag = FALSE;

    if(ubPLY_GetOpMode() == PLY_MODE_R)
        return;

#if (APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
    ubKNL_PlayRtCfged = 0;
    vKNL_SetPlayRole(KNL_NONE);
#endif

#if defined(BSP_DVR_SDK)
    KNL_SetPlayBackIngFlg(1);
#endif
    KNL_SetPlayDestFld(pVideoInfo->tSimFolder);
	KNL_SetRecordFunc(KNL_VIDEO_PLAY);
	for(tPlayRole = KNL_STA1; tPlayRole < DISPLAY_MODE; tPlayRole++)
	{
		tVdoSrcNum = (KNL_SRC)(KNL_SRC_1_MAIN + tPlayRole);
		KNL_VdoStop(tVdoSrcNum);
	}
	ubKNL_WaitNodeFinish(KNL_SRC_1_MAIN);
#if (defined(S2019A) && defined(OP_AP))
#if (APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
    if(pVideoInfo->tSimFolder == KNL_SIM_FLD)
    {
        ubKNL_PlayRtCfged = 1;
		vKNL_SetPlayRole(ubKNL_GetTXFldRole(pVideoInfo->uwSimFldSelIdx));
	}
	else	
#endif
	    sPRF_KeepAlive(TRUE);
#endif
#if defined(BSP_DVR_SDK)
    //justin 2019.08.20
    KNL_VdoStop(KNL_SRC_PREVIEW_LOCAL);
    KNL_VdoStop(KNL_SRC_STORAGE_LOCAL);
    KNL_SenStop(KNL_SRC_PREVIEW_LOCAL);
    KNL_SenStop(KNL_SRC_STORAGE_LOCAL);
#endif    
	KNL_ResetVdoProc();
	KNL_ResetLcdChannel();
	if(KNL_DISP_H == tKNL_GetDispType())
		KNL_CreateBlackDmyPat(ulBUF_GetBlkBufAddr(0, BUF_IMG_MERGE), (ulKNL_GetImgMergeBufSz()+((tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)?KNL_JPG_BS_SIZE:0)));
	else if((((KNL_DISP_3T_2L1R == tKNL_GetDispType()) || (KNL_DISP_3T_1L2R == tKNL_GetDispType())) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)) ||
		    (((KNL_DISP_3T_2T1B == tKNL_GetDispType()) || (KNL_DISP_3T_1T2B == tKNL_GetDispType())) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0))  ||
	         ((KNL_DISP_3T_3COL == tKNL_GetDispType()) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)))
		KNL_CreateBlackDmyPat(ulBUF_GetBlkBufAddr(0, BUF_IMG_MERGE), ulKNL_GetImgMergeBufSz());

#if !APP_FS_FILE_LIST_STYLE
    if(ubKNL_GetBackupDispInfoFlag() == FALSE)
    {
        KNL_SetBackupDispInfoFlag(TRUE);
        KNL_BackDispType     	= tKNL_GetDispType();
		KNL_BackSwDispInfo   	= KNL_SwDispInfo;
#if defined(BSP_DVR_SDK)
        if(KNL_BackDispType == KNL_DISP_DUAL_C)
        {
            ubKNL_BackSrcLocate[0]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
    		ubKNL_BackSrcLocate[1]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION2);
    		ubKNL_BackSrcLocate[2]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION3);
    		ubKNL_BackSrcLocate[3]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION4);
        }
        else if(KNL_BackDispType == KNL_DISP_SINGLE)
        {
            ubKNL_BackSrcLocate[0]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
    		ubKNL_BackSrcLocate[1]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION2);
    		ubKNL_BackSrcLocate[2]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION3);
    		ubKNL_BackSrcLocate[3]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION4);
        }
#else
        ubKNL_BackSrcLocate[0]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
		ubKNL_BackSrcLocate[1]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION2);
		ubKNL_BackSrcLocate[2]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION3);
		ubKNL_BackSrcLocate[3]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION4);
#endif		
    }
#endif    

	ubKNL_VdoPlayActNum = KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[0])).SubHidnInfo.ubActiveFileNum;
	if(ubKNL_VdoPlayActNum > REC_SRC_NUM)
		ubKNL_VdoPlayActNum = REC_SRC_NUM;

    for(tPlayRole = KNL_STA1; tPlayRole < 4; tPlayRole++)
    {
        tPlaySrcLoc.tSrcNum[tPlayRole] = KNL_SRC_NONE;
        tPlaySrcLoc.tSrcLocate[tPlayRole] = KNL_DISP_LOCATION_ERR;
    }
		
	if((KNL_DISP_DUAL_C == pVideoInfo->tPlayDispTye) && (KNL_DISP_ROTATE_0 == tKNL_GetDispRotate()))
	{
		pVideoInfo->tPlayDispTye = KNL_DISP_DUAL_U;
		ubDualViewSwpFlag = TRUE;
	}
	else if((KNL_DISP_DUAL_U == pVideoInfo->tPlayDispTye) && (KNL_DISP_ROTATE_90 == tKNL_GetDispRotate()))
	{
		pVideoInfo->tPlayDispTye = KNL_DISP_DUAL_C;
		ubDualViewSwpFlag = TRUE;
	}
	switch(pVideoInfo->tPlayDispTye)
	{
		case KNL_DISP_SINGLE:
			ubPlayFileNum = 1;
#if (APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)			
			if(pVideoInfo->tSimFolder == KNL_SIM_FLD)
			{
				tPlaySrcLoc.tSrcLocate[ubKNL_GetTXFldRole(pVideoInfo->uwSimFldSelIdx)] = KNL_DISP_LOCATION1;
#if defined(BSP_DVR_SDK)
				tPlaySrcLoc.tSrcNum[ubKNL_GetTXFldRole(pVideoInfo->uwSimFldSelIdx)] = KNL_SRC_1_MAIN;//(KNL_SRC)KNL_GetFileHidInfo(uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[0])).SrcNum;
#else
	            tPlaySrcLoc.tSrcNum[ubKNL_GetTXFldRole(pVideoInfo->uwSimFldSelIdx)] = (KNL_SRC)KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[0])).SrcNum;
#endif
				KNL_SetDispSrc(tPlaySrcLoc.tSrcLocate[ubKNL_GetTXFldRole(pVideoInfo->uwSimFldSelIdx)], tPlaySrcLoc.tSrcNum[ubKNL_GetTXFldRole(pVideoInfo->uwSimFldSelIdx)]);
			}
			else
#endif
			{
				tPlaySrcLoc.tSrcLocate[0] = KNL_DISP_LOCATION1;
#if defined(BSP_DVR_SDK)
				tPlaySrcLoc.tSrcNum[0] = KNL_SRC_1_MAIN;//(KNL_SRC)KNL_GetFileHidInfo(uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[0])).SrcNum;
#else
            	tPlaySrcLoc.tSrcNum[0] = (KNL_SRC)KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[0])).SrcNum;
#endif
				KNL_SetDispSrc(tPlaySrcLoc.tSrcLocate[0], tPlaySrcLoc.tSrcNum[0]);
			}
			break;
		case KNL_DISP_DUAL_C:
			ubPlayFileNum = 2;
			if(ubKNL_VdoPlayActNum != ubPlayFileNum)
			{
				for(ubFileIdx = 0; ubFileIdx < pVideoInfo->ubPlayFileNum; ubFileIdx++)
					tPlaySrcLoc.tSrcNum[ubFileIdx] = (KNL_SRC)KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[ubFileIdx])).SrcNum;
				tPlaySrcLoc.tSrcLocate[0] = KNL_DISP_LOCATION2;
				tPlaySrcLoc.tSrcLocate[1] = KNL_DISP_LOCATION1;
				KNL_SetDispSrc(tPlaySrcLoc.tSrcLocate[0], tPlaySrcLoc.tSrcNum[0]);
				KNL_SetDispSrc(tPlaySrcLoc.tSrcLocate[1], tPlaySrcLoc.tSrcNum[1]);
				break;
			}
		case KNL_DISP_DUAL_U:
			ubPlayFileNum = 2;
			if(pVideoInfo->ubPlayFileNum < ubPlayFileNum)
			{
				tPlaySrcLoc.tSrcNum[1]		= KNL_SRC_NONE;
				tPlaySrcLoc.tSrcLocate[1] 	= KNL_DISP_LOCATION_ERR;
				tPlaySrcLoc.tSrcNum[0] 		= (KNL_SRC)KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[0])).SrcNum;
				tPlaySrcLoc.tSrcLocate[0] 	= (tPlaySrcLoc.tSrcNum[0] == (KNL_SRC)KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[0])).SubHidnInfo.ubSrcLocate[0])?KNL_DISP_LOCATION1:KNL_DISP_LOCATION2;
			}
			else
			{
				for(ubFileIdx = 0; ubFileIdx < pVideoInfo->ubPlayFileNum; ubFileIdx++)
				{
					if(ubKNL_VdoPlayActNum == ubPlayFileNum)
					{
						tPlaySrcLoc.tSrcNum[ubFileIdx] = (KNL_SRC)KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[0])).SubHidnInfo.ubSrcLocate[ubFileIdx];
						tPlaySrcLoc.tSrcLocate[0] = (TRUE == ubDualViewSwpFlag)?KNL_DISP_LOCATION2:KNL_DISP_LOCATION1;
						tPlaySrcLoc.tSrcLocate[1] = (TRUE == ubDualViewSwpFlag)?KNL_DISP_LOCATION1:KNL_DISP_LOCATION2;
					}
					else
					{
						tPlaySrcLoc.tSrcNum[ubFileIdx] = (KNL_SRC)KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[ubFileIdx])).SrcNum;
						tPlaySrcLoc.tSrcLocate[0] = KNL_DISP_LOCATION1;
						tPlaySrcLoc.tSrcLocate[1] = KNL_DISP_LOCATION2;
					}
				}
			}
			KNL_SetDispSrc(tPlaySrcLoc.tSrcLocate[0], tPlaySrcLoc.tSrcNum[0]);
			KNL_SetDispSrc(tPlaySrcLoc.tSrcLocate[1], tPlaySrcLoc.tSrcNum[1]);
			break;
		case KNL_DISP_3T_2L1R:
		case KNL_DISP_3T_1L2R:
		case KNL_DISP_3T_2T1B:
		case KNL_DISP_3T_1T2B:
		case KNL_DISP_3T_3COL:
			for(ubFileIdx = 0; ubFileIdx < ubKNL_VdoPlayActNum; ubFileIdx++)
				tPlaySrcLoc.tSrcNum[ubFileIdx] = (KNL_SRC)KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[0])).SubHidnInfo.ubSrcLocate[ubFileIdx];
			tPlaySrcLoc.tSrcLocate[0] = KNL_DISP_LOCATION1;
			tPlaySrcLoc.tSrcLocate[1] = KNL_DISP_LOCATION2;
			tPlaySrcLoc.tSrcLocate[2] = KNL_DISP_LOCATION3;
			KNL_SetDispSrc(KNL_DISP_LOCATION1, KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[0])).SubHidnInfo.ubSrcLocate[0]);
			KNL_SetDispSrc(KNL_DISP_LOCATION2, KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[0])).SubHidnInfo.ubSrcLocate[1]);
			KNL_SetDispSrc(KNL_DISP_LOCATION3, KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[0])).SubHidnInfo.ubSrcLocate[2]);
			break;
		case KNL_DISP_QUAD:
		case KNL_DISP_H:
			ubPlayFileNum = pVideoInfo->ubPlayFileNum;
			for(ubFileIdx = 0; ubFileIdx < pVideoInfo->ubPlayFileNum; ubFileIdx++)
				tPlaySrcLoc.tSrcNum[ubFileIdx] = (KNL_SRC)KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[ubFileIdx])).SrcNum;
			KNL_SetDispSrc(KNL_DISP_LOCATION1, KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[0])).SubHidnInfo.ubSrcLocate[0]);
			KNL_SetDispSrc(KNL_DISP_LOCATION2, KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[0])).SubHidnInfo.ubSrcLocate[1]);
			KNL_SetDispSrc(KNL_DISP_LOCATION3, KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[0])).SubHidnInfo.ubSrcLocate[2]);
			KNL_SetDispSrc(KNL_DISP_LOCATION4, KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[0])).SubHidnInfo.ubSrcLocate[3]);
			break;
		default:
            KNL_SetPlayDestFld(KNL_REAL_FLD);
			KNL_SetRecordFunc(KNL_RECORDFUNC_DISABLE);
			KNL_SetBackupDispInfoFlag(FALSE);
			if(pVideoInfo->pRecordStsNtyCb)
				pVideoInfo->pRecordStsNtyCb(KNL_ErrorVdoPlay);
			return;
	}
#if !defined(BSP_DVR_SDK)
	for(ubFileIdx = 0; ubFileIdx < ubKNL_VdoPlayActNum; ubFileIdx++)
	{
#if (APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
		if(pVideoInfo->tSimFolder == KNL_SIM_FLD)
		{
			uwPlayRes_H[ubKNL_GetTXFldRole(pVideoInfo->uwSimFldSelIdx)] = KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[0])).SubHidnInfo.uwRes_HSize;
			uwPlayRes_V[ubKNL_GetTXFldRole(pVideoInfo->uwSimFldSelIdx)] = KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[0])).SubHidnInfo.uwRes_VSize;
		}
		else
#endif
		{
			uwPlayRes_H[ubFileIdx] = KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[0])).SubHidnInfo.uwRes_HSize;
			uwPlayRes_V[ubFileIdx] = KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[0])).SubHidnInfo.uwRes_VSize;
		}
	}
#else
        uwPlayRes_H[0] = KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[0])).SubHidnInfo.uwRes_HSize;
		uwPlayRes_V[0] = KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[0])).SubHidnInfo.uwRes_VSize;
        uwPlayRes_H[1] = 0x500;
        uwPlayRes_V[1] = 0x2D0;
#endif
	KNL_DispSetup4VideoPlay(tPlaySrcLoc, pVideoInfo, uwPlayRes_H, uwPlayRes_V);

	ubPlayFileNum = pVideoInfo->ubPlayFileNum;
    KNL_PlayInfo.ubOrigFileNum = ubPlayFileNum;
    KNL_PlayInfo.ubCurFileNum = ubPlayFileNum;    
    KNL_PlayInfo.uwOrigGpIdx = KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[0])).uwGroupIdx;
    KNL_PlayInfo.uwCurGpIdx = KNL_PlayInfo.uwOrigGpIdx;
    KNL_PlayInfo.tPlayDispTye = pVideoInfo->tPlayDispTye;
    KNL_PlayInfo.ubCurFileInGPNum = ubKNL_VdoPlayActNum;
    for(ubFileIdx = 0; ubFileIdx < ubPlayFileNum; ubFileIdx++)
	{
	    KNL_PlayInfo.ulOrigFileIdx[ubFileIdx] = pVideoInfo->ulVideoPlayIdx[ubFileIdx];
	    KNL_PlayInfo.ulCurFileIdx[ubFileIdx] = pVideoInfo->ulVideoPlayIdx[ubFileIdx];
        KNL_PlayInfo.ubOrigSrcNum[ubFileIdx] = KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[ubFileIdx])).SrcNum;
        PlayBackFileInfo[ubFileIdx] = KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[ubFileIdx]));
	}
    if(pVideoInfo->tSimFolder == KNL_REAL_FLD)
    {
    	ubPlyRet = ubPLY_Start(PLY_MODE_NORMAL,ubKNL_VdoPlayActNum, ubPlayFileNum, &PlayBackFileInfo[0]);
        if(ubPlyRet != 1)
    	{
    	    KNL_SetPlayDestFld(KNL_REAL_FLD);
    		KNL_SetRecordFunc(KNL_RECORDFUNC_DISABLE);
    		//KNL_VideoPlayStop();
    		//KNL_SetBackupDispInfoFlag(FALSE);
    		if(pVideoInfo->pRecordStsNtyCb)
    			pVideoInfo->pRecordStsNtyCb(KNL_ErrorVdoPlay);
    	}
    }
#elif (OP_STA && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
    FS_FILE_HIDDEN_INFO_t PlayBackFileInfo[4];
    uint8_t ubPlayFileNum = 0xFF;
    uint8_t ubPlyRet = 0;
    uint8_t ubFileIdx;
    KNL_SrcLocateMap_t tPlaySrcLoc;
    KNL_ROLE tPlayRole;
    KNL_SRC tVdoSrcNum;
    uint16_t uwPlayRes_H[4] = {0, 0, 0, 0}, uwPlayRes_V[4] = {0, 0, 0, 0};
    uint32_t i;
    KNL_ROLE tBackRoleNum;
    KNL_SRC tBackSrcNumMain,tBackSrcNumAux;

    if(ubPLY_GetOpMode() == PLY_MODE_R)
        return;

	//! Ado related paremter reset
    ulTxPlyAdo32EncFirstFlg = 1;
    ulTxPlyAdo32EncRemainDataSz = 0;
	for(i=0; i<ADO_AUDIO32_MAX_NUM; i++)
	{
		ADO_Ado32EncInit(i,SNX_AUD32_FMT16_16K_16KBPS);
	}

    KNL_SetPlayDestFld(pVideoInfo->tSimFolder);
    KNL_SetRecordFunc(KNL_VIDEO_PLAY);
    for(tPlayRole = KNL_STA1; tPlayRole < DISPLAY_MODE; tPlayRole++)
    {
        tVdoSrcNum = (KNL_SRC)(KNL_SRC_1_MAIN + tPlayRole);
        KNL_VdoStop(tVdoSrcNum);
        KNL_SenStop(tVdoSrcNum);
    }
    for(tPlayRole = KNL_STA1; tPlayRole < DISPLAY_MODE; tPlayRole++)
    {
        tVdoSrcNum = (KNL_SRC)(KNL_SRC_1_AUX + tPlayRole);
        KNL_VdoStop(tVdoSrcNum);
        KNL_SenStop(tVdoSrcNum);
    }
    SEN_SetIspOutEn(FALSE);
	SEN_SetDetectVideoState(0);
    tBackRoleNum = (KNL_ROLE)ubKNL_GetRole();
	if(ptKNL_VdoRoleMap2SrcNum)
	{
		tBackSrcNumMain = ptKNL_VdoRoleMap2SrcNum(KNL_MAIN_PATH, tBackRoleNum);
		tBackSrcNumAux = ptKNL_VdoRoleMap2SrcNum(KNL_SUB_PATH, tBackRoleNum);
	}
	else
	{
		tBackSrcNumMain = (KNL_SRC)(KNL_SRC_1_MAIN + tBackRoleNum);
		tBackSrcNumAux = (KNL_SRC)(KNL_SRC_1_AUX + tBackRoleNum);
	}
    ubKNL_WaitNodeFinish(tBackSrcNumMain);
    ubKNL_WaitNodeFinish(tBackSrcNumAux);
#if defined(S2019A)
    sPRF_KeepAlive(TRUE);
#endif

    KNL_ResetVdoProc();
    if(ubKNL_GetBackupDispInfoFlag() == FALSE)
    {
        KNL_SetBackupDispInfoFlag(TRUE);
        KNL_BackDispType        = tKNL_GetDispType();
        KNL_BackSwDispInfo      = KNL_SwDispInfo;
        ubKNL_BackSrcLocate[0]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
        ubKNL_BackSrcLocate[1]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION2);
        ubKNL_BackSrcLocate[2]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION3);
        ubKNL_BackSrcLocate[3]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION4);
        uwKNL_BackResH = uwKNL_GetVdoH(tBackSrcNumMain);
        uwKNL_BackResV = uwKNL_GetVdoV(tBackSrcNumMain);
    }
    
    for(tPlayRole = KNL_STA1; tPlayRole < DISPLAY_MODE; tPlayRole++)
    {
        tPlaySrcLoc.tSrcNum[tPlayRole] = KNL_SRC_NONE;
        tPlaySrcLoc.tSrcLocate[tPlayRole] = KNL_DISP_LOCATION_ERR;
    }
    
    ubKNL_VdoPlayActNum = 1;//KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[0])).SubHidnInfo.ubActiveFileNum;
    if(ubKNL_VdoPlayActNum > REC_SRC_NUM)
        ubKNL_VdoPlayActNum = REC_SRC_NUM;

    ubPlayFileNum = 1;
    tPlaySrcLoc.tSrcLocate[0] = KNL_DISP_LOCATION1;
    tPlaySrcLoc.tSrcNum[0] = KNL_SRC_1_MAIN;
    KNL_SetDispSrc(tPlaySrcLoc.tSrcLocate[0], tPlaySrcLoc.tSrcNum[0]);

    uwPlayRes_H[0] = KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[0])).SubHidnInfo.uwRes_HSize;
    uwPlayRes_V[0] = KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[0])).SubHidnInfo.uwRes_VSize;
    uwPlayRes_H[1] = 0x500;
    uwPlayRes_V[1] = 0x2D0;

    KNL_DispSetup4VideoPlay(tPlaySrcLoc, pVideoInfo, uwPlayRes_H, uwPlayRes_V);
    
    ubPlayFileNum = pVideoInfo->ubPlayFileNum;
    KNL_PlayInfo.ubOrigFileNum = ubPlayFileNum;
    KNL_PlayInfo.ubCurFileNum = ubPlayFileNum;    
    KNL_PlayInfo.uwOrigGpIdx = KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[0])).uwGroupIdx;
    KNL_PlayInfo.uwCurGpIdx = KNL_PlayInfo.uwOrigGpIdx;
    KNL_PlayInfo.tPlayDispTye = pVideoInfo->tPlayDispTye;
    KNL_PlayInfo.ubCurFileInGPNum = ubKNL_VdoPlayActNum;
    for(ubFileIdx = 0; ubFileIdx < ubPlayFileNum; ubFileIdx++)
    {
        KNL_PlayInfo.ulOrigFileIdx[ubFileIdx] = pVideoInfo->ulVideoPlayIdx[ubFileIdx];
        KNL_PlayInfo.ulCurFileIdx[ubFileIdx] = pVideoInfo->ulVideoPlayIdx[ubFileIdx];
        KNL_PlayInfo.ubOrigSrcNum[ubFileIdx] = KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[ubFileIdx])).SrcNum;
        PlayBackFileInfo[ubFileIdx] = KNL_GetFileHidInfo(pVideoInfo->tSimFolder,uwKNL_GetSortResult(pVideoInfo->ulVideoPlayIdx[ubFileIdx]));
    }
    osDelay(200);	// wait rx switch playing display mode ready 
    ubPlyRet = ubPLY_Start(PLY_MODE_NORMAL,ubKNL_VdoPlayActNum, ubPlayFileNum, &PlayBackFileInfo[0]);
    if(ubPlyRet != 1)
    {
        ptKNL_RP_CbFunc(0,1,0,0);
        KNL_SetPlayDestFld(KNL_REAL_FLD);
        KNL_SetRecordFunc(KNL_RECORDFUNC_DISABLE);
        KNL_VideoPlayStop();
        KNL_SetBackupDispInfoFlag(FALSE);
        if(pVideoInfo->pRecordStsNtyCb)
            pVideoInfo->pRecordStsNtyCb(KNL_ErrorVdoPlay);
    }
    else
        ptKNL_RP_CbFunc(0,0,0,0);
#endif
}
//------------------------------------------------------------------------------
uint16_t uwKNL_RecMonit_HSize[4] = {0};
uint16_t uwKNL_RecMonit_VSize[4] = {0};
#if OP_AP
void KNL_RecFileFormatConfigInit(void)
{
	REC_FILEFORMAT sRecFileFormat;
    uint8_t ubIndex;
    uint8_t uwTmp;
	uint8_t ubMaxSlotNum = 0;

#if defined(BSP_DVR_SDK)
    ubMaxSlotNum = DISPLAY_MODE;
#else
	ubMaxSlotNum = ubKNL_GetTRXSlotNum();
#endif
    for(ubIndex = 0; ubIndex < REC_SRC_NUM; ubIndex++)
	{
        memset(&sRecFileFormat, 0x00, sizeof(REC_FILEFORMAT));
		if(KNL_VIDEO_PLAY == tKNL_GetRecordFunc())
		{
            sRecFileFormat.ubConfiged = (ubKNL_VdoPlayActCh[ubIndex])?REC_SRC_CONFIGED:REC_SRC_UNCONFIGED;
			sRecFileFormat.ubCh = KNL_SRC_1_MAIN + ubIndex;
		}
		else
		{
			sRecFileFormat.ubCh = KNL_SRC_1_MAIN + ubIndex;	//! ubSrcNum[ubIndex];
		#if (DISPLAY_MODE == DISPLAY_4T1R)
			#ifdef BUC_CU
			if(TRUE == ubKNL_BbPathAct)
			{
				sRecFileFormat.ubConfiged = REC_SRC_CONFIGED;
			}
			else
			#endif
			{
				sRecFileFormat.ubConfiged = ((tKNL_GetDispType() == KNL_DISP_QUAD) || (tKNL_GetDispType() == KNL_DISP_H))?REC_SRC_CONFIGED:
											 (((tKNL_GetDispType() == KNL_DISP_DUAL_C) || (tKNL_GetDispType() == KNL_DISP_DUAL_U)) && ((KNL_SwDispInfo.tSrcNum[0] == sRecFileFormat.ubCh) ||(KNL_SwDispInfo.tSrcNum[1] == sRecFileFormat.ubCh)))?REC_SRC_CONFIGED:
											 (((tKNL_GetDispType() == KNL_DISP_3T_2L1R) || (tKNL_GetDispType() == KNL_DISP_3T_1L2R) || (tKNL_GetDispType() == KNL_DISP_3T_2T1B) || (tKNL_GetDispType() == KNL_DISP_3T_1T2B) || (tKNL_GetDispType() == KNL_DISP_3T_3COL)) &&
											  ((KNL_SwDispInfo.tSrcNum[0] == sRecFileFormat.ubCh) || (KNL_SwDispInfo.tSrcNum[1] == sRecFileFormat.ubCh) || (KNL_SwDispInfo.tSrcNum[2] == sRecFileFormat.ubCh)))?REC_SRC_CONFIGED:
											 ((tKNL_GetDispType() == KNL_DISP_SINGLE) && (KNL_SwDispInfo.tSrcNum[0] == sRecFileFormat.ubCh))?REC_SRC_CONFIGED:REC_SRC_UNCONFIGED;
			}
		#else
			if(tKNL_GetDispType() == KNL_DISP_SINGLE)
            {
                #if (DISPLAY_MODE == DISPLAY_1T1R)
                sRecFileFormat.ubConfiged = (ubIndex < ubMaxSlotNum)?REC_SRC_CONFIGED:REC_SRC_UNCONFIGED;
                #else
                sRecFileFormat.ubConfiged = (KNL_SwDispInfo.tSrcNum[0] == sRecFileFormat.ubCh)? REC_SRC_CONFIGED:REC_SRC_UNCONFIGED;
                #endif
            }
            else
            {
                sRecFileFormat.ubConfiged = (ubIndex < ubMaxSlotNum)?REC_SRC_CONFIGED:REC_SRC_UNCONFIGED;
            }
		#endif
		}
        uwTmp = VDO_FRAME_RATE(uwKNL_GetVdoH(sRecFileFormat.ubCh),uwKNL_GetVdoV(sRecFileFormat.ubCh));
        sRecFileFormat.ubSourceType = MEDIA_SRC_1V1A;
#if defined(BSP_DVR_SDK)
        uwTmp = uwTmp;
		sRecFileFormat.uwVFrmInterval = 33;
		if(ubIndex == 1)
		{
		    sRecFileFormat.ubCamRole = (REC_ROLE_AP<<4)+REC_CAM_LOCAL;
			sRecFileFormat.ulHoSize1 = VDO_LOCAL_STORAGE_H_SIZE;
			sRecFileFormat.ulVoSize1 = VDO_LOCAL_STORAGE_V_SIZE;
            sRecFileFormat.uwBSMaxBufNum = BUF_NUM_VDO_BS_STORAGE;
		}
		else if(ubIndex == 0)
		{
		    sRecFileFormat.ubCamRole = (REC_ROLE_AP<<4)+REC_CAM_REMOTE;
			sRecFileFormat.ulHoSize1 = VDO_MAIN_H_SIZE(VDO_DISP_TYPE);
			sRecFileFormat.ulVoSize1 = VDO_MAIN_V_SIZE(VDO_DISP_TYPE);
            sRecFileFormat.uwBSMaxBufNum = BUF_NUM_VDO_BS;
		}
		sRecFileFormat.ulHoSize2 = 0;
        sRecFileFormat.ulVoSize2 = 0;
#else
        sRecFileFormat.uwVFrmInterval = (1000/uwTmp);
        sRecFileFormat.ubCamRole = (REC_ROLE_AP<<4)+REC_CAM_REMOTE;
        sRecFileFormat.ulHoSize1 = uwKNL_GetVdoH(sRecFileFormat.ubCh);
        sRecFileFormat.ulVoSize1 = uwKNL_GetVdoV(sRecFileFormat.ubCh);
        sRecFileFormat.ulHoSize2 = uwKNL_GetVdoH(sRecFileFormat.ubCh);
        sRecFileFormat.ulVoSize2 = uwKNL_GetVdoV(sRecFileFormat.ubCh);
        sRecFileFormat.uwBSMaxBufNum = BUF_NUM_VDO_BS;
#endif		

#if(ADO_ENC_TYPE==SW_AAC_ENC)
        sRecFileFormat.uwAFrmInterval 	= 640;	//aac
#else
        sRecFileFormat.uwAFrmInterval 	= 1280;	//alaw
#endif
        sRecFileFormat.ulSampleRate 	= 16000;
        sRecFileFormat.uwBlockAlign 	= 256;
        REC_FileFormatConfigure(&sRecFileFormat);
		
		if(sRecFileFormat.ulHoSize1 > sRecFileFormat.ulHoSize2)
		{
			uwKNL_RecMonit_HSize[ubIndex] = sRecFileFormat.ulHoSize1;
			uwKNL_RecMonit_VSize[ubIndex] = sRecFileFormat.ulVoSize1;
		}
		else
		{
			uwKNL_RecMonit_HSize[ubIndex] = sRecFileFormat.ulHoSize2;
			uwKNL_RecMonit_VSize[ubIndex] = sRecFileFormat.ulVoSize2;
		}
	}
	tKNL_Info.tPlayDispType = ((ubMaxSlotNum >= DISPLAY_MODE) && (TRUE == ubKNL_BbPathAct))?VDO_DISP_TYPE:tKNL_GetDispType();
	if((ubMaxSlotNum != DISPLAY_MODE) && (ubMaxSlotNum == 2))
		tKNL_Info.tPlayDispType = (KNL_DISP_ROTATE_0 == tKNL_GetDispRotate())?KNL_DISP_DUAL_U:KNL_DISP_DUAL_C;
}
#endif

#if (OP_STA && APP_REC_FUNC_ENABLE)
void KNL_RecFileFormatConfigInit(void)
{
	REC_FILEFORMAT sRecFileFormat;
    KNL_TXREC_CFG sKNL_RxRecCfg[REC_SRC_NUM];
    uint8_t ubIndex;
    uint8_t uwTmp;
	uint8_t ubMaxSlotNum = 0;

#if defined(BSP_DVR_SDK)
    ubMaxSlotNum = 2;
#elif defined(BSP_VBM_SDK)
    ubMaxSlotNum = 2;
#elif defined(BSP_RVCS_SDK)
    ubMaxSlotNum = 2;
#else
	ubMaxSlotNum = ubKNL_GetTRXSlotNum();
#endif

    memset(&sKNL_RxRecCfg[0],0x00,sizeof(sKNL_RxRecCfg));
#if defined(VDO_SUBPATH_ENABLE)&&(VDO_SUBPATH_ENABLE!=0)
    #if (defined(APP_TXREC_STREAM_SEL)&&(APP_TXREC_STREAM_SEL==1))
    sKNL_RxRecCfg[0].ubCfg      = 0;
    sKNL_RxRecCfg[0].ubCh       = 1;
    sKNL_RxRecCfg[1].ubCfg      = 1;
    sKNL_RxRecCfg[1].ubCh       = 0;
    #elif (defined(APP_TXREC_STREAM_SEL)&&(APP_TXREC_STREAM_SEL==2))
    sKNL_RxRecCfg[0].ubCfg      = 1;
    sKNL_RxRecCfg[0].ubCh       = 0;
    sKNL_RxRecCfg[1].ubCfg      = 1;
    sKNL_RxRecCfg[1].ubCh       = 1;
    #endif
    sKNL_RxRecCfg[1].uwFrmRate  = HD_SUB_RES_FPS;//VDO_FRAME_RATE(uwKNL_GetVdoH(ubSEN_GetPathSrc(SENSOR_PATH2)),uwKNL_GetVdoV(ubSEN_GetPathSrc(SENSOR_PATH2)));
    sKNL_RxRecCfg[1].ulHoSize1  = uwKNL_GetVdoH(ubSEN_GetPathSrc(SENSOR_PATH2));
    sKNL_RxRecCfg[1].ulVoSize1  = uwKNL_GetVdoV(ubSEN_GetPathSrc(SENSOR_PATH2));
    sKNL_RxRecCfg[1].uwBSMaxBufNum = BUF_NUM_VDO_BS_SUBSTREAM;  
#else
    sKNL_RxRecCfg[0].ubCfg      = 1;
    sKNL_RxRecCfg[0].ubCh       = 0;
    sKNL_RxRecCfg[1].ubCfg      = 0;
    sKNL_RxRecCfg[1].ubCh       = 1;
#endif
    sKNL_RxRecCfg[0].uwFrmRate  = VDO_FRAME_RATE(uwKNL_GetVdoH(ubSEN_GetPathSrc(SENSOR_PATH1)),uwKNL_GetVdoV(ubSEN_GetPathSrc(SENSOR_PATH1)));
    sKNL_RxRecCfg[0].ulHoSize1  = uwKNL_GetVdoH(ubSEN_GetPathSrc(SENSOR_PATH1));
    sKNL_RxRecCfg[0].ulVoSize1  = uwKNL_GetVdoV(ubSEN_GetPathSrc(SENSOR_PATH1));
    sKNL_RxRecCfg[0].uwBSMaxBufNum = BUF_NUM_VDO_BS;

    printf("FSP0=%d,H=%d,V=%d\n",sKNL_RxRecCfg[0].uwFrmRate,sKNL_RxRecCfg[0].ulHoSize1,sKNL_RxRecCfg[0].ulVoSize1);
    printf("FSP1=%d,H=%d,V=%d\n",sKNL_RxRecCfg[1].uwFrmRate,sKNL_RxRecCfg[1].ulHoSize1,sKNL_RxRecCfg[1].ulVoSize1);
    for(ubIndex = 0; ubIndex < REC_SRC_NUM; ubIndex++)
	{
        memset(&sRecFileFormat, 0x00, sizeof(REC_FILEFORMAT));
		if(KNL_VIDEO_PLAY == tKNL_GetRecordFunc())
		{
            sRecFileFormat.ubConfiged = (ubKNL_VdoPlayActCh[ubIndex])?REC_SRC_CONFIGED:REC_SRC_UNCONFIGED;
			sRecFileFormat.ubCh = KNL_SRC_1_MAIN + ubIndex;
		}
		else
		{
            sRecFileFormat.ubCh = (ubIndex < ubMaxSlotNum)?sKNL_RxRecCfg[ubIndex].ubCh:ubIndex;
            sRecFileFormat.ubConfiged = (ubIndex < ubMaxSlotNum)?sKNL_RxRecCfg[ubIndex].ubCfg:REC_SRC_UNCONFIGED;
		}
        uwTmp = sKNL_RxRecCfg[ubIndex].uwFrmRate;

        sRecFileFormat.ubSourceType = MEDIA_SRC_1V1A;
        sRecFileFormat.uwVFrmInterval = 1000/uwTmp;
        sRecFileFormat.ubCamRole = (REC_ROLE_STA<<4)+REC_CAM_LOCAL;

        sRecFileFormat.ulHoSize1 = sKNL_RxRecCfg[ubIndex].ulHoSize1;
        sRecFileFormat.ulVoSize1 = sKNL_RxRecCfg[ubIndex].ulVoSize1;
        sRecFileFormat.uwBSMaxBufNum = sKNL_RxRecCfg[ubIndex].uwBSMaxBufNum;
        sRecFileFormat.ulHoSize2 = uwKNL_GetVdoH(ubSEN_GetPathSrc(SENSOR_PATH2));
        sRecFileFormat.ulVoSize2 = uwKNL_GetVdoV(ubSEN_GetPathSrc(SENSOR_PATH2));       
        
#if(ADO_ENC_TYPE==SW_AAC_ENC)
        sRecFileFormat.uwAFrmInterval 	= 640;	//aac
#else
        sRecFileFormat.uwAFrmInterval 	= 1280;	//alaw
#endif
        sRecFileFormat.ulSampleRate 	= 16000;
        sRecFileFormat.uwBlockAlign 	= 256;
        REC_FileFormatConfigure(&sRecFileFormat);
		
		if(sRecFileFormat.ulHoSize1 > sRecFileFormat.ulHoSize2)
		{
			uwKNL_RecMonit_HSize[ubIndex] = sRecFileFormat.ulHoSize1;
			uwKNL_RecMonit_VSize[ubIndex] = sRecFileFormat.ulVoSize1;
		}
		else
		{
			uwKNL_RecMonit_HSize[ubIndex] = sRecFileFormat.ulHoSize2;
			uwKNL_RecMonit_VSize[ubIndex] = sRecFileFormat.ulVoSize2;
		}
	}
	tKNL_Info.tPlayDispType = KNL_DISP_SINGLE;
}
#endif
//------------------------------------------------------------------------------
uint8_t ubKNL_GetPlayDispType(void)
{
	return (uint8_t)tKNL_Info.tPlayDispType;
}
//------------------------------------------------------------------------------
int32_t KNL_SdVideoPlayBack(uint8_t ubSrcNum, uint32_t ulAddress, uint32_t ulSize)
{
	KNL_PROCESS tKNLInfo;
	uint32_t ulTemp;
	uint8_t ubDummyBuf[4] = {0xAF, 0x00, 0x00, 0x03};
#if !(OP_STA && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
    #ifdef S2019A
	uint8_t ubStaNum = 0;
    #endif
    if (memcmp((uint8_t *)(ulAddress  + 8), ubDummyBuf, 4) == 0)
        return 1;
#else
    static uint16_t uwKNL_SkipFrameCnt = 0;
    #ifdef S2019A
	uint8_t ubStaNum = 0;
	uint32_t ulPlyTime = 0;
    #endif
    if (memcmp((uint8_t *)(ulAddress  + 8), ubDummyBuf, 4) == 0)
    {
        uwKNL_SkipFrameCnt++;
        return 1;
    }
    #ifdef S2019A	
    else
    {
        *(uint8_t *)(ulAddress+3) = (uint8_t)(uwKNL_SkipFrameCnt & 0xFF);
        uwKNL_SkipFrameCnt=0;
    }
    #endif
#endif

#if defined(BSP_DVR_SDK)
    if(ubSrcNum == 1)   ubSrcNum = KNL_SRC_1_MAIN;
#endif	
	if((KNL_VIDEO_PLAY != tKNL_GetRecordFunc()) ||
	   (!ubKNL_ChkExistNode(KNL_NODE_REC_PLAY)) || (!ubKNL_ChkVdoFlowAct(ubSrcNum)))
		return 1;

	if(PLY_FPS_ChkDisable() == 1)
	{
#ifdef S2019A
        ubStaNum = ubKNL_SrcNumMap(ubSrcNum);
        if(0xFF == ubStaNum)
            return 1;
        ulKNL_CurFrmIdx[ubStaNum] = 1;
#endif
        tKNLInfo.ulSize         = ulSize;                       
        tKNLInfo.ubSrcNum       = ubSrcNum;
        tKNLInfo.ulDramAddr2    = ulAddress;
        tKNLInfo.ubCurNode      = KNL_NODE_REC_PLAY;
        tKNLInfo.ubNextNode     = ubKNL_GetNextNode(ubSrcNum, KNL_NODE_REC_PLAY);
#if (OP_STA && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
        tKNLInfo.ubEvent = 0;
        *(uint8_t *)(ulAddress) = 0xAA;
#ifdef S2019A
        ulPlyTime = (ulPLY_GetDecVdoFrm(ubSrcNum) * ulMedia_GetScale(ubSrcNum,REC_STR_V1))/1000;
        if((ulPLY_GetDecVdoFrm(ubSrcNum) % (1000/ulMedia_GetScale(ubSrcNum,REC_STR_V1))) == 0)
            printf("PT=%d %d\n",ulPLY_GetDecVdoFrm(ubSrcNum),ulPlyTime);
        *(uint8_t *)(ulAddress+1) = (uint8_t)(ulPlyTime >> 8);
        *(uint8_t *)(ulAddress+2) = (uint8_t)ulPlyTime;
#endif
#endif
#ifdef RVCS_APP
        ulKNL_SetWiFiDtBufAddr(tKNLInfo.ulDramAddr2, tKNLInfo.ulSize, tKNLInfo.ulIdx, tKNLInfo.ulGop, tKNLInfo.ubEvent);
#endif				
	}
	else
	{
	#ifdef S2019A
		ubStaNum = ubKNL_SrcNumMap(ubSrcNum);
		if(0xFF == ubStaNum)
			return 1;
		ulKNL_CurFrmIdx[ubStaNum] = 1;
		ulTemp = ulKNL_GetBsBufAddr(ubSrcNum);
		if((ubSrcNum <= KNL_SRC_4_MAIN) && (ulSize > tKNL_VdoBsOvfInfo.ulBsBufSize))
			tKNL_VdoBsOvfInfo.ulBsOvfAddr[ubStaNum] = ulKNL_GetBsOvfBufAddr(ubSrcNum);
	#else
		ulTemp = ulKNL_GetBsBufAddr(ubSrcNum);
	#endif
    	if(ulTemp != BUF_FAIL)
    	{
        	DMAC_RESULT tDmaResult = DMAC_OK;

	        tDmaResult = tDMAC_MemCopy(ulAddress, ulTemp, ulSize, NULL);
    	    if(DMAC_OK == tDmaResult)
        	{
            	tKNLInfo.ulSize 		= ulSize;                       
            	tKNLInfo.ubSrcNum       = ubSrcNum;
            	tKNLInfo.ulDramAddr2    = ulTemp;
	            tKNLInfo.ubCurNode      = KNL_NODE_REC_PLAY;
	            tKNLInfo.ubNextNode     = ubKNL_GetNextNode(ubSrcNum, KNL_NODE_REC_PLAY);
#if (OP_STA && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
	            tKNLInfo.ubEvent = 0;
	            *(uint8_t *)(ulTemp) = 0xAA;
	#ifdef S2019A
				ulPlyTime = (ulPLY_GetDecVdoFrm(ubSrcNum) * ulMedia_GetScale(ubSrcNum,REC_STR_V1))/1000;
				if((ulPLY_GetDecVdoFrm(ubSrcNum) % (1000/ulMedia_GetScale(ubSrcNum,REC_STR_V1))) == 0)
			    	printf("PT=%d %d\n",ulPLY_GetDecVdoFrm(ubSrcNum),ulPlyTime);
				*(uint8_t *)(ulTemp+1) = (uint8_t)(ulPlyTime >> 8);
				*(uint8_t *)(ulTemp+2) = (uint8_t)ulPlyTime;
            	tKNLInfo.ulSize = ulKNL_AddEncImgInfo(tKNLInfo);
	#else
            	tKNLInfo.ulSize = ulKNL_AddAuxInfo(KNL_VDO_PKT,tKNLInfo.ubSrcNum,tKNLInfo.ulDramAddr2,tKNLInfo.ulSize,tKNLInfo.ulIdx,tKNLInfo.ulGop,tKNLInfo.ubVdoGop,KNL_TIMER_Get1ms());
	#endif
#endif
            	if(osMessagePut(KNL_VdoCodecProcQueue, &tKNLInfo, 0) == osErrorResource)
            	{
					ubKNL_ReleaseBsBufAddr(KNL_NODE_REC_PLAY, ubSrcNum, tKNLInfo.ulDramAddr2);
                	printd(DBG_ErrorLvl, "KNL_Q->Full !!!\r\n");
            	}
        	}
        	else
        	{
				ubKNL_ReleaseBsBufAddr(KNL_NODE_REC_PLAY, ubSrcNum, tKNLInfo.ulDramAddr2);
            	printd(DBG_ErrorLvl, "DMA NRDY @%s !\n", __func__);
        	}
    	}
    	else
    	{
        	printd(DBG_ErrorLvl, "Busy:%d\r\n", ubSrcNum);
    	}
	}
	return 1;    
}

//------------------------------------------------------------------------------
#if defined(OP_STA) && (APP_PLYBK_ENABLE == 1) && defined(RVCS_APP)
static void KNL_PlyBk_DownloadThread(void const *argument)
{
	uint16_t uwRecFileSelIdx;

	while(1)
	{
        osMessageGet(KNL_QueDwnldMode, &uwRecFileSelIdx, osWaitForever);
		printd(DBG_ErrorLvl, "Dwnld thread, get rec index:0x%x\r\n", uwRecFileSelIdx);
		WiFiDt_Set_PlyBk_Dwnld_mode(1);
		ubKNL_DownloadMode_Stop = 0;
		KNL_SetRecordFunc(KNL_VIDEO_DOWNLOAD);
		KNL_DownloadFile(KNL_REAL_FLD, uwRecFileSelIdx);
		WiFiDt_Set_PlyBk_Dwnld_mode(0);
		KNL_SenStart(KNL_STA1);
	}
}
#endif
#endif
//------------------------------------------------------------------------------
void KNL_RevertDisplayMode(void)
{
#if APP_REC_FUNC_ENABLE
#if OP_AP
    KNL_ROLE tKNL_Role[4];
    uint8_t ubRoleIdx = 0;
#if defined(BSP_DVR_SDK)
    KNL_ROLE tPlayRole;
    KNL_SRC tVdoSrcNum;
#endif
    if(ubKNL_GetBackupDispInfoFlag() == TRUE)
    {
#if !defined(BSP_DVR_SDK)
		for(ubRoleIdx = 0; ubRoleIdx < 4; ubRoleIdx++)
			tKNL_Role[ubRoleIdx] = VDO_KNLSrcNumMap2KNLRoleNum((KNL_SRC)ubKNL_BackSrcLocate[ubRoleIdx]);
		if(TRUE == KNL_BackSwDispInfo.ubSetupFlag)
		{
			switch(KNL_BackDispType)
			{
				case KNL_DISP_SINGLE:
					tKNL_Role[0] = VDO_KNLSrcNumMap2KNLRoleNum(KNL_BackSwDispInfo.tSrcNum[0]);
					break;
				case KNL_DISP_DUAL_C:
				case KNL_DISP_DUAL_U:
					for(ubRoleIdx = 0; ubRoleIdx < 2; ubRoleIdx++)
						tKNL_Role[ubRoleIdx] = VDO_KNLSrcNumMap2KNLRoleNum(KNL_BackSwDispInfo.tSrcNum[ubRoleIdx]);
					break;
				case KNL_DISP_3T_2L1R:
				case KNL_DISP_3T_1L2R:
				case KNL_DISP_3T_2T1B:
				case KNL_DISP_3T_1T2B:
				case KNL_DISP_3T_3COL:
					for(ubRoleIdx = 0; ubRoleIdx < 3; ubRoleIdx++)
						tKNL_Role[ubRoleIdx] = VDO_KNLSrcNumMap2KNLRoleNum(KNL_BackSwDispInfo.tSrcNum[ubRoleIdx]);
					break;
			#ifdef BUC_CU
				case KNL_DISP_QUAD:
					for(ubRoleIdx = 0; ubRoleIdx < 4; ubRoleIdx++)
						tKNL_Role[ubRoleIdx] = VDO_KNLSrcNumMap2KNLRoleNum(KNL_BackSwDispInfo.tSrcNum[ubRoleIdx]);
					break;
			#endif
				default:
					break;
			}
		}
	#if (DISPLAY_2T1R == DISPLAY_MODE)
		else if((KNL_DISP_ROTATE_90 == tKNL_GetDispRotate()) && (KNL_DISP_DUAL_C == KNL_BackDispType))
		{
			tKNL_Role[0] = VDO_KNLSrcNumMap2KNLRoleNum((KNL_SRC)ubKNL_BackSrcLocate[1]);
			tKNL_Role[1] = VDO_KNLSrcNumMap2KNLRoleNum((KNL_SRC)ubKNL_BackSrcLocate[0]);
		}
	#endif
#else
        for(tPlayRole = KNL_STA1; tPlayRole < DISPLAY_MODE; tPlayRole++)
        {
            tVdoSrcNum = (KNL_SRC)(KNL_SRC_1_MAIN + tPlayRole);
            KNL_VdoStop(tVdoSrcNum);
        }
		ubKNL_WaitNodeFinish(KNL_SRC_1_MAIN);
		
        //justin 2019.08.20
        KNL_VdoStop(KNL_SRC_PREVIEW_LOCAL);
        KNL_VdoStop(KNL_SRC_STORAGE_LOCAL);
        KNL_SenStop(KNL_SRC_PREVIEW_LOCAL);
        KNL_SenStop(KNL_SRC_STORAGE_LOCAL);

        tKNL_Role[0] = VDO_KNLSrcNumMap2KNLRoleNum((KNL_SRC)ubKNL_BackSrcLocate[1]);
        tKNL_Role[1] = VDO_KNLSrcNumMap2KNLRoleNum((KNL_SRC)ubKNL_BackSrcLocate[0]);
#endif    
        KNL_SetDispSrc(KNL_DISP_LOCATION1, ubKNL_BackSrcLocate[0]);
		KNL_SetDispSrc(KNL_DISP_LOCATION2, ubKNL_BackSrcLocate[1]);
		KNL_SetDispSrc(KNL_DISP_LOCATION3, ubKNL_BackSrcLocate[2]);
		KNL_SetDispSrc(KNL_DISP_LOCATION4, ubKNL_BackSrcLocate[3]);
        KNL_SetPlayDestFld(KNL_REAL_FLD);
		KNL_SetRecordFunc(KNL_RECORDFUNC_DISABLE);
#if !defined(BSP_DVR_SDK)
		#if (defined(S2019A) && defined(OP_AP))
		sPRF_KeepAlive(FALSE);
		for(ubRoleIdx = KNL_STA1; ubRoleIdx < DISPLAY_MODE; ubRoleIdx++)
		{
			BUF_Reset((BUF_VDO_MAIN_BS0 + ubRoleIdx));
			tKNL_VdoBsOvfInfo.ulBsOvfAddr[ubRoleIdx] = 0;
		}
		#endif
        #if (defined(RTC676x) && defined(OP_AP))
        for(ubRoleIdx = KNL_STA1; ubRoleIdx < DISPLAY_MODE; ubRoleIdx++)
			BUF_Reset((BUF_VDO_MAIN_BS0 + ubRoleIdx));
        #endif
		VDO_RestartPreview(KNL_BackDispType, tKNL_Role);
#else
        #if (defined(S2019A) && defined(OP_AP))
        sPRF_KeepAlive(FALSE);
        for(ubRoleIdx = KNL_STA1; ubRoleIdx < DISPLAY_MODE; ubRoleIdx++)
        {
            BUF_Reset((BUF_VDO_MAIN_BS0 + ubRoleIdx));
            tKNL_VdoBsOvfInfo.ulBsOvfAddr[ubRoleIdx] = 0;
        }
		#endif
        VDO_RestartPreview(KNL_DISP_DUAL_C, tKNL_Role);	
        if(KNL_BackDispType != KNL_DISP_DUAL_C)
        {
            if(ubKNL_BackSrcLocate[0] == KNL_SRC_1_MAIN)
                tKNL_Role[0] = KNL_STA1;
            else if(ubKNL_BackSrcLocate[0] == KNL_SRC_PREVIEW_LOCAL)
                tKNL_Role[0] = KNL_STA2;                
            VDO_SwitchDisplayType(KNL_BackDispType,tKNL_Role);
        }
#endif
		KNL_SetBackupDispInfoFlag(FALSE);
    }
    KNL_H264DecFlgReset();
#elif (OP_STA && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
#if defined(BSP_DVR_SDK)
    KNL_ROLE tPlayRole;
    KNL_SRC tVdoSrcNum;
#endif
    if(ubKNL_GetBackupDispInfoFlag() == TRUE)
    {
#if defined(BSP_DVR_SDK)
        for(tPlayRole = KNL_STA1; tPlayRole < DISPLAY_MODE; tPlayRole++)
        {
            tVdoSrcNum = (KNL_SRC)(KNL_SRC_1_MAIN + tPlayRole);
            KNL_VdoStop(tVdoSrcNum);
        }
        ubKNL_WaitNodeFinish(KNL_SRC_1_MAIN);
#endif    
        KNL_SetDispSrc(KNL_DISP_LOCATION1, ubKNL_BackSrcLocate[0]);
        KNL_SetDispSrc(KNL_DISP_LOCATION2, ubKNL_BackSrcLocate[1]);
        KNL_SetDispSrc(KNL_DISP_LOCATION3, ubKNL_BackSrcLocate[2]);
        KNL_SetDispSrc(KNL_DISP_LOCATION4, ubKNL_BackSrcLocate[3]);
        KNL_SetPlayDestFld(KNL_REAL_FLD);
        //KNL_SetRecordFunc(KNL_RECORDFUNC_DISABLE);
#if !defined(BSP_DVR_SDK)
	#if defined(S2019A)
        sPRF_KeepAlive(FALSE);
        uint8_t ubRoleIdx = 0;
        for(ubRoleIdx = KNL_STA1; ubRoleIdx < DISPLAY_MODE; ubRoleIdx++)
        {
            BUF_Reset((BUF_VDO_MAIN_BS0 + ubRoleIdx));
            tKNL_VdoBsOvfInfo.ulBsOvfAddr[ubRoleIdx] = 0;
        }
	#endif
        VDO_TXRestartPreview(uwKNL_BackResH,uwKNL_BackResV);
#else
        VDO_TXRestartPreview(uwKNL_BackResH,uwKNL_BackResV);
#endif
        KNL_SetBackupDispInfoFlag(FALSE);
    }
#endif    
    #ifdef RVCS_APP
    #if (E_RVCS_ALL_I_FRM == 1)
	ubKNL_UpdVdoGopFlag = TRUE;
    #endif
    #endif
#endif
}
//------------------------------------------------------------------------------
uint8_t KNL_VideoPlayStop(void)
{
#if APP_REC_FUNC_ENABLE
#if OP_AP
	if(KNL_VIDEO_PLAY == tKNL_GetRecordFunc() && tKNL_GetPlayDestFld()== KNL_REAL_FLD)
		ubPLY_Stop();
	if(TRUE == ubKNL_GetBackupDispInfoFlag())
	{
		KNL_ROLE tPlayRole;
		KNL_SRC tVdoSrcNum;

		for(tPlayRole = KNL_STA1; tPlayRole <= KNL_STA4; tPlayRole++)
		{
			tVdoSrcNum = (KNL_SRC)(KNL_SRC_1_MAIN + tPlayRole);
			KNL_VdoStop(tVdoSrcNum);
		}
		ubKNL_WaitNodeFinish(KNL_SRC_1_MAIN);
		KNL_ResetVdoProc();
		KNL_ResetLcdChannel();
		if(KNL_DISP_H == tKNL_GetDispType())
			KNL_CreateBlackDmyPat(ulBUF_GetBlkBufAddr(0, BUF_IMG_MERGE), (ulKNL_GetImgMergeBufSz()+((tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)?KNL_JPG_BS_SIZE:0)));
		else if((((KNL_DISP_3T_2L1R == tKNL_GetDispType()) || (KNL_DISP_3T_1L2R == tKNL_GetDispType())) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)) ||
		        (((KNL_DISP_3T_2T1B == tKNL_GetDispType()) || (KNL_DISP_3T_1T2B == tKNL_GetDispType())) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0))  ||
	            ((KNL_DISP_3T_3COL == tKNL_GetDispType()) && (tKNL_GetDispRotate() == KNL_DISP_ROTATE_0)))
			KNL_CreateBlackDmyPat(ulBUF_GetBlkBufAddr(0, BUF_IMG_MERGE), ulKNL_GetImgMergeBufSz());	
	}
#elif (OP_STA && APP_PLAY_REMOTE_ENABLE)
		uint8_t ubRetry=0;
        ubPLY_Stop();
		// wait stop play process finish
        while (tKNL_GetRecordFunc() == KNL_VIDEO_PLAY)
        {
            osDelay(100);
            if(++ubRetry>10)
                break;
        }
        if(TRUE == ubKNL_GetBackupDispInfoFlag())
        {
            KNL_ROLE tPlayRole;
            KNL_SRC tVdoSrcNum;
            for(tPlayRole = KNL_STA1; tPlayRole <= KNL_STA4; tPlayRole++)
            {
                tVdoSrcNum = (KNL_SRC)(KNL_SRC_1_MAIN + tPlayRole);
                KNL_VdoStop(tVdoSrcNum);
            }
            ubKNL_WaitNodeFinish(KNL_SRC_1_MAIN);
            KNL_ResetVdoProc();
        }
        KNL_RevertDisplayMode();
		KNL_TXRecordResumeBusyClr();
        #ifdef RVCS_APP
        #if (E_RVCS_ALL_I_FRM == 1)
		ubKNL_UpdVdoGopFlag = TRUE;
		#endif
		#endif	
		ADO_AdcStart();
#endif    
#endif
	return KNL_OK;
}
//------------------------------------------------------------------------------
#if (OP_STA && APP_PLAY_REMOTE_ENABLE)
void KNL_PhotoPlayStop(void)
{
    KNL_RecordAct_t tUI_PlayAct = {KNL_RECORDFUNC_DISABLE, NULL,};
    tUI_PlayAct.tRecordFunc = KNL_RECORDFUNC_DISABLE;
        tUI_PlayAct.pRecordStsNtyCb = NULL;
    tKNL_ExecRecordFunc(tUI_PlayAct);
}

//------------------------------------------------------------------------------
#ifdef RVCS_APP
uint8_t KNL_VideoDownloadStop(void)
{
	ubKNL_DownloadMode_Stop = 1;
	KNL_SetRecordFunc(KNL_RECORDFUNC_DISABLE);
	
	return KNL_OK;
}
#endif
#endif
//------------------------------------------------------------------------------
void KNL_SetRecordFunc(KNL_RecordFunc_t tRecordFunc)
{
#if (APP_PHOTOGRAPH_FUNC_ENABLE || APP_REC_FUNC_ENABLE)
	osMutexWait(osKNL_RecordFuncMutex, osWaitForever);
	#if APP_PHOTOGRAPH_FUNC_ENABLE
	if(KNL_PHOTO_PLAY == tKNL_RecordAct.tRecordFunc)
		KNL_PhotoLcdDisplayOFF();
	#endif
	tKNL_RecordAct.tRecordFunc = tRecordFunc;
	osMutexRelease(osKNL_RecordFuncMutex);
#endif
}
//------------------------------------------------------------------------------
KNL_RecordFunc_t tKNL_GetRecordFunc(void)
{
	KNL_RecordFunc_t tRecordFunc = KNL_RECORDFUNC_DISABLE;

#if (APP_PHOTOGRAPH_FUNC_ENABLE || APP_REC_FUNC_ENABLE)
	osMutexWait(osKNL_RecordFuncMutex, osWaitForever);
	tRecordFunc = tKNL_RecordAct.tRecordFunc;
	osMutexRelease(osKNL_RecordFuncMutex);
#endif
	return tRecordFunc;
}
//------------------------------------------------------------------------------
void KNL_SetPlayDestFld(KNL_FldType_t tFldType)
{
#if (APP_PHOTOGRAPH_FUNC_ENABLE || APP_REC_FUNC_ENABLE)
	osMutexWait(osKNL_RecordFuncMutex, osWaitForever);
	tKNL_RecordAct.tSimFolder = tFldType;
	osMutexRelease(osKNL_RecordFuncMutex);
#endif
}
//------------------------------------------------------------------------------
KNL_FldType_t tKNL_GetPlayDestFld(void)
{
	KNL_FldType_t tDestFld = KNL_REAL_FLD;

#if (APP_PHOTOGRAPH_FUNC_ENABLE || APP_REC_FUNC_ENABLE)
	osMutexWait(osKNL_RecordFuncMutex, osWaitForever);
	tDestFld = tKNL_RecordAct.tSimFolder;
	osMutexRelease(osKNL_RecordFuncMutex);
#endif
	return tDestFld;
}
//------------------------------------------------------------------------------
void KNL_SetPhotoLocRes(uint8_t ubResIdx)
{
#if (APP_PHOTOGRAPH_FUNC_ENABLE || APP_REC_FUNC_ENABLE)
	osMutexWait(osKNL_RecordFuncMutex, osWaitForever);
	tKNL_RecordAct.ubPhotoLocResIdx = ubResIdx;
	osMutexRelease(osKNL_RecordFuncMutex);
#endif
}
//------------------------------------------------------------------------------
uint8_t ubKNL_GetPhotoLocRes(void)
{
	uint8_t ubPhotoLocResIdx = KNL_RECORDFUNC_DISABLE;
#if (APP_PHOTOGRAPH_FUNC_ENABLE || APP_REC_FUNC_ENABLE)
	osMutexWait(osKNL_RecordFuncMutex, osWaitForever);
	ubPhotoLocResIdx = tKNL_RecordAct.ubPhotoLocResIdx;
	osMutexRelease(osKNL_RecordFuncMutex);
#endif
	return ubPhotoLocResIdx;
}
//------------------------------------------------------------------------------
void KNL_SetRecordCapSrc(uint8_t ubSrcNum)
{
#if (APP_PHOTOGRAPH_FUNC_ENABLE || APP_REC_FUNC_ENABLE)
	osMutexWait(osKNL_RecordFuncMutex, osWaitForever);
	tKNL_RecordAct.ubNowPhotoCapSrc = ubSrcNum;
	osMutexRelease(osKNL_RecordFuncMutex);
#endif
}
//------------------------------------------------------------------------------
uint8_t ubKNL_GetRecordCapSrc(void)
{
    uint8_t ubSrcNum = 0xFF;
#if (APP_PHOTOGRAPH_FUNC_ENABLE || APP_REC_FUNC_ENABLE)
	osMutexWait(osKNL_RecordFuncMutex, osWaitForever);
	ubSrcNum = tKNL_RecordAct.ubNowPhotoCapSrc;
	osMutexRelease(osKNL_RecordFuncMutex);
#endif
	return ubSrcNum;
}
//------------------------------------------------------------------------------
void KNL_SetBackupDispInfoFlag(uint8_t ubFlag)
{
#if (APP_PHOTOGRAPH_FUNC_ENABLE || APP_REC_FUNC_ENABLE)
	osMutexWait(osKNL_RecordFuncMutex, osWaitForever);
	tKNL_RecordAct.ubBackupDispInfoflag = ubFlag;
	osMutexRelease(osKNL_RecordFuncMutex);
#endif
}
//------------------------------------------------------------------------------
uint8_t ubKNL_GetBackupDispInfoFlag(void)
{
    uint8_t ubFlag = FALSE;
#if (APP_PHOTOGRAPH_FUNC_ENABLE || APP_REC_FUNC_ENABLE)
	osMutexWait(osKNL_RecordFuncMutex, osWaitForever);
	ubFlag = tKNL_RecordAct.ubBackupDispInfoflag;
	osMutexRelease(osKNL_RecordFuncMutex);
#endif
	return ubFlag;
}
//------------------------------------------------------------------------------
#if (APP_PHOTOGRAPH_FUNC_ENABLE || APP_REC_FUNC_ENABLE)
static void KNL_RecordThread(void const *argument)
{
	KNL_RecordAct_t tKNL_RecordEvt;

	tKNL_RecordEvt.tRecordFunc = KNL_RECORDFUNC_DISABLE;
	while(1)
	{
		osMessageGet(osKNL_RecordMsgQue, &tKNL_RecordEvt, osWaitForever);
		if(KNL_RECORDFUNC_DISABLE == tKNL_RecordEvt.tRecordFunc)
		{
		    KNL_SetPlayDestFld(KNL_REAL_FLD);
			KNL_SetRecordFunc(KNL_RECORDFUNC_DISABLE);
#if (APP_REC_FUNC_ENABLE && OP_STA)			
            if(KNL_TXRecordResumeBusyMode()==KNL_TXREC_BUSY_PLAYSTOPPHOTO)
			    KNL_TXRecordResumeBusyClr();
#endif			
			continue;
		}
		tKNL_RecordAct.pRecordStsNtyCb = tKNL_RecordEvt.pRecordStsNtyCb;
		switch(tKNL_RecordEvt.tRecordFunc)
		{
	#if APP_PHOTOGRAPH_FUNC_ENABLE
			case KNL_PHOTO_CAPTURE:
				KNL_PhotoCaptureFunc();
				break;
			case KNL_PHOTO_PLAY:
                #if OP_AP            
				KNL_PhotoPlayFunc(&tKNL_RecordEvt);
                #endif
                #if(OP_STA && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
				KNL_PhotoPlayFuncSTA(&tKNL_RecordEvt);
                #endif
				break;
	#endif  
	#if ( (OP_AP && APP_REC_FUNC_ENABLE) || (OP_STA && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE))
            case KNL_VIDEO_PLAY:
				KNL_VideoPlayFunc(&tKNL_RecordEvt);
				break;
            case KNL_RECORDFUNC_LOOP:
            case KNL_RECORDFUNC_MANU:
				KNL_VideoRecFunc(&tKNL_RecordEvt);
				break;
	#endif
			default:
				break;
		}
		tKNL_RecordEvt.tRecordFunc = KNL_RECORDFUNC_DISABLE;
	}
}
#endif
//------------------------------------------------------------------------------
KNL_Status_t tKNL_ExecRecordFunc(KNL_RecordAct_t tRecordAct)
{
	if(osKNL_RecordMsgQue)
	{
        KNL_Status_t tKNL_RecordSts;

        if(ubKNL_TmrErrFlg)
            return KNL_ERR;

	#if !APP_PHOTOGRAPH_FUNC_ENABLE
		if((KNL_PHOTO_CAPTURE == tRecordAct.tRecordFunc) || (KNL_PHOTO_CAPTURE == tRecordAct.tRecordFunc))
			return KNL_ERR;
	#endif
	#if !APP_REC_FUNC_ENABLE
		if((KNL_RECORDFUNC_LOOP == tRecordAct.tRecordFunc) ||
		   (KNL_RECORDFUNC_MANU == tRecordAct.tRecordFunc) ||
		   (KNL_VIDEO_PLAY == tRecordAct.tRecordFunc))
			return KNL_ERR;
	#endif
		 if(tRecordAct.tSimFolder == KNL_SIM_FLD)
            tKNL_RecordSts = KNL_OK;
         else
            tKNL_RecordSts = tKNL_ChkSdCardSts();
        if( tKNL_RecordSts == KNL_OK )
        {
            if(((ubKNL_ChkFreeSizeValid(KNL_FILE) != 1) && (KNL_RECORDFUNC_MANU == tRecordAct.tRecordFunc)))
                tKNL_RecordSts = KNL_ERR;
            else if(((ubKNL_ChkFreeSizeValid(KNL_PHOTO) != 1) && (KNL_PHOTO_CAPTURE == tRecordAct.tRecordFunc)))
                tKNL_RecordSts = KNL_ErrorCap;
			
			if(ubKNL_ChkGarbageUsageValid(KNL_GARBAGE_USAGE_THRESHOLD) != 1)
				tKNL_RecordSts = KNL_ERR;
        }
		if( KNL_OK != tKNL_RecordSts )
		{
			KNL_RecordFunc_t tRecordFunc;

			tRecordFunc = tKNL_GetRecordFunc();
			if(tRecordAct.pRecordStsNtyCb)
				tRecordAct.pRecordStsNtyCb(tKNL_RecordSts);
			if(KNL_RECORDFUNC_LOOP == tRecordAct.tRecordFunc)
			{
				KNL_SetRecordFunc(KNL_RECORDFUNC_LOOP);
				tKNL_RecordAct.pRecordStsNtyCb = tRecordAct.pRecordStsNtyCb;
				tKNL_RecordAct.tRecordSts = KNL_RECORDING_STOP;
			}
			else
			{
			    KNL_SetPlayDestFld(KNL_REAL_FLD);
				KNL_SetRecordFunc(KNL_RECORDFUNC_DISABLE);
				tKNL_RecordAct.pRecordStsNtyCb = tRecordAct.pRecordStsNtyCb;
			}
			return ((KNL_RECORDFUNC_LOOP == tRecordFunc) || (KNL_RECORDFUNC_MANU == tRecordFunc) || (KNL_RECORDFUNC_DISABLE == tRecordFunc))?KNL_ERR:tKNL_RecordSts;
		}
		osMessagePut(osKNL_RecordMsgQue, &tRecordAct, 0);
		if((KNL_PHOTO_PLAY == tRecordAct.tRecordFunc) || (KNL_VIDEO_PLAY == tRecordAct.tRecordFunc))
			osDelay(30);
		return KNL_OK;
	}
	return KNL_ERR;
}

//------------------------------------------------------------------------------
uint8_t ubKNL_ChkFreeSizeValid( uint8_t ubType )
{
	uint32_t ulPhotoSzTh;
	if(tKNL_FsMediaInfo.MediaType[tKNL_FsMediaInfo.MediaSel]==FS_MEDIA_TYPE_SD)
	{
		ulPhotoSzTh = KNL_SD_PHOTO_SIZE_THRESHOLD;
	}
	else if(tKNL_FsMediaInfo.MediaType[tKNL_FsMediaInfo.MediaSel]==FS_MEDIA_TYPE_SF)
	{
		ulPhotoSzTh = KNL_SF_PHOTO_SIZE_THRESHOLD;
	}	
    if( (ubType == KNL_FILE) && (FS_GetLoopingStatus(tKNL_FsMediaInfo.MediaSel, LOOPING_NORMAL) == LOOPING_OFF) && (ulFS_GetFreeSpace(tKNL_FsMediaInfo.MediaSel) < KNL_FILE_SIZE_THRESHOLD))      return 0;
    else if( (ubType == KNL_PHOTO) && (ulFS_GetFreeSpace(tKNL_FsMediaInfo.MediaSel) < ulPhotoSzTh))     return 0;
    return 1;   
}

//------------------------------------------------------------------------------
uint8_t ubKNL_ChkGarbageUsageValid( uint8_t ubUsageThreshold )
{
	uint64_t ullSdCardSz;
	uint64_t ullFreeSz;
	uint64_t ullRecFileSz;
	uint64_t ullGarbageFizeSz;
	uint8_t ubGarbageUsage;
	
	if(ubUsageThreshold>100)
	{
		//printf("KNL ChkUsageValidInSdCard fail->threshold fail[%d]\n",ubUsageThreshold);
		return 0;
	}
	
	ullSdCardSz  = ulFS_GetTotalSpace(tKNL_FsMediaInfo.MediaSel)<<20;
	ullFreeSz    = ulFS_GetFreeSpace(tKNL_FsMediaInfo.MediaSel)<<20;
	ullRecFileSz = ullFS_GetEmgFldTotalFileSz(tKNL_FsMediaInfo.MediaSel) + ullFS_GetTimelapseFldTotalFileSz(tKNL_FsMediaInfo.MediaSel) + ullFS_GetRecFldTotalFileSz(tKNL_FsMediaInfo.MediaSel);
	
	if( ullSdCardSz > (ullFreeSz+ullRecFileSz) )
	{
		ullGarbageFizeSz = ullSdCardSz - ullFreeSz - ullRecFileSz;
		ubGarbageUsage = (ullGarbageFizeSz*100)/ullSdCardSz;
		if(ubGarbageUsage > ubUsageThreshold)
		{
			//printf("KNL ChkUsageValidInSdCard fail->Garbage file[%dMB] is too big[%d]\n",ulGarbageFizeSz/1024,ubUsageThreshold);
			return 0;
		}
	}
	
	return 1;
}
//------------------------------------------------------------------------------
#if  APP_REC_FUNC_ENABLE
char chREC_LatestFileName[FS_FILE_NAME_MAX_LENGTH];
uint32_t ulREC_LatestFileNameLen;
void KNL_RecFileCreate(uint8_t ubCh,FS_KNL_CRE_PROCESS_t *tRecProc)
{	
	tRecProc->MediaSel = tKNL_FsMediaInfo.MediaSel;
	
#if (APP_FS_ROLLING_FILE_NAME == 1)
	ulREC_LatestFileNameLen = ulFS_GetLatestFileName(tKNL_FsMediaInfo.MediaSel, &chREC_LatestFileName[0]);	
	tRecProc->SrcNum = (FS_SRC_NUM)ubCh;
	tRecProc->ubRecGroupFileNum = 4;
	tRecProc->FileName.ubLen = 8;
	FS_FileNameHandle(tKNL_FsMediaInfo.MediaSel, tRecProc->FileName.chName, tRecProc->FileName.ubLen, chREC_LatestFileName, ulREC_LatestFileNameLen);
	memcpy(chREC_LatestFileName, tRecProc->FileName.chName, tRecProc->FileName.ubLen);
#else
	#if (BSP_RTC_TIMER_SEL == RTC_TIMER_INTERNAL)
	RTC_Calendar_t tCalendar;
	#elif (BSP_RTC_TIMER_SEL == RTC_TIMER_EXTERNAL)
	RTC_PCF85063A_Calendar_t tCalendar;
	#endif

	wRTC_GETCALENDAR(&tCalendar);
	tRecProc->SrcNum = (FS_SRC_NUM)ubCh;
	tRecProc->ubRecGroupFileNum = 4;
	tRecProc->FileName.ubLen = 21;
	snprintf(tRecProc->FileName.chName, tRecProc->FileName.ubLen+1, "VID_%04d%02d%02d_%02d%02d%02d_%01d",
			 tCalendar.uwYear,tCalendar.ubMonth,tCalendar.ubDate,
			 tCalendar.ubHour,tCalendar.ubMin,tCalendar.ubSec,
			 ubCh);
#endif
}
//------------------------------------------------------------------------------
uint32_t ubKNL_GetRecDataRate(void)
{
	uint32_t ulDataRate = 0;
#if OP_AP
	#if defined(BSP_DVR_SDK)
		ulDataRate = ulKNL_WithSenDataRate;
	#else	//BUC,VBM
		#if defined(A7130)
			ulDataRate = RC_MAX_BW_A1_SERIES;
		#elif defined(RTC676x)
			ulDataRate = RC_MAX_BW_R1_SERIES;
		#elif defined(S2019A)
			ulDataRate = 0x300000;
		#endif
	#endif
#else
	ulDataRate = ulKNL_WithSenDataRate;
#endif
	ulDataRate/=8;
	return ulDataRate;
}
//------------------------------------------------------------------------------
static void KNL_RecSdMonitorThread(void const *argument)
{
	FS_MEDIA_INOUT_STATUS tKNL_SdCardDet;
	KNL_RecordFunc_t tRecordFunc;
	uint32_t ulRecDataRate;	//unit: bytes/s
	uint32_t ulRecTime;	//unit: sec
	uint32_t ulOneFileSz;
	uint32_t ulFreeSz;
	uint32_t i;
	uint16_t uwMaxHSz = 0;
	uint16_t uwMaxVSz = 0;
	while(1)
	{
		tKNL_SdCardDet = FS_ChkMediaExist(tKNL_FsMediaInfo.MediaSel);
		if(FS_MEDIA_OUT == tKNL_SdCardDet)
		{
			tRecordFunc = tKNL_GetRecordFunc();
			switch(tRecordFunc)
			{
				case KNL_RECORDFUNC_LOOP:
				case KNL_RECORDFUNC_MANU:
				{
					KNL_Status_t tVdoRecStopRet;

					if(KNL_RECORDING_START == tKNL_RecordAct.tRecordSts)
					{
						tVdoRecStopRet = KNL_VideoRecStop(tRecordFunc,0);
						if(tKNL_RecordAct.pRecordStsNtyCb)
						{
							tKNL_RecordAct.pRecordStsNtyCb(KNL_ErrorNoCard);
							tKNL_RecordAct.pRecordStsNtyCb(tVdoRecStopRet);
						}
						for(i=0; i<4; i++)
						{
							uwKNL_RecMonit_HSize[i] = 0;
							uwKNL_RecMonit_VSize[i] = 0;
						}
					}
					break;
				}
				case KNL_VIDEO_PLAY:
                    if(tKNL_RecordAct.tSimFolder == KNL_REAL_FLD)
                    {
    					if(tKNL_RecordAct.pRecordStsNtyCb)
    						tKNL_RecordAct.pRecordStsNtyCb(KNL_ErrorNoCard);
                    }
					break;
			#if (OP_STA && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)	
				case KNL_PHOTO_PLAY:
                    if(tKNL_RecordAct.tSimFolder == KNL_REAL_FLD)
                    {
                        KNL_ROLE tPlayRole;
                        KNL_SRC tVdoSrcNum;
                        printf("SD OUT A\n");
                        KNL_ResetVdoProc();
                        for (tPlayRole = KNL_STA1; tPlayRole < DISPLAY_MODE; tPlayRole++)
                        {
                            tVdoSrcNum = (KNL_SRC)(KNL_SRC_1_MAIN + tPlayRole);
                            KNL_VdoStart(tVdoSrcNum);
                        }
                        
                        for (tPlayRole = KNL_STA1; tPlayRole < DISPLAY_MODE; tPlayRole++)
                        {
                            tVdoSrcNum = (KNL_SRC)(KNL_SRC_1_AUX + tPlayRole);
                            KNL_VdoStart(tVdoSrcNum);
                        }                     
                        KNL_PhotoPlayStop();
                        KNL_TXRecordResume(KNL_TXREC_BUSY_PLAYSTOPPHOTO,1);
                    }
					break;
			#endif		
				default:
					break;
			}
		}
		else if((FS_MEDIA_IN == tKNL_SdCardDet) && (FS_MEDIA_RDY == FS_ChkMediaRdy(tKNL_FsMediaInfo.MediaSel)))
		{
			tRecordFunc = tKNL_GetRecordFunc();
			if(tRecordFunc==KNL_RECORDFUNC_LOOP)
			{
				ulRecDataRate = ubKNL_GetRecDataRate();
			}
			else if(tRecordFunc==KNL_RECORDFUNC_MANU)
			{
				if(KNL_TimelapseStatus==REC_TIMELAPSE_OFF)
				{
					ulRecDataRate = ubKNL_GetRecDataRate();
				}
				else if(KNL_TimelapseStatus==REC_TIMELAPSE_ON)
				{
					for(i=0; i<4; i++)
					{
						if(uwKNL_RecMonit_HSize[i]>uwMaxHSz)
						{
							uwMaxHSz = uwKNL_RecMonit_HSize[i];
							uwMaxVSz = uwKNL_RecMonit_VSize[i];
						}
					}
					ulRecDataRate = ((uwMaxHSz*uwMaxVSz*1.5)/KNL_MIN_COMPRESS_RATIO)/8;
				}
			}
			ulRecTime   = REC_GetRecTime();
			ulOneFileSz = (ulRecDataRate/1024)*ulRecTime;
			ulFreeSz    = ulFS_GetFreeSpace(tKNL_FsMediaInfo.MediaSel)*1024;
			
			if((KNL_RECORDFUNC_LOOP == tKNL_GetRecordFunc()) &&
			   (KNL_RECORDING_STOP == tKNL_RecordAct.tRecordSts) &&
			   (ubKNL_ChkGarbageUsageValid(KNL_GARBAGE_USAGE_THRESHOLD) == 1) &&
				ulOneFileSz < ulFreeSz)
			{
#if (OP_STA && APP_REC_FUNC_ENABLE)
			    if(ubKNL_GetTXRecMode()==KNL_TXREC_LOOP)
#endif
                {         
    				KNL_RecordAct_t tKNL_RecChkAct;
    				tKNL_RecChkAct.tRecordFunc     = KNL_RECORDFUNC_LOOP;
    				tKNL_RecChkAct.pRecordStsNtyCb = tKNL_RecordAct.pRecordStsNtyCb;
                    tKNL_RecChkAct.ubRecOnceStopCBFlag = 0;
    				KNL_VideoRecFunc(&tKNL_RecChkAct);
#if (OP_STA && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
                    KNL_TXRecordReady();
                    KNL_TXRecordResumeBusyClr();
#endif
                }
#if (OP_STA && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)	                
                else if (KNL_TxFsFldLayer == KNL_TX_FLDROOT && ubKNL_GetTXRecMode()==KNL_TXREC_IDLE)
                    KNL_TXRecordResume(KNL_TXREC_BUSY_NONE,0);
#endif
			}
			else if(ulOneFileSz > ulFreeSz)	//stop rec
			{
				printf("KNL REC moni thread->free size isn't enough, REC STOP!! [Predict file size=%d KBytes, Media free size=%d KBytes]\n",ulOneFileSz,ulFreeSz);
				KNL_RecordFunc_t tRecordFunc;
				KNL_Status_t tVdoRecStopRet;
				tRecordFunc = tKNL_GetRecordFunc();
				if(KNL_RECORDING_START == tKNL_RecordAct.tRecordSts)
				{
					tVdoRecStopRet = KNL_VideoRecStop(tRecordFunc,0);
					if(tKNL_RecordAct.pRecordStsNtyCb)
					{
						tKNL_RecordAct.pRecordStsNtyCb(tVdoRecStopRet);
					}
					for(i=0; i<4; i++)
					{
						uwKNL_RecMonit_HSize[i] = 0;
						uwKNL_RecMonit_VSize[i] = 0;
					}
				}
			}
		}
#if (OP_STA && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)	
		if(tKNL_SdCardDet==FS_MEDIA_OUT && ubKNL_GetCommLinkStatus(KNL_MASTER_AP)&& KNL_TxFsFldLayer != KNL_TX_FLDROOT)
		{
		    printf("SD OUT B\n");
	        ptKNL_RP_FsCbFunc(5,0,0,0);
            KNL_SetRecordFunc(KNL_RECORDFUNC_LOOP);
            KNL_TXFSSetFldLayer(KNL_TX_FLDROOT);
		}
#endif				
        osDelay(20);
	}
}
//------------------------------------------------------------------------------
static void KNL_RecEmergencyThread(void const *argument)
{  
    uint8_t ubNum;	
    uint8_t ubActiveSrcNum,ubCloseFileOkNum,i;
    FS_KNL_MOVE_PROCESS_t Info;
    REC_EMERGENCY  EMGInfo;  
    FS_EMERG_FILE_INFO_t FileInfo[8];   
    uint8_t ubTimeout = 150;
#if APP_FS_ROLLING_FILE_NAME  
    char cFileName[FS_FILE_NAME_MAX_LENGTH+1];
#endif
	uint32_t ulEMG_Max_FileNum;
	
	while(1)
	{		 
        osMessageGet(KNL_QueEmergency, &EMGInfo, osWaitForever);	
        FS_SetLoopDelStop(FS_LOOPDEL_STOP);    
		ulKNL_EMG_fileNum = ulFS_GetEmgFileNum(tKNL_FsMediaInfo.MediaSel);
        printf("\nEMG %d %d %d %d %d\n",EMGInfo.ubCloseFileCheck,EMGInfo.uwGroupInf[0],EMGInfo.uwGroupInf[1],EMGInfo.uwNowGroupIndex,ulKNL_EMG_fileNum);
		
        if(EMGInfo.ubCloseFileCheck)
        {
            ubActiveSrcNum = 0;
             
            for(i=0; i<REC_SRC_NUM; i++)			
            {
                if ((ubREC_StateGet(i) != REC_CREATE_NULL) && (ubREC_StateGet(i) != REC_CREATE_INIT))
                    ubActiveSrcNum++;
            }
//            printf("\nRecE ActiveSrcNum %d \n",ubActiveSrcNum);
            ubTimeout = 100;
            while(--ubTimeout)
            {
                ubCloseFileOkNum = 0;
                for(i=0; i<REC_SRC_NUM; i++)
                {
                    if (FS_ChkCloseStatus(tKNL_FsMediaInfo.MediaSel, (FS_SRC_NUM)(FS_VDO_SRC_0 + i)) == FS_REC_CLOSED_OK)
                        ubCloseFileOkNum++;
                } 
                if( ubCloseFileOkNum != ubActiveSrcNum)
                    osDelay(100);
                else
                    break;
            }
            if(ubTimeout == 0)
                printf("EMG check close file state timeout_%d_%d \n",ubCloseFileOkNum,ubActiveSrcNum);               
        }

        FS_GetEmgFileInfo(tKNL_FsMediaInfo.MediaSel, EMGInfo.uwGroupInf[0], EMGInfo.uwGroupInf[1],&ubNum, FileInfo);					
	
        printf("EMG_fileNum %d %d\n",ulKNL_EMG_fileNum,ubNum);  

        for(i=0; i<ubNum; i++)
        {
			ulKNL_EMG_fileNum = ulFS_GetEmgFileNum(tKNL_FsMediaInfo.MediaSel);
			// setting max file num in EMG folder
			switch(FS_GetSdCardSize(tKNL_FsMediaInfo.MediaSel))
			{
				case FS_CARD_SIZE_OTHERS:
				case FS_CARD_SIZE_256MB:
				case FS_CARD_SIZE_512MB:
				case FS_CARD_SIZE_1GB:
				case FS_CARD_SIZE_2GB:
					ulEMG_Max_FileNum = 2;
					break;
				case FS_CARD_SIZE_4GB:
					ulEMG_Max_FileNum = 5;
					break;
				case FS_CARD_SIZE_8GB:
					ulEMG_Max_FileNum = 8;
					break;
				case FS_CARD_SIZE_16GB:
					ulEMG_Max_FileNum = 15;
					break;
				case FS_CARD_SIZE_32GB:
					ulEMG_Max_FileNum = 30;
					break;
				case FS_CARD_SIZE_64GB:
					ulEMG_Max_FileNum = 50;
					break;
				case FS_CARD_SIZE_128GB:
					ulEMG_Max_FileNum = 100;
					break;
			}
			if(ulKNL_EMG_fileNum >= ulEMG_Max_FileNum)
            {
                printf("EMG folder full %d\n",ulKNL_EMG_fileNum);  
                break;
            }
			
			Info.MediaSel = tKNL_FsMediaInfo.MediaSel;
			
            // source
            Info.SrcFilePath = FILE_PATH_DEFAULT;
			memcpy(&Info.SrcFldName, &FileInfo[i].FldName, sizeof(FileInfo[i].FldName));
			memcpy(&Info.SrcFileName, &FileInfo[i].FileName, sizeof(FileInfo[i].FileName));
            
            // destination
            Info.DstFilePath = FILE_PATH_DEFAULT;
            Info.DstFldName.ubLen = 3;
            memcpy(Info.DstFldName.chName, "EMG", Info.DstFldName.ubLen);
#if APP_FS_ROLLING_FILE_NAME            
            Info.DstFileName.ubLen = 7;
            snprintf(cFileName, Info.DstFileName.ubLen+1, "%05d-%01d", FileInfo[i].uwGroupIdx, FileInfo[i].SrcNum);
            memcpy(Info.DstFileName.chName, cFileName, Info.DstFileName.ubLen);
			memcpy(Info.DstFileName.chExt,  FileInfo[i].FileName.chExt, 3);
#else
			memcpy(&Info.DstFileName, &FileInfo[i].FileName, sizeof(FileInfo[i].FileName));
#endif
            if(FS_MoveFile(&Info) == FS_SEND_Q_SUCCESS)
            {
                ubTimeout = 50;
                while(--ubTimeout)
                {
                    if(FS_ChkMoveFileStatus(Info.MediaSel) == FS_MOVE_INI)
                        osDelay(60);
                    else
                        break;
                }

                if(ubTimeout == 0)
                    printf("EMG MoveFile timeout");                 
            }
            osDelay(2000);
        }
        REC_SetEmergencyState(REC_MOVE_OK);
        printf("EMG_End \n");        
        FS_SetLoopDelStop(FS_LOOPDEL_RELEASE);
	}
}
//------------------------------------------------------------------------------
uint32_t ulKNL_GetEmergencyfileNumber(void)
{	
    return ulFS_GetEmgFileNum(tKNL_FsMediaInfo.MediaSel);
}
//------------------------------------------------------------------------------
void KNL_ResetH264IPCnt(void)
{
#if (defined(OP_AP) && defined(BSP_DVR_SDK))
    H264_ResetIPCnt(ENCODE_2);
#endif
#if defined(OP_STA)
#if (defined(VDO_SUBPATH_ENABLE)&&(VDO_SUBPATH_ENABLE!=0))
    H264_ResetIPCnt(ENCODE_0);
    H264_ResetIPCnt(ENCODE_1);
#else
    H264_ResetIPCnt(ENCODE_0);
#endif
#endif
}
#endif
//------------------------------------------------------------------------------
void KNL_SetDmyPatColor(uint8_t ubRed, uint8_t ubGreen, uint8_t ubBlue)
{
	float fY_Value, fCb_Value, fCr_Value;

	fY_Value  = 0.299*ubRed + 0.587*ubGreen + 0.114*ubBlue;
	fCb_Value = -0.1687*ubRed - 0.3313*ubGreen + 0.5*ubBlue + 128;
	fCr_Value = 0.5*ubRed - 0.4187*ubGreen - 0.0813*ubBlue + 128;
	tKNL_DmyPatColor.ubY  = (fY_Value<0?0:(fY_Value>255?255:fY_Value));
	tKNL_DmyPatColor.ubCb = (fCb_Value<0?0:(fCb_Value>255?255:fCb_Value));
	tKNL_DmyPatColor.ubCr = (fCr_Value<0?0:(fCr_Value>255?255:fCr_Value));
}
//------------------------------------------------------------------------------
void KNL_CreateBlackDmyPat(uint32_t ulBufAddr, uint32_t ulBufSize)
{
	KNL_DISP_TYPE tDispType;
	KNL_DISP_ROTATE tDispRot = KNL_DISP_ROTATE_0;
	uint32_t ulDmyCbCr = 0, ulDmyY = 0, ulDmySize = 0, ulDmyCycle, *pPatAddr, ulIdx;
	uint32_t ulDmyBufAddr, ulDmyBufSize = 0, ulDmyOffset = 0;
	uint32_t ulCbCrColor = 0x80808080;
	uint16_t uwHSize = 0;
	uint8_t ubDmySrc = KNL_SRC_1_MAIN;
	uint8_t ubScaleDmyParam = 0, ubDmyArea = 1, ubAreaIdx;

	tDispType = tKNL_GetDispType();
	tDispRot  = tKNL_GetDispRotate();
	ubDmySrc  = (KNL_DISP_ROTATE_90 == tDispRot)?KNL_SRC_2_MAIN:KNL_SRC_1_MAIN;
	ubDmyArea = (KNL_DISP_ROTATE_90 == tDispRot)?2:1;
	if((KNL_DISP_H == tDispType) && (KNL_DISP_ROTATE_0 == tDispRot))
	{
		uint8_t ubSrc1, ubSrc4;
		ubSrc1 = ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
		ubSrc4 = ubKNL_GetDispSrc(KNL_DISP_LOCATION4);
		if((KNL_SRC_NONE == ubSrc1) && (KNL_SRC_NONE == ubSrc4))
		{
			ubDmySrc = KNL_SRC_1_MAIN;
			ubScaleDmyParam = (uwKNL_GetVdoH(ubDmySrc) > 1024)?2:1;
		}
		else
		{
			ubDmySrc = (KNL_SRC_NONE == ubSrc1)?ubSrc4:ubSrc1;
			ubScaleDmyParam = ubKNL_GetVdoScaleParam(ubDmySrc);
		}
	}
	else if(((KNL_DISP_H == tDispType) && (KNL_DISP_ROTATE_90 == tDispRot)) ||
	        (((KNL_DISP_3T_2L1R == tDispType) || (KNL_DISP_3T_1L2R == tDispType)) && (KNL_DISP_ROTATE_90 == tDispRot)) ||
		    (((KNL_DISP_3T_2T1B == tDispType) || (KNL_DISP_3T_1T2B == tDispType)) && ( KNL_DISP_ROTATE_0 == tDispRot)) ||
	        (( KNL_DISP_3T_3COL == tDispType) && (KNL_DISP_ROTATE_0 == tDispRot)))
	{
		uint8_t ubSrc2 = KNL_SRC_NONE, ubSrc3 = KNL_SRC_NONE;
		if(KNL_DISP_H == tDispType)
		{
			ubSrc2 = ubKNL_GetDispSrc(KNL_DISP_LOCATION2);
			ubSrc3 = ubKNL_GetDispSrc(KNL_DISP_LOCATION3);
		}
		else
		{
			KNL_SRC tLocSrc;
			KNL_DISP_LOCATION tDispLoc;
			ubDmyArea = 2;
			for(tLocSrc = KNL_SRC_1_MAIN; tLocSrc <=  KNL_SRC_4_MAIN; tLocSrc++)
			{
				tDispLoc = tKNL_SearchSrcLocation(tLocSrc);
				if(KNL_DISP_LOCATION2 == tDispLoc)
					ubSrc2 = tLocSrc;
				else if(KNL_DISP_LOCATION3 == tDispLoc)
					ubSrc3 = tLocSrc;
			}
		}
		ubDmySrc = ((KNL_SRC_NONE == ubSrc2) && (KNL_SRC_NONE == ubSrc3))?KNL_SRC_2_MAIN:(KNL_SRC_NONE == ubSrc2)?ubSrc3:ubSrc2;
		ubScaleDmyParam = ubKNL_GetVdoScaleParam(ubDmySrc);
	}
	ulCbCrColor = (tKNL_DmyPatColor.ubCr << 24) + (tKNL_DmyPatColor.ubCb << 16) + (tKNL_DmyPatColor.ubCr << 8) + tKNL_DmyPatColor.ubCb;
	ubScaleDmyParam = ubKNL_GetVdoScaleParam(ubDmySrc);
	ulDmyOffset = (uwKNL_GetVdoH(ubDmySrc) >> ubScaleDmyParam) * (uwKNL_GetVdoV(ubDmySrc) >> ubScaleDmyParam) * 3 >> 1;
	for(ubAreaIdx = 0; ubAreaIdx < ubDmyArea; ubAreaIdx++)
	{
		ulDmyBufAddr = ulBufAddr + (ubAreaIdx * ulDmyOffset);
		ulDmyBufSize = ulBufSize / ubDmyArea;
		uwHSize   = ((((KNL_DISP_H == tDispType) && (KNL_DISP_ROTATE_0 == tDispRot)) ||
            	 	   (KNL_DISP_ROTATE_90 == tDispRot))?uwKNL_GetVdoV(ubDmySrc):uwKNL_GetVdoH(ubDmySrc)) >> ubScaleDmyParam;
		ulDmyCbCr = uwHSize << 1;
		ulDmyY	  = uwHSize;
		ulDmySize = ulDmyCbCr + ulDmyY;
		tDMAC_MemSet(tKNL_DmyPatColor.ubY, ulDmyBufAddr, ulDmySize, NULL);
		pPatAddr = (uint32_t *)ulDmyBufAddr;
		ulDmyCycle = (ulDmyCbCr / 8);
		for(ulIdx = 0; ulIdx < ulDmyCycle; ulIdx++)
			memcpy((pPatAddr + ((ulIdx * 2) + 1)), &ulCbCrColor, 4);
		ulDmyCycle = (ulDmyBufSize - ulDmySize) / ulDmySize;
		for(ulIdx = 1; ulIdx <= ulDmyCycle; ulIdx++)
			tDMAC_MemCopy(ulDmyBufAddr, (ulDmyBufAddr + (ulDmySize * ulIdx)), ulDmySize, NULL);
	}
}
//------------------------------------------------------------------------------
#if(ADO_ENC_TYPE==SW_AAC_ENC)
#if 0
#define AUDIO_PLAY_BUF_MALLOC           0x180	// 1KB malloc size for buf
#define	AUDIO_WIFI_SEND_BUFF_TH			0x180
const uint8_t MENINITVALUE[AUDIO_PLAY_BUF_MALLOC]__attribute__((aligned (32))) = {
	0x01, 0x40, 0x22, 0x80, 0xA3, 0x7B, 0x58, 0x85, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2F, 
	0x01, 0x40, 0x22, 0x80, 0xA3, 0x7B, 0x58, 0x85, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2F, 
	0x01, 0x40, 0x22, 0x80, 0xA3, 0x7B, 0x58, 0x85, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2F
};
#else
#define AUDIO_PLAY_BUF_MALLOC           0x100	// 1KB malloc size for buf
#define	AUDIO_WIFI_SEND_BUFF_TH			0x100
const uint8_t MENINITVALUE[AUDIO_PLAY_BUF_MALLOC]__attribute__((aligned (32))) = {
	0x01, 0x40, 0x22, 0x80, 0xA3, 0x7B, 0x58, 0x85, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2F, 
	0x01, 0x40, 0x22, 0x80, 0xA3, 0x7B, 0x58, 0x85, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 
	0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2D, 0x2F
};
#endif
#else	//alaw
#define AUDIO_PLAY_BUF_MALLOC           0x800	// 1KB malloc size for buf
#define	AUDIO_WIFI_SEND_BUFF_TH			0x800
const uint8_t MENINITVALUE[AUDIO_PLAY_BUF_MALLOC]__attribute__((aligned (32))) = {
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,    

	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
    
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,     

	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
    
    0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,    

	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
    
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,     

	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5,
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 
	0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5, 0xD5 

};
#endif
//------------------------------------------------------------------------------
uint32_t ul1ms_cnt=0;
uint32_t KNL_TIMER_Get1ms(void)
{
	return ul1ms_cnt;
}
//------------------------------------------------------------------------------
void KNL_TIMER_Get1Sec(uint32_t *ulVal)
{
	*ulVal = ul1ms_cnt/1000;
}
//------------------------------------------------------------------------------
#if APP_REC_FUNC_ENABLE	
uint32_t ulKNL_ADO_GetMemInitValueAdr(void)
{
	return (uint32_t) MENINITVALUE;
}
//------------------------------------------------------------------------------
uint32_t ulKNL_ADO_GetWifiPacketSize(void)
{
	return AUDIO_WIFI_SEND_BUFF_TH;
}
//------------------------------------------------------------------------------
void KNL_RecordOnceEnd_SDK(void)
{
	KNL_RecordAct_t tKNL_RecEndAct;

	tKNL_RecEndAct.tRecordFunc     = tKNL_GetRecordFunc();
	tKNL_RecEndAct.pRecordStsNtyCb = tKNL_RecordAct.pRecordStsNtyCb;
    tKNL_RecEndAct.ubRecOnceStopCBFlag = 1;
	KNL_VideoRecFunc(&tKNL_RecEndAct);
    printd(DBG_CriticalLvl, "record once finish!!\r\n");
}
//------------------------------------------------------------------------------
void KNL_PlayTimeBarEvent_SDK(void)
{
    printd(DBG_InfoLvl, "KNL Play Time Bar Event->%d_%d_%d\n",ubPLY_GetTimeBarLvl(), ulPLY_GetTotalPlayTime(),ulPLY_GetSchedule());	 
}
//------------------------------------------------------------------------------
void KNL_PlayOverEvent_SDK(PLY_EVENT tEvent)
{
	KNL_Status_t tPlaySts = KNL_VDOPLAY_STOP;

    printd(DBG_CriticalLvl,"PlayOverEvent %d\n",tEvent);
	if(PLY_EVENT_STOP == tEvent)
		tPlaySts = KNL_ErrorVdoPlay;
	if(tKNL_RecordAct.pRecordStsNtyCb)
		tKNL_RecordAct.pRecordStsNtyCb(tPlaySts);
} 
#endif
//------------------------------------------------------------------------------

#if RTC676x
void KNL_VCTimeOutEvent(void)
{
	printf("Time-Out Event(VC)\r\n");
	printf("WDT Reset\r\n");
	WDT_RST_Enable(WDT_CLK_EXTCLK, 0);
	while(1);	
}
void KNL_ATimeOutEvent(void)
{
	printf("Time-Out Event(A)\r\n");
	printf("WDT Reset\r\n");
	WDT_RST_Enable(WDT_CLK_EXTCLK, 0);
	while(1);	
}
#endif

void KNL_1MSTrigger(void)
{
	static uint32_t ulTemp = 0;
#if defined(BSP_DVR_SDK)	
	if(ubKNL_ModifyDPCnt)   
	    ubKNL_ModifyDPCnt--;
#endif
	ul1ms_cnt++;
	
	if( ul1ms_cnt >= ulTemp )
	{
		ulTemp = ul1ms_cnt - ulTemp;
		if( ulTemp!=1 )
		{
            ubKNL_TmrErrFlg = 1;
		    printd(DBG_CriticalLvl, "KNL 1ms trig fail->diff=%d\n",ulTemp);
		}
	}
	ulTemp = ul1ms_cnt;
	
#if APP_REC_FUNC_ENABLE  
    if(ubPLY_GetOpMode() == PLY_MODE_P || ubPLY_GetOpMode() == PLY_MODE_PR)    PLY_Send1msCountSamephore();
#endif    
    
	if(ulKNL_ResetICntMS == 1)	memset(&ubKNL_ResetIFlg[0],1,KNL_SRC_NUM);
	if(ulKNL_ResetICntMS >= 1)	ulKNL_ResetICntMS--;
}
//------------------------------------------------------------------------------
void KNL_1MSCounterInit(void)
{
	TIMER_SETUP_t TmSetup;

	TmSetup.tCLK 		= TIMER_CLK_EXTCLK;
	TmSetup.ulTmLoad 	= 10000;
	TmSetup.ulTmCounter = TmSetup.ulTmLoad;
	TmSetup.ulTmMatch1 	= TmSetup.ulTmLoad + 1;
	TmSetup.ulTmMatch2 	= TmSetup.ulTmLoad + 1;
	TmSetup.tOF 		= TIMER_OF_ENABLE;
	TmSetup.tDIR 		= TIMER_DOWN_CNT;
	TmSetup.tEM 		= TIMER_CB;
	TmSetup.pvEvent 	= KNL_1MSTrigger;
	TIMER_Start(TIMER1_1, TmSetup);
}

#if RTC676x
//uint8_t ubKNL_FwUpgradeFlg = 0;
//uint8_t ubKNL_StartVCCheckFlg = 0;
//uint8_t ubKNL_StartACheckFlg = 0;
//void KNL_EnterFwUpgradeMode(void)
//{
//	ubKNL_FwUpgradeFlg = 1;
//}

//void KNL_QuitFwUpgradeMode(void)
//{
//	ubKNL_FwUpgradeFlg = 0;
//}

//void KNL_StartChkVCTimeOut(void)
//{
//	TIMER_SETUP_t TmSetup;

//	if(!ubKNL_FwUpgradeFlg)
//	{	
//		ubKNL_StartVCCheckFlg = 1;
//		
//		TmSetup.tCLK 		= TIMER_CLK_EXTCLK;

//	#ifdef OP_STA
//		TmSetup.ulTmLoad 	= 10000*CHK_TIME_OUT_FOR_STA;
//	#endif	
//	#ifdef OP_AP
//		TmSetup.ulTmLoad 	= 10000*CHK_TIME_OUT_FOR_AP;
//	#endif
//		
//		TmSetup.ulTmCounter = TmSetup.ulTmLoad;
//		TmSetup.ulTmMatch1 	= TmSetup.ulTmLoad + 1;
//		TmSetup.ulTmMatch2 	= TmSetup.ulTmLoad + 1;
//		TmSetup.tOF 		= TIMER_OF_ENABLE;
//		TmSetup.tDIR 		= TIMER_DOWN_CNT;
//		TmSetup.tEM 		= TIMER_CB;	
//		TmSetup.pvEvent 	= KNL_VCTimeOutEvent;
//		TIMER_Start(TIMER1_2, TmSetup);
//	}
//}

//void KNL_StopChkVCTimeOut(void)
//{
//	if(!ubKNL_FwUpgradeFlg)
//	{
//		ubKNL_StartVCCheckFlg = 0;
//		TIMER_Stop(TIMER1_2);		
//	}
//	else if(ubKNL_StartVCCheckFlg)
//	{
//		ubKNL_StartVCCheckFlg = 0;
//		TIMER_Stop(TIMER1_2);		
//	}
//}

//void KNL_StartChkATimeOut(void)
//{
//	TIMER_SETUP_t TmSetup;

//	if(!ubKNL_FwUpgradeFlg)
//	{
//		ubKNL_StartACheckFlg = 1;
//		
//		TmSetup.tCLK 		= TIMER_CLK_EXTCLK;

//	#ifdef OP_STA
//		TmSetup.ulTmLoad 	= 10000*CHK_TIME_OUT_FOR_STA;
//	#endif	
//	#ifdef OP_AP
//		TmSetup.ulTmLoad 	= 10000*CHK_TIME_OUT_FOR_AP;
//	#endif
//		
//		TmSetup.ulTmCounter = TmSetup.ulTmLoad;
//		TmSetup.ulTmMatch1 	= TmSetup.ulTmLoad + 1;
//		TmSetup.ulTmMatch2 	= TmSetup.ulTmLoad + 1;
//		TmSetup.tOF 		= TIMER_OF_ENABLE;
//		TmSetup.tDIR 		= TIMER_DOWN_CNT;
//		TmSetup.tEM 		= TIMER_CB;	
//		TmSetup.pvEvent 	= KNL_ATimeOutEvent;
//		TIMER_Start(TIMER1_3, TmSetup);
//	}
//}

//void KNL_StopChkATimeOut(void)
//{
//	if(!ubKNL_FwUpgradeFlg)
//	{
//		ubKNL_StartACheckFlg = 0;
//		TIMER_Stop(TIMER1_3);		
//	}
//	else if(ubKNL_StartACheckFlg)
//	{
//		ubKNL_StartACheckFlg = 0;
//		TIMER_Stop(TIMER1_3);
//	}
//}
#endif

#ifdef RTC676x
// Richwave
void KNL_SetSocketFd(int fd)
{
	KNL_SocketFd = fd;
}

int KNL_GetSocketFd(void)
{
	return KNL_SocketFd;
}
#endif

//-----------------------------------------------------------------------------
//Sorting
//-----------------------------------------------------------------------------
// Folder
KNL_TX_FLDINFO tKNL_TXFldInfo;
FS_FLD_INFO_t tKNL_SortFolderInfo[KNL_TOTAL_SUB_FLD_NUM];
uint16_t uwKNL_SortFLDResult[KNL_TOTAL_SUB_FLD_NUM];
uint32_t ulKNL_SortValidFLDNum = KNL_TOTAL_SUB_FLD_NUM;
static KNL_SORTMODE_t tKNL_SortFLDMode = SORT_INVALILD;
uint16_t uwKNL_SortFolderIndex = 0xFFFF;                    // No used ??
// File
FS_FILE_HIDDEN_INFO_t tKNL_SortFileHiddenInfo[KNL_MAX_FILE_NUM];
uint16_t uwKNL_SortResult[KNL_MAX_FILE_NUM];
uint32_t ulKNL_SortValidFileNum = KNL_MAX_FILE_NUM;
static KNL_SORTMODE_t tKNL_SortMode = SORT_INVALILD;
FS_FILE_INFO_t tKNL_SortFileInfo[KNL_MAX_FILE_NUM];
//-----------------------------------------------------------------------------
uint32_t KNL_Atoi(char *Input, uint32_t length)
{
	uint32_t i, j;
	uint32_t power10;
	uint32_t Output;

	Output = 0;
	for( i=0; i<length; i++ )
	{
		power10 = 1;
		for( j=(length-i-1); j>0; j-- )
		{
			power10 = power10*10;
		}
		Output = Output + ((Input[i]-0x30)*power10);
	}
	return Output;
}
//-----------------------------------------------------------------------------
FS_FLD_INFO_t KNL_GetFLDInfo(uint32_t ulIdx)
{
    return tKNL_SortFolderInfo[ulIdx];
}
//-----------------------------------------------------------------------------
uint16_t uwKNL_GetSortFLDResult(uint32_t ulIdx)
{
    uint8_t k = 0;
    if((tKNL_SortFLDMode == SORT_BY_NAME_DESCENDING) || (tKNL_SortFLDMode == SORT_BY_TIME_DESCENDING) || 
        (tKNL_SortFLDMode == SORT_BY_FILE_SIZE_DESCENDING) || (tKNL_SortFLDMode == SORT_BY_NAME_DESCENDING_BY_TIME))
    {
        k = tKNL_TXFldInfo.ubFldNum;
        if(tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].EmgFuncEnable == FS_ON)
            k++;
        if(tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].TimelapseFuncEnable == FS_ON)
            k++;
        
        if(ulIdx >= k)
            return uwKNL_SortFLDResult[(ulKNL_SortValidFLDNum - 1) - (ulIdx-k)];
        else
            return uwKNL_SortFLDResult[ulIdx];
    }
    else
        return uwKNL_SortFLDResult[ulIdx];  
}
//------------------------------------------------------------------------------
uint8_t ubKNL_CompareFldIndex(uint8_t ubSortMode,uint16_t uwAindex, uint16_t uwBindex ) 
{
    uint8_t i;
		
	switch (ubSortMode) {
		case SORT_BY_TIME_DESCENDING:
        case SORT_BY_TIME_ASCENDING:
            if (tKNL_SortFolderInfo[uwAindex].CreTime.uwYear < tKNL_SortFolderInfo[uwBindex].CreTime.uwYear)              //uwCreateYear
            {
                return KNL_SORT_SMALL;
            } 
            else if (tKNL_SortFolderInfo[uwAindex].CreTime.uwYear > tKNL_SortFolderInfo[uwBindex].CreTime.uwYear) 
            {
                return KNL_SORT_BIG;
            }
            else if (tKNL_SortFolderInfo[uwAindex].CreTime.ubMonth < tKNL_SortFolderInfo[uwBindex].CreTime.ubMonth)        //ubCreateMonth
            {
                return KNL_SORT_SMALL;
            }
            else if (tKNL_SortFolderInfo[uwAindex].CreTime.ubMonth > tKNL_SortFolderInfo[uwBindex].CreTime.ubMonth) 
            {
                return KNL_SORT_BIG;
            }
            else if (tKNL_SortFolderInfo[uwAindex].CreTime.ubDay < tKNL_SortFolderInfo[uwBindex].CreTime.ubDay)           //ubCreateDay
            {
                return KNL_SORT_SMALL;
            }
            else if (tKNL_SortFolderInfo[uwAindex].CreTime.ubDay > tKNL_SortFolderInfo[uwBindex].CreTime.ubDay) 
            {
                return KNL_SORT_BIG;
            }
            else if (tKNL_SortFolderInfo[uwAindex].CreTime.ubHour < tKNL_SortFolderInfo[uwBindex].CreTime.ubHour)         //uwCreateHour
            {
                return KNL_SORT_SMALL;
            }
            else if (tKNL_SortFolderInfo[uwAindex].CreTime.ubHour > tKNL_SortFolderInfo[uwBindex].CreTime.ubHour) 
            {
                return KNL_SORT_BIG;
            }
            else if (tKNL_SortFolderInfo[uwAindex].CreTime.ubMin < tKNL_SortFolderInfo[uwBindex].CreTime.ubMin)         //ubCreateMin
            {
                return KNL_SORT_SMALL;
            }
            else if (tKNL_SortFolderInfo[uwAindex].CreTime.ubMin > tKNL_SortFolderInfo[uwBindex].CreTime.ubMin) 
            {
                return KNL_SORT_BIG;
            }
            else if (tKNL_SortFolderInfo[uwAindex].CreTime.ubSec < tKNL_SortFolderInfo[uwBindex].CreTime.ubSec)         //ubCreateSec
            {
                return KNL_SORT_SMALL;
            }
            else if (tKNL_SortFolderInfo[uwAindex].CreTime.ubSec > tKNL_SortFolderInfo[uwBindex].CreTime.ubSec) 
            {
                return KNL_SORT_BIG;
            }
			break;

		case SORT_BY_NAME_DESCENDING:
        case SORT_BY_NAME_ASCENDING:  
        case SORT_BY_NAME_DESCENDING_BY_TIME:  
        case SORT_BY_NAME_ASCENDING_BY_TIME:  
                for (i = 0; i < tKNL_SortFolderInfo[uwAindex].FldName.ubLen; i++) 
                {
                    if(tKNL_SortFolderInfo[uwAindex].FldName.chName[i] > tKNL_SortFolderInfo[uwBindex].FldName.chName[i])
                        return KNL_SORT_BIG;
                    else if(tKNL_SortFolderInfo[uwAindex].FldName.chName[i] < tKNL_SortFolderInfo[uwBindex].FldName.chName[i])  
                        return KNL_SORT_SMALL;   
                }            		
			break;
	}
	return KNL_SORT_EQUAL;
}
//------------------------------------------------------------------------------
void KNL_FLD_BubbleSortByNameBaseOnSameTime(uint16_t arr[], uint32_t len)
{
	int i, j, temp;
	uint8_t ubNameCmpResult;
	uint8_t ubTimeCmpResult;
	
	if(len>KNL_TOTAL_SUB_FLD_NUM)
		return;
	
	if(len>=2)
	{
		for(i = 0; i < len - 1; ++i)
		{
			for(j = 0; j < len - 1 - i; ++j)
			{
				ubNameCmpResult = ubKNL_CompareFldIndex(SORT_BY_NAME_ASCENDING, arr[j], arr[j+1]);
				ubTimeCmpResult = ubKNL_CompareFldIndex(SORT_BY_TIME_ASCENDING, arr[j], arr[j+1]);
				if( ubTimeCmpResult==KNL_SORT_EQUAL && ubNameCmpResult==KNL_SORT_BIG )
				{
					temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
				}
			}
		}
	}
}
//------------------------------------------------------------------------------
void KNL_SortFLD(KNL_FldType_t tSimFld,uint8_t ubSortMode, uint16_t uwFLDNum)
{
#if !APP_FS_CUSTOMER1_PATH_ENABLE
    uint16_t len = uwFLDNum;
    uint16_t uwStartIdx=0;
#endif
    uint16_t i;
    
    for (i = 0; i < KNL_TOTAL_SUB_FLD_NUM; i++) 
    {
        uwKNL_SortFLDResult[i] = i;
    }  

#if !APP_FS_CUSTOMER1_PATH_ENABLE
    if(tSimFld)
        uwStartIdx = tKNL_TXFldInfo.ubFldNum;
    if(tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].EmgFuncEnable == FS_ON)
        uwStartIdx++;
    if(tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].TimelapseFuncEnable == FS_ON)
        uwStartIdx++;
	
	if( len>=(uwStartIdx+2) )
		KNL_FLD_FILE_BubbleSort(0, ubSortMode, &uwKNL_SortFLDResult[uwStartIdx], len-uwStartIdx);
#if 0
	for (i=0; i <len; i++)
	{
		printf("->%3d_%s, %3d_%s, [%d_%d_%d] [%d_%d_%d]\n",
			i,tKNL_SortFolderInfo[i].FldName.chName, 
			uwKNL_SortFLDResult[i], tKNL_SortFolderInfo[uwKNL_SortFLDResult[i]].FldName.chName,
			tKNL_SortFolderInfo[uwKNL_SortFLDResult[i]].CreTime.uwYear, tKNL_SortFolderInfo[uwKNL_SortFLDResult[i]].CreTime.ubMonth, tKNL_SortFolderInfo[uwKNL_SortFLDResult[i]].CreTime.ubDay,
			tKNL_SortFolderInfo[uwKNL_SortFLDResult[i]].CreTime.ubHour, tKNL_SortFolderInfo[uwKNL_SortFLDResult[i]].CreTime.ubMin, tKNL_SortFolderInfo[uwKNL_SortFLDResult[i]].CreTime.ubSec);
		
		WDT_TimerClr(WDT_RST);
	}	
	printf("----------------------------------------------\n");
#endif    
	
	if( len>=(uwStartIdx+2) )
		KNL_FLD_BubbleSortByNameBaseOnSameTime(&uwKNL_SortFLDResult[uwStartIdx], len-uwStartIdx);
#if 0
	for (i=0; i <len; i++)
	{
		printf("->%3d_%s, %3d_%s, [%d_%d_%d] [%d_%d_%d]\n",
			i,tKNL_SortFolderInfo[i].FldName.chName, 
			uwKNL_SortFLDResult[i], tKNL_SortFolderInfo[uwKNL_SortFLDResult[i]].FldName.chName,
			tKNL_SortFolderInfo[uwKNL_SortFLDResult[i]].CreTime.uwYear, tKNL_SortFolderInfo[uwKNL_SortFLDResult[i]].CreTime.ubMonth, tKNL_SortFolderInfo[uwKNL_SortFLDResult[i]].CreTime.ubDay,
			tKNL_SortFolderInfo[uwKNL_SortFLDResult[i]].CreTime.ubHour, tKNL_SortFolderInfo[uwKNL_SortFLDResult[i]].CreTime.ubMin, tKNL_SortFolderInfo[uwKNL_SortFLDResult[i]].CreTime.ubSec);
		
		WDT_TimerClr(WDT_RST);
	}
#endif
#endif
}
//-----------------------------------------------------------------------------
uint32_t ulKNL_GetSortingFolders(KNL_FldType_t tSimFld,KNL_SORTMODE_t tSortMode, KNL_FOLDERSINFO_t *pFoldersInfo)
{
    uint32_t i = 0, j;
	uint8_t ubFsTimeout = 30;
	FS_MEDIA_RDY_ACC Status;
	FS_GET_A_SINGLE_FLD_INTO_t SingleFldInfo;
	FS_GET_A_SERIES_FLD_INTO_t SeriesFldInfo;
	FS_Q_STATUS FsWaitStatus;
	uint8_t ubHitFlg;

	memset((uint8_t*)pFoldersInfo, 0, KNL_TOTAL_SUB_FLD_NUM*sizeof(KNL_FOLDERSINFO_t));
	if(tKNL_FsMediaInfo.MediaType[tKNL_FsMediaInfo.MediaSel]==FS_MEDIA_TYPE_SD)
	{
		if(!ubSD_ChkCardIn(tSD_GetDevIF()))
#if (OP_AP && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
			goto SKIPCHKMEDIA;
#else
			return 0;
#endif
	}
	ubFsTimeout = 30;
	while(1)
	{
		Status = FS_ChkMediaRdy(tKNL_FsMediaInfo.MediaSel);
		if( Status!=FS_MEDIA_RDY )
		{
			osDelay(100);
			ubFsTimeout--;
		}			
		else
			break;
		
		if(!ubFsTimeout)
		{
			if(Status==FS_MEDIA_NOT_RDY)
				printd(DBG_ErrorLvl, "SD Card not ready !\n");
			else if(Status==FS_MEDIA_GET_INFO_FAIL)
				printd(DBG_ErrorLvl, "SD Card get info fail !\n");
			return 0;
		}
	}
#if (OP_AP && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
SKIPCHKMEDIA:
#endif
	tKNL_SortFLDMode = tSortMode;
	ulKNL_SortValidFLDNum = 0;
    memset(&tKNL_TXFldInfo,0x00,sizeof(KNL_TX_FLDINFO));
    if(tSimFld == KNL_SIM_FLD)
    {
        #define TXFLD   "TXFLD1"
        for(i=KNL_STA1; i<DISPLAY_MODE;i++)
        {
            if(ubKNL_GetCommLinkStatus(i) == BB_LINK)
            {
                memcpy(&tKNL_SortFolderInfo[tKNL_TXFldInfo.ubFldNum].FldName.chName[0] , TXFLD, sizeof(TXFLD)-1);
                tKNL_SortFolderInfo[tKNL_TXFldInfo.ubFldNum].FldName.chName[sizeof(TXFLD)-2] = (0x30+i);
                tKNL_SortFolderInfo[tKNL_TXFldInfo.ubFldNum].FldName.ubLen = sizeof(TXFLD)-1;
                tKNL_TXFldInfo.ubLinked[tKNL_TXFldInfo.ubFldNum]=i;
                tKNL_TXFldInfo.ubFldNum++;
            }
        }
    }
#if (OP_AP && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)    
    if(tKNL_FsMediaInfo.MediaType[tKNL_FsMediaInfo.MediaSel]==FS_MEDIA_TYPE_SD)
	{
		if(!ubSD_ChkCardIn(tSD_GetDevIF()))
			goto SKIPGETINFO;
	}
#endif
	SeriesFldInfo.OutputFldInfo  = &tKNL_SortFolderInfo[tKNL_TXFldInfo.ubFldNum];
	SeriesFldInfo.OutputValidNum = &ulKNL_SortValidFLDNum;
	SeriesFldInfo.ulOffset       = 0;
	SeriesFldInfo.ulNum          = KNL_TOTAL_SUB_FLD_NUM;
	if(tKNL_FsMediaInfo.MediaType[tKNL_FsMediaInfo.MediaSel]==FS_MEDIA_TYPE_SD)
	{
		FS_GetFldInfo(tKNL_FsMediaInfo.MediaSel, A_SERIES_INFO, SingleFldInfo, SeriesFldInfo, FILE_PATH2);
	}
	else if(tKNL_FsMediaInfo.MediaType[tKNL_FsMediaInfo.MediaSel]==FS_MEDIA_TYPE_SF)
	{
		FS_GetFldInfo(tKNL_FsMediaInfo.MediaSel, A_SERIES_INFO, SingleFldInfo, SeriesFldInfo, FILE_PATH1);	
	}
	ubFsTimeout = 60;
	while(1)
	{
		FsWaitStatus = FS_ChkGetFldInfoStatus(tKNL_FsMediaInfo.MediaSel);
		if(FsWaitStatus==FS_GET_INFO_FAIL)
		{
			printd(DBG_ErrorLvl, "KNL Get Sorting Folders fail!\n");
			return 0;
		}
		else if(FsWaitStatus==FS_GET_INFO_OK)
		{
			break;
		}
		else
		{
			osDelay(50);
			if(!--ubFsTimeout)
			{
				printd(DBG_ErrorLvl, "KNL Get Sorting Folders Timeout!\n");
				return 0;
			}
		}
	}
	
	//remove non-sonix version folder
	ubHitFlg = 0;
	for(i=tKNL_TXFldInfo.ubFldNum; i<(tKNL_TXFldInfo.ubFldNum+ulKNL_SortValidFLDNum); i++)
	{
		if(ubHitFlg)
		{
			i--;
		}
		if((tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].EmgFuncEnable==FS_ON && 
			memcmp(tKNL_SortFolderInfo[i].FldName.chName, tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].DefEmgFldName.chName, tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].DefEmgFldName.ubLen)==0) ||
		
		   (tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].TimelapseFuncEnable==FS_ON && 
			memcmp(tKNL_SortFolderInfo[i].FldName.chName, tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].DefTimelapseFldName.chName, tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].DefTimelapseFldName.ubLen)==0) ||
		
		   (tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].FldStrcMode==STANDARD_DCIM && 
			memcmp(&tKNL_SortFolderInfo[i].FldName.chName[3], tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].chDefRecFldName, 5)==0) ||
		
		   (tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].FldStrcMode==DCIM_WITH_VDO_PHOTO_FLD && 
			(memcmp(tKNL_SortFolderInfo[i].FldName.chName, tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].Cust1_DefVideoFldName.chName, tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].Cust1_DefVideoFldName.ubLen)==0 || 
			memcmp(tKNL_SortFolderInfo[i].FldName.chName, tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].Cust1_DefPhotoFldName.chName, tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].Cust1_DefPhotoFldName.ubLen)==0)))
		{
			ubHitFlg = 0;
			continue;
		}
		
		//move
		for(j=i+1; j<ulKNL_SortValidFLDNum; j++)
		{
			tKNL_SortFolderInfo[j-1] = tKNL_SortFolderInfo[j];
		}
		ubHitFlg = 1;
		ulKNL_SortValidFLDNum--;
	}
	i = (tKNL_TXFldInfo.ubFldNum+ulKNL_SortValidFLDNum)-1;
	ubHitFlg = 0;
	if((tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].EmgFuncEnable==FS_ON && 
		memcmp(tKNL_SortFolderInfo[i].FldName.chName, tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].DefEmgFldName.chName, tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].DefEmgFldName.ubLen)==0) ||
	
	   (tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].TimelapseFuncEnable==FS_ON && 
		memcmp(tKNL_SortFolderInfo[i].FldName.chName, tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].DefTimelapseFldName.chName, tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].DefTimelapseFldName.ubLen)==0) ||
	
	   (tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].FldStrcMode==STANDARD_DCIM && 
		memcmp(&tKNL_SortFolderInfo[i].FldName.chName[3], tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].chDefRecFldName, 5)==0) ||
	
	   (tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].FldStrcMode==DCIM_WITH_VDO_PHOTO_FLD && 
		(memcmp(tKNL_SortFolderInfo[i].FldName.chName, tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].Cust1_DefVideoFldName.chName, tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].Cust1_DefVideoFldName.ubLen)==0 || 
		memcmp(tKNL_SortFolderInfo[i].FldName.chName, tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].Cust1_DefPhotoFldName.chName, tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].Cust1_DefPhotoFldName.ubLen)==0)))
	{
		ubHitFlg = 1;
	}
	if(ubHitFlg==0)
	{
	    if(ulKNL_SortValidFLDNum)		ulKNL_SortValidFLDNum--;
	}
	
#if (OP_AP && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE) 
SKIPGETINFO:
#endif
    ulKNL_SortValidFLDNum += tKNL_TXFldInfo.ubFldNum;
	KNL_SortFLD(tSimFld,SORT_BY_TIME_ASCENDING, ulKNL_SortValidFLDNum);
	
	if( tKNL_SortFLDMode==SORT_BY_NAME_DESCENDING ||
		tKNL_SortFLDMode==SORT_BY_NAME_DESCENDING_BY_TIME ||
		tKNL_SortFLDMode==SORT_BY_TIME_DESCENDING )
    {
        i = 0;
        if(tSimFld == KNL_SIM_FLD)// TX Folder
        {
            for(i=0; i < tKNL_TXFldInfo.ubFldNum; i++)
            {
                memcpy(&pFoldersInfo[i].FldName, &tKNL_SortFolderInfo[uwKNL_SortFLDResult[i]].FldName, sizeof(tKNL_SortFolderInfo[uwKNL_SortFLDResult[i]].FldName));
                pFoldersInfo[i].FilePath = tKNL_SortFolderInfo[uwKNL_SortFLDResult[i]].FilePath;
            }
        }
        if( tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].EmgFuncEnable == FS_ON)
        {
            memcpy(&pFoldersInfo[i].FldName, &tKNL_SortFolderInfo[uwKNL_SortFLDResult[i]].FldName, sizeof(tKNL_SortFolderInfo[uwKNL_SortFLDResult[i]].FldName));
            pFoldersInfo[i].FilePath = tKNL_SortFolderInfo[uwKNL_SortFLDResult[i]].FilePath;
            i++;
        }
        if( tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].TimelapseFuncEnable == FS_ON )
        {
            memcpy(&pFoldersInfo[i].FldName, &tKNL_SortFolderInfo[uwKNL_SortFLDResult[i]].FldName, sizeof(tKNL_SortFolderInfo[uwKNL_SortFLDResult[i]].FldName));
            pFoldersInfo[i].FilePath = tKNL_SortFolderInfo[uwKNL_SortFLDResult[i]].FilePath;
            i++;
        }
        j = ulKNL_SortValidFLDNum - 1;  // Number convert to last index.
        for ( ; i < ulKNL_SortValidFLDNum; i++) 
		{
			memcpy(&pFoldersInfo[i].FldName, &tKNL_SortFolderInfo[uwKNL_SortFLDResult[j]].FldName, sizeof(tKNL_SortFolderInfo[uwKNL_SortFLDResult[j]].FldName));
			pFoldersInfo[i].FilePath = tKNL_SortFolderInfo[uwKNL_SortFLDResult[j]].FilePath;
            j--;
		}        
    }
    else
    {
        for (i = 0; i < ulKNL_SortValidFLDNum; i++)
        {
		    memcpy(&pFoldersInfo[i].FldName, &tKNL_SortFolderInfo[uwKNL_SortFLDResult[i]].FldName, sizeof(tKNL_SortFolderInfo[uwKNL_SortFLDResult[i]].FldName));
			pFoldersInfo[i].FilePath = tKNL_SortFolderInfo[uwKNL_SortFLDResult[i]].FilePath;
        }
    }
    return ulKNL_SortValidFLDNum;
}
//-----------------------------------------------------------------------------
FS_FILE_HIDDEN_INFO_t KNL_GetFileHidInfo(KNL_FldType_t tSimFld,uint32_t ulIdx)
{
#if (OP_AP && APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)	
    if(tSimFld == KNL_SIM_FLD)
        return tKNL_TXFSHiddenInfo;
    else
#endif
		return tKNL_SortFileHiddenInfo[ulIdx];	
}
//-----------------------------------------------------------------------------
uint16_t uwKNL_GetSortResult(uint32_t ulIdx)
{   
    if((tKNL_SortMode == SORT_BY_NAME_DESCENDING) || (tKNL_SortMode == SORT_BY_TIME_DESCENDING) || 
        (tKNL_SortMode == SORT_BY_FILE_SIZE_DESCENDING) || (tKNL_SortMode == SORT_BY_NAME_DESCENDING_BY_TIME))
        return uwKNL_SortResult[ulKNL_SortValidFileNum - ulIdx - 1];
    else
        return uwKNL_SortResult[ulIdx];  
}
//------------------------------------------------------------------------------
uint8_t ubKNL_CompareFileIndex(uint8_t ubSortMode,uint16_t uwAindex, uint16_t uwBindex ) 
{
    uint8_t i;
		
	switch (ubSortMode) {
		case SORT_BY_TIME_DESCENDING:
        case SORT_BY_TIME_ASCENDING:
//            if (tFS_SortFileInfo[uwAindex].ulRtcLongTime < tFS_SortFileInfo[uwBindex].ulRtcLongTime)              //ulRtcLongTime
//            {
//                return FS_SORT_SMALL;
//            } 
//            else if (tFS_SortFileInfo[uwAindex].ulRtcLongTime > tFS_SortFileInfo[uwBindex].ulRtcLongTime) 
//            {
//                return FS_SORT_BIG;
//            }

            if (tKNL_SortFileHiddenInfo[uwAindex].CreTime.uwYear < tKNL_SortFileHiddenInfo[uwBindex].CreTime.uwYear)              //uwCreateYear
            {
                return KNL_SORT_SMALL;
            } 
            else if (tKNL_SortFileHiddenInfo[uwAindex].CreTime.uwYear > tKNL_SortFileHiddenInfo[uwBindex].CreTime.uwYear) 
            {
                return KNL_SORT_BIG;
            }
            else if (tKNL_SortFileHiddenInfo[uwAindex].CreTime.ubMonth < tKNL_SortFileHiddenInfo[uwBindex].CreTime.ubMonth)        //ubCreateMonth
            {
                return KNL_SORT_SMALL;
            }
            else if (tKNL_SortFileHiddenInfo[uwAindex].CreTime.ubMonth > tKNL_SortFileHiddenInfo[uwBindex].CreTime.ubMonth) 
            {
                return KNL_SORT_BIG;
            }
            else if (tKNL_SortFileHiddenInfo[uwAindex].CreTime.ubDay < tKNL_SortFileHiddenInfo[uwBindex].CreTime.ubDay)           //ubCreateDay
            {
                return KNL_SORT_SMALL;
            }
            else if (tKNL_SortFileHiddenInfo[uwAindex].CreTime.ubDay > tKNL_SortFileHiddenInfo[uwBindex].CreTime.ubDay) 
            {
                return KNL_SORT_BIG;
            }
            else if (tKNL_SortFileHiddenInfo[uwAindex].CreTime.ubHour < tKNL_SortFileHiddenInfo[uwBindex].CreTime.ubHour)         //uwCreateHour
            {
                return KNL_SORT_SMALL;
            }
            else if (tKNL_SortFileHiddenInfo[uwAindex].CreTime.ubHour > tKNL_SortFileHiddenInfo[uwBindex].CreTime.ubHour) 
            {
                return KNL_SORT_BIG;
            }
            else if (tKNL_SortFileHiddenInfo[uwAindex].CreTime.ubMin < tKNL_SortFileHiddenInfo[uwBindex].CreTime.ubMin)         //ubCreateMin
            {
                return KNL_SORT_SMALL;
            }
            else if (tKNL_SortFileHiddenInfo[uwAindex].CreTime.ubMin > tKNL_SortFileHiddenInfo[uwBindex].CreTime.ubMin) 
            {
                return KNL_SORT_BIG;
            }
            else if (tKNL_SortFileHiddenInfo[uwAindex].CreTime.ubSec < tKNL_SortFileHiddenInfo[uwBindex].CreTime.ubSec)         //ubCreateSec
            {
                return KNL_SORT_SMALL;
            }
            else if (tKNL_SortFileHiddenInfo[uwAindex].CreTime.ubSec > tKNL_SortFileHiddenInfo[uwBindex].CreTime.ubSec) 
            {
                return KNL_SORT_BIG;
            }
			break;

		case SORT_BY_NAME_DESCENDING:
        case SORT_BY_NAME_ASCENDING:  
        case SORT_BY_NAME_DESCENDING_BY_TIME:  
        case SORT_BY_NAME_ASCENDING_BY_TIME:  
                for (i = 0; i < tKNL_SortFileHiddenInfo[uwAindex].FileName.ubLen; i++) 
                {
                    if(tKNL_SortFileHiddenInfo[uwAindex].FileName.chName[i] > tKNL_SortFileHiddenInfo[uwBindex].FileName.chName[i])
                        return KNL_SORT_BIG;
                    else if(tKNL_SortFileHiddenInfo[uwAindex].FileName.chName[i] < tKNL_SortFileHiddenInfo[uwBindex].FileName.chName[i])  
                        return KNL_SORT_SMALL;   
                }            		
			break;

		case SORT_BY_FILE_SIZE_DESCENDING:
        case SORT_BY_FILE_SIZE_ASCENDING: 
            if (tKNL_SortFileHiddenInfo[uwAindex].ullFileSize < tKNL_SortFileHiddenInfo[uwBindex].ullFileSize) 
            {
                return KNL_SORT_SMALL;
            } 
            else if (tKNL_SortFileHiddenInfo[uwAindex].ullFileSize > tKNL_SortFileHiddenInfo[uwBindex].ullFileSize) 
            {
                return KNL_SORT_BIG;
            }
	
			break;
	}
	return KNL_SORT_EQUAL;
}
//------------------------------------------------------------------------------
void KNL_FLD_FILE_BubbleSort(uint8_t ubType, uint8_t ubSortMode, uint16_t arr[], uint32_t len)
{
	int i, j, temp;
	uint8_t ubResult;
	
	if(ubType==0)	// folder
	{
		if(len>KNL_TOTAL_SUB_FLD_NUM)
			return;
	}
	else if(ubType==1)	// file
	{
		if(len>KNL_MAX_FILE_NUM)
			return;		
	}
	
	if(len>=2)
	{
		for(i = 0; i < len - 1; ++i)
		{
			for(j = 0; j < len - 1 - i; ++j)
			{
				if(ubType==0)	// folder
					ubResult = ubKNL_CompareFldIndex(ubSortMode, arr[j], arr[j+1]);
				else if(ubType==1)	// file
					ubResult = ubKNL_CompareFileIndex(ubSortMode, arr[j], arr[j+1]);
				if (ubResult == KNL_SORT_BIG)
				{
					temp = arr[j];
					arr[j] = arr[j + 1];
					arr[j + 1] = temp;
				}
			}
		}
	}
}
//------------------------------------------------------------------------------
void KNL_SortFile(uint8_t ubSortMode, uint16_t uwFileNum)
{
    uint16_t len = uwFileNum;
    uint16_t i;
    uint16_t uwFileNum1=0;
    uint16_t uwTmp[KNL_MAX_FILE_NUM];
    
    for (i = 0; i < KNL_MAX_FILE_NUM; i++) 
    {
        uwKNL_SortResult[i] = i;
    }
	
	if( len>=2 )
		KNL_FLD_FILE_BubbleSort(1, ubSortMode, &uwKNL_SortResult[0], len);
	
    if(ubSortMode == SORT_BY_NAME_DESCENDING || ubSortMode == SORT_BY_NAME_ASCENDING || 
        ubSortMode == SORT_BY_NAME_DESCENDING_BY_TIME || ubSortMode == SORT_BY_NAME_ASCENDING_BY_TIME)
    {
        // Check Rolling 
        for (i = 0; i < len - 1; i++)
        {
            if(tKNL_SortFileHiddenInfo[uwKNL_SortResult[i]].uwGroupIdx != tKNL_SortFileHiddenInfo[uwKNL_SortResult[i+1]].uwGroupIdx)
            {
                if(tKNL_SortFileHiddenInfo[uwKNL_SortResult[i]].uwGroupIdx > tKNL_SortFileHiddenInfo[uwKNL_SortResult[i+1]].uwGroupIdx)
                {
                    // Do Rolling case
                    uwFileNum1 = i+1;
                    memcpy((void*)&uwTmp[0],(void*)&uwKNL_SortResult[uwFileNum1],((len-uwFileNum1)<<1));
                    memcpy((void*)&uwTmp[(len-uwFileNum1)],(void*)&uwKNL_SortResult[0],(uwFileNum1<<1));
                    memcpy((void*)&uwKNL_SortResult[0],(void*)&uwTmp[0],(len<<1));
                    break;
                }
            }
        }
    }
}
//-----------------------------------------------------------------------------
uint16_t uwKNL_GetSortingFiles(uint16_t uwFolderIndex, KNL_SORTMODE_t tSortMode, KNL_FILESINFO_t *pFilesInfo)
{
    uint32_t i = 0, j;	
	uint8_t ubFsTimeout;
	uint8_t *pFilesDataAddr;
	FS_FLD_NAME_INFO_t FldNameInfo;
	FS_GET_A_SINGLE_FILE_INTO_t SingleFileInfo;
	FS_GET_A_SERIES_FILE_INTO_t SeriesFileInfo;
	FS_FILE_PATH FilePath;
	FS_Q_STATUS FsWaitStatus;

//	if((uwFS_SortFolderIndex == uwFolderIndex) && (tFS_SortMode == tSortMode))
//		return uwFS_SortValidFileNum[0];
	
	if(tKNL_FsMediaInfo.MediaType[tKNL_FsMediaInfo.MediaSel]==FS_MEDIA_TYPE_SD)
	{
		if(!ubSD_ChkCardIn(tSD_GetDevIF()))
			return 0;		
	}
	uwKNL_SortFolderIndex = uwFolderIndex;
	tKNL_SortMode 		  = tSortMode;
	ulKNL_SortValidFileNum = 0;
	
	memset(&FldNameInfo, 0x0, sizeof(FldNameInfo));
	if(tKNL_FsMediaInfo.MediaType[tKNL_FsMediaInfo.MediaSel]==FS_MEDIA_TYPE_SD)
	{
		FldNameInfo = KNL_GetFLDInfo(uwKNL_GetSortFLDResult(uwFolderIndex)).FldName;
		SeriesFileInfo.OutputHidnFileInfo = &tKNL_SortFileHiddenInfo[0];
		SeriesFileInfo.OutputValidNum     = &ulKNL_SortValidFileNum;
		SeriesFileInfo.FldName            = FldNameInfo;
		SeriesFileInfo.ulOffset           = 0;
		SeriesFileInfo.ulNum              = KNL_MAX_FILE_NUM;
		if( memcmp(FldNameInfo.chName, tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].DefEmgFldName.chName, tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].DefEmgFldName.ubLen)==0 )
		{
			FilePath = FILE_PATH3;
		}
		else if( memcmp(FldNameInfo.chName, tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].DefTimelapseFldName.chName, tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].DefTimelapseFldName.ubLen)==0 )
		{
			FilePath = FILE_PATH4;
		}
		else
		{
#if APP_FS_CUSTOMER1_PATH_ENABLE
			if( memcmp(FldNameInfo.chName, tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].Cust1_DefVideoFldName.chName, tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].Cust1_DefVideoFldName.ubLen)==0 )
			{
				FilePath = FILE_PATH5;
			}
			else if( memcmp(FldNameInfo.chName, tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].Cust1_DefPhotoFldName.chName, tKNL_FsMediaInfo.InitPara.MediaInfo[tKNL_FsMediaInfo.MediaSel].Cust1_DefPhotoFldName.ubLen)==0 )
			{
				FilePath = FILE_PATH6;
			}
			else
#endif
			{
				FilePath = FILE_PATH_DEFAULT;
			}
		}
		FS_GetFileHiddenInfo(tKNL_FsMediaInfo.MediaSel, A_SERIES_INFO, SingleFileInfo, SeriesFileInfo, FilePath);
	}
	else if(tKNL_FsMediaInfo.MediaType[tKNL_FsMediaInfo.MediaSel]==FS_MEDIA_TYPE_SF)
	{
		SeriesFileInfo.OutputFileInfo = &tKNL_SortFileInfo[0];
		SeriesFileInfo.OutputValidNum = &ulKNL_SortValidFileNum;
		SeriesFileInfo.FldName        = FldNameInfo;
		SeriesFileInfo.ulOffset       = 0;
		SeriesFileInfo.ulNum          = KNL_MAX_FILE_NUM;
		FS_GetFileInfo(tKNL_FsMediaInfo.MediaSel, A_SERIES_INFO, SingleFileInfo, SeriesFileInfo, FILE_PATH2);
	}
	ubFsTimeout = 200;
	while(1)
	{
		FsWaitStatus = FS_ChkGetFileInfoStatus(tKNL_FsMediaInfo.MediaSel);
		if(FsWaitStatus==FS_GET_INFO_FAIL)
		{
			printd(DBG_ErrorLvl, "KNL Get Sorting Files fail->Get File Info Err!\n");
			return 0;
		}
		else if(FsWaitStatus==FS_GET_INFO_OK)
		{
			break;
		}
		else
		{
			osDelay(50);
			if(!--ubFsTimeout)
			{
				printd(DBG_ErrorLvl, "KNL Get Sorting Files fail->Get File Info Timeout!\n");
				return 0;
			}
		}
	}
	
	if(tKNL_FsMediaInfo.MediaType[tKNL_FsMediaInfo.MediaSel]==FS_MEDIA_TYPE_SF)
	{
		memset(tKNL_SortFileHiddenInfo, 0, KNL_MAX_FILE_NUM*sizeof(FS_FILE_HIDDEN_INFO_t));
		for (i = 0; i < ulKNL_SortValidFileNum; i ++)
		{		
			memcpy(tKNL_SortFileHiddenInfo[i].FileName.chName, tKNL_SortFileInfo[i].FileName.chName, tKNL_SortFileInfo[i].FileName.ubLen);		
			tKNL_SortFileHiddenInfo[i].FileName.ubLen = tKNL_SortFileInfo[i].FileName.ubLen;
			
			memcpy(tKNL_SortFileHiddenInfo[i].FileName.chExt, tKNL_SortFileInfo[i].FileName.chExt, 3);
			
			memcpy(&tKNL_SortFileHiddenInfo[i].CreTime, &tKNL_SortFileInfo[i].CreTime, sizeof(tKNL_SortFileInfo[i].CreTime));
			
			tKNL_SortFileHiddenInfo[i].ulFirstClus = tKNL_SortFileInfo[i].ulFirstClus;
			
			tKNL_SortFileHiddenInfo[i].ullFileSize = tKNL_SortFileInfo[i].ullFileSize;
			
			tKNL_SortFileHiddenInfo[i].NoFatChainFlag = tKNL_SortFileInfo[i].NoFatChainFlag;
			
			tKNL_SortFileHiddenInfo[i].FilePath = tKNL_SortFileInfo[i].FilePath;
		}
	}

	pFilesDataAddr = (uint8_t *)pFilesInfo;
	memset(pFilesDataAddr, 0, KNL_MAX_FILE_NUM*sizeof(KNL_FILESINFO_t));
    
    if(SORT_BY_NAME_DESCENDING == tKNL_SortMode)
        KNL_SortFile(SORT_BY_NAME_ASCENDING, ulKNL_SortValidFileNum);
    else if(SORT_BY_NAME_DESCENDING_BY_TIME == tKNL_SortMode)
        KNL_SortFile(SORT_BY_NAME_ASCENDING_BY_TIME, ulKNL_SortValidFileNum);
    else
        KNL_SortFile(tKNL_SortMode, ulKNL_SortValidFileNum);

    if((tKNL_SortMode == SORT_BY_NAME_DESCENDING) || (tKNL_SortMode == SORT_BY_TIME_DESCENDING) || 
        (tKNL_SortMode == SORT_BY_FILE_SIZE_DESCENDING) || (tKNL_SortMode == SORT_BY_NAME_DESCENDING_BY_TIME))
    {
        for (i = 0; i < ulKNL_SortValidFileNum; i ++) 
        {            
            j = ulKNL_SortValidFileNum - i - 1;
			memcpy(&pFilesInfo[i].HidnFileInfo, &tKNL_SortFileHiddenInfo[uwKNL_SortResult[j]], sizeof(FS_FILE_HIDDEN_INFO_t));
        }
    }
    else
    {
        for (i = 0; i < ulKNL_SortValidFileNum; i++)
        {
			memcpy(&pFilesInfo[i].HidnFileInfo, &tKNL_SortFileHiddenInfo[uwKNL_SortResult[i]], sizeof(FS_FILE_HIDDEN_INFO_t));
        }
    }
    return (uint16_t)(ulKNL_SortValidFileNum&0xFFFF);
}
//-----------------------------------------------------------------------------
void KNL_ResetSortingResult(void)
{
	uwKNL_SortFolderIndex = 0xFFFF;
}
//-----------------------------------------------------------------------------
void KNL_EnPerDebugMode(uint8_t ubDbgEn, pvPerDbgRptCbFunc pSetupCbFunc)
{
	ubKNL_PerDbgEn = ubDbgEn;
	if(KNL_PERDBG_OFF == ubKNL_PerDbgEn)
		pKNL_PerDbgFunc[0] = NULL;
	else if(KNL_PERDBG_ON == ubKNL_PerDbgEn)
		pKNL_PerDbgFunc[0] = pSetupCbFunc;
	else if(KNL_LATYDBG_OFF == ubKNL_PerDbgEn)
		pKNL_PerDbgFunc[1] = NULL;
#if (defined(S2019A) && sPRF_LTYMEAS_EN)
	else if(KNL_LATYDBG_ON == ubKNL_PerDbgEn)
	{
		uint8_t ubStaNum;
		pKNL_PerDbgFunc[1] = pSetupCbFunc;
		for(ubStaNum = KNL_STA1; ubStaNum <= KNL_STA4; ubStaNum++)
		{
			tKNL_VdoLatency.tLatency[ubStaNum].ubDispFlag = TRUE;
			tKNL_VdoLatency.tLatency[ubStaNum].fMinLtcy   = 0;
		}
	}
#endif
}
//-----------------------------------------------------------------------------
uint8_t ubKNL_TransmitCRC8(uint32_t ulData_Addr, uint32_t ulData_Len)
{
	CRC_t tCRC2_Setup;
	uint32_t ulCRC_Cal;
	uint8_t ubTemp;
	
	osSemaphoreWait(tKNL_CrcAccSem, osWaitForever);	
	
	tCRC2_Setup.CRC_INIT_VALUE = INIT_ALL_ZERO;
	tCRC2_Setup.CRC_FINAL_XOR_VALUE = XOR_ALL_ZERO;
	tCRC2_Setup.CRC_ORDER = 7;

	ulCRC_Cal = (uint16_t)ulCRC_Calc(tCRC2_Setup,CRC_P_16,ulData_Addr,ulData_Len);
	
	ubTemp = ulCRC_Cal & 0xFF;
	
	osSemaphoreRelease(tKNL_CrcAccSem);
	
	return ubTemp;
}

#ifdef OP_STA
//-----------------------------------------------------------------------------
void KNL_SetHQImgCapEn(uint8_t ubEn)
{
	tKNL_CapHQImg.ubHQ_En = ubEn;
}
//-----------------------------------------------------------------------------
uint8_t ubKNL_GetHQImgCapEn(void)
{
	return tKNL_CapHQImg.ubHQ_En;
}
//-----------------------------------------------------------------------------
void KNL_SetHQImgSize(uint16_t uwH, uint16_t uwV)
{
	tKNL_CapHQImg.uwHQ_H  = uwH;
	tKNL_CapHQImg.uwHQ_V  = uwV;
}
//-----------------------------------------------------------------------------
uint8_t ubKNL_HQImgCapSetup(uint8_t ubSrcNum, uint8_t ubFin, uint8_t ubCapRet)
{
	uint16_t uwH_Size = 0, uwV_Size = 0;
	uint8_t ubIspAxiBusRate = 5;

	uwH_Size = (!ubFin)?tKNL_CapHQImg.uwHQ_H:uwKNL_GetVdoH(ubSrcNum);
	uwV_Size = (!ubFin)?tKNL_CapHQImg.uwHQ_V:uwKNL_GetVdoV(ubSrcNum);
	ubIspAxiBusRate = (!ubFin)?3:5;
	if((ubSrcNum == KNL_SRC_1_MAIN) || (ubSrcNum == KNL_SRC_2_MAIN) || (ubSrcNum == KNL_SRC_3_MAIN) || (ubSrcNum == KNL_SRC_4_MAIN))
	{
		SEN_SetIspOutEn(FALSE);
		SEN_SetScaleMode(((!ubFin)?SEN_SCALEUP_MODE:SEN_NORMAL_MODE));
		SEN_SetResChgState(SENSOR_PATH1, uwH_Size, uwV_Size);
	}
	else
		return FALSE;
	SEN_SetAXIRate(ubIspAxiBusRate);
	if(ubFin)
		KNL_SetHQImgCapEn(FALSE);
	BUF_ResetFreeAddr();
	KNL_BufInit();
	SEN_SetPathAddr(SENSOR_PATH1, ulBUF_GetSen1YuvFreeBuf());
	SEN_SetIspOutEn(TRUE);
	if(ubFin)
		osMessagePut(osKNL_CapHQImgQue, &ubCapRet, 0);
	return TRUE;
}
//-----------------------------------------------------------------------------
#endif

void KNL_UvcCapture(uint16_t uwH, uint16_t uwV)
{
    if( (uwKNL_GetVdoH(KNL_SRC_1_MAIN)==uwH)&&(uwKNL_GetVdoV(KNL_SRC_1_MAIN)==uwV) )
        KNL_doHighQualityImageCapture();
}

void KNL_doHighQualityImageCapture(void)
{
#if (defined(OP_AP) && (USBD_UVC_MJ_FMT == USBD_UVC_FMT) && USBD_ENABLE)
	if((DISPLAY_1T1R == DISPLAY_MODE) && ((USBD_UVC_MODE == tUSBD_GetClassMode()) || (TRUE == ubUSBD_ChkCompUvcClass())) &&
	   (KNL_CAPHQ_DIS == tKNL_CapHQImgSte))
		tKNL_CapHQImgSte = KNL_CAPHQ_EN;
#endif
#if (defined(OP_STA) && (USBD_UVC_MJ_FMT == USBD_UVC_FMT) && USBD_ENABLE)
	if((KNL_TUNINGMODE_OFF == KNL_GetTuningToolMode()) && ((USBD_UVC_MODE == tUSBD_GetClassMode()) || (TRUE == ubUSBD_ChkCompUvcClass())))
	{
		KNL_SRC tSrcNum;
		uint8_t ubCapRet;

		if(ptKNL_VdoRoleMap2SrcNum)
			tSrcNum = ptKNL_VdoRoleMap2SrcNum(KNL_MAIN_PATH, (KNL_ROLE)ubKNL_GetRole());
		else
			tSrcNum = (KNL_SRC)(KNL_SRC_1_MAIN + ubKNL_GetRole());
		KNL_VdoStop(tSrcNum);
		ubKNL_WaitNodeFinish(tSrcNum);
		KNL_ResetVdoProc();
	#ifdef A7130
		BB_ClearTxBuf(BB_TX_MASTER, BB_DATA_VIDEO);
	#endif
	#ifdef S2019A
		KNL_StopSPRFTxProcess(TRUE);
	#endif
		KNL_SetHQImgCapEn(TRUE);
		osMessageGet(osKNL_CapHQImgQue, &ubCapRet, osWaitForever);
		KNL_VdoStart(tSrcNum);
	}
#endif
}
//------------------------------------------------------------------------------
#ifdef RTC676x
void KNL_UpdateStaInfo(uint8_t ubWorkSta, uint8_t ubUpdSta)
{
	if((ubWorkSta > KNL_STA4) || (ubUpdSta > KNL_STA4))
		return;
	tKNL_StaMapTab[ubWorkSta].tKNL_Role   = (KNL_ROLE)ubUpdSta;
	tKNL_StaMapTab[ubWorkSta].tTWC_StaNum = (TWC_TAG)ubUpdSta;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_GetStaInfo(KNL_StaType_t tStaType, uint8_t ubSta)
{
	uint8_t ubMap = ubSta;
#ifdef OP_AP
	switch(tStaType)
	{
		case KNL_ROLENUM:
			if(ubSta > KNL_STA4)
				break;
			return tKNL_StaMapTab[ubSta].tKNL_Role;
		case KNL_TWCTAG:
			if(ubSta > TWC_STA4)
				break;
			return tKNL_StaMapTab[ubSta].tTWC_StaNum;
		default:
			ubMap = 0xFF;
			break;
	}
#endif
	return ubMap;
}
#endif

#if APP_REC_FUNC_ENABLE
uint32_t ulKNL_SortNexFile(KNL_FldType_t tSimFld,KNL_PLY_NextItem_t ubDirt, KNL_PlayAct_t *pPlayInfo, FS_FILE_HIDDEN_INFO_t *pPtr)
{
    uint32_t i,j,ulSortIdx;
    uint8_t ubFileNum=0;
    uint16_t uwGpIdx;
    FS_SRC_NUM SrcNum[4];
    FS_FILE_HIDDEN_INFO_t Cur_PlayBackFileInfo,Next_PlayBackFileInfo;
   
    ulSortIdx = pPlayInfo->ulCurFileIdx[0];
    memset(&SrcNum[0],0xFF,4);
    for( i = 0; i < pPlayInfo->ubCurFileInGPNum ; i++)
    {
        Cur_PlayBackFileInfo = KNL_GetFileHidInfo(tSimFld,uwKNL_GetSortResult(pPlayInfo->ulOrigFileIdx[i]));
        if(Cur_PlayBackFileInfo.uwGroupIdx == pPlayInfo->uwOrigGpIdx)
            SrcNum[i] = Cur_PlayBackFileInfo.SrcNum;
    }
    Cur_PlayBackFileInfo = KNL_GetFileHidInfo(tSimFld,uwKNL_GetSortResult(pPlayInfo->ulCurFileIdx[0]));
    
    if( ubDirt == KNL_PLY_NEXT )
    {
        for( i = ulSortIdx + 1; i < ulKNL_SortValidFileNum; i++)
        {
            Next_PlayBackFileInfo = KNL_GetFileHidInfo(tSimFld,uwKNL_GetSortResult(i));
            if(Next_PlayBackFileInfo.ubVer==0)
                return 0xFFFFFFF3;

            if(pPlayInfo->tPlayDispTye == KNL_DISP_SINGLE)
            {
                if( Cur_PlayBackFileInfo.SubHidnInfo.uwRes_HSize != Next_PlayBackFileInfo.SubHidnInfo.uwRes_HSize ||
                    Cur_PlayBackFileInfo.SubHidnInfo.uwRes_VSize != Next_PlayBackFileInfo.SubHidnInfo.uwRes_VSize )
                    continue;
                
                Next_PlayBackFileInfo.SrcNum = pPlayInfo->ubOrigSrcNum[0];    
                *pPtr = Next_PlayBackFileInfo;
                
                pPlayInfo->ubCurFileInGPNum = Next_PlayBackFileInfo.SubHidnInfo.ubActiveFileNum;
                pPlayInfo->uwCurGpIdx = Next_PlayBackFileInfo.uwGroupIdx;
                pPlayInfo->ulCurFileIdx[0] = i;
                return pPlayInfo->ulCurFileIdx[0];
            }
            else
            {
                if(Next_PlayBackFileInfo.SubHidnInfo.ubDispMode != pPlayInfo->tPlayDispTye)
                    continue;
                
                if((Next_PlayBackFileInfo.uwGroupIdx != pPlayInfo->uwCurGpIdx) && Next_PlayBackFileInfo.ubVer!=0)    
                {
                    uwGpIdx = Next_PlayBackFileInfo.uwGroupIdx;
                    ulSortIdx = i;
                    for( j = ulSortIdx ; j < (ulSortIdx + pPlayInfo->ubCurFileInGPNum); j++)
                    {
                        Next_PlayBackFileInfo = KNL_GetFileHidInfo(tSimFld,uwKNL_GetSortResult(j));

                        if(Next_PlayBackFileInfo.uwGroupIdx != uwGpIdx) 
                            continue;
                        *(pPtr+ubFileNum) = Next_PlayBackFileInfo;
                        pPlayInfo->ulCurFileIdx[ubFileNum] = j;
                        pPlayInfo->uwCurGpIdx = Next_PlayBackFileInfo.uwGroupIdx;
                        pPlayInfo->ubCurFileInGPNum = Next_PlayBackFileInfo.SubHidnInfo.ubActiveFileNum;
                        ubFileNum++;
                    }
                    pPlayInfo->ubCurFileNum = (ubFileNum < pPlayInfo->ubOrigFileNum)? ubFileNum:pPlayInfo->ubOrigFileNum;
                    return pPlayInfo->ulCurFileIdx[0];
                }
                else if(Cur_PlayBackFileInfo.uwGroupIdx != Next_PlayBackFileInfo.uwGroupIdx && Next_PlayBackFileInfo.ubVer==0)    
                    return 0xFFFFFFF6;
            }
        }
        return 0xFFFFFFFF;
    }
    else if( ubDirt == KNL_PLY_PREV )
    {
        for( i = ulSortIdx; i > 0;)
        {
            i--;
            Next_PlayBackFileInfo = KNL_GetFileHidInfo(tSimFld,uwKNL_GetSortResult(i));
            if(pPlayInfo->tPlayDispTye == KNL_DISP_SINGLE)
            {
                if( Cur_PlayBackFileInfo.SubHidnInfo.uwRes_HSize != Next_PlayBackFileInfo.SubHidnInfo.uwRes_HSize ||
                    Cur_PlayBackFileInfo.SubHidnInfo.uwRes_VSize != Next_PlayBackFileInfo.SubHidnInfo.uwRes_VSize )
                    continue;

                Next_PlayBackFileInfo.SrcNum = pPlayInfo->ubOrigSrcNum[0];
                *pPtr = Next_PlayBackFileInfo;
                pPlayInfo->ubCurFileInGPNum = Next_PlayBackFileInfo.SubHidnInfo.ubActiveFileNum;
                pPlayInfo->uwCurGpIdx = Next_PlayBackFileInfo.uwGroupIdx;
                pPlayInfo->ulCurFileIdx[0] = i;
                return pPlayInfo->ulCurFileIdx[0];
            }
            else
            {
                if(Next_PlayBackFileInfo.SubHidnInfo.ubDispMode != pPlayInfo->tPlayDispTye)
                    continue;
                
                if((Next_PlayBackFileInfo.uwGroupIdx != pPlayInfo->uwCurGpIdx) && Next_PlayBackFileInfo.ubVer!=0)
                {
                    uwGpIdx = Next_PlayBackFileInfo.uwGroupIdx;
                    ulSortIdx = i;
                    for( j = 0 ; j<pPlayInfo->ubCurFileInGPNum ; j++)
                    {
                        Next_PlayBackFileInfo = KNL_GetFileHidInfo(tSimFld,uwKNL_GetSortResult(ulSortIdx-j));
                        
                        if(Next_PlayBackFileInfo.uwGroupIdx != uwGpIdx)
                            continue;

                        *(pPtr+ubFileNum) = Next_PlayBackFileInfo;
                        pPlayInfo->ulCurFileIdx[ubFileNum] = (ulSortIdx-j);
                        pPlayInfo->uwCurGpIdx = Next_PlayBackFileInfo.uwGroupIdx;
                        pPlayInfo->ubCurFileInGPNum = Next_PlayBackFileInfo.SubHidnInfo.ubActiveFileNum;
                        ubFileNum++;
                    }
                    pPlayInfo->ubCurFileNum = (ubFileNum < pPlayInfo->ubOrigFileNum)? ubFileNum:pPlayInfo->ubOrigFileNum;
                    return pPlayInfo->ulCurFileIdx[0];
                }
                else if(Cur_PlayBackFileInfo.uwGroupIdx != Next_PlayBackFileInfo.uwGroupIdx && Next_PlayBackFileInfo.ubVer==0)    
                    return 0xFFFFFFF6;
            }
        }
        return 0xFFFFFFFF;            
    }
    else
        return 0xFFFFFFFF;
}

uint32_t ulKNL_PlayNextFile(KNL_PLY_NextItem_t ubDirt)
{
    FS_FILE_HIDDEN_INFO_t PlayBackFileInfoTest[4];
    uint32_t ulFileIdx;
    // File Sorting to Next File
    ulFileIdx = ulKNL_SortNexFile(KNL_REAL_FLD,ubDirt,&KNL_PlayInfo,&PlayBackFileInfoTest[0]);
    if(ulFileIdx >= 0xFFFFFFF0)  
    {
        printf("PlayNextFile Over\n");
        return ulFileIdx;
    }
	printf("PlayNextFile %d\n",ulFileIdx);
    // Play Next File
    ubPLY_Pause(PLY_PAUSE_ON);
    ubPLY_Start(PLY_MODE_NORMAL,KNL_PlayInfo.ubCurFileInGPNum ,KNL_PlayInfo.ubCurFileNum,&PlayBackFileInfoTest[0]);
    return ulFileIdx;    
}
#endif

#if APP_REC_FUNC_ENABLE
//------------------------------------------------------------------------------
static void KNL_StorageRecFilesProc(void const *argument)
{
    KNL_StrgRecInfo_t tKNL_RecFilsInfo;

	while(1)
	{
		osMessageGet(osKNL_StrgRecQue, &tKNL_RecFilsInfo, osWaitForever);
		if(!ubREC_SendVDOQueue(&tKNL_RecFilsInfo.tRecInfo))
			printd(DBG_ErrorLvl, "SendVDOQueue Fail: %s: %d\n\r", __FILE__, __LINE__);
		if(TRUE == tKNL_RecFilsInfo.ubRelease)
			ubKNL_ReleaseBsBufAddr(tKNL_RecFilsInfo.ubNode, tKNL_RecFilsInfo.ubSrcNum, tKNL_RecFilsInfo.tRecInfo.ulDramAddr);
	}
}
#endif

#if (APP_REC_FUNC_ENABLE && OP_STA)
uint8_t ubKNL_TXRecMode = KNL_TXREC_CHECKSD;    // 0=KNL_TXREC_IDLE,1=RECStop,2=RECLoop,3=REC Once,4=RECPhoto,
                                                // 5=SDFormat,6=WaitFormat,7=WaitRecStop,8=KNL_TXREC_CHECKSD.
uint8_t ubKNL_TXRecResumeBusy = 0;
uint8_t ubKNL_TXRecResumeBusyMode = KNL_TXREC_BUSY_NONE;
uint8_t ubKNL_TXRecInitFlag=0;
uint32_t ulKNL_TXRecCnt=TXREC_TIMEOUT_MS(0);
uint8_t ubKNL_TXRecPreSt=0;
uint8_t ubKNL_TXRecPreLk=0;
uint32_t ulKNL_TXRecLEDFlashCnt=TXREC_TIMEOUT_MS(0);
void KNL_TXRecordProcess(void)
{
    if(ubKNL_TXRecMode == KNL_TXREC_STOP)        // Record Stop
    { 
        if(KNL_RECORDING_START == tKNL_RecordAct.tRecordSts)
        {
            KNL_Status_t tVdoRecStopRet;
            tVdoRecStopRet = KNL_VideoRecStop(tKNL_GetRecordFunc(),0);
            if(tKNL_RecordAct.pRecordStsNtyCb)
                tKNL_RecordAct.pRecordStsNtyCb(tVdoRecStopRet);
        }
        ubKNL_TXRecMode = KNL_TXREC_WAITRECSTOP;
    }
    else if(ubKNL_TXRecMode == KNL_TXREC_WAITRECSTOP)   // Record continuous
    {
        if(ubREC_StateGet(0) == REC_CREATE_NULL && ubREC_StateGet(1) == REC_CREATE_NULL && 
            ubREC_StateGet(2) == REC_CREATE_NULL && ubREC_StateGet(3) == REC_CREATE_NULL)
            ubKNL_TXRecMode = KNL_TXREC_IDLE;
    }
    else if((ubKNL_TXRecMode == KNL_TXREC_LOOP)||(ubKNL_TXRecMode == KNL_TXREC_ONCE))   // Record continuous
    {
#if APP_PC_CONNECT_EN
        if(ubKNL_TXRecInitFlag == 0 && ubKNL_TXRecResumeBusy == 0 && (tKNL_ChkSdCardSts() == KNL_OK) && (ubKNL_GetPcConnEnterStatus() == 0))
#else   
        if(ubKNL_TXRecInitFlag == 0 && ubKNL_TXRecResumeBusy == 0 && (tKNL_ChkSdCardSts() == KNL_OK))
#endif
        {    
            KNL_RecordAct_t tKNL_TxRecChkAct;
            if(ubKNL_TXRecMode == KNL_TXREC_LOOP)
                tKNL_TxRecChkAct.tRecordFunc     = KNL_RECORDFUNC_LOOP;
            else if(ubKNL_TXRecMode == KNL_TXREC_ONCE)
                tKNL_TxRecChkAct.tRecordFunc     = KNL_RECORDFUNC_MANU;
            tKNL_TxRecChkAct.ubRecOnceStopCBFlag = 0;
            tKNL_TxRecChkAct.pRecordStsNtyCb = NULL;
            KNL_VideoRecFunc(&tKNL_TxRecChkAct);
            ubKNL_TXRecInitFlag = 1;
        }
    }
    else if(ubKNL_TXRecMode == KNL_TXREC_PHOTO)   // Photo Capture
    {
        if(KNL_RECORDING_START == tKNL_RecordAct.tRecordSts)
        {
            KNL_Status_t tVdoRecStopRet;
            tVdoRecStopRet = KNL_VideoRecStop(tKNL_GetRecordFunc(),0);
            if(tKNL_RecordAct.pRecordStsNtyCb)
                tKNL_RecordAct.pRecordStsNtyCb(tVdoRecStopRet);
            KNL_SetRecordFunc(KNL_RECORDFUNC_DISABLE);
        }
        ubKNL_TXRecMode = KNL_TXREC_WAITPHOTO;
    }
    else if(ubKNL_TXRecMode == KNL_TXREC_WAITPHOTO)   // Wait Photo Stop
    {
        if(ubREC_StateGet(0) == REC_CREATE_NULL && ubREC_StateGet(1) == REC_CREATE_NULL && 
            ubREC_StateGet(2) == REC_CREATE_NULL && ubREC_StateGet(3) == REC_CREATE_NULL)
        {
        #if (defined(BSP_RVCS_SDK)&&APP_PHOTOGRAPH_FUNC_ENABLE)
            KNL_CamPhotoCaptureFunc();
        #else
        		printd(DBG_CriticalLvl, "KNL TX Record Process->Photo capture func disable\n");
        #endif
        	ubKNL_TXRecMode = KNL_TXREC_WAITPHOTOFINISH;
        	ulKNL_TXRecCnt = TXREC_TIMEOUT_MS(0);
        }    
    }
    else if(ubKNL_TXRecMode == KNL_TXREC_WAITPHOTOFINISH)   // Wait Photo Stop
    {
        ulKNL_TXRecCnt++;
        if(ulKNL_TXRecCnt >= TXREC_TIMEOUT_MS(10))
        {
            ubKNL_TXRecMode = KNL_TXREC_LOOP;
            ubKNL_TXRecInitFlag = 0;
        }
    }
    else if(ubKNL_TXRecMode == KNL_TXREC_SDFORMAT)   // SD Format
    {     
        ulKNL_TXRecCnt++;
        if(ulKNL_TXRecCnt >= TXREC_TIMEOUT_MS(500)) 
        {
            printd(DBG_CriticalLvl, "SD Card Format %d !\n",ulKNL_TXRecCnt);
            if(KNL_RECORDING_START == tKNL_RecordAct.tRecordSts)
            {
                KNL_Status_t tVdoRecStopRet;
                tVdoRecStopRet = KNL_VideoRecStop(tKNL_GetRecordFunc(),0);
                if(tKNL_RecordAct.pRecordStsNtyCb)
                    tKNL_RecordAct.pRecordStsNtyCb(tVdoRecStopRet);
                ubKNL_TXRecMode = KNL_TXREC_WAITRECSTOPFMT;
                ulKNL_TXRecCnt = TXREC_TIMEOUT_MS(0);
            }
            else
            {
                FS_MediaFormat(tKNL_FsMediaInfo.MediaSel);
                ubKNL_TXRecMode = KNL_TXREC_WAITFORMAT;
                ulKNL_TXRecCnt = TXREC_TIMEOUT_MS(0);
            }
        }
    }
    else if(ubKNL_TXRecMode == KNL_TXREC_WAITFORMAT)   // wait format ready
    {
        if((ulKNL_TXRecCnt%TXREC_TIMEOUT_MS(500)) == 0)   
            printd(DBG_CriticalLvl, "Wait Format Ready %d !\n",ulKNL_TXRecCnt);

        ulKNL_TXRecCnt++;
        if(ulKNL_TXRecCnt >= TXREC_TIMEOUT_MS(500))
        {
            ubKNL_TXRecMode = KNL_TXREC_LOOP;
            ubKNL_TXRecInitFlag = 0;
        }
    }
    else if(ubKNL_TXRecMode == KNL_TXREC_WAITRECSTOPFMT)   // wait rec stop ready
    {
        if((ulKNL_TXRecCnt%TXREC_TIMEOUT_MS(500)) == 0)   
            printd(DBG_CriticalLvl, "Wait Rec Stop Ready %d !\n",ulKNL_TXRecCnt);

        ulKNL_TXRecCnt++;
        if(ulKNL_TXRecCnt>=TXREC_TIMEOUT_MS(2500) ||(ubPLY_GetOpMode() == PLY_MODE_N) || (ubPLY_GetOpMode() == PLY_MODE_P))
        {
            FS_MediaFormat(tKNL_FsMediaInfo.MediaSel);
             ubKNL_TXRecMode = KNL_TXREC_WAITFORMAT;
             ulKNL_TXRecCnt = TXREC_TIMEOUT_MS(0);
        }
    }
    else if(ubKNL_TXRecMode == KNL_TXREC_CHECKSD)
    {
        ulKNL_TXRecCnt++;
        if(tKNL_ChkSdCardSts() == KNL_OK)
        {
            if((ulKNL_TXRecCnt % TXREC_TIMEOUT_MS(1200)) == 0)  
            {
                ubKNL_TXRecMode = KNL_TXREC_LOOP;
                ulKNL_TXRecCnt = TXREC_TIMEOUT_MS(0);
            }
        }
        else
        {
            if((ulKNL_TXRecCnt % TXREC_TIMEOUT_MS(1000)) == 0)  
                printd(DBG_CriticalLvl, "Check SD Card Status\n");
        }
        
#if defined(BSP_DVR_SDK)
        if(ulKNL_TXRecCnt < TXREC_TIMEOUT_MS(300))
            pRecStsRpt(0);
#endif
        ubKNL_TXRecPreSt=0;
    }
    
    if(ubKNL_TXRecPreLk != ubKNL_GetCommLinkStatus(KNL_MASTER_AP))
    {
#if defined(BSP_DVR_SDK)
        if(ubKNL_TXRecPreLk == BB_LOST_LINK)
            pRecStsRpt(ubKNL_TXRecPreSt);
#endif
        ubKNL_TXRecPreLk = (ubKNL_TXRecPreLk == BB_LOST_LINK)? BB_LINK:BB_LOST_LINK;
    }

    if((ubPLY_GetOpMode() == PLY_MODE_R)||(ubPLY_GetOpMode() == PLY_MODE_PR))
    {
#if defined(BSP_DVR_SDK)
        if(ubKNL_TXRecPreSt == 0)
            pRecStsRpt(1);
#endif
        ubKNL_TXRecPreSt=1;
    }
    else
    {
#if defined(BSP_DVR_SDK)
        if(ubKNL_TXRecPreSt == 1)
            pRecStsRpt(0);
#endif
        ubKNL_TXRecPreSt=0;
    }

    if((++ulKNL_TXRecLEDFlashCnt%TXREC_TIMEOUT_MS(500)) == 0)
    {
        if( ubKNL_TXRecMode == KNL_TXREC_SDFORMAT || ubKNL_TXRecMode == KNL_TXREC_WAITFORMAT || 
            ubKNL_TXRecMode == KNL_TXREC_WAITRECSTOPFMT || ubKNL_TXRecMode == KNL_TXREC_CHECKSD ||
            FS_ChkMediaExist(tKNL_FsMediaInfo.MediaSel) == FS_MEDIA_OUT)
            POWER_LED_IO = ~POWER_LED_IO;
        else
            POWER_LED_IO = 1;
    }
}
uint8_t ubKNL_GetTXRecMode(void)
{
    return ubKNL_TXRecMode;
}
void KNL_TXRecordFormat(void)
{
    ubKNL_TXRecMode = KNL_TXREC_SDFORMAT;
    ulKNL_TXRecCnt = TXREC_TIMEOUT_MS(0);
}
void KNL_TXRecordStop(void)
{
    ubKNL_TXRecMode = KNL_TXREC_STOP;
    ulKNL_TXRecCnt = TXREC_TIMEOUT_MS(0); 
}
void KNL_TXRecordPhoto(void)
{
    if(tKNL_ChkSdCardSts() == KNL_OK)
    {
        ubKNL_TXRecMode = KNL_TXREC_PHOTO;
        ulKNL_TXRecCnt = TXREC_TIMEOUT_MS(0); 
    }
}
void KNL_TXRecordResume(uint8_t ubMode,uint8_t ubBusy)
{
#if APP_PC_CONNECT_EN
    if(tKNL_RecordAct.tRecordSts == KNL_RECORDING_START || ubKNL_GetPcConnEnterStatus() == 1 )
#else
	if(tKNL_RecordAct.tRecordSts == KNL_RECORDING_START)
#endif	
        return;    
    ubKNL_TXRecResumeBusyMode = ubMode;
    ubKNL_TXRecResumeBusy = ubBusy;
    ubKNL_TXRecMode = KNL_TXREC_LOOP;
    ubKNL_TXRecInitFlag = 0;
    ulKNL_TXRecCnt = TXREC_TIMEOUT_MS(0);   
}
void KNL_TXRecordResumeBusyClr(void)
{
    ubKNL_TXRecResumeBusyMode = KNL_TXREC_BUSY_NONE;
    ubKNL_TXRecResumeBusy = 0;
}
uint8_t KNL_TXRecordResumeBusyMode(void)
{
    return ubKNL_TXRecResumeBusyMode;
}
void KNL_TXRecordReady(void)
{
    ubKNL_TXRecInitFlag = 1;
}
#endif

#if (defined(BSP_SN93711_FHD_REC_RX_V4)||defined(BSP_D_SN93701_SSD2828_RX_V5) || defined(BSP_D_SN93701_TC358778_RX_V6)|| defined(BSP_D_SN93703_TC358778_RX_V6))
#ifdef VBM_PU
#include "UI_VBMPU.h"
#else
#include "UI_BUCCU[HD].h"
#endif
uint8_t ubKNL_AutoGenPhotoThreadInitFlag = 0;
uint8_t ubKNL_AutoGenPhotoFlag = 0;
uint32_t ulKNL_AutoGenPhotoProcessingFlag = 0;
uint32_t ulKNL_AutoGenPhotoNum = 0;
void KNL_AutoGenPhotoProcessThread(void const *argument)
{
	uint32_t ulPhotoSize = 0x80000;
	uint32_t i;
	while(1)
	{
		if(ubKNL_AutoGenPhotoFlag)
		{
			ubKNL_AutoGenPhotoFlag = 0;
			ulKNL_AutoGenPhotoProcessingFlag = 1;
			for(i=0; i<ulKNL_AutoGenPhotoNum; i++)
			{
				if( ulFS_GetFreeSpace(KNL_GetFsMedia())*1024*1024 < ulPhotoSize )
				{
					printf("KNL auto gen photo fail->no enough free size\n");
					break;
				}
				UI_DisplayArrowKeyFunc(ENTER_ARROW);
				osDelay(3000);
			}
		}
		ulKNL_AutoGenPhotoProcessingFlag = 0;
		osDelay(50);
	}
}
void KNL_AutoGenPhoto(uint32_t ulCapNum)
{
	if(ulKNL_AutoGenPhotoProcessingFlag==1)
		return;
	
	if(ubKNL_AutoGenPhotoThreadInitFlag==0)
	{
		osThreadDef(KnlAutoGenPhotoProcessThread, KNL_AutoGenPhotoProcessThread, osPriorityNormal, 1, 1024);
		if( osThreadCreate(osThread(KnlAutoGenPhotoProcessThread), NULL)==NULL )
		{
			printd(DBG_ErrorLvl, "KNL AutoGenPhoto->Create auto gen photo thread fail\n");
			return;
		}
		ubKNL_AutoGenPhotoThreadInitFlag = 1;
	}
	
	ubKNL_AutoGenPhotoFlag = 1;
	ulKNL_AutoGenPhotoNum = ulCapNum;
}

uint8_t ubKNL_CopyFileThreadInitFlag = 0;
uint8_t ubKNL_CopyFileFlag = 0;
uint32_t ulKNL_CopyFileProcessingFlag = 0;
uint32_t ulKNL_CopyFileNum = 0;
FS_FILE_INFO_t tKNL_CopyFileInfo[KNL_MAX_FILE_NUM];
void KNL_CopyFileProcessThread(void const *argument)
{
	uint32_t ulTempBufAddr = 0x3F00000;
	
	FS_MEDIA_SEL Src_MediaSel = FS_MEDIA_1;
	FS_SRC_NUM Src_SrcNum = FS_JPG_SRC_0;
	uint32_t ulSrcOpenFileSz;
	
	FS_MEDIA_SEL Dst_MediaSel = FS_MEDIA_0;
	FS_KNL_CRE_PROCESS_t KnlCreProc;
	FS_SRC_NUM Dst_SrcNum = FS_JPG_SRC_0;
	FS_FILE_SUB_HIDN_INFO_t tJpgHidInfo;
	
	uint32_t ulFileNum;
	uint32_t i;
	FS_FLD_NAME_INFO_t FldNameInfo;
	FS_GET_A_SINGLE_FILE_INTO_t SingleFileInfo;
	FS_GET_A_SERIES_FILE_INTO_t SeriesFileInfo;
	FS_Q_STATUS FsWaitStatus;
	uint8_t ubFsTimeout;
	while(1)
	{
		#if 1
		if(ubKNL_CopyFileFlag)
		{
			ubKNL_CopyFileFlag = 0;
			ulKNL_CopyFileProcessingFlag = 1;
			
			//get file list
			if(tKNL_FsMediaInfo.MediaType[Src_MediaSel]==FS_MEDIA_TYPE_SF)
			{
				memset(tKNL_CopyFileInfo, 0, sizeof(tKNL_CopyFileInfo));
				memset(&FldNameInfo, 0x0, sizeof(FldNameInfo));
				
				SeriesFileInfo.OutputFileInfo = &tKNL_CopyFileInfo[0];
				SeriesFileInfo.OutputValidNum = &ulFileNum;
				SeriesFileInfo.FldName        = FldNameInfo;
				SeriesFileInfo.ulOffset       = 0;
				SeriesFileInfo.ulNum          = ulKNL_CopyFileNum;
				FS_GetFileInfo(Src_MediaSel, A_SERIES_INFO, SingleFileInfo, SeriesFileInfo, FILE_PATH2);
				ubFsTimeout = 100;
				while(1)
				{
					FsWaitStatus = FS_ChkGetFileInfoStatus(Src_MediaSel);
					if(FsWaitStatus==FS_GET_INFO_FAIL)
					{
						printd(DBG_ErrorLvl, "KNL copy file fail->Get File Info Err!\n");
						break;
					}
					else if(FsWaitStatus==FS_GET_INFO_OK)
					{
						break;
					}
					else
					{
						osDelay(100);
						if(!--ubFsTimeout)
						{
							printd(DBG_ErrorLvl, "KNL copy file fail->Get File Info Timeout!\n");
							break;
						}
					}
				}
				
				if(FsWaitStatus==FS_GET_INFO_OK)
				{
					//copy file
					for(i=0; i<ulFileNum; i++)
					{
						//-------------------------
						//Source-> Meida 1 -> SF
						//-------------------------
						ulSrcOpenFileSz = tKNL_CopyFileInfo[i].ullFileSize;
						printf("Src->get file[%s.%s] size=0x%X(%d)\n",tKNL_CopyFileInfo[i].FileName.chName, tKNL_CopyFileInfo[i].FileName.chExt, ulSrcOpenFileSz,ulSrcOpenFileSz);
						
						FS_ReadFile(Src_MediaSel, ulTempBufAddr, Src_SrcNum, tKNL_CopyFileInfo[i].ulFirstClus, tKNL_CopyFileInfo[i].NoFatChainFlag, 0, ulSrcOpenFileSz);
						while(FS_ChkReadStatus(Src_MediaSel, Src_SrcNum) != FS_PLY_READ_OK)
						{
							osDelay(20);
						}
						printf("Src->read file[%s.%s] ok\n",tKNL_CopyFileInfo[i].FileName.chName, tKNL_CopyFileInfo[i].FileName.chExt);
						
						//-----------------------------
						//Destination-> Meida 0 -> SD
						//-----------------------------				
						if( ulFS_GetFreeSpace(Dst_MediaSel)*1024*1024 < ulSrcOpenFileSz )
						{
							printf("KNL copy file fail->no enough free size\n");
							break;
						}
						memset(&KnlCreProc, 0, sizeof(KnlCreProc));
						KnlCreProc.MediaSel = Dst_MediaSel;
						KnlCreProc.SrcNum   = Dst_SrcNum;
						KnlCreProc.ubRecGroupFileNum = 1;
						KnlCreProc.FileName.ubLen = tKNL_CopyFileInfo[i].FileName.ubLen;
						memcpy(KnlCreProc.FileName.chName, tKNL_CopyFileInfo[i].FileName.chName, tKNL_CopyFileInfo[i].FileName.ubLen);
						memcpy(KnlCreProc.FileName.chExt, tKNL_CopyFileInfo[i].FileName.chExt, 3);
						KnlCreProc.FileAttr = FILE_ATTR_ARCHIVE;
						KnlCreProc.FilePath = FILE_PATH_DEFAULT;
						FS_CreateFile(&KnlCreProc);
						while(FS_ChkCreateStatus(Dst_MediaSel, Dst_SrcNum) != FS_REC_CREATE_OK)
						{
							osDelay(20);
						}
						
						FS_WriteFile(Dst_MediaSel, Dst_SrcNum, ulTempBufAddr, ulSrcOpenFileSz, NULL);
						
						tJpgHidInfo.ubEvent = 0;
						tJpgHidInfo.ubSrcLocate[0] = Dst_SrcNum;
						tJpgHidInfo.ubSrcLocate[1] = 0;
						tJpgHidInfo.ubSrcLocate[2] = 0;
						tJpgHidInfo.ubSrcLocate[3] = 0;	
						FS_CloseFile(Dst_MediaSel, Dst_SrcNum, &tJpgHidInfo);
						while(FS_ChkCloseStatus(tKNL_FsMediaInfo.MediaSel, FS_JPG_SRC_0) != FS_REC_CLOSED_OK)
						{
							osDelay(20);
						}
						printf("Dst->create file[%s.%s] ok\n",tKNL_CopyFileInfo[i].FileName.chName, tKNL_CopyFileInfo[i].FileName.chExt);
					}
					printf("KNL copy file->get [%d] files\n",ulFileNum);
				}
			}
			else
			{
				printf("KNL copy file fail->source media fail\n");
				break;
			}
		}
		#else
		if(ubKNL_CopyFileFlag)
		{
			ubKNL_CopyFileFlag = 0;
			ulKNL_CopyFileProcessingFlag = 1;
			FS_MediaFormat(FS_MEDIA_1);
		}
		#endif
		ulKNL_CopyFileProcessingFlag = 0;
		osDelay(50);
	}
}
void KNL_CopyFile(uint32_t ulCopyNum)
{
	if(ulKNL_CopyFileProcessingFlag==1)
		return;
	
	if(ubKNL_CopyFileThreadInitFlag==0)
	{
		osThreadDef(KnlCopyFileProcessThread, KNL_CopyFileProcessThread, osPriorityNormal, 1, 4096);
		if( osThreadCreate(osThread(KnlCopyFileProcessThread), NULL)==NULL )
		{
			printd(DBG_ErrorLvl, "KNL CopyFile->Create copy file thread fail\n");
			return;
		}
		ubKNL_CopyFileThreadInitFlag = 1;
	}
	
	ubKNL_CopyFileFlag = 1;
	ulKNL_CopyFileNum = ulCopyNum;
}
#endif

#if defined (OP_STA) && APP_REC_FUNC_ENABLE && defined(RVCS_APP)
void KNL_StartDownloadFile(uint16_t uwRecFileIdx)
{
	printd(DBG_CriticalLvl, "=======>> %s, fIdx:%d\n", __FUNCTION__, uwRecFileIdx);

	if (tKNL_GetRecordFunc() == KNL_VIDEO_DOWNLOAD) {
		printd(DBG_ErrorLvl, "Already in VIDEO_DOWNLOAD mode, %s, fIdx:%d\n", __FUNCTION__, uwRecFileIdx);
		return;
	}

	osMessagePut(KNL_QueDwnldMode, &uwRecFileIdx, 0);
}

void KNL_DownloadFile(KNL_FldType_t tSimFld,uint16_t uwRecFileIndex)
{
    uint32_t ulDestAddr = NULL, ulDestAddrRec, ulDestAddrTemp;
	uint32_t ulFileSize = 0;
    uint8_t ubReadOver = 0;

	FS_FILE_HIDDEN_INFO_t PlayBackFileInfo;

	uint32_t ulFsTotalReadCnt, ulFsRemainReadCnt, ulFsReadCnt = 4;
	uint32_t ulFsReadoutSize 	 =  READ_PLYBK_FILE_SZ_ONE_TIME;	// 128KB
    uint32_t ulFsReadoutOffset = 0x00;

    uint32_t ulFsTtlReadoutSize = 0;
	uint32_t ulFsBlockReadSize = 0;
	uint32_t ulBlockCnt = 0;
	div_t var;
	uint8_t ubPingPongBufIdx = 0;
	uint8_t i;

	PlayBackFileInfo = KNL_GetFileHidInfo(KNL_REAL_FLD,uwKNL_GetSortResult(uwRecFileIndex));

	if (PlayBackFileInfo.ullFileSize == 0)	
	{
		printd(DBG_ErrorLvl, "Error: DownloadFile File Size: 0\n");
		return;
	}
	else {
		ulFileSize = PlayBackFileInfo.ullFileSize;
	}

	var = div((int32_t)ulFileSize, (int32_t)ulFsReadoutSize);
	if ((var.rem))
		var.quot++;
	ulFsTotalReadCnt = (int32_t)var.quot;

	var = div((int32_t)ulFsTotalReadCnt, (int32_t)ulFsReadCnt);
	if ((var.rem))
		var.quot++;
	ulBlockCnt = (int32_t)var.quot;

	printd(DBG_CriticalLvl, "\n\r=======>>>>> DownloadFile, fIdx:%d, fsz:%llu, blckCnt:%d\n\n", 
		uwRecFileIndex, PlayBackFileInfo.ullFileSize, ulBlockCnt);


	ulFsRemainReadCnt = ulFsTotalReadCnt;
	printd(DBG_Debug3Lvl, "ulTotalReadCnt %ld\n", ulFsTotalReadCnt);

	ulDestAddr = ulBUF_GetBlkBufAddr(0,BUF_REC);
	ulDestAddrRec = ulDestAddr;

	if (ulDestAddr == NULL)
	{
		printd(DBG_ErrorLvl, "ulDestAddr fails\n");
		return;
	}
	else
		printd(DBG_Debug3Lvl, "ulDestAddr 0x%x\n", ulDestAddr);
	
	ulFsTtlReadoutSize = 0;
	ulBlockCnt = 0;
    while (ubReadOver == 0)
    {
		ulDestAddr = ulDestAddrRec;

		if (ulFsRemainReadCnt > 4) {
			ulFsReadCnt = 4;
			ulFsRemainReadCnt -= 4;
		}
		else {
			ulFsReadCnt = ulFsRemainReadCnt;
			ulFsRemainReadCnt = 0;
		}

		if (ubPingPongBufIdx == 0)
			ulDestAddr = ulDestAddrRec;
		else
			ulDestAddr = ulDestAddrRec + READ_PLYBK_FILE_SZ_ONE_TIME;

		printd(DBG_Debug3Lvl, "fs read ppIdx: %d\n", ubPingPongBufIdx);
		
		ubPingPongBufIdx = (ubPingPongBufIdx +1) % 2;

		ulFsBlockReadSize = 0;		
		ulBlockCnt = (ulBlockCnt)%15+1;	// 1~15
		ulDestAddrTemp = ulDestAddr;
		for (i=0; i<ulFsReadCnt; i++) // 128KB * 4 = 512KB
		{
			WDT_TimerClr(WDT_RST);

	        FS_ReadFile(FS_MEDIA_0, (uint32_t)ulDestAddrTemp,PlayBackFileInfo.SrcNum, PlayBackFileInfo.ulFirstClus, 
				PlayBackFileInfo.NoFatChainFlag, ulFsReadoutOffset, ulFsReadoutSize);
	
			while(FS_ChkReadStatus(FS_MEDIA_0, PlayBackFileInfo.SrcNum) != FS_PLY_READ_OK)
	        {
	            osDelay(10);
	        }

			ulDestAddrTemp += ulFsReadoutSize;
			ulFsTtlReadoutSize += ulFsReadoutSize;
			ulFsBlockReadSize += ulFsReadoutSize;
			ulFsReadoutOffset += ulFsReadoutSize;

			if (ulFsTtlReadoutSize >= PlayBackFileInfo.ullFileSize)
			{
				printd(DBG_CriticalLvl, "read over in while: %d/%llu\n", ulFsTtlReadoutSize, PlayBackFileInfo.ullFileSize);
				break;
			}

			if (PlayBackFileInfo.ullFileSize - ulFsTtlReadoutSize < READ_PLYBK_FILE_SZ_ONE_TIME)
			{
				ulFsReadoutSize = PlayBackFileInfo.ullFileSize - ulFsTtlReadoutSize;
			}
		}

		while (WiFiDt_ChkVdo_TxTrnsmt())
		{
			printd(DBG_Debug3Lvl, "Q:%d\n", uwWiFiDt_GetTxVdoQues(0));
			osDelay(10);
		}

		// First block & set block index 0
		if (ulBlockCnt == 1 && ulFsTtlReadoutSize == ulFsReadCnt*ulFsReadoutSize)
		{
			printd(DBG_Debug3Lvl, "Frst insrt\n");
			ulKNL_SetWiFiDtBufAddr_DwnldMode((uint32_t)ulDestAddr, ulFsBlockReadSize, PLYBK_DWNLD_MODE_EVENT+0, PlayBackFileInfo.ullFileSize);
			printd(DBG_Debug3Lvl, "MP4 Hdr tag: 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n", 
				*(uint8_t *)(ulDestAddr+3), *(uint8_t *)(ulDestAddr+4), *(uint8_t *)(ulDestAddr+5), *(uint8_t *)(ulDestAddr+6),
				*(uint8_t *)(ulDestAddr+7), *(uint8_t *)(ulDestAddr+8), *(uint8_t *)(ulDestAddr+9), *(uint8_t *)(ulDestAddr+10));
		}
		else
			ulKNL_SetWiFiDtBufAddr_DwnldMode((uint32_t)ulDestAddr, ulFsBlockReadSize, PLYBK_DWNLD_MODE_EVENT+ulBlockCnt, PlayBackFileInfo.ullFileSize);

        if ((ulFsTtlReadoutSize >= PlayBackFileInfo.ullFileSize) && (PlayBackFileInfo.ullFileSize > 0)) 
        {
            ubReadOver = 1;
			printd(DBG_CriticalLvl, "ubReadOver:0x%x\n", ulFsReadoutOffset);
        }

		if (ubKNL_DownloadMode_Stop)
			break;
    }
	printd(DBG_CriticalLvl, "===>> Download Exit\n");
	
	ulDestAddr = NULL;
}
#endif

#if (APP_DOORPHONE_ENABLE==1)    
uint8_t KNL_DP_GetVideoOnOff(uint8_t ubKNLSrcNum)
{
    return ubKNK_VideoOnOffFg[ubKNLSrcNum];
}

void KNL_DP_SetVideoOnOff(uint8_t ubKNLSrcNum, uint8_t ubValue)
{
    ubKNK_VideoOnOffFg[ubKNLSrcNum] = ubValue; // 1 on , 0 off
}
#endif
//------------------------------------------------------------------------------
void KNL_ShowOneThumbnailProcess(KNL_THM_PROC_INFO_t *SrcInfo, KNL_THM_PROC_INFO_t *DstInfo, uint32_t ulOutputThmPixel_H, uint32_t ulOutputThmPixel_V)
{
	uint32_t ulCpyPixel;
	uint32_t ulCpyLine;
	CIPHER_GEN_DMA_INFO_t SrcCpyInfo, DstCpyInfo;

	if( (SrcInfo->ulPixel_H%4)!=0 || (SrcInfo->ulPixel_H_Ofs%4)!=0 ||
		(DstInfo->ulPixel_H%4)!=0 || (DstInfo->ulPixel_H_Ofs%4)!=0 )
	{
		printd(DBG_ErrorLvl, "KNL SingleThmProcess fail->Some pixel setting isn't the multiple of 4\n");
		return;
	}

	SrcInfo->ulPixel_V_Ofs /=2;
	DstInfo->ulPixel_V_Ofs /=2;
	
	if( SrcInfo->ulPixel_H_Ofs+ulOutputThmPixel_H > SrcInfo->ulPixel_H ||
		(SrcInfo->ulPixel_V_Ofs*2)+ulOutputThmPixel_V > SrcInfo->ulPixel_V )
	{
		printd(DBG_ErrorLvl, "KNL SingleThmProcess fail->source crop error\n");
		return;
	}
	
	if( DstInfo->ulPixel_H_Ofs+ulOutputThmPixel_H > DstInfo->ulPixel_H )
	{
		ulCpyPixel = DstInfo->ulPixel_H-DstInfo->ulPixel_H_Ofs;
	}
	else
	{
		ulCpyPixel = ulOutputThmPixel_H;
	}
	
	if( (DstInfo->ulPixel_V_Ofs*2)+ulOutputThmPixel_V > DstInfo->ulPixel_V )
	{
		ulCpyLine = DstInfo->ulPixel_V-(DstInfo->ulPixel_V_Ofs*2);
	}
	else
	{
		ulCpyLine = ulOutputThmPixel_V;
	}
	
	SrcInfo->ulAddr += ((SrcInfo->ulPixel_H*2+SrcInfo->ulPixel_H)*SrcInfo->ulPixel_V_Ofs + SrcInfo->ulPixel_H_Ofs*2);
	DstInfo->ulAddr += ((DstInfo->ulPixel_H*2+DstInfo->ulPixel_H)*DstInfo->ulPixel_V_Ofs + DstInfo->ulPixel_H_Ofs*2);
	
	//Line=0, 2, 4...
	SrcCpyInfo.ulAddr      = SrcInfo->ulAddr;
	SrcCpyInfo.ulLineSz    = ulCpyPixel*2;
	SrcCpyInfo.ulLineGapSz = (SrcInfo->ulPixel_H-SrcInfo->ulPixel_H_Ofs-ulCpyPixel)*2 + SrcInfo->ulPixel_H*1 + SrcInfo->ulPixel_H_Ofs*2;
	SrcCpyInfo.ulLineNum   = ulCpyLine/2;
	DstCpyInfo.ulAddr      = DstInfo->ulAddr;
	DstCpyInfo.ulLineSz    = ulCpyPixel*2;
	DstCpyInfo.ulLineGapSz = (DstInfo->ulPixel_H-DstInfo->ulPixel_H_Ofs-ulCpyPixel)*2 + DstInfo->ulPixel_H*1 + DstInfo->ulPixel_H_Ofs*2;
	DstCpyInfo.ulLineNum   = ulCpyLine/2;
	CIPHER_DMAGenericCopy(&SrcCpyInfo, &DstCpyInfo);
	//Line=1, 3, 5...
	SrcCpyInfo.ulAddr      = SrcInfo->ulAddr + (SrcInfo->ulPixel_H-SrcInfo->ulPixel_H_Ofs)*2 + SrcInfo->ulPixel_H_Ofs*1;
	SrcCpyInfo.ulLineSz    = ulCpyPixel*1;
	SrcCpyInfo.ulLineGapSz = (SrcInfo->ulPixel_H-SrcInfo->ulPixel_H_Ofs-ulCpyPixel)*1 + SrcInfo->ulPixel_H*2 + SrcInfo->ulPixel_H_Ofs*1;
	SrcCpyInfo.ulLineNum   = ulCpyLine/2;
	DstCpyInfo.ulAddr      = DstInfo->ulAddr + (DstInfo->ulPixel_H-DstInfo->ulPixel_H_Ofs)*2 + DstInfo->ulPixel_H_Ofs*1;
	DstCpyInfo.ulLineSz    = ulCpyPixel*1;
	DstCpyInfo.ulLineGapSz = (DstInfo->ulPixel_H-DstInfo->ulPixel_H_Ofs-ulCpyPixel)*1 + DstInfo->ulPixel_H*2 + DstInfo->ulPixel_H_Ofs*1;
	DstCpyInfo.ulLineNum   = ulCpyLine/2;
	CIPHER_DMAGenericCopy(&SrcCpyInfo, &DstCpyInfo);
}
//------------------------------------------------------------------------------
#if (APP_REC_FUNC_ENABLE && APP_PLAY_REMOTE_ENABLE)
#if OP_AP
void KNL_TxFSInfoInstall(uint32_t *pFolder, uint32_t *pFile)
{
    pKNL_TXFldInfo = pFolder;
    pKNL_TXFilInfo = pFile;
}
void KNL_SetTxFSCbFunc(pvKNL_TxFsCbFunc TxFsCbFunc)
{
	ptKNL_TxFsCbFunc = TxFsCbFunc;
}
uint8_t ubKNL_GetTXFldNum(void)
{
    return tKNL_TXFldInfo.ubFldNum;
}
KNL_ROLE ubKNL_GetTXFldRole(uint8_t ubIdx)
{
    return (KNL_ROLE)tKNL_TXFldInfo.ubLinked[ubIdx];
}
void vKNL_SetPlayRole(KNL_ROLE eRole)
{
    ubKNL_PlayRtSTA = eRole;
}
uint8_t ubKNL_GetRemotePlayFrmType(void)
{
    return KNL_RP_SyncHdlr.ubFrmType;
}
uint8_t ubKNL_GetRemotePlayStaNump(void)
{
    return KNL_RP_SyncHdlr.ubKnlSrcStaNum;
}
uint8_t ubKNL_CheckVdoTransmit(uint8_t ubKNL_ROLE)
{
    if(ubKNL_SrcNumMap(KNL_SRC_1_MAIN)==ubKNL_ROLE)
        return ubKNL_RcvFirstIFrame[KNL_SRC_1_MAIN];
    else if (ubKNL_SrcNumMap(KNL_SRC_2_MAIN)==ubKNL_ROLE)
        return ubKNL_RcvFirstIFrame[KNL_SRC_2_MAIN];
    else if (ubKNL_SrcNumMap(KNL_SRC_3_MAIN)==ubKNL_ROLE)
        return ubKNL_RcvFirstIFrame[KNL_SRC_3_MAIN];
    else if (ubKNL_SrcNumMap(KNL_SRC_4_MAIN)==ubKNL_ROLE)
        return ubKNL_RcvFirstIFrame[KNL_SRC_4_MAIN];
    else    return 0;
}
//------------------------------------------------------------------------------
#if defined(A7130)
void KNL_TXBBStart(uint8_t ubSrcNum)
{
	uint8_t ubSrcNumMap;
	uint8_t ubRxVdo_OriPath,ubRxVdo_NewPath;
	uint8_t ubTxAdo_Path;

	ubSrcNumMap = ubSrcNumMap;	//Avoid Warning
	ubSrcNumMap = ubKNL_SrcNumMap(ubSrcNum);
	if(ubSrcNumMap <= KNL_STA4)
    {
        printf("KNL_TXBBStartB=%d\n",ubSrcNum);
		ubRxVdo_OriPath = ubBB_GetRxVdoDataPath();
		ubTxAdo_Path	= ubBB_GetTxAdoDataPath();
		if(TRUE == ubKNL_BbPathAct)
		{
			ubRxVdo_OriPath = BB_PAYLOAD_NONE;
			ubKNL_BbPathAct = FALSE;
		}
		if(ubSrcNumMap == 0)
			ubRxVdo_NewPath = ubRxVdo_OriPath | BB_OPEN_STA1_PAYLOAD;
		else if(ubSrcNumMap == 1)
			ubRxVdo_NewPath = ubRxVdo_OriPath | BB_OPEN_STA2_PAYLOAD;
		else if(ubSrcNumMap == 2)
			ubRxVdo_NewPath = ubRxVdo_OriPath | BB_OPEN_STA3_PAYLOAD;
		else if(ubSrcNumMap == 3)
			ubRxVdo_NewPath = ubRxVdo_OriPath | BB_OPEN_STA4_PAYLOAD;
		BB_SetDataPath((TXADO)ubTxAdo_Path,BB_RX_ADO_ALL_STA,(PAYLOAD_PATH)ubRxVdo_NewPath);
	}
} 
#endif
#endif
#if OP_STA
void KNL_TXFSSetFldLayer(KNL_TX_FLDLAYER tLayer)
{
    KNL_TxFsFldLayer = tLayer;
}
void KNL_TXFSSort(uint8_t ubTrgger, uint8_t ubFSTp, uint32_t ulAdr, uint32_t ulSize)
{
    KNL_TxFsSort.ubTrgger = ubTrgger;
    KNL_TxFsSort.ubFSTp = ubFSTp;
    KNL_TxFsSort.ulAdr = ulAdr;
    KNL_TxFsSort.ulSize = ulSize;
}
void KNL_TXFSHidenInfo(uint8_t ubTrgger, uint8_t ubFSTp, uint16_t uwIdx)
{
    KNL_TxFsSort.ubTrgger = ubTrgger;
    KNL_TxFsSort.ubFSTp = ubFSTp;
    KNL_TxFsSort.ulAdr = (uint32_t)&tKNL_SortFileHiddenInfo[uwKNL_GetSortResult(uwIdx)];
    KNL_TxFsSort.ulSize = sizeof(FS_FILE_HIDDEN_INFO_t);
}
uint8_t KNL_TXFSTriggerChk(void)
{
    return KNL_TxFsSort.ubTrgger;
}

uint8_t ubKNL_GetBufUse(uint8_t ubCh)
{
#ifdef A7130
    uint8_t ubVTotalBufNum,ubVUsedBufNum,ubVPercent;
    uint8_t ubATotalBufNum,ubAUsedBufNum,ubAPercent;
    ubVTotalBufNum = ubBB_GetTxTotalBufNum(BB_DATA_VIDEO,BB_TX_MASTER);
	ubVUsedBufNum  = ubBB_GetTxUsedBufNum(BB_DATA_VIDEO,BB_TX_MASTER);
    ubATotalBufNum = ubBB_GetTxTotalBufNum(BB_DATA_AUDIO,BB_TX_MASTER);
    ubAUsedBufNum = ubBB_GetTxUsedBufNum(BB_DATA_AUDIO,BB_TX_MASTER);
    ubVPercent = ((ubVUsedBufNum*100)/ubVTotalBufNum);
    ubAPercent = ((ubAUsedBufNum*100)/ubATotalBufNum);

    if(ubVPercent >= 100 || ubAPercent >= 100)  return 3;
    else if(ubVPercent >= 70 || ubAPercent >= 70)  return 2;
    else if(ubVPercent >= 50 || ubAPercent >= 50)  return 1;
    else    return 0;
#elif defined(S2019A)
    uint8_t ubRtn=0;
	uint8_t ubLinkStatus;

    BUF_MODE tBsBufMode[] = {
								[KNL_SRC_1_MAIN] = BUF_VDO_MAIN_BS0,
								[KNL_SRC_2_MAIN] = BUF_VDO_MAIN_BS1,
								[KNL_SRC_3_MAIN] = BUF_VDO_MAIN_BS2,
								[KNL_SRC_4_MAIN] = BUF_VDO_MAIN_BS3,
							};    
    if(sPRF_APDIRECT_MODE == tsPRF_GetDrvMode()) {
		ubLinkStatus = ubWiFiDt_GetLinkStatus();
        if(PLY_FPS_ChkDisable() == 1)
        {
            if (uwS2019App_GetBufUsedLvl(0) > 80)
            	ubRtn = 1;

			if (uwS2019App_BufGetPFVdoFrmUsedCnt() > uwS2019App_BufGetPFVdoFrmMaxCnt() - 3) {
				ubRtn = 1;
			}

			if (ubLinkStatus != AP_LINKED) {
				printf("BFusd 1, getLink:%d\n", ubLinkStatus);
				ubRtn = 3;
			}

    		if(ubRtn>=2)    
    			printf("BFUsd=%d %d %d\n",ubRtn,uwS2019App_BufGetPFVdoFrmUsedCnt(),uwS2019App_GetBufUsedLvl(0));
			
			return ubRtn;
        }
        else
        {
			if( (ubCh <= KNL_SRC_4_MAIN) && (ubBUF_GetVdoMainBsFreeBufNum(tBsBufMode[ubCh]) < 1) )
            	return 1;		
		
            if (uwS2019App_GetBufUsedLvl(0) >= 70)  ubRtn = 3;
            else if (uwS2019App_GetBufUsedLvl(0) > 50)  ubRtn = 2;
            else if (uwS2019App_GetBufUsedLvl(0) > 30)  ubRtn = 1;
			else ubRtn = 0;

			if (uwS2019App_BufGetPFVdoFrmUsedCnt() > uwS2019App_BufGetPFVdoFrmMaxCnt() - 3) {
				if (ubRtn < 2)
					ubRtn = 2;
			}

			if (ubLinkStatus != AP_LINKED) {
				printf("BFusd 2, getLink:%d\n", ubLinkStatus);
				ubRtn = 3;
			}

    		if(ubRtn>=2)    
    			printf("BFUsd=%d %d %d\n",ubRtn,uwS2019App_BufGetPFVdoFrmUsedCnt(),uwS2019App_GetBufUsedLvl(0));
            return ubRtn;
        }
    }
    else
        return 0;
#else	
    return 0;   // check buffer used in tx play mode    
#endif
}
void KNL_SetRemoteFSCbFunc(pvKNL_RemotePlayCbFunc RP_CbFunc)
{
    ptKNL_RP_FsCbFunc = RP_CbFunc;
}
void KNL_SetRemotePlayCbFunc(pvKNL_RemotePlayCbFunc RP_CbFunc)
{
    ptKNL_RP_CbFunc = RP_CbFunc;
}
//------------------------------------------------------------------------------
#if (APP_PHOTOGRAPH_FUNC_ENABLE)
void KNL_PhotoPlayFuncSTA(KNL_RecordAct_t *pPhotoInfo)
{
    KNL_SRC ubSrcNum;
    KNL_PROCESS tKNLInfo;
    //uint32_t ulTemp;
#ifdef S2019A
    uint8_t ubStaNum = 0;
#endif
    KNL_ROLE tPlayRole;
    KNL_SRC tVdoSrcNum;
    uint32_t ulJpgBsBufSize;

    KNL_SetRecordFunc(KNL_PHOTO_PLAY);
    if(KNL_OK != tKNL_ReadCaptureFile(pPhotoInfo))
        goto PHOTOPLAY_ERR;

    printf("KNL_PhotoPlayFuncSTA = %x\n",pPhotoInfo->tPhotoPlayInfo.ulFileSize);
    ulJpgBsBufSize = pPhotoInfo->tPhotoPlayInfo.ulFileSize;

//=========================================    
    if(ptKNL_VdoRoleMap2SrcNum)
        ubSrcNum = ptKNL_VdoRoleMap2SrcNum(KNL_MAIN_PATH, (KNL_ROLE)ubKNL_GetRole());
    else
        ubSrcNum = (KNL_SRC)(KNL_SRC_1_MAIN + ubKNL_GetRole());

	for (tPlayRole = KNL_STA1; tPlayRole < DISPLAY_MODE; tPlayRole++)
	{
		tVdoSrcNum = (KNL_SRC)(KNL_SRC_1_MAIN + tPlayRole);
		KNL_VdoStop(tVdoSrcNum);
    	KNL_SenStop(tVdoSrcNum/*ubSrcNum*/);
	}

	for (tPlayRole = KNL_STA1; tPlayRole < DISPLAY_MODE; tPlayRole++)
	{
		tVdoSrcNum = (KNL_SRC)(KNL_SRC_1_AUX + tPlayRole);
		KNL_VdoStop(tVdoSrcNum);
    	KNL_SenStop(tVdoSrcNum/*ubSrcNum*/);
	}
#ifdef S2019A
    ubStaNum = ubKNL_SrcNumMap(ubSrcNum);
    if(0xFF == ubStaNum)
        return;
    BUF_Reset((BUF_VDO_MAIN_BS0 + ubStaNum));
    ulKNL_CurFrmIdx[ubStaNum] = 0;
#endif

    tKNLInfo.ubCurNode      = KNL_NODE_H264_ENC;
    tKNLInfo.ubNextNode     = ubKNL_GetNextNode(ubSrcNum, KNL_NODE_H264_ENC);
#if !(defined(BSP_RVCS_SDK)&&defined(OP_STA)&&APP_PLAY_REMOTE_ENABLE)
    tKNLInfo.ulDramAddr2    = ulKNL_JPGAddr[0];
    *(uint8_t *)(ulKNL_JPGAddr[0]) = 0xAA;
#else
    tKNLInfo.ulDramAddr2    = ulKNL_JPGAddr;
    *(uint8_t *)(ulKNL_JPGAddr) = 0xAA;
    tKNLInfo.ubEvent        = 0xAA;    
#endif
    tKNLInfo.ulSize         = ulJpgBsBufSize;                       
    tKNLInfo.ubSrcNum       = ubSrcNum;
    printf("BSADR=%x %x\n",tKNLInfo.ulDramAddr2,tKNLInfo.ulSize);
    
#ifdef S2019A
    tKNLInfo.ulSize = ulKNL_AddEncImgInfo(tKNLInfo);
#else
    tKNLInfo.ulSize = ulKNL_AddAuxInfo(KNL_VDO_PKT,tKNLInfo.ubSrcNum,tKNLInfo.ulDramAddr2,tKNLInfo.ulSize,tKNLInfo.ulIdx,tKNLInfo.ulGop,tKNLInfo.ubVdoGop,KNL_TIMER_Get1ms());
#endif
    if(osMessagePut(KNL_VdoCodecProcQueue, &tKNLInfo, 0) == osErrorResource)
        printd(DBG_ErrorLvl, "KNL_Q->Full !!!\r\n");
//=========================================
    //KNL_SenStart(ubSrcNum);	//for playback S1S2 Busy
	if(pPhotoInfo->pRecordStsNtyCb)
		pPhotoInfo->pRecordStsNtyCb(KNL_OK);
	return;
PHOTOPLAY_ERR:
	KNL_SetRecordFunc(KNL_RECORDFUNC_DISABLE);
	if(pPhotoInfo->pRecordStsNtyCb)
		pPhotoInfo->pRecordStsNtyCb(KNL_ErrorTimeout);
}
#endif
#endif
#endif
//------------------------------------------------------------------------------
void KNL_FillSameColorOnDisp(uint8_t ubRed, uint8_t ubGreen, uint8_t ubBlue, uint32_t ulDispAddr, uint32_t ulDispH, uint32_t ulDispV)
{
	float fY_Value, fU_Value, fV_Value;
	uint8_t ubY_Value, ubU_Value, ubV_Value;
	
	fY_Value = 0.299*ubRed + 0.587*ubGreen + 0.114*ubBlue;
	fU_Value = -0.1687*ubRed - 0.3313*ubGreen + 0.5*ubBlue + 128;
	fV_Value = 0.5*ubRed - 0.4187*ubGreen - 0.0813*ubBlue + 128;
	
	ubY_Value = (fY_Value<0?0:(fY_Value>255?255:fY_Value));
	ubU_Value = (fU_Value<0?0:(fU_Value>255?255:fU_Value));
	ubV_Value = (fV_Value<0?0:(fV_Value>255?255:fV_Value));
	
	uint8_t ubEvenPat[8] = {ubY_Value, ubY_Value, ubY_Value, ubY_Value, ubU_Value, ubV_Value, ubU_Value, ubV_Value};
	uint8_t ubOddPat[4] = {ubY_Value, ubY_Value, ubY_Value, ubY_Value};
	uint32_t i;
	
	for(i=0; i<((ulDispH*2)/sizeof(ubEvenPat)); i++)
	{
		memcpy((uint8_t*)(ulDispAddr+(i*sizeof(ubEvenPat))), ubEvenPat, sizeof(ubEvenPat));
	}
	for(i=0; i<(ulDispH/sizeof(ubOddPat)); i++)
	{
		memcpy((uint8_t*)((ulDispAddr+(ulDispH*2))+(i*sizeof(ubOddPat))), ubOddPat, sizeof(ubOddPat));
	}
	
	for(i=0; i<(ulDispV/2-1); i++)
	{
		tDMAC_MemCopy(ulDispAddr, (ulDispAddr+ulDispH*2+ulDispH)+(i*(ulDispH*2+ulDispH)), ulDispH*2, NULL);
	}
	for(i=0; i<(ulDispV/2-1); i++)
	{
		tDMAC_MemCopy(ulDispAddr+(ulDispH*2), (ulDispAddr+ulDispH*2+ulDispH+ulDispH*2)+(i*(ulDispH*2+ulDispH)), ulDispH, NULL);
	}
}
//------------------------------------------------------------------------------
void KNL_FillWhiteOnLcd(uint16_t uwHSz, uint16_t uwVSz)
{
	KNL_FillSameColorOnDisp(255, 255, 255, ulBUF_GetBlkBufAddr(0, BUF_LCD_IP), uwHSz, uwVSz);
	KNL_FillSameColorOnDisp(255, 255, 255, ulBUF_GetBlkBufAddr(0, BUF_LCD_IP)+((uwHSz*uwVSz*3/2)), uwHSz, uwVSz);
}
//------------------------------------------------------------------------------
#if APP_FS_FILE_LIST_STYLE
KNL_Status_t KNL_ShowingThm(uint32_t ulThmIdx, KNL_FILESINFO_t *FileInfo)
{
	uint32_t ulFrameAddr = 0;
	uint32_t ulFrameSz = 0;
	uint32_t ulYuvAddr = 0;
	uint8_t ubSpsSize = 0;
	uint8_t ubPpsSize = 0;
	KNL_PROCESS tKNLInfo;
	KNL_THM_PROC_INFO_t SrcInfo, DstInfo;
	uint32_t ulThmPixel_H, ulThmPixel_V;
	osEvent osKNL_ThmShow;
	uint8_t ubTimeout;
	uint8_t *pJpgAddr;
	uint16_t uwJpgHSize = 0, uwJpgVSize = 0;
	KNL_NODE_INFO tPhotoPlayNodeInfo;
	uint32_t ulJpgBsAddr = 0;
	uint8_t ubThmShowFlag = 0;
	uint16_t uwShowThmScaleHSize = 0, uwShowThmScaleVSize = 0;
	uint32_t uwShowThmScaleHGap = 4;
	uint32_t uwShowThmScaleVGap = 4;
	
	KNL_ThmShowInfo.ubShowingThmFlg = 1;
	
#if defined(BSP_DVR_SDK)
	uint32_t ulRecBufAddr;
	ulRecBufAddr = ulBUF_GetBlkBufAddr(0,BUF_REC);
	KNL_ThmShowInfo.ulReadTempBufAddr = ulRecBufAddr;
	KNL_ThmShowInfo.ulDecYuvBufAddr   = ulRecBufAddr + (1920 * 1088 * 1.5);
#else
	KNL_ThmShowInfo.ulReadTempBufAddr = ulBUF_GetBlkBufAddr(0,BUF_THM_SHOWING_READ_TEMP);
	KNL_ThmShowInfo.ulDecYuvBufAddr   = ulBUF_GetBlkBufAddr(0,BUF_THM_SHOWING_DEC_YUV);
#endif

	ulFrameAddr = KNL_ThmShowInfo.ulReadTempBufAddr;
	ulYuvAddr   = KNL_ThmShowInfo.ulDecYuvBufAddr;
	
	if( memcmp(FileInfo->HidnFileInfo.FileName.chExt, "MP4", 3)==0 )
	{
		ulFrameSz = ubPLY_ThumbnailOpen(FileInfo->HidnFileInfo.SrcNum, FileInfo->HidnFileInfo.ulFirstClus, FileInfo->HidnFileInfo.NoFatChainFlag, ulFrameAddr,FileInfo->HidnFileInfo.ullFileSize);
		if(ulFrameSz==0)
		{
			printd(DBG_ErrorLvl, "KNL Showing Thm fail->Read I frame from MP4 timeout\n");
			goto KNL_SHOWING_THM_FAIL;
		}
		else if(ulFrameSz==0xFFFFFFFF)
		{
		    printd(DBG_InfoLvl, "File No I frame\n");
			
			KNL_LcdDisplaySetting();
			
			if(KNL_ThmShowInfo.ubLcdDispAddrKeepFlg==0)
			{
				KNL_ThmShowInfo.ubLcdDispAddrKeepFlg = 1;
				KNL_ThmShowInfo.ulLcdDispCurAddr = ulKNL_GetLcdDispAddr(KNL_SRC_1_MAIN);
				KNL_ThmShowInfo.ulLcdDispKeepAddr = KNL_ThmShowInfo.ulLcdDispCurAddr;
			}
			else if(KNL_ThmShowInfo.ubLcdDispAddrKeepFlg==1)
			{
				KNL_ThmShowInfo.ulLcdDispCurAddr = KNL_ThmShowInfo.ulLcdDispKeepAddr;
			}
			KNL_ActiveLcdDispBuf(KNL_SRC_1_MAIN);
	    }
	    else
	    {
    		ubSpsSize = *(uint8_t *)(ulFrameAddr+ 3);
    		ubPpsSize = *(uint8_t *)(ulFrameAddr+ 7 + ubSpsSize);             // 7 = Update SPS NAL unit(4)+PPS NAL unit(4)
    		*(uint8_t *)(ulFrameAddr+3) = 0x01;                               // Update NAL unit
    		*(uint8_t *)(ulFrameAddr + ubSpsSize + 7) = 0x01;                 // Update SPS NAL unit(4)+Sps Length+PPS NAL unit(4)
    		*(uint8_t *)(ulFrameAddr+ ubSpsSize + ubPpsSize + 8) = 0x00;      // Update SPS NAL unit(4)+Sps Length +PPS NAL unit(4)+ PPS Length
    		*(uint8_t *)(ulFrameAddr+ ubSpsSize + ubPpsSize + 9) = 0x00;
    		*(uint8_t *)(ulFrameAddr+ ubSpsSize + ubPpsSize + 10) = 0x00;
    		*(uint8_t *)(ulFrameAddr+ ubSpsSize + ubPpsSize + 11) = 0x01;
    		
    		tKNLInfo.ubCurNode   = KNL_NODE_VDO_BS_BUF1;
    		tKNLInfo.ubNextNode  = ubKNL_GetNextNode(VDO_GetSourceNumber(KNL_MAIN_PATH, KNL_STA1),KNL_NODE_VDO_BS_BUF1);	
    		tKNLInfo.ubSrcNum	 = KNL_SRC_1_MAIN;
    		tKNLInfo.ulDramAddr2 = ulFrameAddr;
    		tKNLInfo.ulSize      = ulFrameSz;
			tKNLInfo.uwHSize     = FileInfo->HidnFileInfo.SubHidnInfo.uwRes_HSize;
			tKNLInfo.uwVSize     = FileInfo->HidnFileInfo.SubHidnInfo.uwRes_VSize;
    		if(osMessagePut(KNL_VdoCodecProcQueue, &tKNLInfo, 0) == osErrorResource)
    		{
    			printd(DBG_ErrorLvl, "KNL Showing Thm fail->Send Q fail!\n");
    			goto KNL_SHOWING_THM_FAIL;
    		}
    		KNL_ThmShowInfo.osThrdID = osThreadGetId();
    		osKNL_ThmShow = osSignalWait(osKNL_ShowingThmSignal, 300);
    		if(!((osKNL_ThmShow.status == osEventSignal) && (osKNL_ThmShow.value.signals == osKNL_ShowingThmSignal)))
    		{
    			printd(DBG_ErrorLvl, "KNL Showing Thm fail->Sem timeout\n");
    			goto KNL_SHOWING_THM_FAIL;
    		}
		}
		ubThmShowFlag = 1;
		if(FileInfo->HidnFileInfo.SubHidnInfo.uwRes_HSize>=1920 && FileInfo->HidnFileInfo.SubHidnInfo.uwRes_VSize>=1080)
		{
			uwShowThmScaleHSize = FileInfo->HidnFileInfo.SubHidnInfo.uwRes_HSize/4;
			uwShowThmScaleVSize = FileInfo->HidnFileInfo.SubHidnInfo.uwRes_VSize/4;
		}
		else if(FileInfo->HidnFileInfo.SubHidnInfo.uwRes_HSize>=1280 && FileInfo->HidnFileInfo.SubHidnInfo.uwRes_VSize>=720)
		{
			uwShowThmScaleHSize = FileInfo->HidnFileInfo.SubHidnInfo.uwRes_HSize/4;
			uwShowThmScaleVSize = FileInfo->HidnFileInfo.SubHidnInfo.uwRes_VSize/4;
		}
		else if(FileInfo->HidnFileInfo.SubHidnInfo.uwRes_HSize>=640 && FileInfo->HidnFileInfo.SubHidnInfo.uwRes_VSize>=480)
		{
			uwShowThmScaleHSize = FileInfo->HidnFileInfo.SubHidnInfo.uwRes_HSize/2;
			uwShowThmScaleVSize = FileInfo->HidnFileInfo.SubHidnInfo.uwRes_VSize/2;
		}
		else
		{
			uwShowThmScaleHSize = FileInfo->HidnFileInfo.SubHidnInfo.uwRes_HSize/4;
			uwShowThmScaleVSize = FileInfo->HidnFileInfo.SubHidnInfo.uwRes_VSize/4;
		}
	}
	else if( memcmp(FileInfo->HidnFileInfo.FileName.chExt, "JPG", 3)==0 )
	{
		if(FS_ReadFile(tKNL_FsMediaInfo.MediaSel, ulFrameAddr, FileInfo->HidnFileInfo.SrcNum, FileInfo->HidnFileInfo.ulFirstClus, FileInfo->HidnFileInfo.NoFatChainFlag, 0, FileInfo->HidnFileInfo.ullFileSize) != FS_SEND_Q_SUCCESS)
		{
			printd(DBG_ErrorLvl, "KNL Showing Thm fail->Rd JPG send Q fail\n");
			goto KNL_SHOWING_THM_FAIL;
		}
		
		ubTimeout = 100;
		while(FS_ChkReadStatus(tKNL_FsMediaInfo.MediaSel, FileInfo->HidnFileInfo.SrcNum) != FS_PLY_READ_OK)
		{
			osDelay(20);
			if(!--ubTimeout)
			{
				printd(DBG_ErrorLvl, "KNL Showing Thm fail->Read JPG timeout\n");
				goto KNL_SHOWING_THM_FAIL;
			}
		}
		
		KNL_LcdDisplaySetting();
		
		if(KNL_ThmShowInfo.ubLcdDispAddrKeepFlg==0)
		{
			KNL_ThmShowInfo.ubLcdDispAddrKeepFlg = 1;
			KNL_ThmShowInfo.ulLcdDispCurAddr = ulKNL_GetLcdDispAddr(KNL_SRC_1_MAIN);
			KNL_ThmShowInfo.ulLcdDispKeepAddr = KNL_ThmShowInfo.ulLcdDispCurAddr;
		}
		else if(KNL_ThmShowInfo.ubLcdDispAddrKeepFlg==1)
		{
			KNL_ThmShowInfo.ulLcdDispCurAddr = KNL_ThmShowInfo.ulLcdDispKeepAddr;
		}
		
		pJpgAddr   = (uint8_t *)ulFrameAddr;
		uwJpgHSize = (pJpgAddr[(KNL_JPG_FRAMEHEADER_START+KNL_JPEG_HEADER_H_OFFSET)] << 8) + pJpgAddr[(KNL_JPG_FRAMEHEADER_START+KNL_JPEG_HEADER_H_OFFSET+1)];
        uwJpgVSize = (pJpgAddr[(KNL_JPG_FRAMEHEADER_START+KNL_JPEG_HEADER_V_OFFSET)] << 8) + pJpgAddr[(KNL_JPG_FRAMEHEADER_START+KNL_JPEG_HEADER_V_OFFSET+1)];
		memset(&tPhotoPlayNodeInfo, 0, sizeof(KNL_NODE_INFO));
		tPhotoPlayNodeInfo.ubVMirror = (tKNL_GetDispRotate() == KNL_DISP_ROTATE_90)?JPEG_V_MIRROR:JPEG_MIRROR_DISABLE;
		ulJpgBsAddr = ulFrameAddr + KNL_JPG_HEADER_SIZE;
		if(KNL_DISP_ROTATE_90 == tKNL_GetDispRotate())
		{
			tPhotoPlayNodeInfo.ubJpgScale = 0;
			if(ubKNL_JPEGDecode(&tPhotoPlayNodeInfo, JPEG_YUV420, JPEG_FN_USE_POLLING, uwJpgHSize, uwJpgVSize, ulYuvAddr, ulJpgBsAddr)!=JPEG_PASS)
			{
				printd(DBG_ErrorLvl, "KNL Showing Thm fail->JPG decode fail\n");
				goto KNL_SHOWING_THM_FAIL;
			}
			
			if(ubKNL_JPEGEncode(JPEG_YUV420, JPEG_FN_USE_POLLING, uwJpgHSize, uwJpgVSize, ulYuvAddr, ulJpgBsAddr)!=JPEG_PASS)
			{
				printd(DBG_ErrorLvl, "KNL Showing Thm fail->JPG encode fail\n");
				goto KNL_SHOWING_THM_FAIL;
			}
			tPhotoPlayNodeInfo.ubHMirror = JPEG_H_MIRROR;

			tPhotoPlayNodeInfo.ubRotate  = JPEG_ROT_90Deg;
			if(uwJpgHSize>=1920 && uwJpgVSize>=1080)
			{
				tPhotoPlayNodeInfo.ubJpgScale = 2;
			}
			else if(uwJpgHSize>=1280 && uwJpgVSize>=720)
			{
				tPhotoPlayNodeInfo.ubJpgScale = 2;
			}
			else if(uwJpgHSize>=640 && uwJpgVSize>=480)
			{
				tPhotoPlayNodeInfo.ubJpgScale = 1;
			}
			else
			{
				tPhotoPlayNodeInfo.ubJpgScale = 2;
			}
			if(ubKNL_JPEGDecode(&tPhotoPlayNodeInfo, JPEG_YUV420, JPEG_FN_USE_POLLING, uwJpgHSize, uwJpgVSize, ulYuvAddr, ulJpgBsAddr)!=JPEG_PASS)
			{
				printd(DBG_ErrorLvl, "KNL Showing Thm fail->JPG encode fail\n");
				goto KNL_SHOWING_THM_FAIL;
			}
		}
		else
		{
			if(uwJpgHSize>=1920 && uwJpgVSize>=1080)
			{
				tPhotoPlayNodeInfo.ubJpgScale = 2;
			}
			else if(uwJpgHSize>=1280 && uwJpgVSize>=720)
			{
				tPhotoPlayNodeInfo.ubJpgScale = 2;
			}
			else if(uwJpgHSize>=640 && uwJpgVSize>=480)
			{
				tPhotoPlayNodeInfo.ubJpgScale = 1;
			}
			else
			{
				tPhotoPlayNodeInfo.ubJpgScale = 2;
			}
			if(ubKNL_JPEGDecode(&tPhotoPlayNodeInfo, JPEG_YUV420, JPEG_FN_USE_POLLING, uwJpgHSize, uwJpgVSize, ulYuvAddr, ulJpgBsAddr)!=JPEG_PASS)
			{
				printd(DBG_ErrorLvl, "KNL Showing Thm fail->JPG decode fail\n");
				goto KNL_SHOWING_THM_FAIL;
			}
		}
		
		KNL_ActiveLcdDispBuf(KNL_SRC_1_MAIN);
		
		ubThmShowFlag = 1;
		if(uwJpgHSize>=1920 && uwJpgVSize>=1080)
		{
			uwShowThmScaleHSize = uwJpgHSize/4;
			uwShowThmScaleVSize = uwJpgVSize/4;
		}
		else if(uwJpgHSize>=1280 && uwJpgVSize>=720)
		{
			uwShowThmScaleHSize = uwJpgHSize/4;
			uwShowThmScaleVSize = uwJpgVSize/4;
		}
		else if(uwJpgHSize>=640 && uwJpgVSize>=480)
		{
			uwShowThmScaleHSize = uwJpgHSize/2;
			uwShowThmScaleVSize = uwJpgVSize/2;
		}
		else
		{
			uwShowThmScaleHSize = uwJpgHSize/4;
			uwShowThmScaleVSize = uwJpgVSize/4;
		}
	}
	
	if(ubThmShowFlag)
	{
		SrcInfo.ulAddr = ulYuvAddr;
		DstInfo.ulAddr = KNL_ThmShowInfo.ulLcdDispCurAddr;
		
		if(KNL_DISP_ROTATE_90 == tKNL_GetDispRotate())
		{
			SrcInfo.ulPixel_H     = uwShowThmScaleVSize;
			SrcInfo.ulPixel_V     = uwShowThmScaleHSize;
			SrcInfo.ulPixel_H_Ofs = 0;
			SrcInfo.ulPixel_V_Ofs = 0;
			
			DstInfo.ulPixel_H = 720;
			DstInfo.ulPixel_V = 1280;
			ulThmPixel_H = 180;
			ulThmPixel_V = 320;
			DstInfo.ulPixel_H_Ofs = (ulThmIdx/3)*ulThmPixel_H + (ulThmIdx/3+1)*uwShowThmScaleHGap;
			DstInfo.ulPixel_V_Ofs = (1280-ulThmPixel_V) - (ulThmIdx%3)*ulThmPixel_V - (ulThmIdx%3+1)*uwShowThmScaleVGap;
		}
		else
		{
			SrcInfo.ulPixel_H     = uwShowThmScaleHSize;
			SrcInfo.ulPixel_V     = uwShowThmScaleVSize;
			SrcInfo.ulPixel_H_Ofs = 0;
			SrcInfo.ulPixel_V_Ofs = 0;

			DstInfo.ulPixel_H = 1280;//VDO_MAIN_H_SIZE(tKNL_GetDispType());
			DstInfo.ulPixel_V = 720;//VDO_MAIN_V_SIZE(tKNL_GetDispType());

			ulThmPixel_H = 320;
			ulThmPixel_V = 180;
			DstInfo.ulPixel_H_Ofs = (ulThmIdx%3)*ulThmPixel_H + (ulThmIdx%3+1)*uwShowThmScaleHGap;
			DstInfo.ulPixel_V_Ofs = (ulThmIdx/3)*ulThmPixel_V + (ulThmIdx/3+1)*uwShowThmScaleVGap;
		}
		if(ulFrameSz==0xFFFFFFFF)
		{
			KNL_FillSameColorOnDisp(0, 0, 0, ulYuvAddr, SrcInfo.ulPixel_H, SrcInfo.ulPixel_V);
		}
		KNL_ShowOneThumbnailProcess(&SrcInfo, &DstInfo, ulThmPixel_H, ulThmPixel_V);
		KNL_ThmShowInfo.ubShowingThmFlg = 0;
		return KNL_OK;
	}
KNL_SHOWING_THM_FAIL:
	KNL_ThmShowInfo.ubShowingThmFlg = 0;
	return KNL_ERR;
}
//------------------------------------------------------------------------------
void KNL_ThumbnailSwtichView(void)
{
    KNL_ResetLcdChannel();
    if(ubKNL_GetBackupDispInfoFlag() == FALSE)
    {
        KNL_SetBackupDispInfoFlag(TRUE);
        KNL_BackDispType        = tKNL_GetDispType();
        KNL_BackSwDispInfo      = KNL_SwDispInfo;
#if defined(BSP_DVR_SDK)
        if(KNL_BackDispType == KNL_DISP_DUAL_C)
        {
            ubKNL_BackSrcLocate[0]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
            ubKNL_BackSrcLocate[1]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION2);
            ubKNL_BackSrcLocate[2]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION3);
            ubKNL_BackSrcLocate[3]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION4);
        }
        else if(KNL_BackDispType == KNL_DISP_SINGLE)
        {
            ubKNL_BackSrcLocate[0]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
            ubKNL_BackSrcLocate[1]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION2);
            ubKNL_BackSrcLocate[2]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION3);
            ubKNL_BackSrcLocate[3]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION4);
        }
#else
        ubKNL_BackSrcLocate[0]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION1);
        ubKNL_BackSrcLocate[1]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION2);
        ubKNL_BackSrcLocate[2]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION3);
        ubKNL_BackSrcLocate[3]  = (KNL_SRC)ubKNL_GetDispSrc(KNL_DISP_LOCATION4);
#endif		
    }
    KNL_ThmShowInfo.ubEnFlg = 1;
    KNL_ROLE CamRole = KNL_STA1;
	KNL_SRC tVDO_KNLSrcNum;
	tVDO_KNLSrcNum = VDO_GetSourceNumber(KNL_MAIN_PATH, CamRole);
	KNL_ThmShowInfo.uwHSize_Display = uwKNL_GetVdoH(tVDO_KNLSrcNum);
	KNL_ThmShowInfo.uwVSize_Display = uwKNL_GetVdoV(tVDO_KNLSrcNum);
    KNL_SetDispSrc(KNL_DISP_LOCATION1, KNL_SRC_1_MAIN);
    VDO_SwitchDisplayType(KNL_DISP_SINGLE, &CamRole);
}
#endif
//------------------------------------------------------------------------------
#if APP_PC_CONNECT_EN
void KNL_PcConn_SetSdFwuMode(KNL_PCCONN_FW_UPDATE_MODE Mode)
{
	KNL_PcConn_SdFwuMode = Mode;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_GetPcConnEnterStatus(void)
{
	return ubKNL_PcConnEnterFlg;
}
//------------------------------------------------------------------------------
uint8_t ubKNL_GetPcConnSdFwuStatus(void)
{
	return ubKNL_PcConnSdFwuFlg;
}
//------------------------------------------------------------------------------
void KNL_PcConn_SdFwUpdateProcess(void)
{
	FWU_UpgResult_t tFwuUpgRet;
	FS_GET_A_SINGLE_FILE_INTO_t SingleFileInfo;
	FS_GET_A_SERIES_FILE_INTO_t SeriesFileInfo;
	FS_FILE_INFO_t FileInfo;
	uint8_t ubTimeout;
	FS_Q_STATUS FsWaitStatus;
	uint8_t ubHitFlg;
	FS_KNL_MANUAL_DEL_PROCESS_t tDelAct;
	
	//stop rec or play
#if APP_REC_FUNC_ENABLE
	KNL_RecordFunc_t tRecordFunc;
	KNL_Status_t tVdoRecStopRet;
	tRecordFunc = tKNL_GetRecordFunc();
	if(KNL_RECORDING_START == tKNL_RecordAct.tRecordSts)
	{
		osThreadSuspend(KNL_RecSdMonitorThreadId);
		osDelay(100);
		tVdoRecStopRet = KNL_VideoRecStop(tRecordFunc,0);
		if(tKNL_RecordAct.pRecordStsNtyCb)
		{
			tKNL_RecordAct.pRecordStsNtyCb(tVdoRecStopRet);
		}
	}
	else if(KNL_VIDEO_PLAY == tKNL_GetRecordFunc())
	{
		 KNL_VideoPlayStop();
	}
#endif
	
	//fw update
	KNL_Stop();
	FWU_Disable();
	USBD_UnInit();		
	
	tFwuUpgRet = FWU_SdUpgradeStart(ulBUF_GetFreeAddr());
	printd(DBG_CriticalLvl, "\r\nKNL PcConn->FW Upgrade %s\r\n", (FWU_UPG_SUCCESS == tFwuUpgRet)?"Success":"Fail !");
	if(FWU_UPG_SUCCESS != tFwuUpgRet)
	{
		SYS_Reboot();
	}
	else
	{
		printd(DBG_ErrorLvl, "KNL PcConn->Search Eng File...\n");
	
		ubHitFlg = 0;
		
		//search EM.bin
		SingleFileInfo.OutputFileInfo = &FileInfo;
		SingleFileInfo.FileName = KNL_PcConn_EngModeFileName;
		FS_GetFileInfo(tKNL_FsMediaInfo.MediaSel, A_SINGLE_INFO, SingleFileInfo, SeriesFileInfo, FILE_PATH1);
		ubTimeout = 60;
		while(1)
		{
			FsWaitStatus = FS_ChkGetFileInfoStatus(tKNL_FsMediaInfo.MediaSel);
			if(FsWaitStatus==FS_GET_INFO_FAIL)
			{
				printd(DBG_ErrorLvl, "KNL PcConn->Get Eng File Info Err!\n");
				break;
			}
			else if(FsWaitStatus==FS_GET_INFO_OK)
			{
				printd(DBG_ErrorLvl, "KNL PcConn->Get Eng File, don't delete FW file\n");
				ubHitFlg = 1;
				break;
			}
			else
			{
				osDelay(50);
				if(!--ubTimeout)
				{
					printd(DBG_ErrorLvl, "KNL PcConn->Get File Info Timeout!\n");
					break;
				}
			}
		}
		
		//delete fw file
		if(ubHitFlg==0)
		{
			printd(DBG_ErrorLvl, "KNL PcConn->Delete fwu file\n");
		
			tDelAct.MediaSel = tKNL_FsMediaInfo.MediaSel;
			memset(&tDelAct.FldName, 0, sizeof(tDelAct.FldName));
			memset(&tDelAct.FileName, 0, sizeof(tDelAct.FileName));
			tDelAct.FileName = KNL_PcConn_SdFwuFileName;
			tDelAct.FilePath = FILE_PATH1;
			FS_ManualDeleteFile(&tDelAct);
			ubTimeout = 60;
			while(FS_ChkManualDelStatus(tDelAct.MediaSel) != FS_MANUAL_DEL_OK)
			{
				osDelay(50);
				if(!--ubTimeout)
				{
					printd(DBG_ErrorLvl, "KNL PcConn->Delete FW file err !!\n");
					break;
				}
			}
		}
		printd(DBG_ErrorLvl, "KNL PcConn->system reboot\n");
		SYS_Reboot();
	}
}
//------------------------------------------------------------------------------
void KNL_PcConn_SdFwUpdateThread(void const *argument)
{
	uint8_t ubEnFlg = 0;
	FS_GET_A_SINGLE_FILE_INTO_t SingleFileInfo;
	FS_GET_A_SERIES_FILE_INTO_t SeriesFileInfo;
	FS_FILE_INFO_t FileInfo;
	uint8_t ubTimeout;
	FS_Q_STATUS FsWaitStatus;
	uint8_t ubHitFlg;
	while(1)
	{
		if(FS_ChkMediaRdy(tKNL_FsMediaInfo.MediaSel)==FS_MEDIA_RDY && ubEnFlg==0)
		{
			ubEnFlg = 1;
			
			//find FW file in root
			SingleFileInfo.OutputFileInfo = &FileInfo;
			SingleFileInfo.FileName = KNL_PcConn_SdFwuFileName;
			FS_GetFileInfo(tKNL_FsMediaInfo.MediaSel, A_SINGLE_INFO, SingleFileInfo, SeriesFileInfo, FILE_PATH1);
			ubTimeout = 60;
			ubHitFlg = 0;
			while(1)
			{
				FsWaitStatus = FS_ChkGetFileInfoStatus(tKNL_FsMediaInfo.MediaSel);
				if(FsWaitStatus==FS_GET_INFO_FAIL)
				{
					printd(DBG_ErrorLvl, "KNL PcConn->Get FWU File Info Err!\n");
					break;
				}
				else if(FsWaitStatus==FS_GET_INFO_OK)
				{
					ubHitFlg = 1;
					break;
				}
				else
				{
					osDelay(50);
					if(!--ubTimeout)
					{
						printd(DBG_ErrorLvl, "KNL PcConn->Get File Info Timeout!\n");
						break;
					}
				}
			}
			if(ubHitFlg==1)
			{
				ubKNL_PcConnSdFwuFlg = 1;
				
				if(KNL_PcConnCbFunc_OtherAction!=NULL)
				{
					while(KNL_PcConn_SdFwuMode==KNL_PCCONN_WAIT)
						osDelay(20);

					if(KNL_PcConn_SdFwuMode==KNL_PCCONN_UPDATE)
					{
						KNL_PcConn_SdFwUpdateProcess();
					}
					
					KNL_PcConn_SdFwuMode = KNL_PCCONN_WAIT;
				}
				else
				{
					KNL_PcConn_SdFwUpdateProcess();
				}
			}
		}
		else if(FS_ChkMediaRdy(tKNL_FsMediaInfo.MediaSel)!=FS_MEDIA_RDY)
		{
			ubEnFlg = 0;
			ubKNL_PcConnSdFwuFlg = 0;
		}
		osDelay(100);
	}
}
//------------------------------------------------------------------------------
void KNL_PcConnectInit(KNL_PCCONN_INIT_t *Info)
{
	if(Info->EnterPcConnCb!=NULL)
		KNL_EnterPcConnCbFunc = Info->EnterPcConnCb;
	
	if(Info->LeavePcConnCb!=NULL)
		KNL_LeavePcConnCbFunc = Info->LeavePcConnCb;
	
	if(Info->EnterPcConnCb!=NULL)
		KNL_PcConnCbFunc_OtherAction = Info->OtherAction;
	
	if(Info->SdCardPlugoutCb!=NULL)
		KNL_PcConnCbFunc_SdCardPlugout = Info->SdCardPlugoutCb;
	
	if(Info->EngModeFileName.ubLen!=0)
		memcpy(&KNL_PcConn_EngModeFileName, &Info->EngModeFileName, sizeof(KNL_PcConn_EngModeFileName));
	
	if(Info->SdFwuFileName.ubLen!=0)
		memcpy(&KNL_PcConn_SdFwuFileName, &Info->SdFwuFileName, sizeof(KNL_PcConn_SdFwuFileName));
	
	osThreadDef(KNL_PcConn_SdFwUpdateThread, KNL_PcConn_SdFwUpdateThread, osPriorityNormal, 1, 8192);
	KNL_PcConn_SdFwUpdateThreadId = osThreadCreate(osThread(KNL_PcConn_SdFwUpdateThread), NULL);
}
//------------------------------------------------------------------------------
void KNL_LeavePcConnect(void)
{
	osMutexWait(osKNL_Mutex_PcConnect, osWaitForever);
	if(ubKNL_LeavePcConnectFirstFlg==1 && FS_ChkMediaExist(tKNL_FsMediaInfo.MediaSel) == FS_MEDIA_IN && ubKNL_PcConnSdFwuFlg==0 && ubKNL_PcConnEnterFlg)
	{
		printd(DBG_ErrorLvl, "KNL Leave PcConnect...\n");
#if (OP_STA	&& APP_PC_CONNECT_EN)
        if(ubKNL_GetCommLinkStatus(KNL_MASTER_AP))
		{
		    uint8_t ubData=0;
			if(ubKNL_TwcSend(KNL_MASTER_AP, TWC_TX_PCCNT_RPT, &ubData, 2, 16) != TWC_SUCCESS)
				printd(DBG_ErrorLvl, " TWC_SYNC_TIMESTAMP -> Fail\r\n");
			osDelay(100);
		}
#endif
		if(KNL_LeavePcConnCbFunc!=NULL)
			KNL_LeavePcConnCbFunc();
		SYS_Reboot();
	}
	ubKNL_LeavePcConnectFirstFlg = 1;
	ubKNL_PcConnEnterFlg = 0;
	osMutexRelease(osKNL_Mutex_PcConnect);
}
//------------------------------------------------------------------------------
void KNL_EnterPcConnect(void)
{
	osMutexWait(osKNL_Mutex_PcConnect, osWaitForever);
	ubKNL_PcConnEnterFlg = 1;
	if(ubKNL_PcConnSdFwuFlg==0)
	{
		ubKNL_PcConnectAccFlg = 1;
		if(FS_ChkMediaExist(tKNL_FsMediaInfo.MediaSel) == FS_MEDIA_IN)
		{
			osThreadSuspend(KNL_PcConn_SdFwUpdateThreadId);
			
			osDelay(500);		
			printd(DBG_ErrorLvl, "KNL Enter PcConnect...\n");
#if (OP_STA	&& APP_PC_CONNECT_EN)	
            if(ubKNL_GetCommLinkStatus(KNL_MASTER_AP))
            {
                uint8_t ubData=1;
                if(ubKNL_TwcSend(KNL_MASTER_AP, TWC_TX_PCCNT_RPT, &ubData, 2, 16) != TWC_SUCCESS)
                    printd(DBG_ErrorLvl, " TWC_SYNC_TIMESTAMP -> Fail\r\n");
                osDelay(100);
            }
#endif
			//stop rec or play
#if APP_REC_FUNC_ENABLE
			KNL_RecordFunc_t tRecordFunc;
			KNL_Status_t tVdoRecStopRet;
			tRecordFunc = tKNL_GetRecordFunc();
			if(KNL_RECORDING_START == tKNL_RecordAct.tRecordSts)
			{
				osThreadSuspend(KNL_RecSdMonitorThreadId);
				osDelay(100);
				tVdoRecStopRet = KNL_VideoRecStop(tRecordFunc,0);
				if(tKNL_RecordAct.pRecordStsNtyCb)
				{
					tKNL_RecordAct.pRecordStsNtyCb(tVdoRecStopRet);
				}
			}
			else if(KNL_VIDEO_PLAY == tKNL_GetRecordFunc())
			{
				 KNL_VideoPlayStop();
			}
#endif
			
			if(KNL_EnterPcConnCbFunc!=NULL)
				KNL_EnterPcConnCbFunc();
			USBD_SetMscCapacities(ulKNL_FsSdIdentify());
			printd(DBG_ErrorLvl, "KNL Enter PcConnect...ok!\n");
		}
		ubKNL_PcConnectAccFlg = 0;
	}
	osMutexRelease(osKNL_Mutex_PcConnect);
}
#endif
//------------------------------------------------------------------------------
#include <stdarg.h>
typedef struct
{
	uint32_t ulIdx;
	uint8_t ubFuncName[24];
	uint32_t ulLine;
}KNL_DBG_INFO_t;

#define KNL_GetUINT8(addr)			(*(volatile uint8_t *)(addr))
#define KNL_GetUINT16(addr)			(*(volatile uint16_t *)(addr))
#define KNL_GetUINT32(addr)			(*(volatile uint32_t *)(addr))
#define KNL_PutUINT8(addr, data)	(*(volatile uint8_t *)(addr)=(data))
#define KNL_PutUINT16(addr, data)	(*(volatile uint16_t *)(addr)=(data))
#define KNL_PutUINT32(addr, data)	(*(volatile uint32_t *)(addr)=(data))
	
uint32_t ulKnlDbgInitFlg = 0;
uint32_t ulKnlDbgBufStartAddr;
uint32_t ulKnlDbgBufSz;
uint32_t ulKnlDbgBufIdx = 0;
uint32_t ulKnlDbgRecIdx = 0;
uint32_t ulKnlDbgRingFlg = 0;
uint32_t ulDbgMaxNum;
void KNL_StoreDbgInfo(const char *cFuncName, uint32_t ulLine)
{
#if KNL_DEBUG_INFO_EN
	KNL_DBG_INFO_t Info = {0};
	va_list arg_ptr;
	uint8_t  ubPrintfString[24] = {0};
	uint8_t  ubLen;
	
	if(ulKnlDbgInitFlg==0)
	{
		ulKnlDbgBufStartAddr = ulBUF_GetFreeAddr();
		ulKnlDbgBufSz = (BSP_DDRSIZE>>20) - ulKnlDbgBufStartAddr;
		if(ulKnlDbgBufSz>=0x20000)
			ulKnlDbgBufSz = 0x20000;
		else
			ulKnlDbgBufSz = (ulKnlDbgBufSz/sizeof(KNL_DBG_INFO_t))*sizeof(KNL_DBG_INFO_t);
		
		ulDbgMaxNum = ulKnlDbgBufSz/sizeof(KNL_DBG_INFO_t);
		if(ulDbgMaxNum<10)
			return;
		
		printd(DBG_ErrorLvl, "KNL StoreDbgInfo->BufAddr=0x%X, BufSz=0x%X, RecNum=%d\n",ulKnlDbgBufStartAddr,ulKnlDbgBufSz,ulDbgMaxNum);
		
		memset((uint8_t*)ulKnlDbgBufStartAddr, 0, ulKnlDbgBufSz);
	}
	
	va_start(arg_ptr, cFuncName);
	vsprintf((char *) ubPrintfString, cFuncName, arg_ptr);
	va_end(arg_ptr);
	ubLen = strlen((char*)ubPrintfString);
	
	//assign value
	Info.ulIdx = ulKnlDbgRecIdx;
	memcpy(Info.ubFuncName, cFuncName, ubLen);
	Info.ulLine = ulLine;
	
	//copy to dram
	memcpy((uint8_t*)(ulKnlDbgBufStartAddr+(ulKnlDbgBufIdx*sizeof(KNL_DBG_INFO_t))), &Info, sizeof(KNL_DBG_INFO_t));
	ulKnlDbgBufIdx++;
	if(ulKnlDbgBufIdx==ulDbgMaxNum)
	{
		ulKnlDbgBufIdx = 0;
		ulKnlDbgRingFlg = 1;
	}
	
	ulKnlDbgRecIdx++;
	
	ulKnlDbgInitFlg = 1;
#endif
}
//------------------------------------------------------------------------------
void KNL_PrintDbgInfo(void)
{
#if KNL_DEBUG_INFO_EN
	SYS_PrintLevel_t SysDbgLvl;
	uint32_t i;
	uint32_t ulPrintNum;
	KNL_DBG_INFO_t *Info;
	
	if(!ulKnlDbgInitFlg)
		return;
	
	SysDbgLvl = (SYS_PrintLevel_t)lSYS_DebugLvl;
	
	SYS_SetPrintLevel(DBG_OFF);
	
	if(ulKnlDbgRingFlg==0)
	{
		ulPrintNum = ulKnlDbgBufIdx;
	}
	else if(ulKnlDbgRingFlg==1)
	{
		ulPrintNum = ulDbgMaxNum;
	}
	for(i=0; i<ulPrintNum; i++)
	{
		Info = (KNL_DBG_INFO_t*)(ulKnlDbgBufStartAddr+(i*sizeof(KNL_DBG_INFO_t)));
		printf("Idx=%d, Fun=%s, Line=%d\n",Info->ulIdx ,Info->ubFuncName, Info->ulLine);
	}
	
	ulKnlDbgBufIdx = 0;
	ulKnlDbgRecIdx = 0;
	ulKnlDbgRingFlg = 0;
	
	SYS_SetPrintLevel(SysDbgLvl);
#endif
}

#if KNL_DEBUG_APP_Q_FULL_EN
#include "AKEY.h"
#include <stdlib.h>
osThreadId KNL_AutoEnterFileListThreadId = NULL;
void KNL_AutoEnterFileListThread(void const *argument)
{
	uint8_t ubEnFlg = 0;
	KEY_Event_t tAKEY_Event;
	uint32_t i;
	uint32_t ulRandTime;
	while(1)
	{
		if(FS_ChkMediaRdy(tKNL_FsMediaInfo.MediaSel)==FS_MEDIA_RDY)
		{
			if(ubEnFlg==0)
			{
				osDelay(1000);
				ubEnFlg = 1;
			}
			else if(ubEnFlg==1)
			{
#if 0
				//menu
				tAKEY_Event.ubKeyAction = 0;
				tAKEY_Event.ubKeyID	  	= 1;
				tAKEY_Event.uwKeyCnt  	= 0;
				KEY_QueueSend(AKEY, &tAKEY_Event);
				tAKEY_Event.ubKeyAction = 2;
				tAKEY_Event.ubKeyID	  	= 1;
				tAKEY_Event.uwKeyCnt  	= 0;
				KEY_QueueSend(AKEY, &tAKEY_Event);
				osDelay(500);
				
				for(i=0; i<10; i++)
				{
					//down
					tAKEY_Event.ubKeyAction = 0;
					tAKEY_Event.ubKeyID	  	= 3;
					tAKEY_Event.uwKeyCnt  	= 0;
					KEY_QueueSend(AKEY, &tAKEY_Event);
					tAKEY_Event.ubKeyAction = 2;
					tAKEY_Event.ubKeyID	  	= 3;
					tAKEY_Event.uwKeyCnt  	= 0;
					KEY_QueueSend(AKEY, &tAKEY_Event);
					osDelay(100);
				}
				
				//menu
				tAKEY_Event.ubKeyAction = 0;
				tAKEY_Event.ubKeyID	  	= 1;
				tAKEY_Event.uwKeyCnt  	= 0;
				KEY_QueueSend(AKEY, &tAKEY_Event);
				tAKEY_Event.ubKeyAction = 2;
				tAKEY_Event.ubKeyID	  	= 1;
				tAKEY_Event.uwKeyCnt  	= 0;
				KEY_QueueSend(AKEY, &tAKEY_Event);
				osDelay(1000);
				
				//menu
				tAKEY_Event.ubKeyAction = 0;
				tAKEY_Event.ubKeyID	  	= 1;
				tAKEY_Event.uwKeyCnt  	= 0;
				KEY_QueueSend(AKEY, &tAKEY_Event);
				tAKEY_Event.ubKeyAction = 2;
				tAKEY_Event.ubKeyID	  	= 1;
				tAKEY_Event.uwKeyCnt  	= 0;
				KEY_QueueSend(AKEY, &tAKEY_Event);
				
				osDelay(500);
#else
				//down
				tAKEY_Event.ubKeyAction = 0;
				tAKEY_Event.ubKeyID	  	= 3;
				tAKEY_Event.uwKeyCnt  	= 0;
				KEY_QueueSend(AKEY, &tAKEY_Event);
				tAKEY_Event.ubKeyAction = 2;
				tAKEY_Event.ubKeyID	  	= 3;
				tAKEY_Event.uwKeyCnt  	= 0;
				KEY_QueueSend(AKEY, &tAKEY_Event);
				
				//random time
				ulRandTime = rand() % 21;
				ulRandTime *= 10;
				//printf("%d\n",ulRandTime);
				osDelay(ulRandTime);
#endif
			}
		}
		else
		{
			osDelay(500);
		}
	}
}
void KNL_AutoEnterFileListStart(void)
{
	if(KNL_AutoEnterFileListThreadId==NULL)
	{
		osThreadDef(KNL_AutoEnterFileListThread, KNL_AutoEnterFileListThread, osPriorityNormal, 1, 8192);
		KNL_AutoEnterFileListThreadId = osThreadCreate(osThread(KNL_AutoEnterFileListThread), NULL);
	}
	else
	{
		osThreadResume(KNL_AutoEnterFileListThreadId);
	}
	printd(DBG_ErrorLvl, "KNL AutoEnterFileList Start\n");
}
void KNL_AutoEnterFileListStop(void)
{
	osThreadSuspend(KNL_AutoEnterFileListThreadId);
	printd(DBG_ErrorLvl, "KNL AutoEnterFileList Stop\n");
}
#endif
//------------------------------------------------------------------------------
void KNL_ForceStopRec(void)
{
#if APP_REC_FUNC_ENABLE
	KNL_RecordFunc_t tRecordFunc;
	KNL_Status_t tVdoRecStopRet;
	tRecordFunc = tKNL_GetRecordFunc();
	if(KNL_RECORDING_START == tKNL_RecordAct.tRecordSts)
	{
		osThreadSuspend(KNL_RecSdMonitorThreadId);
		osDelay(100);
		tVdoRecStopRet = KNL_VideoRecStop(tRecordFunc,0);
		if(tKNL_RecordAct.pRecordStsNtyCb)
		{
			tKNL_RecordAct.pRecordStsNtyCb(tVdoRecStopRet);
		}
		osDelay(100);
		osThreadResume(KNL_RecSdMonitorThreadId);
	}
#endif
}
//------------------------------------------------------------------------------
uint8_t ubKNL_CheckCvbs(void)
{
	return ubKNL_CamIsCvbs;
}	
//------------------------------------------------------------------------------
void KNL_SetYuvBufNub(uint8_t ubNb)
{
#if (defined(VBM_PU) || defined(BUC_CU))
	ubNb = ubNb;
#else
	SEN_SetYuvBufNub(ubNb);
#endif	
	
}	
//------------------------------------------------------------------------------
#if (defined(OP_STA) || (defined(OP_AP) && defined(BSP_DVR_SDK)))
KNL_ISP_RESOLUTION ubKNL_GetIspResolution(void)
{
    if(ISP_RES == ISP_1296P)    // 3M Pixel
        return KNL_ISP_1296P;
    else if(ISP_RES == ISP_FHD) // 2M Pixel
        return KNL_ISP_FHD;
    else
        return KNL_ISP_HD;
}
#endif
#if defined(OP_STA)
uint8_t ubKNL_MDResChBackup=0;
void KNL_MDResChBackup(uint8_t ubMd)
{
    ubKNL_MDResChBackup=ubMd;
}
uint8_t ubKNL_MDResChRestore(void)
{
    return ubKNL_MDResChBackup;
}
#endif

